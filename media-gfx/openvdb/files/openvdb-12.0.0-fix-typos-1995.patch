From 3348bd3c2a610fa22f800a72fc1f5e7fd9ffb5e5 Mon Sep 17 00:00:00 2001
From: Dimitris Apostolou <dimitris.apostolou@icloud.com>
Date: Wed, 15 Jan 2025 02:00:58 +0200
Subject: [PATCH] Fix typos

Signed-off-by: Dimitris Apostolou <dimitris.apostolou@icloud.com>
---
 CMakeLists.txt                                |  8 +-
 README.md                                     |  2 +-
 ci/build.sh                                   |  2 +-
 ci/download_houdini.sh                        |  2 +-
 ci/install_windows_cuda.ps1                   |  4 +-
 cmake/OpenVDBHoudiniSetup.cmake               |  4 +-
 cmake/config/OpenVDBCXX.cmake                 |  4 +-
 cmake/config/OpenVDBVersions.cmake            |  2 +-
 doc/ax/ax.txt                                 | 30 +++----
 doc/ax/axcplusplus.txt                        | 10 +--
 doc/ax/axexamples.txt                         |  4 +-
 doc/ax/gen_function_docs                      |  4 +-
 doc/build.txt                                 |  4 +-
 doc/examplecode.txt                           |  4 +-
 doc/math.txt                                  |  2 +-
 doc/nanovdb/HowToBuild.md                     |  2 +-
 doc/nanovdb/SourceTree.md                     |  2 +-
 doc/points.txt                                |  6 +-
 nanovdb/nanovdb/GridHandle.h                  |  6 +-
 nanovdb/nanovdb/HostBuffer.h                  |  6 +-
 nanovdb/nanovdb/NanoVDB.h                     | 32 +++----
 nanovdb/nanovdb/PNanoVDB.h                    |  4 +-
 nanovdb/nanovdb/cuda/DeviceBuffer.h           |  4 +-
 nanovdb/nanovdb/docs/doxygen-config           |  6 +-
 .../index_grid_cuda_kernel.cu                 |  2 +-
 .../make_custom_nanovdb_cuda_kernel.cu        |  2 +-
 .../nodemanager_cuda_kernel.cu                |  2 +-
 .../openvdb_to_nanovdb_cuda_kernel.cu         |  2 +-
 .../read_nanovdb_sphere.cc                    |  2 +-
 ...ead_nanovdb_sphere_accessor_cuda_kernel.cu |  2 +-
 nanovdb/nanovdb/io/IO.h                       |  2 +-
 nanovdb/nanovdb/math/DitherLUT.h              |  2 +-
 nanovdb/nanovdb/math/HDDA.h                   | 10 +--
 nanovdb/nanovdb/math/Stencils.h               |  6 +-
 nanovdb/nanovdb/python/test/TestNanoVDB.py    |  2 +-
 nanovdb/nanovdb/tools/GridBuilder.h           |  2 +-
 nanovdb/nanovdb/tools/GridChecksum.h          |  6 +-
 nanovdb/nanovdb/tools/GridStats.h             |  4 +-
 nanovdb/nanovdb/tools/GridValidator.h         |  2 +-
 nanovdb/nanovdb/tools/cuda/GridChecksum.cuh   |  6 +-
 nanovdb/nanovdb/tools/cuda/GridStats.cuh      |  2 +-
 nanovdb/nanovdb/tools/cuda/PointsToGrid.cuh   | 10 +--
 nanovdb/nanovdb/unittest/TestNanoVDB.cc       |  6 +-
 nanovdb/nanovdb/unittest/TestNanoVDB.cu       | 32 +++----
 nanovdb/nanovdb/unittest/TestOpenVDB.cc       |  6 +-
 nanovdb/nanovdb/util/Timer.h                  |  2 +-
 nanovdb/nanovdb/util/Util.h                   |  2 +-
 nanovdb/nanovdb/util/cuda/Timer.h             |  4 +-
 openvdb/openvdb/CMakeLists.txt                |  4 +-
 openvdb/openvdb/Metadata.cc                   |  2 +-
 openvdb/openvdb/TypeList.h                    | 34 +++----
 openvdb/openvdb/io/Archive.cc                 |  4 +-
 openvdb/openvdb/math/BBox.h                   |  4 +-
 openvdb/openvdb/math/ConjGradient.h           |  2 +-
 openvdb/openvdb/math/FiniteDifference.h       | 32 +++----
 openvdb/openvdb/math/Half.cc                  |  6 +-
 openvdb/openvdb/math/Maps.cc                  |  2 +-
 openvdb/openvdb/math/Maps.h                   | 46 +++++-----
 openvdb/openvdb/math/Mat.h                    |  4 +-
 openvdb/openvdb/math/Mat3.h                   |  6 +-
 openvdb/openvdb/math/Mat4.h                   |  4 +-
 openvdb/openvdb/math/Operators.h              |  8 +-
 openvdb/openvdb/math/QuantizedUnitVec.h       |  4 +-
 openvdb/openvdb/math/Quat.h                   |  2 +-
 openvdb/openvdb/math/Stencils.h               |  6 +-
 openvdb/openvdb/math/Transform.h              |  6 +-
 openvdb/openvdb/math/Vec2.h                   |  2 +-
 openvdb/openvdb/openvdb.h                     |  2 +-
 openvdb/openvdb/points/AttributeArray.h       |  2 +-
 openvdb/openvdb/points/AttributeSet.cc        |  2 +-
 openvdb/openvdb/points/AttributeSet.h         |  2 +-
 openvdb/openvdb/points/IndexIterator.h        |  2 +-
 openvdb/openvdb/points/PointAttribute.h       |  2 +-
 openvdb/openvdb/points/PointDataGrid.h        |  2 +-
 openvdb/openvdb/points/PointReplicate.h       |  4 +-
 openvdb/openvdb/points/PointStatistics.h      |  6 +-
 openvdb/openvdb/points/PointTransfer.h        |  2 +-
 openvdb/openvdb/points/StreamCompression.h    |  2 +-
 .../points/impl/PointRasterizeSDFImpl.h       |  6 +-
 .../openvdb/points/impl/PointReplicateImpl.h  |  2 +-
 openvdb/openvdb/tools/Clip.h                  |  2 +-
 openvdb/openvdb/tools/Composite.h             |  2 +-
 openvdb/openvdb/tools/DenseSparseTools.h      |  2 +-
 openvdb/openvdb/tools/FastSweeping.h          | 20 ++---
 openvdb/openvdb/tools/Filter.h                |  4 +-
 openvdb/openvdb/tools/FindActiveValues.h      |  2 +-
 openvdb/openvdb/tools/Interpolation.h         |  6 +-
 openvdb/openvdb/tools/LevelSetAdvect.h        |  6 +-
 openvdb/openvdb/tools/LevelSetMorph.h         |  6 +-
 openvdb/openvdb/tools/MeshToVolume.h          | 16 ++--
 openvdb/openvdb/tools/Morphology.h            |  6 +-
 openvdb/openvdb/tools/MultiResGrid.h          |  8 +-
 openvdb/openvdb/tools/PointsToMask.h          |  4 +-
 openvdb/openvdb/tools/RayTracer.h             |  8 +-
 openvdb/openvdb/tools/TopologyToLevelSet.h    |  6 +-
 openvdb/openvdb/tools/ValueTransformer.h      |  2 +-
 openvdb/openvdb/tools/VolumeAdvect.h          |  4 +-
 openvdb/openvdb/tree/InternalNode.h           |  2 +-
 openvdb/openvdb/tree/LeafManager.h            |  2 +-
 openvdb/openvdb/tree/LeafNodeBool.h           |  2 +-
 openvdb/openvdb/tree/RootNode.h               |  2 +-
 openvdb/openvdb/tree/ValueAccessor.h          |  6 +-
 .../openvdb/unittest/TestAttributeArray.cc    |  4 +-
 openvdb/openvdb/unittest/TestCoord.cc         |  2 +-
 openvdb/openvdb/unittest/TestDense.cc         | 10 +--
 .../openvdb/unittest/TestDenseSparseTools.cc  |  6 +-
 openvdb/openvdb/unittest/TestDivergence.cc    |  2 +-
 openvdb/openvdb/unittest/TestFile.cc          |  2 +-
 openvdb/openvdb/unittest/TestFilter.cc        |  4 +-
 openvdb/openvdb/unittest/TestGradient.cc      |  6 +-
 openvdb/openvdb/unittest/TestIndexFilter.cc   |  2 +-
 openvdb/openvdb/unittest/TestIndexIterator.cc |  4 +-
 openvdb/openvdb/unittest/TestLeafMask.cc      |  4 +-
 openvdb/openvdb/unittest/TestMaps.cc          |  2 +-
 openvdb/openvdb/unittest/TestMorphology.cc    |  4 +-
 openvdb/openvdb/unittest/TestNodeMask.cc      |  6 +-
 .../unittest/TestParticlesToLevelSet.cc       |  2 +-
 openvdb/openvdb/unittest/TestPointCount.cc    |  4 +-
 openvdb/openvdb/unittest/TestPointMove.cc     |  2 +-
 .../openvdb/unittest/TestPointRasterizeSDF.cc |  6 +-
 openvdb/openvdb/unittest/TestPrePostAPI.cc    |  8 +-
 .../openvdb/unittest/TestStreamCompression.cc |  2 +-
 openvdb/openvdb/unittest/TestTools.cc         | 12 +--
 openvdb/openvdb/unittest/TestTree.cc          | 10 +--
 .../openvdb/unittest/TestVolumeToSpheres.cc   |  2 +-
 openvdb/openvdb/unittest/util.h               |  2 +-
 openvdb/openvdb/util/CpuTimer.h               |  2 +-
 openvdb/openvdb/util/NodeMasks.h              |  4 +-
 openvdb/openvdb/util/PagedArray.h             | 14 +--
 openvdb_ax/openvdb_ax/ast/AST.h               |  4 +-
 openvdb_ax/openvdb_ax/ast/Parse.h             |  2 +-
 openvdb_ax/openvdb_ax/ast/PrintTree.cc        |  2 +-
 openvdb_ax/openvdb_ax/ax.cc                   |  2 +-
 openvdb_ax/openvdb_ax/codegen/Codecs.cc       |  2 +-
 .../openvdb_ax/codegen/ComputeGenerator.cc    |  4 +-
 .../openvdb_ax/codegen/FunctionRegistry.h     |  2 +-
 .../codegen/PointComputeGenerator.cc          |  8 +-
 .../openvdb_ax/codegen/StandardFunctions.cc   | 10 +--
 openvdb_ax/openvdb_ax/codegen/SymbolTable.h   |  2 +-
 openvdb_ax/openvdb_ax/codegen/Utils.h         |  6 +-
 .../openvdb_ax/codegen/VolumeFunctions.cc     |  6 +-
 .../openvdb_ax/compiler/AttributeRegistry.h   |  2 +-
 openvdb_ax/openvdb_ax/compiler/Compiler.cc    |  2 +-
 .../openvdb_ax/compiler/PointExecutable.cc    |  2 +-
 .../openvdb_ax/compiler/PointExecutable.h     |  6 +-
 .../openvdb_ax/compiler/VolumeExecutable.cc   |  2 +-
 .../openvdb_ax/compiler/VolumeExecutable.h    |  8 +-
 openvdb_ax/openvdb_ax/grammar/axparser.y      |  2 +-
 .../openvdb_ax/math/OpenSimplexNoise.cc       |  2 +-
 openvdb_ax/openvdb_ax/test/CMakeLists.txt     |  2 +-
 .../openvdb_ax/test/backend/TestCodecs.cc     |  4 +-
 .../test/backend/TestFunctionTypes.cc         |  4 +-
 .../openvdb_ax/test/cmd/vdb_ax_test_fail_19   |  2 +-
 .../openvdb_ax/test/cmd/vdb_ax_test_fail_20   |  2 +-
 .../openvdb_ax/test/cmd/vdb_ax_test_pass_15   |  6 +-
 .../openvdb_ax/test/compiler/TestAXRun.cc     |  2 +-
 .../test/integration/CompareGrids.cc          |  4 +-
 .../openvdb_ax/test/integration/TestHarness.h |  2 +-
 .../test/integration/TestVDBFunctions.cc      |  4 +-
 openvdb_ax/openvdb_ax/test/main.cc            |  2 +-
 openvdb_cmd/vdb_ax/cli.h                      | 10 +--
 openvdb_cmd/vdb_ax/main.cc                    |  2 +-
 openvdb_cmd/vdb_tool/CMakeLists.txt           |  2 +-
 openvdb_cmd/vdb_tool/include/Parser.h         | 14 +--
 openvdb_cmd/vdb_tool/include/Tool.h           | 88 +++++++++----------
 openvdb_cmd/vdb_tool/include/Util.h           |  4 +-
 openvdb_cmd/vdb_view/RenderModules.cc         |  2 +-
 openvdb_houdini/openvdb_houdini/AXUtils.h     |  2 +-
 .../openvdb_houdini/AttributeTransferUtil.h   |  2 +-
 .../openvdb_houdini/CMakeLists.txt            |  4 +-
 openvdb_houdini/openvdb_houdini/ParmFactory.h |  2 +-
 .../openvdb_houdini/SOP_NodeVDB.cc            |  2 +-
 openvdb_houdini/openvdb_houdini/SOP_NodeVDB.h | 12 +--
 .../openvdb_houdini/SOP_OpenVDB_AX.cc         |  2 +-
 .../openvdb_houdini/SOP_OpenVDB_Activate.cc   |  2 +-
 .../openvdb_houdini/SOP_OpenVDB_Create.cc     |  2 +-
 .../SOP_OpenVDB_Filter_Level_Set.cc           |  2 +-
 .../SOP_OpenVDB_From_Polygons.cc              |  4 +-
 .../openvdb_houdini/SOP_OpenVDB_Noise.cc      |  4 +-
 .../SOP_OpenVDB_Points_Convert.cc             |  2 +-
 .../SOP_OpenVDB_Potential_Flow.cc             |  2 +-
 .../SOP_OpenVDB_Rasterize_Points.cc           |  2 +-
 .../SOP_OpenVDB_Sample_Points.cc              |  2 +-
 .../openvdb_houdini/reference/GU_PrimVDB.cc   |  2 +-
 .../AEOpenVDBToPolygonsTemplate.mel           |  2 +-
 .../AEOpenVDBVisualizeTemplate.mel            |  2 +-
 .../LTemplate/IncludeFiles/LTemplate.inc      |  4 +-
 openvdb_wolfram/OpenVDBLink/Messages.m        |  4 +-
 openvdb_wolfram/OpenVDBLink/Readme.md         |  2 +-
 189 files changed, 514 insertions(+), 514 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e17ee726b2..e659a59b10 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -44,7 +44,7 @@
 #  ensure policy scope is set up correctly
 cmake_minimum_required(VERSION 3.20)
 
-# CMP0091 allows for MSVC ABI targetting via CMAKE_MSVC_RUNTIME_LIBRARY
+# CMP0091 allows for MSVC ABI targeting via CMAKE_MSVC_RUNTIME_LIBRARY
 # from CMake 3.15 and above. Must come before project().
 if(POLICY CMP0091)
   cmake_policy(SET CMP0091 NEW)
@@ -93,7 +93,7 @@ option(USE_CCACHE "Build using Ccache if found on the path" ON)
 cmake_dependent_option(USE_EXPLICIT_INSTANTIATION "Use explicit instantiation for all supported classes
 and methods against a pre-defined list of OpenVDB trees. This makes the core library larger and slower
 to compile, but speeds up the compilation of all dependent code by bypassing the expensive template
-instantation." ON "NOT WIN32" OFF)
+instantiation." ON "NOT WIN32" OFF)
 option(OPENVDB_FUTURE_DEPRECATION "Generate messages for upcoming deprecation" ON)
 option(OPENVDB_ENABLE_UNINSTALL "Adds a CMake uninstall target." ON)
 option(USE_COLORED_OUTPUT "Always produce ANSI-colored output (GNU/Clang only)." OFF)
@@ -124,7 +124,7 @@ option(USE_EXR [=[
 Use OpenEXR while building openvdb components. If enabled, this also switches USE_IMATH_HALF to ON unless
 it too was provided and set to OFF.]=] OFF)
 option(USE_IMATH_HALF [=[
-Use the definiton of half floating point types from the Imath library. If OFF, the embedded definition provided
+Use the definition of half floating point types from the Imath library. If OFF, the embedded definition provided
 by OpenVDB is used. If OPENVDB_BUILD_CORE is OFF, CMake attempts to query the located openvdb build configuration
 to select the correct half support. You may set this to on to force Imath half to be used if you know it to be
 required.]=] ${USE_EXR})
@@ -135,7 +135,7 @@ option(USE_NANOVDB "Use NanoVDB while building openvdb components." ${OPENVDB_BU
 cmake_dependent_option(OPENVDB_DISABLE_BOOST_IMPLICIT_LINKING
   "Disable the implicit linking of Boost libraries on Windows" ON "WIN32" OFF)
 option(USE_STATIC_DEPENDENCIES [=[
-Only search for and use static libraries. If OFF the shared versions of requried libraries are prioritised, falling
+Only search for and use static libraries. If OFF the shared versions of required libraries are prioritised, falling
 back to static libraries. Forcing individual static dependencies can be enabled by setting XXX_USE_STATIC_LIBS
 to ON, where XXX is the package name. On Windows this behaviour is less strict, with any located libraries assumed
 to be static. This has no effect for any packages found with Xxx_DIR (i.e. CMake CONFIG mode).]=] OFF)
diff --git a/README.md b/README.md
index 2eb65de52d..6f368a7b7b 100644
--- a/README.md
+++ b/README.md
@@ -64,7 +64,7 @@ apt-get install -y libtbb-dev
 apt-get install -y libblosc-dev
 
 # MacOS
-# @note We are using homebrew in this example to install requried dependencies
+# @note We are using homebrew in this example to install required dependencies
 #  https://brew.sh/
 brew install boost
 brew install tbb
diff --git a/ci/build.sh b/ci/build.sh
index b0b3c8dfb1..83fc86bf60 100755
--- a/ci/build.sh
+++ b/ci/build.sh
@@ -182,7 +182,7 @@ cd ${BUILD_DIR}
 set -x
 
 # Note:
-# - print and lod binary options are always on and can be toggles with: OPENVDB_BUILD_BINARIES=ON/OFF
+# - print and load binary options are always on and can be toggles with: OPENVDB_BUILD_BINARIES=ON/OFF
 # - always enabled the python tests with OPENVDB_BUILD_PYTHON_UNITTESTS if the python module is in use,
 #   regardless of the 'test' component being enabled or not (see the OPENVDB_BUILD_PYTHON_UNITTESTS option).
 cmake \
diff --git a/ci/download_houdini.sh b/ci/download_houdini.sh
index 0f63a4eceb..0ebf6a967a 100755
--- a/ci/download_houdini.sh
+++ b/ci/download_houdini.sh
@@ -48,7 +48,7 @@ if [[ $PLATFORM =~ "linux" ]]; then
     cd ..
 
 elif [[ $PLATFORM =~ "macos" ]]; then
-    # Exract files by mounting the downloaded dmg (we only really want to
+    # Extract files by mounting the downloaded dmg (we only really want to
     # expand Houdini.framework)
     hdiutil attach hou.dmg
     pkgutil --expand-full /Volumes/Houdini/Houdini.pkg Houdini
diff --git a/ci/install_windows_cuda.ps1 b/ci/install_windows_cuda.ps1
index f365cca7e7..fa958f725c 100644
--- a/ci/install_windows_cuda.ps1
+++ b/ci/install_windows_cuda.ps1
@@ -5,7 +5,7 @@
 ## Constants
 ## -------------------
 
-# Dictionary of known cuda versions and thier download URLS, which do not follow a consistent pattern :(
+# Dictionary of known cuda versions and their download URLS, which do not follow a consistent pattern :(
 $CUDA_KNOWN_URLS = @{
     "8.0.44" = "http://developer.nvidia.com/compute/cuda/8.0/Prod/network_installers/cuda_8.0.44_win10_network-exe";
     "8.0.61" = "http://developer.nvidia.com/compute/cuda/8.0/Prod2/network_installers/cuda_8.0.61_win10_network-exe";
@@ -30,7 +30,7 @@ $CUDA_KNOWN_URLS = @{
     "12.4.0" = "https://developer.download.nvidia.com/compute/cuda/12.4.0/network_installers/cuda_12.4.0_windows_network.exe"
 }
 
-# @todo - change this to be based on _MSC_VER intead, or invert it to be CUDA keyed instead?
+# @todo - change this to be based on _MSC_VER instead, or invert it to be CUDA keyed instead?
 $VISUAL_STUDIO_MIN_CUDA = @{
     "2022" = "12.4";
     "2019" = "10.1";
diff --git a/cmake/OpenVDBHoudiniSetup.cmake b/cmake/OpenVDBHoudiniSetup.cmake
index a4ab24f2e0..55e29e7d7c 100644
--- a/cmake/OpenVDBHoudiniSetup.cmake
+++ b/cmake/OpenVDBHoudiniSetup.cmake
@@ -245,7 +245,7 @@ set(HOUDINI_LIB_DIR ${_houdini_install_root}/${HOUDINI_DSOLIB_DIR})
 #  Configure dependencies
 # ------------------------------------------------------------------------
 
-# Congfigure dependency hints to point to Houdini. Allow for user overriding
+# Configure dependency hints to point to Houdini. Allow for user overriding
 # if custom Houdini installations are in use
 
 # ZLIB - FindPackage ( ZLIB) only supports a few path hints. We use
@@ -339,7 +339,7 @@ if(NOT OPENVDB_HOUDINI_ABI)
 endif()
 
 # ------------------------------------------------------------------------
-#  Configure libstc++ CXX11 ABI
+#  Configure libstdc++ CXX11 ABI
 # ------------------------------------------------------------------------
 
 if(UNIX AND NOT APPLE)
diff --git a/cmake/config/OpenVDBCXX.cmake b/cmake/config/OpenVDBCXX.cmake
index 3586732bdb..99d7d70b05 100644
--- a/cmake/config/OpenVDBCXX.cmake
+++ b/cmake/config/OpenVDBCXX.cmake
@@ -38,7 +38,7 @@ endif()
 if(WIN32 AND CMAKE_MSVC_RUNTIME_LIBRARY)
   message(STATUS "CMAKE_MSVC_RUNTIME_LIBRARY set to target ${CMAKE_MSVC_RUNTIME_LIBRARY}")
 
-  # Configure Boost library varient on Windows
+  # Configure Boost library variant on Windows
   if(NOT Boost_USE_STATIC_RUNTIME)
     set(Boost_USE_STATIC_RUNTIME OFF)
     if(CMAKE_MSVC_RUNTIME_LIBRARY STREQUAL MultiThreaded OR
@@ -324,7 +324,7 @@ if(OPENVDB_ENABLE_ASSERTS)
   message(STATUS "OpenVDB asserts are ENABLED")
 endif()
 
-# Intialize extra build type targets where possible
+# Initialize extra build type targets where possible
 
 if(NOT TARGET gcov_html)
   find_program(GCOVR_PATH gcovr)
diff --git a/cmake/config/OpenVDBVersions.cmake b/cmake/config/OpenVDBVersions.cmake
index 0b8dd5ef6a..f7535414d0 100644
--- a/cmake/config/OpenVDBVersions.cmake
+++ b/cmake/config/OpenVDBVersions.cmake
@@ -33,7 +33,7 @@ if(NOT DISABLE_DEPENDENCY_VERSION_CHECKS)
   # a compiler with complete support for our MINIMUM_CXX_STANDARD (currently 17).
   # What's usually important is that the version of libstdc++ and glibc in use
   # matches. Compilers other than GCC should provide options to ensure this
-  # targetting e.g. --gcc-toolchain and -fgnuc-version with Clang.
+  # targeting e.g. --gcc-toolchain and -fgnuc-version with Clang.
   set(MINIMUM_GCC_VERSION 11.2.1)
   set(MINIMUM_CLANG_VERSION 5.0)
   set(MINIMUM_ICC_VERSION 19)
diff --git a/doc/ax/ax.txt b/doc/ax/ax.txt
index 268afc5ab8..0b8fa2f90b 100644
--- a/doc/ax/ax.txt
+++ b/doc/ax/ax.txt
@@ -299,7 +299,7 @@ on the source and target types. See the below examples:
 This example demonstrates floating point truncation in AX.
 @code
 float a = 1.1f;
-int b = 5.5f; // implict conversion from literal 5.5f. "b" is set to 5
+int b = 5.5f; // implicit conversion from literal 5.5f. "b" is set to 5
 b = a; // implicit conversion from float "a". "b" is set to 1
 @endcode
 @par
@@ -343,9 +343,9 @@ Matrices are stored in row major layout (lexographical access order) which
 matches the representation of a matrix in OpenVDB. Matrix support consists of
 @b `float` and @b `double` precision elements with dimensions either @b `3x3` or
 @b `4x4` (total size of 9 and 16 elements respectively). There are no integer or
-boolean matrix types. Similiar to vectors, the suffix letter on the type denotes
+boolean matrix types. Similar to vectors, the suffix letter on the type denotes
 the contained elements precision, with the number corresponding to the matrix
-dimension. A matrix of type @b `mat3d` therefor corresponds to a @b `3x3` matrix
+dimension. A matrix of type @b `mat3d` therefore corresponds to a @b `3x3` matrix
 (9 elements) with @b `double` precision elements.
 @par Element Access
 As elements of all matrix and vector types are stored contiguously, they can be
@@ -385,7 +385,7 @@ detect these cases and convert values when necessary. This is known as
 <b>implicit type conversion</b> and the way in which the target operation type
 is chosen is known as <b>type precedence</b>.
 @par
-When referring to type precedence, we are primarily refering to the conversion of
+When referring to type precedence, we are primarily referring to the conversion of
 one @b scalar type to another. For vectors, matrices and other containers, this
 refers to the conversion of their element type e.g. `mat3f` to `mat3d`. The
 conversion rules for more than the element type (e.g. `int` to `mat4f`) are
@@ -670,7 +670,7 @@ The behaviour of a given compound assignment (for example `a += b`) is similar
 to replacing the compound assignment with a @ref axopassignment
 "direct assignment" followed by a @ref axopbinarithmetic "binary expression"
 with the same operands and given arithmetic token (i.e. `a = a + b`). However,
-compound assignments imporantly do @b not evaluate the @b `lhs` twice. This is
+compound assignments importantly do @b not evaluate the @b `lhs` twice. This is
 important when assigning to an expression which is not an attribute or local
 value. The best example of this is assigning to a @ref axopunincdec "pre-crement"
 operation:
@@ -1066,7 +1066,7 @@ b[2] = tmp[2];
 <tr style="text-align:center"><td>@ref axvecmats "matrix"</td>
 <td style="text-align:left">
 Performs matrix multiplication and returns the matrix product, which is matrix
-of matchign size and type. <b>Operand sizes must match.</b> e.g:
+of matching size and type. <b>Operand sizes must match.</b> e.g:
 <!-- A -->@code{.c}
 mat4f a = 1, b = 2;
 mat4f c = a * b;
@@ -1124,9 +1124,9 @@ These operations only run on @b integral operands. After @ref axtypeprecedence
 <th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th>
 </tr>
 <tr style="text-align:center">
-<td>@ref axscalars "intergral"</td>
+<td>@ref axscalars "integral"</td>
 <td>`& | ^ << >>`</td>
-<td>@ref axscalars "intergral"</td>
+<td>@ref axscalars "integral"</td>
 <td style="text-align:left">
 Returns the result of the bitwise operation as described above. If either operand
 is not an integral type (`bool` `int32` or `int64`), the program is ill formed.
@@ -1296,7 +1296,7 @@ increment / decrement operators are supported.
 
 @subsubsection axopunarithmetic Arithmetic
 @par
-Arithmetic unary operators are comprised of arithemtic and bitwise operators.
+Arithmetic unary operators are comprised of arithmetic and bitwise operators.
 @par
 <table>
 <tr><th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
@@ -1514,8 +1514,8 @@ The <b>`[]`</b> operator is valid for both vectors and matrices. It has the form
 following the @ref axopassignment "assignment casting" rules and falls within
 the valid size of the @a `container`. <b>No bounds checking is performed</b>.
 @par
-As matrices are also an array of contigous values, they can be accessed in the
-same way. This can make some operations much simplier; a typical example being
+As matrices are also an array of contiguous values, they can be accessed in the
+same way. This can make some operations much simpler; a typical example being
 iterating through all matrix elements and performing some logic:
 @par
 @code{.c}
@@ -1578,7 +1578,7 @@ a_{30}\quad a_{31}\quad a_{32}\quad a_{33}\\
 <th>Access [a]</th>
 <th>Access [a,b]</th>
 <th style="border-right-style:none;">Result</th>
-<td style="border:none" rowspan="17"></td> <!-- table seperator -->
+<td style="border:none" rowspan="17"></td> <!-- table separator -->
 <th>Access [a]</th>
 <th>Access [a,b]</th>
 <th>Result</th>
@@ -1740,7 +1740,7 @@ a = int(b.x);
 @endcode
 @par
 Whilst explicit casts take only a single argument, the operator itself supports
-multiple or empty arguments for function calls. Whe multiple arguments are
+multiple or empty arguments for function calls. When multiple arguments are
 provided, they are parsed from first to last and processed in reverse order.
 @b However, the order of runtime evaluation is @b unspecified i.e. they may
 evaluate in any order. Each function parameter is initialized with its
@@ -2005,10 +2005,10 @@ can be used to assign any scalar a value.
 <table>
 <tr><th>Type</th><th>Literal Tokens</th></tr>
 <tr><td>`bool`</td><td>Tokens @b `true` and @b `false`</td></tr>
-<tr><td>`int32`</td><td>No suffix, automatically infered from integral literals</td></tr>
+<tr><td>`int32`</td><td>No suffix, automatically inferred from integral literals</td></tr>
 <tr><td>`int64`</td><td>The letter @b `l` e.g. @code int64 a = 10l; @endcode</td></tr>
 <tr><td>`float`</td><td>The letter @b `f` e.g. @code float a = 0.0f; @endcode</td></tr>
-<tr><td>`double`</td><td>No suffix, automatically infered from floating point literals.</td></tr>
+<tr><td>`double`</td><td>No suffix, automatically inferred from floating point literals.</td></tr>
 <tr><td>`string`</td><td>Character strings wrapped in double quotes @b \" @b \"</td></tr>
 </table>
 @par
diff --git a/doc/ax/axcplusplus.txt b/doc/ax/axcplusplus.txt
index 05674b954b..a4c9b41ac6 100644
--- a/doc/ax/axcplusplus.txt
+++ b/doc/ax/axcplusplus.txt
@@ -117,7 +117,7 @@ parser is accessed through the @b ast module.
 @subsection vdbaxast The AST
 @par
 The @b ast module provides:
- - The complete implemenation of an @ref AST.h "AX abstract syntax tree"
+ - The complete implementation of an @ref AST.h "AX abstract syntax tree"
  - The openvdb::ax::ast::parse() method
  - The @vdblink::ax::ast::Visitor AST Visitor@endlink
  - AST scanners and tools
@@ -302,7 +302,7 @@ f@density = f$my_value;
 @endcode
 @par
 When compiled, this program will attempt to read a single float type value with
-the storage name "my_value". If the value cannot be found, a zero intialized
+the storage name "my_value". If the value cannot be found, a zero initialized
 block of memory (with size of the desired type) is returned. So, with no further
 setup, this will assign each value of @b density to 0.0f.
 @par
@@ -351,7 +351,7 @@ exe->execute(density); // density set to 1.0f
 @endcode
 @warning
 Care should be taken to ensure that modifications to custom data values are
-peformed outside of any calls to `execute()`. Any attempt to modify the data
+performed outside of any calls to `execute()`. Any attempt to modify the data
 whilst executables attempt to access it will result in undefined behaviour.
 
 @subsubsection vdbaxcodegen Codegen
@@ -396,7 +396,7 @@ if (!exe) {
     for (cosnt auto& msg : err) std::cout << msg << std::endl;
 }
 
-// without logger, divison by zero warning won't be reported
+// without logger, division by zero warning won't be reported
 exe = compiler.compile<ax::VolumeExecutable>("f@a = 1.0f / 0.0f;");
 
 // without logger, invalid AX will cause a runtime error but
@@ -412,7 +412,7 @@ catch (...) {
 A single instance of the @vdblink::ax::Compiler AX Compiler@endlink uses a
 uniquely constructed <A HREF="https://llvm.org/doxygen/classllvm_1_1LLVMContext.html">
 LLVMContext</A>. This context is @b shared between copies of the Compiler,
-however new Compilers create new LLVMContexts. It is therefor unsafe to invoke
+however new Compilers create new LLVMContexts. It is therefore unsafe to invoke
 concurrent calls to @vdblink::ax::Compiler::compile() Compiler::compile()
 @endlink on Compilers which share the same underlying LLVMContext.
 @par
diff --git a/doc/ax/axexamples.txt b/doc/ax/axexamples.txt
index c462950a42..8d78124f01 100644
--- a/doc/ax/axexamples.txt
+++ b/doc/ax/axexamples.txt
@@ -124,7 +124,7 @@ calculate a position based curl noise on points in a particular group, and to
 use that calculation to update point velocities.
 @par
 <!-- P -->@code{.c}
-// Only calcualte noise and apply it to points if the current point is NOT in
+// Only calculate noise and apply it to points if the current point is NOT in
 // a group called "escaped". Note that the PointExecutable also has native
 // support for group based execution.
 if (!ingroup("escaped")) {
@@ -197,7 +197,7 @@ These examples demonstrate how to use AX on VDB volume grids.
 
 @subsection axexamplevolumeclamp Volume Clamping
 @par
-Below is a small example of reading adn writing to voxels within a VDB volume.
+Below is a small example of reading and writing to voxels within a VDB volume.
 As with points, the @ symbol specifies an access to a named volume, with the
 type of each volume preceding it and the name appearing as a suffix. For
 example: `float@density` would imply a @b float volume called @b density.
diff --git a/doc/ax/gen_function_docs b/doc/ax/gen_function_docs
index 1a15c166a9..a42fe59eaa 100755
--- a/doc/ax/gen_function_docs
+++ b/doc/ax/gen_function_docs
@@ -25,13 +25,13 @@ usually automatically updated from the most recent output of the @ref vdbaxbinar
 # 1) Create the contents list (reference links to each function)
 # Get all the function names
 $BINARY functions --list-names > tmp.txt
-# Remove commans
+# Remove commas
 tr -d , < tmp.txt > tmp2.txt
 # Add new lines between names
 tr ' ' '\n' < tmp2.txt > tmp.txt
 # Remove empty lines (created by the vdb_ax binary wrapping output)
 sed  '/^$/d' tmp.txt > tmp2.txt
-# Append doxygen references to each funciton
+# Append doxygen references to each function
 sed -e 's/^\(.*\)/\t<li> @ref ax\1 \"\1\"<\/li>/' tmp2.txt >> functions.txt
 
 # End the function list and add a line break
diff --git a/doc/build.txt b/doc/build.txt
index c04e870aa3..4c1d501022 100644
--- a/doc/build.txt
+++ b/doc/build.txt
@@ -457,7 +457,7 @@ provide:
 =`/path/to/install/dir` # The location you wish to install OpenVDB to. See
 the link for default values.
 - @b Xxx_ROOT =`/path/to/Xxx/` # Give CMake a path to where a package has been
-installed or simply to where your prefered package is installed if it cannot
+installed or simply to where your preferred package is installed if it cannot
 locate it.
 
 For example, a typical first attempt at generating the build files may look as
@@ -472,7 +472,7 @@ available, their corresponding CMake flags and their default values.
 
 After the CMake build files have been successfully generated, run the build
 tool within the build directory to compile the project. On UNIX, you can
-typically incoke `make` directly:
+typically invoke `make` directly:
 @code
 make -j4
 @endcode
diff --git a/doc/examplecode.txt b/doc/examplecode.txt
index a1ba3bd00f..ffeff6a664 100644
--- a/doc/examplecode.txt
+++ b/doc/examplecode.txt
@@ -1734,7 +1734,7 @@ tbb::parallel_for(leafManager.leafRange(/*grainsize=*/1000000), op);
 
 @subsection sPointGroups Creating and Assigning Point Groups
 
-Point groups in OpenVDB are analagous to Houdini point groups as an
+Point groups in OpenVDB are analogous to Houdini point groups as an
 efficient way of tagging specific points to belong to a named group.
 
 This example uses the data set generated in the @ref sPointsGeneration example.
@@ -1919,7 +1919,7 @@ point groups for a custom filter. This is using the same data set
 from the previous example.
 
 @code
-// Evalutate true for points that are positive in Y only
+// Evaluate true for points that are positive in Y only
 struct PositiveYFilter
 {
     using Handle = openvdb::points::AttributeHandle<openvdb::Vec3f>;
diff --git a/doc/math.txt b/doc/math.txt
index 5e80f4752a..7c2c19e6ef 100644
--- a/doc/math.txt
+++ b/doc/math.txt
@@ -336,7 +336,7 @@ openvdb::math::Mat4d matrixBinv =
 // Create a new transform that maps the index space of linearTransformA
 // to the index space of linearTransformB.
 openvdb::math::Transform::Ptr linearTransformAtoB =
-    openvdb::math::Trasform::createLinearTransform(matrixA * matrixBinv);
+    openvdb::math::Transform::createLinearTransform(matrixA * matrixBinv);
 @endcode
 Notice that in the above example, the internal representation used by
 the transform will be simplified if possible to use one of the various
diff --git a/doc/nanovdb/HowToBuild.md b/doc/nanovdb/HowToBuild.md
index ab3638c098..ab67362bba 100644
--- a/doc/nanovdb/HowToBuild.md
+++ b/doc/nanovdb/HowToBuild.md
@@ -19,7 +19,7 @@ NanoVDB is now a module of the larger OpenVDB project. A user can build both lib
   foo@bar:~$ cmake .. -DUSE_NANOVDB=ON -DTBB_ROOT=/path/to/tbb -DBOOST_ROOT=/path/to/boost -DBLOSC_ROOT=/path/to/blosc -DCMAKE_INSTALL_PREFIX=/install/path
   foo@bar:~$ make -j 4 && make install
   ```
-Note that the default value of `NANOVDB_USE_OPENVDB` is linked to `OPENVDB_BUILD_CORE` option and can be overriden by passing on `-DNANOVDB_USE_OPENVDB=OFF`. The `Boost` library is included because it is a requirement for building OpenVDB.
+Note that the default value of `NANOVDB_USE_OPENVDB` is linked to `OPENVDB_BUILD_CORE` option and can be overridden by passing on `-DNANOVDB_USE_OPENVDB=OFF`. The `Boost` library is included because it is a requirement for building OpenVDB.
 
 In general, CMake will try to find every optional dependency when a user opts to add an additional dependency. Be sure to check the CMake log to see what dependencies were **not** found.
 
diff --git a/doc/nanovdb/SourceTree.md b/doc/nanovdb/SourceTree.md
index 49bb8dc4b7..c5fdde538f 100644
--- a/doc/nanovdb/SourceTree.md
+++ b/doc/nanovdb/SourceTree.md
@@ -3,7 +3,7 @@
 #### Overview of the directory tree of NanoVDB.
 
 * [NanoVDB.h](https://github.com/AcademySoftwareFoundation/openvdb/blob/master/nanovdb/nanovdb/NanoVDB.h) C++11 implementation of the core data structure and its access methods.
-* [CNanoVDB.h](https://github.com/AcademySoftwareFoundation/openvdb/blob/master/nanovdb/nanovdb/CNanoVDB.h) Incomplete but useable C99 implementation of the core data structure and its access methods.  Designed in particular for use in OpenCL kernels.  Note that this relies on zero-sized arrays for the _reserved padding, so will not work on all compilers (with MSVC being a particular example)
+* [CNanoVDB.h](https://github.com/AcademySoftwareFoundation/openvdb/blob/master/nanovdb/nanovdb/CNanoVDB.h) Incomplete but usable C99 implementation of the core data structure and its access methods.  Designed in particular for use in OpenCL kernels.  Note that this relies on zero-sized arrays for the _reserved padding, so will not work on all compilers (with MSVC being a particular example)
 * [PNanoVDB.h](https://github.com/AcademySoftwareFoundation/openvdb/blob/master/nanovdb/nanovdb/PNanoVDB.h) C99 implementation of the core data structure and its access methods. More complete coverage than CNanoVDB.  This version is pointer-less and supports virtually all graphics APIs.
 * [GridHandle.h](https://github.com/AcademySoftwareFoundation/openvdb/blob/master/nanovdb/nanovdb/GridHandle.h) defines a handler for the memory allocated to a NanoVDB grid.
 * [io/IO.h](https://github.com/AcademySoftwareFoundation/openvdb/blob/master/nanovdb/nanovdb/io/IO.h) implements I/O support.
diff --git a/doc/points.txt b/doc/points.txt
index 6bf2e250f6..4cc820a1dc 100644
--- a/doc/points.txt
+++ b/doc/points.txt
@@ -156,7 +156,7 @@ memory or disk footprint.
 
 As mentioned in the introduction, the PointIndexTree is a structure in OpenVDB
 that stores an array of offset indices to a linear point array in the leaf
-nodes. In constrast, the PointDataTree stores the actual data localised in the
+nodes. In contrast, the PointDataTree stores the actual data localised in the
 leaf nodes.
 
 The PointIndexTree has this tree configuration:
@@ -196,7 +196,7 @@ data. While technically it would be valid to use a non-zero background value and
 tile value, this would simply mean that only the first voxel in the LeafNode
 contains points which is neither an efficient storage mechanism nor particularly
 common. For this reason, the LeafNode constructor may take a background value
-but it is internally overriden to be zero on construction.
+but it is internally overridden to be zero on construction.
 
 @subsection secPtActiveValues Active Values
 
@@ -224,7 +224,7 @@ for (; iterOn; ++iterOn) {
 }
 @endcode
 
-These are analagous to the value iterators in the LeafNode and are creating an
+These are analogous to the value iterators in the LeafNode and are creating an
 index iterator that wraps the value iterator together with a null filter.
 
 It is also possible to iterate over indices within a specific voxel by using the
diff --git a/nanovdb/nanovdb/GridHandle.h b/nanovdb/nanovdb/GridHandle.h
index 05e492046b..0ae8c2f35b 100644
--- a/nanovdb/nanovdb/GridHandle.h
+++ b/nanovdb/nanovdb/GridHandle.h
@@ -250,12 +250,12 @@ class GridHandle
     /// @param is input stream containing a raw grid buffer
     /// @param gridName string name of the grid to be read
     /// @param pool optional pool from which to allocate the new grid buffer
-    /// @throw Will throw a std::logic_error if the stream does not contain a valid raw grid with the speficied name
+    /// @throw Will throw a std::logic_error if the stream does not contain a valid raw grid with the specified name
     void read(std::istream& is, const std::string &gridName, const BufferT& pool = BufferT());
 
     /// @brief Read a raw grid buffer from a file
     /// @param filename string name of the input file containing a raw grid buffer
-    /// @param pool optional pool from which to allocate the new grid buffe
+    /// @param pool optional pool from which to allocate the new grid buffer
     void read(const std::string &fileName, const BufferT& pool = BufferT()) {
         std::ifstream is(fileName, std::ios::in | std::ios::binary);
         if (!is.is_open()) throw std::ios_base::failure("Unable to open file named \"" + fileName + "\" for input");
@@ -279,7 +279,7 @@ class GridHandle
     /// @param gridName string name of the grid to be read
     /// @param pool optional pool from which to allocate the new grid buffer
     /// @throw Will throw a std::ios_base::failure if the file does not exist and a
-    ///        std::logic_error if the files does not contain a valid raw grid withe the specified name
+    ///        std::logic_error if the files does not contain a valid raw grid with the specified name
     void read(const std::string &fileName, const std::string &gridName, const BufferT& pool = BufferT()) {
         std::ifstream is(fileName, std::ios::in | std::ios::binary);
         if (!is.is_open()) throw std::ios_base::failure("Unable to open file named \"" + fileName + "\" for input");
diff --git a/nanovdb/nanovdb/HostBuffer.h b/nanovdb/nanovdb/HostBuffer.h
index 70c9ce0fa4..bcbcb4326a 100644
--- a/nanovdb/nanovdb/HostBuffer.h
+++ b/nanovdb/nanovdb/HostBuffer.h
@@ -11,7 +11,7 @@
 
     @details This HostBuffer can be used in multiple ways, most of which are
              demonstrated in the examples below. Memory in the pool can
-             be managed or unmanged (e.g. internal or external) and can
+             be managed or unmanaged (e.g. internal or external) and can
              be shared between multiple buffers or belong to a single buffer.
 
    Example that uses HostBuffer::create inside io::readGrids to create a
@@ -145,7 +145,7 @@ class HostBuffer
      /// @brief Move copy-constructor
     HostBuffer(HostBuffer&& other);
 
-    /// @brief Custom descructor
+    /// @brief Custom destructor
     ~HostBuffer() { this->clear(); }
 
     /// @brief Move copy assignment operation
@@ -185,7 +185,7 @@ class HostBuffer
     void init(uint64_t bufferSize, void *data = nullptr);
 
     //@{
-    /// @brief Retuns a pointer to the raw memory buffer managed by this allocator.
+    /// @brief Returns a pointer to the raw memory buffer managed by this allocator.
     ///
     /// @warning Note that the pointer can be NULL if the allocator was not initialized!
     const void* data() const { return mData; }
diff --git a/nanovdb/nanovdb/NanoVDB.h b/nanovdb/nanovdb/NanoVDB.h
index 36b412b0e4..11c9350387 100644
--- a/nanovdb/nanovdb/NanoVDB.h
+++ b/nanovdb/nanovdb/NanoVDB.h
@@ -249,7 +249,7 @@ enum class GridType : uint32_t { Unknown = 0, //  unknown value type - should ra
 /// @brief Maps a GridType to a c-string
 /// @param dst destination string of size 12 or larger
 /// @param gridType GridType enum to be mapped to a string
-/// @return Retuns a c-string used to describe a GridType
+/// @return Returns a c-string used to describe a GridType
 __hostdev__ inline char* toStr(char *dst, GridType gridType)
 {
     switch (gridType){
@@ -301,7 +301,7 @@ enum class GridClass : uint32_t { Unknown = 0,
                                   StrLen = End + 7};// this entry is used to determine the minimum size of c-string
 
 
-/// @brief Retuns a c-string used to describe a GridClass
+/// @brief Returns a c-string used to describe a GridClass
 /// @param dst destination string of size 7 or larger
 /// @param gridClass GridClass enum to be converted to a string
 __hostdev__ inline char* toStr(char *dst, GridClass gridClass)
@@ -335,7 +335,7 @@ enum class GridFlags : uint32_t {
     StrLen = End + 23,// this entry is used to determine the minimum size of c-string
 };
 
-/// @brief Retuns a c-string used to describe a GridFlags
+/// @brief Returns a c-string used to describe a GridFlags
 /// @param dst destination string of size 23 or larger
 /// @param gridFlags GridFlags enum to be converted to a string
 __hostdev__ inline const char* toStr(char *dst, GridFlags gridFlags)
@@ -709,11 +709,11 @@ class Version
     __hostdev__ bool isCompatible() const { return this->getMajor() == uint32_t(NANOVDB_MAJOR_VERSION_NUMBER); }
     /// @brief Returns the difference between major version of this instance and NANOVDB_MAJOR_VERSION_NUMBER
     /// @return return 0 if the major version equals NANOVDB_MAJOR_VERSION_NUMBER, else a negative age if this
-    ///         instance has a smaller major verion (is older), and a positive age if it is newer, i.e. larger.
+    ///         instance has a smaller major version (is older), and a positive age if it is newer, i.e. larger.
     __hostdev__ int age() const {return int(this->getMajor()) - int(NANOVDB_MAJOR_VERSION_NUMBER);}
 }; // Version
 
-/// @brief print the verion number to a c-string
+/// @brief print the version number to a c-string
 /// @param dst destination string of size 8 or more
 /// @param v version to be printed
 /// @return returns destination string @c dst
@@ -1655,7 +1655,7 @@ struct NodeTrait<const GridOrTreeOrRootT, 3>
     using type = const typename GridOrTreeOrRootT::RootNodeType;
 };
 
-// ----------------------------> Froward decelerations of random access methods <--------------------------------------
+// ----------------------------> Forward declarations of random access methods <--------------------------------------
 
 template<typename BuildT>
 struct GetValue;
@@ -1735,9 +1735,9 @@ class Checksum
     /// @brief return the 64 bit checksum of this instance
     [[deprecated("Use Checksum::data instead.")]]
     __hostdev__ uint64_t checksum() const { return mCRC64; }
-    [[deprecated("Use Checksum::head and Ckecksum::tail instead.")]]
+    [[deprecated("Use Checksum::head and Checksum::tail instead.")]]
     __hostdev__ uint32_t& checksum(int i) {NANOVDB_ASSERT(i==0 || i==1); return mCRC32[i]; }
-    [[deprecated("Use Checksum::head and Ckecksum::tail instead.")]]
+    [[deprecated("Use Checksum::head and Checksum::tail instead.")]]
     __hostdev__ uint32_t checksum(int i) const {NANOVDB_ASSERT(i==0 || i==1); return mCRC32[i]; }
 
     __hostdev__ uint64_t  full() const { return mCRC64; }
@@ -2154,12 +2154,12 @@ class Grid : public GridData
     __hostdev__ bool             hasStdDeviation() const { return DataType::mFlags.isMaskOn(GridFlags::HasStdDeviation); }
     __hostdev__ bool             isBreadthFirst() const { return DataType::mFlags.isMaskOn(GridFlags::IsBreadthFirst); }
 
-    /// @brief return true if the specified node type is layed out breadth-first in memory and has a fixed size.
+    /// @brief return true if the specified node type is laid out breadth-first in memory and has a fixed size.
     ///        This allows for sequential access to the nodes.
     template<typename NodeT>
     __hostdev__ bool isSequential() const { return NodeT::FIXED_SIZE && this->isBreadthFirst(); }
 
-    /// @brief return true if the specified node level is layed out breadth-first in memory and has a fixed size.
+    /// @brief return true if the specified node level is laid out breadth-first in memory and has a fixed size.
     ///        This allows for sequential access to the nodes.
     template<int LEVEL>
     __hostdev__ bool isSequential() const { return NodeTrait<TreeT, LEVEL>::type::FIXED_SIZE && this->isBreadthFirst(); }
@@ -2569,7 +2569,7 @@ struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) RootData
 
     __hostdev__ Tile* probeTile(const CoordT& ijk)
     {
-#if 1 // switch between linear and binary seach
+#if 1 // switch between linear and binary search
         const auto key = CoordToKey(ijk);
         for (Tile *p = reinterpret_cast<Tile*>(this + 1), *q = p + mTableSize; p < q; ++p)
             if (p->key == key)
@@ -3216,7 +3216,7 @@ struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) InternalData
         mTable[n].value = v;
     }
 
-    /// @brief Returns a pointer to the child node at the specifed linear offset.
+    /// @brief Returns a pointer to the child node at the specified linear offset.
     __hostdev__ ChildT* getChild(uint32_t n)
     {
         NANOVDB_ASSERT(mChildMask.isOn(n));
@@ -3732,7 +3732,7 @@ class InternalNode : public InternalData<ChildT, Log2Dim>
 
 // --------------------------> LeafData<T> <------------------------------------
 
-/// @brief Stuct with all the member data of the LeafNode (useful during serialization of an openvdb LeafNode)
+/// @brief Struct with all the member data of the LeafNode (useful during serialization of an openvdb LeafNode)
 ///
 /// @note No client code should (or can) interface with this struct so it can safely be ignored!
 template<typename ValueT, typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
@@ -3873,7 +3873,7 @@ struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) LeafFnBase
 
 // --------------------------> LeafData<Fp4> <------------------------------------
 
-/// @brief Stuct with all the member data of the LeafNode (useful during serialization of an openvdb LeafNode)
+/// @brief Struct with all the member data of the LeafNode (useful during serialization of an openvdb LeafNode)
 ///
 /// @note No client code should (or can) interface with this struct so it can safely be ignored!
 template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
@@ -6261,7 +6261,7 @@ struct FileHeader {// 16 bytes
 // Grid size in memory             (uint64_t)   |
 // Grid size on disk               (uint64_t)   |
 // Grid name hash key              (uint64_t)   |
-// Numer of active voxels          (uint64_t)   |
+// Number of active voxels          (uint64_t)  |
 // Grid type                       (uint32_t)   |
 // Grid class                      (uint32_t)   |
 // Characters in grid name         (uint32_t)   |
@@ -6270,7 +6270,7 @@ struct FileHeader {// 16 bytes
 // Size of a voxel in world units  (3*double)   |
 // Byte size of the grid name      (uint32_t)   |
 // Number of nodes per level       (4*uint32_t) |
-// Numer of active tiles per level (3*uint32_t) |
+// Number of active tiles per level (3*uint32_t)|
 // Codec for file compression      (uint16_t)   |
 // Padding due to 8B alignment     (uint16_t)   |
 // Version number                  (uint32_t)   |
diff --git a/nanovdb/nanovdb/PNanoVDB.h b/nanovdb/nanovdb/PNanoVDB.h
index 3e7b306b3a..c6f441972f 100644
--- a/nanovdb/nanovdb/PNanoVDB.h
+++ b/nanovdb/nanovdb/PNanoVDB.h
@@ -442,7 +442,7 @@ float pnanovdb_min(float a, float b) { return min(a, b); }
 float pnanovdb_max(float a, float b) { return max(a, b); }
 #endif
 
-// ------------------------------------------------ Coord/Vec3 Utilties -----------------------------------------------------------
+// ------------------------------------------------ Coord/Vec3 Utilities -----------------------------------------------------------
 
 #if defined(PNANOVDB_C)
 PNANOVDB_FORCE_INLINE pnanovdb_vec3_t pnanovdb_vec3_uniform(float a)
@@ -1638,7 +1638,7 @@ struct pnanovdb_grid_type_constants_t
 };
 PNANOVDB_STRUCT_TYPEDEF(pnanovdb_grid_type_constants_t)
 
-// The following table with offsets will nedd to be updates as new GridTypes are added in NanoVDB.h
+// The following table with offsets will need to be updates as new GridTypes are added in NanoVDB.h
 PNANOVDB_STATIC_CONST pnanovdb_grid_type_constants_t pnanovdb_grid_type_constants[PNANOVDB_GRID_TYPE_END] =
 {
 {28, 28, 28, 28, 28, 32,  0, 8, 20, 32,  8224, 8224, 8224, 8224, 8224, 270368,  1056, 1056, 1056, 1056, 1056, 33824,  80, 80, 80, 80, 96, 96},
diff --git a/nanovdb/nanovdb/cuda/DeviceBuffer.h b/nanovdb/nanovdb/cuda/DeviceBuffer.h
index 465bd9dc6b..1eb07310bc 100644
--- a/nanovdb/nanovdb/cuda/DeviceBuffer.h
+++ b/nanovdb/nanovdb/cuda/DeviceBuffer.h
@@ -183,7 +183,7 @@ public:

     ///////////////////////////////////////////////////////////////////////

-    /// @brief Retuns a raw void pointer to the host/CPU buffer managed by this allocator.
+    /// @brief Returns a raw void pointer to the host/CPU buffer managed by this allocator.
     /// @warning Note that the pointer can be NULL!
     void* data() const { return mCpuData; }

@@ -211,14 +211,14 @@ public:

     ///////////////////////////////////////////////////////////////////////

-    /// @brief Retuns a raw pointer to the specified device/GPU buffer managed by this allocator.
+    /// @brief Returns a raw pointer to the specified device/GPU buffer managed by this allocator.
     /// @warning Note that the pointer can be NULL!
     void* deviceData(int device) const {
         NANOVDB_ASSERT(device >= 0 && device < mDeviceCount);
         return mGpuData[device];
     }

-    /// @brief Retuns a raw pointer to the current device/GPU buffer managed by this allocator.
+    /// @brief Returns a raw pointer to the current device/GPU buffer managed by this allocator.
     /// @warning Note that the pointer can be NULL!
     void* deviceData() const {
         int device = cudaCpuDeviceId;
diff --git a/nanovdb/nanovdb/docs/doxygen-config b/nanovdb/nanovdb/docs/doxygen-config
index 42ba331a75..03825bc9b1 100644
--- a/nanovdb/nanovdb/docs/doxygen-config
+++ b/nanovdb/nanovdb/docs/doxygen-config
@@ -1096,7 +1096,7 @@ HTML_STYLESHEET        =
 # cascading style sheets that are included after the standard style sheets
 # created by doxygen. Using this option one can overrule certain style aspects.
 # This is preferred over using HTML_STYLESHEET since it does not replace the
-# standard style sheet and is therefor more robust against future updates.
+# standard style sheet and is therefore more robust against future updates.
 # Doxygen will copy the style sheet files to the output directory.
 # Note: The order of the extra stylesheet files is of importance (e.g. the last
 # stylesheet in the list overrules the setting of the previous ones in the
@@ -1639,8 +1639,8 @@ EXTRA_PACKAGES         =
 # Note: Only use a user-defined header if you know what you are doing! The
 # following commands have a special meaning inside the header: $title,
 # $datetime, $date, $doxygenversion, $projectname, $projectnumber,
-# $projectbrief, $projectlogo. Doxygen will replace $title with the empy string,
-# for the replacement values of the other commands the user is refered to
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty string,
+# for the replacement values of the other commands the user is referred to
 # HTML_HEADER.
 # This tag requires that the tag GENERATE_LATEX is set to YES.
 
diff --git a/nanovdb/nanovdb/examples/ex_index_grid_cuda/index_grid_cuda_kernel.cu b/nanovdb/nanovdb/examples/ex_index_grid_cuda/index_grid_cuda_kernel.cu
index 82a226e15b..125b71ac48 100644
--- a/nanovdb/nanovdb/examples/ex_index_grid_cuda/index_grid_cuda_kernel.cu
+++ b/nanovdb/nanovdb/examples/ex_index_grid_cuda/index_grid_cuda_kernel.cu
@@ -1,7 +1,7 @@
 // Copyright Contributors to the OpenVDB Project
 // SPDX-License-Identifier: Apache-2.0
 
-#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessable on both the host and device
+#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessible on both the host and device
 #include <nanovdb/cuda/GridHandle.cuh>// required since GridHandle<DeviceBuffer> has device code
 #include <stdio.h> // for printf
 
diff --git a/nanovdb/nanovdb/examples/ex_make_custom_nanovdb_cuda/make_custom_nanovdb_cuda_kernel.cu b/nanovdb/nanovdb/examples/ex_make_custom_nanovdb_cuda/make_custom_nanovdb_cuda_kernel.cu
index 70ba0e87cb..874c6cfa01 100644
--- a/nanovdb/nanovdb/examples/ex_make_custom_nanovdb_cuda/make_custom_nanovdb_cuda_kernel.cu
+++ b/nanovdb/nanovdb/examples/ex_make_custom_nanovdb_cuda/make_custom_nanovdb_cuda_kernel.cu
@@ -1,7 +1,7 @@
 // Copyright Contributors to the OpenVDB Project
 // SPDX-License-Identifier: Apache-2.0
 
-#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessable on both the host and device
+#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessible on both the host and device
 #include <nanovdb/cuda/GridHandle.cuh>// required since GridHandle<DeviceBuffer> has device code
 #include <stdio.h> // for printf
 
diff --git a/nanovdb/nanovdb/examples/ex_nodemanager_cuda/nodemanager_cuda_kernel.cu b/nanovdb/nanovdb/examples/ex_nodemanager_cuda/nodemanager_cuda_kernel.cu
index ae3b3990ff..d94fed4bc7 100644
--- a/nanovdb/nanovdb/examples/ex_nodemanager_cuda/nodemanager_cuda_kernel.cu
+++ b/nanovdb/nanovdb/examples/ex_nodemanager_cuda/nodemanager_cuda_kernel.cu
@@ -1,7 +1,7 @@
 // Copyright Contributors to the OpenVDB Project
 // SPDX-License-Identifier: Apache-2.0
 
-#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessable on both the host and device
+#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessible on both the host and device
 #include <nanovdb/NodeManager.h>
 #include <nanovdb/cuda/GridHandle.cuh>// required since GridHandle<CudaDeviceBuffer> has device code
 #include <nanovdb/cuda/NodeManager.cuh>
diff --git a/nanovdb/nanovdb/examples/ex_openvdb_to_nanovdb_cuda/openvdb_to_nanovdb_cuda_kernel.cu b/nanovdb/nanovdb/examples/ex_openvdb_to_nanovdb_cuda/openvdb_to_nanovdb_cuda_kernel.cu
index e0bf9a021d..1c68a6990b 100644
--- a/nanovdb/nanovdb/examples/ex_openvdb_to_nanovdb_cuda/openvdb_to_nanovdb_cuda_kernel.cu
+++ b/nanovdb/nanovdb/examples/ex_openvdb_to_nanovdb_cuda/openvdb_to_nanovdb_cuda_kernel.cu
@@ -1,7 +1,7 @@
 // Copyright Contributors to the OpenVDB Project
 // SPDX-License-Identifier: Apache-2.0
 
-#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessable on both the host and device
+#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessible on both the host and device
 #include <nanovdb/cuda/GridHandle.cuh>// required since GridHandle<DeviceBuffer> has device code
 #include <stdio.h> // for printf
 
diff --git a/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere/read_nanovdb_sphere.cc b/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere/read_nanovdb_sphere.cc
index e2386216c4..2c36fd6afa 100644
--- a/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere/read_nanovdb_sphere.cc
+++ b/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere/read_nanovdb_sphere.cc
@@ -5,7 +5,7 @@
 
 /// @brief Read a NanoVDB grid form file, check pointer and access a single value
 ///
-/// @note This example does NOT dpend on OpenVDB (or CUDA), only NanoVDB.
+/// @note This example does NOT depend on OpenVDB (or CUDA), only NanoVDB.
 int main()
 {
     try {
diff --git a/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere_accessor_cuda/read_nanovdb_sphere_accessor_cuda_kernel.cu b/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere_accessor_cuda/read_nanovdb_sphere_accessor_cuda_kernel.cu
index 4a15e477c3..2268f6529e 100644
--- a/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere_accessor_cuda/read_nanovdb_sphere_accessor_cuda_kernel.cu
+++ b/nanovdb/nanovdb/examples/ex_read_nanovdb_sphere_accessor_cuda/read_nanovdb_sphere_accessor_cuda_kernel.cu
@@ -1,7 +1,7 @@
 // Copyright Contributors to the OpenVDB Project
 // SPDX-License-Identifier: Apache-2.0
 
-#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessable on both the host and device
+#include <nanovdb/NanoVDB.h> // this defined the core tree data structure of NanoVDB accessible on both the host and device
 #include <stdio.h> // for printf
 
 // This is called by the host only
diff --git a/nanovdb/nanovdb/io/IO.h b/nanovdb/nanovdb/io/IO.h
index a7110846a9..9ed6d98302 100644
--- a/nanovdb/nanovdb/io/IO.h
+++ b/nanovdb/nanovdb/io/IO.h
@@ -16,7 +16,7 @@
 
     \details NanoVDB files take on of two formats:
              1) multiple segments each with multiple grids (segments have easy to access metadata about its grids)
-             2) starting with verion 32.6.0 nanovdb files also support a raw buffer with one or more grids (just a
+             2) starting with version 32.6.0 nanovdb files also support a raw buffer with one or more grids (just a
              dump of a raw grid buffer, so no new metadata in headers as when using segments mentioned above).
 
     // 1: Segment:  FileHeader, MetaData0, gridName0...MetaDataN, gridNameN, compressed Grid0, ... compressed GridN
diff --git a/nanovdb/nanovdb/math/DitherLUT.h b/nanovdb/nanovdb/math/DitherLUT.h
index 7add4a6f33..4085fc0b44 100644
--- a/nanovdb/nanovdb/math/DitherLUT.h
+++ b/nanovdb/nanovdb/math/DitherLUT.h
@@ -182,7 +182,7 @@ ut_initDitherRecursive(int goalres)
     }
 }; // DitherLUT class
 
-}// namspace math
+}// namespace math
 
 }// namespace nanovdb
 
diff --git a/nanovdb/nanovdb/math/HDDA.h b/nanovdb/nanovdb/math/HDDA.h
index c72a58a717..ca86025e4a 100644
--- a/nanovdb/nanovdb/math/HDDA.h
+++ b/nanovdb/nanovdb/math/HDDA.h
@@ -66,7 +66,7 @@ class HDDA
         }
     }
 
-    /// @brief Simular to init above except it uses the bounds of the input ray
+    /// @brief Similar to init above except it uses the bounds of the input ray
     __hostdev__ void init(const RayT& ray, int dim) { this->init(ray, ray.t0(), ray.t1(), dim); }
 
     /// @brief Updates the HDDA to march with the specified dimension
@@ -248,7 +248,7 @@ class DDA
         }
     }
 
-    /// @brief Simular to init above except it uses the bounds of the input ray
+    /// @brief Similar to init above except it uses the bounds of the input ray
     __hostdev__ void init(const RayT& ray) { this->init(ray, ray.t0(), ray.t1()); }
 
     /// @brief Increment the voxel index to next intersected voxel or node
@@ -483,7 +483,7 @@ class TreeMarcher
 
 /// @brief A Tree Marcher for Point Grids
 ///
-/// @note This class will handle correctly offseting the ray by 0.5 to ensure that
+/// @note This class will handle correctly offsetting the ray by 0.5 to ensure that
 /// the underlying HDDA will intersect with the grid-cells. See details below.
 
 template<typename AccT, typename RayT, typename CoordT = Coord>
@@ -498,10 +498,10 @@ class PointTreeMarcher : public TreeMarcher<LeafNode<typename AccT::ValueType>,
     /// @details An offset by 0.5 is applied to the ray to account for the fact that points in vdb
     ///          grids are bucketed into so-called grid cell, which are centered round grid voxels,
     ///          whereas the DDA is based on so-called grid nodes, which are coincident with grid
-    ///          voxels. So, rather than offsettting the points by 0.5 to bring them into a grid
+    ///          voxels. So, rather than offsetting the points by 0.5 to bring them into a grid
     ///          node representation this method offsets the eye of the ray by 0.5, which effectively
     ///          ensures that the DDA operates on grid cells as oppose to grid nodes. This subtle
-    ///          but important offset by 0.5 is explined in more details in our online documentation.
+    ///          but important offset by 0.5 is explained in more details in our online documentation.
     __hostdev__ bool init(RayT ray) { return BaseT::init(ray.offsetEye(0.5)); }
 };// PointTreeMarcher
 
diff --git a/nanovdb/nanovdb/math/Stencils.h b/nanovdb/nanovdb/math/Stencils.h
index e46638106c..6767a79732 100644
--- a/nanovdb/nanovdb/math/Stencils.h
+++ b/nanovdb/nanovdb/math/Stencils.h
@@ -243,7 +243,7 @@ class BaseStencil
     ///
     /// @details The ordering of bit mask is ( -x, +x, -y, +y, -z, +z ), so to
     /// check if there is an intersection in -y use (mask & (1u<<2)) where mask is
-    /// ther return value from this function. To check if there are any
+    /// the return value from this function. To check if there are any
     /// intersections use mask!=0u, and for no intersections use mask==0u.
     /// To count the number of intersections use __builtin_popcount(mask).
     __hostdev__ inline Mask intersectionMask(ValueType isoValue = ValueType(0)) const
@@ -338,7 +338,7 @@ class BoxStencil: public BaseStencil<BoxStencil<GridT>, 8, GridT>
     /// @param xyz Floating point coordinate position. Index space and NOT world space.
     /// @warning It is assumed that the stencil has already been moved
     /// to the relevant voxel position, e.g. using moveTo(xyz).
-    /// @note Trilinear interpolation kernal reads as:
+    /// @note Trilinear interpolation kernel reads as:
     ///       v000 (1-u)(1-v)(1-w) + v001 (1-u)(1-v)w + v010 (1-u)v(1-w) + v011 (1-u)vw
     ///     + v100 u(1-v)(1-w)     + v101 u(1-v)w     + v110 uv(1-w)     + v111 uvw
     __hostdev__ inline ValueType interpolation(const Vec3<ValueType>& xyz) const
@@ -539,7 +539,7 @@ class GradStencil : public BaseStencil<GradStencil<GridT>, 7, GridT>
     /// from which the level set was derived.
     ///
     /// @note This method assumes that the grid represents a level set
-    /// with distances in world units and a simple affine transfrom
+    /// with distances in world units and a simple affine transform
     /// with uniform scaling.
     __hostdev__ inline Vec3<ValueType> cpt()
     {
diff --git a/nanovdb/nanovdb/python/test/TestNanoVDB.py b/nanovdb/nanovdb/python/test/TestNanoVDB.py
index 03660c6342..dbe3965348 100644
--- a/nanovdb/nanovdb/python/test/TestNanoVDB.py
+++ b/nanovdb/nanovdb/python/test/TestNanoVDB.py
@@ -597,7 +597,7 @@ def test_sample_from_points_float(self):
                     [100.0, 0.0, 0.0],  # on the boundary
                     [0.0, 0.0, 99.0],  # interior point inside the narrow band
                     [0.0, 101.0, 0.0],  # exterior point inside the narrow band
-                    [110.0, 0.0, 0.0],  # exterior point ouside the narrow band
+                    [110.0, 0.0, 0.0],  # exterior point outside the narrow band
                 ],
                 dtype=torch.float32,
                 device=torch.device("cuda", 0),
diff --git a/nanovdb/nanovdb/tools/GridBuilder.h b/nanovdb/nanovdb/tools/GridBuilder.h
index 428215ba65..f396588947 100644
--- a/nanovdb/nanovdb/tools/GridBuilder.h
+++ b/nanovdb/nanovdb/tools/GridBuilder.h
@@ -34,7 +34,7 @@ namespace nanovdb {
 
 namespace tools::build {
 
-// ----------------------------> Froward decelerations of random access methods <--------------------------------------
+// ----------------------------> Forward declarations of random access methods <--------------------------------------
 
 template <typename T> struct GetValue;
 template <typename T> struct SetValue;
diff --git a/nanovdb/nanovdb/tools/GridChecksum.h b/nanovdb/nanovdb/tools/GridChecksum.h
index 62323c30f5..0d8f5dcd59 100644
--- a/nanovdb/nanovdb/tools/GridChecksum.h
+++ b/nanovdb/nanovdb/tools/GridChecksum.h
@@ -138,9 +138,9 @@ inline __hostdev__ uint32_t crc32(const void *begin, const void *end, uint32_t c
 }
 
 /// @brief Compute crc32 checksum of @c data with @c size bytes using a lookup table
-/// @param data pointer to begenning of data
+/// @param data pointer to beginning of data
 /// @param size byte size
-/// @param lut pointer to loopup table for accelerated crc32 computation
+/// @param lut pointer to lookup table for accelerated crc32 computation
 /// @param crc initial value of the checksum
 /// @return crc32 checksum of @c data with @c size bytes
 inline __hostdev__ uint32_t crc32(const void *data, size_t size, const uint32_t lut[256], uint32_t crc = 0)
@@ -154,7 +154,7 @@ inline __hostdev__ uint32_t crc32(const void *data, size_t size, const uint32_t
 /// @brief Compute crc32 checksum of data between @c begin and @c end using a lookup table
 /// @param begin points to beginning of data
 /// @param end points to end of @data, (exclusive)
-/// @param lut pointer to loopup table for accelerated crc32 computation
+/// @param lut pointer to lookup table for accelerated crc32 computation
 /// @param crc initial value of crc32 checksum
 /// @return return crc32 checksum
 inline __hostdev__ uint32_t crc32(const void *begin, const void *end, const uint32_t lut[256], uint32_t crc = 0)
diff --git a/nanovdb/nanovdb/tools/GridStats.h b/nanovdb/nanovdb/tools/GridStats.h
index fac54b20f7..1489ff1cda 100644
--- a/nanovdb/nanovdb/tools/GridStats.h
+++ b/nanovdb/nanovdb/tools/GridStats.h
@@ -59,7 +59,7 @@ class Extrema;
 /// @tparam BuildT Build type of the input grid
 /// @param grid typed grid
 /// @param bbox index bounding box in which min/max are computed
-/// @return Extream of values insixe @c bbox
+/// @return Extrema of values inside @c bbox
 template<typename BuildT>
 Extrema<typename NanoGrid<BuildT>::ValueType>
 getExtrema(const NanoGrid<BuildT>& grid, const CoordBBox &bbox);
@@ -244,7 +244,7 @@ class Stats<ValueT, 0> : public Extrema<ValueT, 0>
 {
 protected:
     using BaseT = Extrema<ValueT, 0>;
-    using RealT = double; // for accuracy the internal precission must be 64 bit floats
+    using RealT = double; // for accuracy the internal precision must be 64 bit floats
     size_t mSize;
     double mAvg, mAux;
 
diff --git a/nanovdb/nanovdb/tools/GridValidator.h b/nanovdb/nanovdb/tools/GridValidator.h
index 6a8565cbef..72e448f678 100644
--- a/nanovdb/nanovdb/tools/GridValidator.h
+++ b/nanovdb/nanovdb/tools/GridValidator.h
@@ -212,7 +212,7 @@ bool validateGrid(const GridHandleT &handle, uint32_t gridID, CheckMode mode, bo
 /// @param handle GridHandle containing host grids (0,1...,N)
 /// @param mode node of validation tests
 /// @param verbose if true information is printed if a grid fails a validation test
-/// @return true if all grids pass alle the validation tests
+/// @return true if all grids pass all the validation tests
 template <typename GridHandleT>
 bool validateGrids(const GridHandleT &handle, CheckMode mode, bool verbose)
 {
diff --git a/nanovdb/nanovdb/tools/cuda/GridChecksum.cuh b/nanovdb/nanovdb/tools/cuda/GridChecksum.cuh
index 5cc964e5d5..eef49d5ebc 100644
--- a/nanovdb/nanovdb/tools/cuda/GridChecksum.cuh
+++ b/nanovdb/nanovdb/tools/cuda/GridChecksum.cuh
@@ -72,7 +72,7 @@ inline void updateChecksum(GridData *d_gridData, cudaStream_t stream = 0)
 namespace util::cuda {
 
 /// @brief Cuda kernel that computes CRC32 checksums of blocks of data using a look-up-table
-/// @param d_data device pointer to raw data from wich to compute the CRC32 checksums
+/// @param d_data device pointer to raw data from which to compute the CRC32 checksums
 /// @param d_blockCRC device pointer to array of @c blockCount checksums for each block
 /// @param blockCount number of blocks and checksums
 /// @param blockSize size of each block in bytes
@@ -85,7 +85,7 @@ __global__ void crc32Kernel(const T *d_data, uint32_t* d_blockCRC, uint32_t bloc
 }
 
 /// @brief Cuda kernel that computes CRC32 checksums of blocks of data (without using a look-up-table)
-/// @param d_data device pointer to raw data from wich to compute the CRC32 checksums
+/// @param d_data device pointer to raw data from which to compute the CRC32 checksums
 /// @param d_blockCRC device pointer to array of @c blockCount checksums for each block
 /// @param blockCount number of blocks and checksums
 /// @param blockSize size of each block in bytes
@@ -374,7 +374,7 @@ inline Checksum getChecksum(const GridData *d_gridData, cudaStream_t stream)
 /// @param stream optional cuda stream (defaults to zero)
 /// @return The actual mode used for checksum computation. Eg. if @c d_gridData is NULL (or @c mode = CheckMode::Empty)
 ///         then CheckMode::Empty is always returned. Else if the grid has no nodes or blind data CheckMode::Partial
-///         is always returnd (even if @c mode = CheckMode::Full).
+///         is always returned (even if @c mode = CheckMode::Full).
 inline void updateChecksum(GridData *d_gridData, CheckMode mode, cudaStream_t stream)
 {
     NANOVDB_ASSERT(d_gridData);
diff --git a/nanovdb/nanovdb/tools/cuda/GridStats.cuh b/nanovdb/nanovdb/tools/cuda/GridStats.cuh
index 0ba570acfa..537db1b4b9 100644
--- a/nanovdb/nanovdb/tools/cuda/GridStats.cuh
+++ b/nanovdb/nanovdb/tools/cuda/GridStats.cuh
@@ -32,7 +32,7 @@ void updateGridStats(NanoGrid<BuildT> *d_grid, StatsMode mode = StatsMode::Defau
 
 //================================================================================================
 
-/// @brief Allows for the construction of NanoVDB grids without any dependecy
+/// @brief Allows for the construction of NanoVDB grids without any dependency
 template<typename BuildT, typename StatsT = Stats<typename NanoGrid<BuildT>::ValueType>>
 class GridStats
 {
diff --git a/nanovdb/nanovdb/tools/cuda/PointsToGrid.cuh b/nanovdb/nanovdb/tools/cuda/PointsToGrid.cuh
index bcf335efe1..fc16f5cfdd 100644
--- a/nanovdb/nanovdb/tools/cuda/PointsToGrid.cuh
+++ b/nanovdb/nanovdb/tools/cuda/PointsToGrid.cuh
@@ -70,7 +70,7 @@ pointsToGrid(const PtrT dWorldPoints,
 /// @param maxPointsPerVoxel Max density of points per voxel, i.e. maximum number of points in any voxel
 /// @param tolerance allow for point density to vary by the specified tolerance (defaults to 1). That is, the voxel size
 ///                  is selected such that the max density is +/- the tolerance.
-/// @param maxIterations Maximum number of iterations used to seach for a voxel size that produces a point density
+/// @param maxIterations Maximum number of iterations used to search for a voxel size that produces a point density
 ///                      with specified tolerance takes.
 /// @param type Defined the way point information is represented in the output grid (see PointType enum in NanoVDB.h)
 ///             Should not be PointType::Disable!
@@ -141,13 +141,13 @@ class fancy_ptr
     const T* mPtr;
 public:
     /// @brief Default constructor.
-    /// @note  This method is atcually not required by cuda::PointsToGrid
+    /// @note  This method is actually not required by cuda::PointsToGrid
     /// @param ptr Pointer to array of elements
     __hostdev__ explicit fancy_ptr(const T* ptr = nullptr) : mPtr(ptr) {}
-    /// @brief Index acces into the array pointed to by the stored pointer.
+    /// @brief Index access into the array pointed to by the stored pointer.
     /// @note  This method is required by cuda::PointsToGrid!
     /// @param i Unsigned index of the element to be returned
-    /// @return Const refernce to the element at the i'th poisiton
+    /// @return Const reference to the element at the i'th position
     __hostdev__ inline const T& operator[](size_t i) const {return mPtr[i];}
     /// @brief Dummy implementation required by pointer_traits.
     /// @note  Note that only the return type matters!
@@ -691,7 +691,7 @@ jump:// this marks the beginning of the actual algorithm
             goto jump;
         }
     }
-    if (iterCounter>1 && mVerbose) std::cerr << "Used " << iterCounter << " attempts to determine dx that produces a target dpoint denisty\n\n";
+    if (iterCounter>1 && mVerbose) std::cerr << "Used " << iterCounter << " attempts to determine dx that produces a target dpoint density\n\n";
 
     if (mVerbose==2) mTimer.restart("Compute prefix sum of points per voxel");
     mData.pointsPerVoxelPrefix = mMemPool.template alloc<uint32_t>(mData.voxelCount, mStream);
diff --git a/nanovdb/nanovdb/unittest/TestNanoVDB.cc b/nanovdb/nanovdb/unittest/TestNanoVDB.cc
index 33e120c063..60f68924c0 100644
--- a/nanovdb/nanovdb/unittest/TestNanoVDB.cc
+++ b/nanovdb/nanovdb/unittest/TestNanoVDB.cc
@@ -5511,8 +5511,8 @@ TEST_F(TestNanoVDB, VectorSampleFromVoxels)
     //std::cerr << "1'th order: v = " << sampler1(ijk) << std::endl;
     for (int i = 0; i < 3; ++i)
         EXPECT_NEAR(exact[i], sampler1(ijk)[i], 1e-5);
-    //EXPECT_FALSE(sampler1.zeroCrossing());// triggeres a static_assert error
-    //EXPECT_FALSE(sampler1.gradient(grid->indexToWorld(ijk)));// triggeres a static_assert error
+    //EXPECT_FALSE(sampler1.zeroCrossing());// triggers a static_assert error
+    //EXPECT_FALSE(sampler1.gradient(grid->indexToWorld(ijk)));// triggers a static_assert error
 
     nanovdb::math::SampleFromVoxels<nanovdb::NanoTree<nanovdb::Vec3f>, 3> sampler3(grid->tree());
     //auto sampler3 = nanovdb::math::createSampler<3>( acc );
@@ -5663,7 +5663,7 @@ TEST_F(TestNanoVDB, GridValidator)
     EXPECT_EQ(fastChecksum, nanovdb::tools::evalChecksum(grid, nanovdb::CheckMode::Full));
     EXPECT_TRUE(nanovdb::tools::isValid(grid, nanovdb::CheckMode::Full, true));
 
-    leaf->data()->mValueMask.toggle(0); // change a singel bit in a value mask
+    leaf->data()->mValueMask.toggle(0); // change a single bit in a value mask
 
     EXPECT_NE(fastChecksum, nanovdb::tools::evalChecksum(grid, nanovdb::CheckMode::Full));
     EXPECT_FALSE(nanovdb::tools::isValid(grid, nanovdb::CheckMode::Full, false));
diff --git a/nanovdb/nanovdb/unittest/TestNanoVDB.cu b/nanovdb/nanovdb/unittest/TestNanoVDB.cu
index 0d5f797299..95135500ab 100644
--- a/nanovdb/nanovdb/unittest/TestNanoVDB.cu
+++ b/nanovdb/nanovdb/unittest/TestNanoVDB.cu
@@ -727,13 +727,13 @@ TEST(TestNanoVDBCUDA, mergeSplitDeviceGrids)
 TEST(TestNanoVDBCUDA, CudaIndexGridToGrid_basic)
 {
     using BufferT = nanovdb::cuda::DeviceBuffer;
-    const float value = 1.23456f, backgroud = 1.0f;
+    const float value = 1.23456f, background = 1.0f;
     const nanovdb::Coord ijk(1,2,3);
     nanovdb::GridHandle<BufferT> floatHdl;
     nanovdb::FloatGrid *floatGrid = nullptr;
     //nanovdb::util::Timer timer;
     {// create float grid with one active voxel
-        nanovdb::tools::build::Grid<float> grid(backgroud);
+        nanovdb::tools::build::Grid<float> grid(background);
         auto srcAcc = grid.getAccessor();
         srcAcc.setValue(ijk, value);
         auto nodeCount = grid.nodeCount();
@@ -750,11 +750,11 @@ TEST(TestNanoVDBCUDA, CudaIndexGridToGrid_basic)
         EXPECT_EQ(ijk, floatGrid->indexBBox()[0]);
         EXPECT_EQ(ijk, floatGrid->indexBBox()[1]);
         auto acc = floatGrid->getAccessor();
-        EXPECT_EQ(backgroud, acc.getValue(nanovdb::Coord(-1)));
+        EXPECT_EQ(background, acc.getValue(nanovdb::Coord(-1)));
         EXPECT_FALSE(acc.isActive(nanovdb::Coord(-1)));
-        EXPECT_EQ(backgroud, acc.getValue(nanovdb::Coord(8)));
+        EXPECT_EQ(background, acc.getValue(nanovdb::Coord(8)));
         EXPECT_FALSE(acc.isActive(nanovdb::Coord(8)));
-        EXPECT_EQ(backgroud, acc.getValue(nanovdb::Coord(0)));
+        EXPECT_EQ(background, acc.getValue(nanovdb::Coord(0)));
         EXPECT_FALSE(acc.isActive(nanovdb::Coord(0)));
         EXPECT_EQ(value, acc.getValue(ijk));
         EXPECT_TRUE(acc.isActive(ijk));
@@ -771,7 +771,7 @@ TEST(TestNanoVDBCUDA, CudaIndexGridToGrid_basic)
     //timer.restart("Create value list on CPU");
     EXPECT_EQ(1u + 512u, idxGrid->valueCount());// background + 512 values in one leaf node
     float *values = new float[idxGrid->valueCount()], *d_values = nullptr;
-    values[0] = backgroud;
+    values[0] = background;
     const float *q = floatGrid->tree().getFirstLeaf()->mValues;
     for (float *p=values+1, *e=p+512;p!=e; ++p) *p = *q++;
     //timer.restart("Allocate and copy values from CPU to GPU");
@@ -796,23 +796,23 @@ TEST(TestNanoVDBCUDA, CudaIndexGridToGrid_basic)
     EXPECT_EQ(floatGrid->indexBBox(), floatGrid2->indexBBox());
     EXPECT_EQ(floatGrid->worldBBox(), floatGrid2->worldBBox());
     // probe background in root node
-    EXPECT_EQ(backgroud, acc.getValue(nanovdb::Coord(-1)));
+    EXPECT_EQ(background, acc.getValue(nanovdb::Coord(-1)));
     EXPECT_FALSE(acc.isActive(nanovdb::Coord(-1)));
-    EXPECT_EQ(backgroud, acc2.getValue(nanovdb::Coord(-1)));
+    EXPECT_EQ(background, acc2.getValue(nanovdb::Coord(-1)));
     EXPECT_FALSE(acc2.isActive(nanovdb::Coord(-1)));
     // probe background in upper node
-    EXPECT_EQ(backgroud, acc.getValue(nanovdb::Coord(128)));
+    EXPECT_EQ(background, acc.getValue(nanovdb::Coord(128)));
     EXPECT_FALSE(acc.isActive(nanovdb::Coord(128)));
-    EXPECT_EQ(backgroud, floatGrid2->tree().getValue(nanovdb::Coord(128)));
-    EXPECT_EQ(backgroud, acc2.getValue(nanovdb::Coord(128)));
+    EXPECT_EQ(background, floatGrid2->tree().getValue(nanovdb::Coord(128)));
+    EXPECT_EQ(background, acc2.getValue(nanovdb::Coord(128)));
     EXPECT_FALSE(acc2.isActive(nanovdb::Coord(128)));
     // probe background in leaf node
-    EXPECT_EQ(backgroud, acc.getValue(nanovdb::Coord(0)));
+    EXPECT_EQ(background, acc.getValue(nanovdb::Coord(0)));
     EXPECT_FALSE(acc.isActive(nanovdb::Coord(0)));
-    EXPECT_EQ(backgroud, leaf2->getValue(nanovdb::Coord(0)));
+    EXPECT_EQ(background, leaf2->getValue(nanovdb::Coord(0)));
     EXPECT_FALSE(leaf2->isActive(nanovdb::Coord(0)));
-    EXPECT_EQ(backgroud, floatGrid2->tree().getValue(nanovdb::Coord(0)));
-    EXPECT_EQ(backgroud, acc2.getValue(nanovdb::Coord(0)));
+    EXPECT_EQ(background, floatGrid2->tree().getValue(nanovdb::Coord(0)));
+    EXPECT_EQ(background, acc2.getValue(nanovdb::Coord(0)));
     EXPECT_FALSE(acc2.isActive(nanovdb::Coord(0)));
 
     EXPECT_EQ(value, acc2.getValue(ijk));
@@ -1445,7 +1445,7 @@ TEST(TestNanoVDBCUDA, Large_CudaPointsToGrid_World64)
 }// Large_CudaPointsToGrid_World64
 
 TEST(TestNanoVDBCUDA, Large_CudaPointsToGrid_World64_density)
-{// unlike the previous unit-test this one selects the dx to match a specefic point density
+{// unlike the previous unit-test this one selects the dx to match a specific point density
     using BuildT = nanovdb::Point;
     using Vec3T  = nanovdb::Vec3d;
     //nanovdb::util::Timer timer;
diff --git a/nanovdb/nanovdb/unittest/TestOpenVDB.cc b/nanovdb/nanovdb/unittest/TestOpenVDB.cc
index 238bdc8026..b229934513 100644
--- a/nanovdb/nanovdb/unittest/TestOpenVDB.cc
+++ b/nanovdb/nanovdb/unittest/TestOpenVDB.cc
@@ -1413,7 +1413,7 @@ TEST_F(TestOpenVDB, PointDataGridRandom)
                 EXPECT_EQ( wldSrc[i], wldDst[i] );
             }
 
-            // compair to original input points
+            // compare to original input points
             auto it = search( wldSrc );
             EXPECT_TRUE( it != positions.end() );
             positions.erase( it );
@@ -2511,11 +2511,11 @@ TEST_F(TestOpenVDB, Tricubic)
     auto sampler2 = nanovdb::math::createSampler<2>(dstAcc);
     //std::cerr << "2'rd order: nanovdb = " << sampler2(ijk) << ", openvdb: " << openvdb::tools::Sampler<2>::sample(srcGrid->tree(), ijk) << std::endl;
     EXPECT_NEAR(sampler2(ijk), openvdb::tools::Sampler<2>::sample(srcGrid->tree(), ijk), 1e-6);
-    EXPECT_NE(exact, sampler2(ijk)); // it's a 3nd order polynomial
+    EXPECT_NE(exact, sampler2(ijk)); // it's a 3rd order polynomial
 
     auto sampler3 = nanovdb::math::createSampler<3>(dstAcc);
     //std::cerr << "3'rd order: v = " << sampler3(ijk) << std::endl;
-    EXPECT_NEAR(exact, sampler3(ijk), 1e-4); // it's a 3nd order polynomial
+    EXPECT_NEAR(exact, sampler3(ijk), 1e-4); // it's a 3rd order polynomial
 } // Tricubic
 
 TEST_F(TestOpenVDB, GridValidator)
diff --git a/nanovdb/nanovdb/util/Timer.h b/nanovdb/nanovdb/util/Timer.h
index b2d8dc9e9c..e2d0dc89ec 100644
--- a/nanovdb/nanovdb/util/Timer.h
+++ b/nanovdb/nanovdb/util/Timer.h
@@ -50,7 +50,7 @@ public:
         return std::chrono::duration_cast<std::chrono::milliseconds>(mStop - mStart).count();
     }

-    /// @brief call record and return the elapsed time (since start) in miliseconds
+    /// @brief call record and return the elapsed time (since start) in milliseconds
     template <typename AccuracyT = std::chrono::milliseconds>
     auto elapsed()
     {
diff --git a/nanovdb/nanovdb/util/Util.h b/nanovdb/nanovdb/util/Util.h
index 7dcdfbdb84..4dd4e2816c 100644
--- a/nanovdb/nanovdb/util/Util.h
+++ b/nanovdb/nanovdb/util/Util.h
@@ -196,7 +196,7 @@ __hostdev__ inline char* strncpy(char *dst, const char *src, size_t max)
 /// @param num signed number to be concatenated after @c dst
 /// @param bas base used when converting @c num to a string
 /// @return destination string @c dst
-/// @note Emulates the behaviour of itoa, except this verion also works on the GPU.
+/// @note Emulates the behaviour of itoa, except this version also works on the GPU.
 __hostdev__ inline char* strcpy(char* dst, int num, int bas = 10)
 {
     NANOVDB_ASSERT(dst != nullptr && bas > 0);
diff --git a/nanovdb/nanovdb/util/cuda/Timer.h b/nanovdb/nanovdb/util/cuda/Timer.h
index 07c9366a0d..07ed1b9d1b 100644
--- a/nanovdb/nanovdb/util/cuda/Timer.h
+++ b/nanovdb/nanovdb/util/cuda/Timer.h
@@ -110,8 +110,8 @@ public:
         return msec;
     }

-    /// @brief elapsed time (since start) in miliseconds
-    /// @return elapsed time (since start) in miliseconds
+    /// @brief elapsed time (since start) in milliseconds
+    /// @return elapsed time (since start) in milliseconds
     inline float elapsed()
     {
         this->record();
diff --git a/openvdb/openvdb/CMakeLists.txt b/openvdb/openvdb/CMakeLists.txt
index 3db0e4e144..d5a8ef4bfa 100644
--- a/openvdb/openvdb/CMakeLists.txt
+++ b/openvdb/openvdb/CMakeLists.txt
@@ -97,7 +97,7 @@ if(WIN32)
        CMAKE_MSVC_RUNTIME_LIBRARY STREQUAL "MultiThreadedDebugDLL")
       if(OPENVDB_CORE_STATIC)
          message(WARNING "Unexpected value for the Windows CRT with target build artifacts."
-          "You are attempting to use the dyanmic CRT (/MD) with a static configuration of OpenVDB."
+          "You are attempting to use the dynamic CRT (/MD) with a static configuration of OpenVDB."
           "This is not recommended and may cause failures.")
       endif()
     endif()
@@ -239,7 +239,7 @@ endif()
 
 # Pull in Boost last as houdini's boost (hboost) is fully namespaced and libs
 # are renamed too. Boost can be pulled in at any time, but do it last so that,
-# if it's in a shared place (like /usr/local) it doesn't accidently pull in
+# if it's in a shared place (like /usr/local) it doesn't accidentally pull in
 # other headers.
 
 if(OPENVDB_USE_DELAYED_LOADING)
diff --git a/openvdb/openvdb/Metadata.cc b/openvdb/openvdb/Metadata.cc
index 8819d4cb06..532023f209 100644
--- a/openvdb/openvdb/Metadata.cc
+++ b/openvdb/openvdb/Metadata.cc
@@ -25,7 +25,7 @@ struct LockedMetadataTypeRegistry {
     MetadataFactoryMap mMap;
 };
 
-// Global function for accessing the regsitry
+// Global function for accessing the registry
 static LockedMetadataTypeRegistry*
 getMetadataTypeRegistry()
 {
diff --git a/openvdb/openvdb/TypeList.h b/openvdb/openvdb/TypeList.h
index 65a26fabcc..c100836013 100644
--- a/openvdb/openvdb/TypeList.h
+++ b/openvdb/openvdb/TypeList.h
@@ -129,7 +129,7 @@ struct TSHasTypeImpl<TypeList<T, Ts...>, T, Idx>
 
 
 /// @brief  Similar to TsAppendImpl but only appends types to a list if the
-///   type does not alreay exist in the list.
+///   type does not already exist in the list.
 /// @details Defines a new @c TypeList with non-unique types appended
 /// @tparam U      Type to append
 /// @tparam ListT  The @c TypeList to append to
@@ -152,7 +152,7 @@ struct TSAppendUniqueImpl<U, TypeList<Ts...>, true> {
     ///   method historically did. e.g:
     ///      TypeList<float, int, float>::Unique<> can become:
     ///        a)  TypeList<float, int>  currently
-    ///        b)  TypeList<int, float>  if we used the afformentioned technique
+    ///        b)  TypeList<int, float>  if we used the aforementioned technique
     ///  Might be useful to have both? Complexity in (a) is currently linear so
     ///  this shouldn't be a problem, but be careful this doesn't change.
     //using type = TypeList<Ts...>;
@@ -174,7 +174,7 @@ struct TSAppendUniqueImpl<U, TypeList<Ts...>, false> {
 ///   @c TypeList for every type (first to last), only if the type does not
 ///   already exist in the new @c TypeList. This has the effect of dropping all
 ///   but the first of duplicate types.
-/// @warning  This implementation previously used an embdedded std::conditional
+/// @warning  This implementation previously used an embedded std::conditional
 ///   which resulted in drastically slow compilation times. If you're changing
 ///   this implementation make sure to profile compile times with larger lists.
 /// @tparam Ts Types within the @c TypeList
@@ -418,27 +418,27 @@ struct TSRemoveIndicesImpl<TypeList<T, Ts...>, First, Last, Idx>
 ///          a user provided converter which provides a @c Type definition.
 /// @tparam  OpT  User struct to convert each type
 /// @tparam Ts  Remaining types in the @c TypeList
-template<template <typename> class OpT, typename... Ts> struct TSTranformImpl;
+template<template <typename> class OpT, typename... Ts> struct TSTransformImpl;
 
 /// @brief  Partial specialization for an empty @c TypeList
 /// @tparam  OpT  User struct to convert each type
 template<template <typename> class OpT>
-struct TSTranformImpl<OpT> {
+struct TSTransformImpl<OpT> {
     using type = TypeList<>;
 };
 
-/// @brief  Implementation of TSTranformImpl. See fwd declaration for details.
+/// @brief  Implementation of TSTransformImpl. See fwd declaration for details.
 /// @tparam OpT  User struct to convert each type
 /// @tparam Ts   Remaining types in the @c TypeList
 /// @tparam T    Current type being converted
 template<template <typename> class OpT, typename T, typename... Ts>
-struct TSTranformImpl<OpT, T, Ts...> {
+struct TSTransformImpl<OpT, T, Ts...> {
 private:
-    using NextList = typename TSTranformImpl<OpT, Ts...>::type;
+    using NextList = typename TSTransformImpl<OpT, Ts...>::type;
 public:
     // Invoke Append for each type to match the behaviour should OpT<T> be a
     // TypeList<>
-    using type = typename TSTranformImpl<OpT>::type::template
+    using type = typename TSTransformImpl<OpT>::type::template
         Append<OpT<T>>::template
         Append<NextList>;
 };
@@ -715,7 +715,7 @@ struct TypeList
     template <size_t First, size_t Last>
     using RemoveByIndex = typename typelist_internal::TSRemoveIndicesImpl<Self, First, Last>::type;
 
-    /// @brief Transform each type of this TypeList, rebuiling a new list of
+    /// @brief Transform each type of this TypeList, rebuilding a new list of
     ///        converted types. This method instantiates a user provided Opt<T> to
     ///        replace each type in the current list.
     /// @warning Transforming types to new TypeList<> objects causes them to expand to
@@ -723,7 +723,7 @@ struct TypeList
     /// @details Example:
     /// @code
     /// {
-    ///     // Templated type decl, where the type T will be subsituted for each type
+    ///     // Templated type decl, where the type T will be substituted for each type
     ///     // in the TypeList being transformed.
     ///     template <typename T>
     ///     using ConvertedType = typename openvdb::PromoteType<T>::Next;
@@ -733,7 +733,7 @@ struct TypeList
     /// }
     /// @endcode
     template<template <typename> class OpT>
-    using Transform = typename typelist_internal::TSTranformImpl<OpT, Ts...>::type;
+    using Transform = typename typelist_internal::TSTransformImpl<OpT, Ts...>::type;
 
     /// @brief Invoke a templated class operator on each type in this list. Use
     ///   this method if you only need access to the type for static methods.
@@ -834,18 +834,18 @@ struct TypeList
 };
 
 /// @brief  A trivial wrapper around a std::tuple but with compatible TypeList
-///   methods. Importantly can be instatiated from a TypeList and implements a
+///   methods. Importantly can be instantiated from a TypeList and implements a
 ///   similar ::foreach interface
 /// @warning  Some member methods here run on actual instances of types in the
 ///   list. As such, it's unlikely that they can always be resolved at compile
-///   time (unlike methods in TypeList). Compilers are notriously bad at
-///   automatically inlining recursive/nested template instations (without fine
+///   time (unlike methods in TypeList). Compilers are notoriously bad at
+///   automatically inlining recursive/nested template instantiations (without fine
 ///   tuning inline options to the frontend) so the public API of this class is
 ///   marked as force inlined. You can disable this behaviour by defining:
 ///      OPENVDB_TYPELIST_NO_FORCE_INLINE
 ///   before including this header. Note however that the ValueAccessor uses
 ///   this API and disabling force inlining can cause significant performance
-///   degredation.
+///   degradation.
 template<typename... Ts>
 struct TupleList
 {
@@ -949,7 +949,7 @@ struct TupleList
     TupleT mTuple;
 };
 
-/// @brief  Specilization of an empty TupleList. Required due to constructor
+/// @brief  Specialization of an empty TupleList. Required due to constructor
 ///   selection.
 template<>
 struct TupleList<>
diff --git a/openvdb/openvdb/io/Archive.cc b/openvdb/openvdb/io/Archive.cc
index 8f99565f20..8bd7ecbfc2 100644
--- a/openvdb/openvdb/io/Archive.cc
+++ b/openvdb/openvdb/io/Archive.cc
@@ -1452,7 +1452,7 @@ Archive::writeGrid(GridDescriptor& gd, GridBase::ConstPtr grid,
     // Write out the Descriptor's header information (grid name and type)
     gd.writeHeader(os);
 
-    // Save the curent stream position as postion to where the offsets for
+    // Save the current stream position as position to where the offsets for
     // this GridDescriptor will be written to.
     int64_t offsetPos = (seekable ? int64_t(os.tellp()) : 0);
 
@@ -1519,7 +1519,7 @@ Archive::writeGridInstance(GridDescriptor& gd, GridBase::ConstPtr grid,
     // and instance parent name).
     gd.writeHeader(os);
 
-    // Save the curent stream position as postion to where the offsets for
+    // Save the current stream position as position to where the offsets for
     // this GridDescriptor will be written to.
     int64_t offsetPos = (seekable ? int64_t(os.tellp()) : 0);
 
diff --git a/openvdb/openvdb/math/BBox.h b/openvdb/openvdb/math/BBox.h
index 4fdcf1027c..629becd5e7 100644
--- a/openvdb/openvdb/math/BBox.h
+++ b/openvdb/openvdb/math/BBox.h
@@ -38,7 +38,7 @@ class BBox
     /// @details If @a sorted is false, sort the points by their
     /// @e x, @e y and @e z components.
     BBox(const Vec3T& xyzMin, const Vec3T& xyzMax, bool sorted);
-    /// @brief Contruct a cubical bounding box from a minimum coordinate
+    /// @brief Construct a cubical bounding box from a minimum coordinate
     /// and an edge length.
     /// @note Inclusive for integral <b>ElementType</b>s
     BBox(const Vec3T& xyzMin, const ElementType& length);
@@ -54,7 +54,7 @@ class BBox
     BBox(const BBox&) = default;
     BBox& operator=(const BBox&) = default;
 
-    /// @brief Sort the mininum and maximum points of this bounding box
+    /// @brief Sort the minimum and maximum points of this bounding box
     /// by their @e x, @e y and @e z components.
     void sort();
 
diff --git a/openvdb/openvdb/math/ConjGradient.h b/openvdb/openvdb/math/ConjGradient.h
index 483db1fa00..c94388229b 100644
--- a/openvdb/openvdb/math/ConjGradient.h
+++ b/openvdb/openvdb/math/ConjGradient.h
@@ -684,7 +684,7 @@ Vector<T>::dot(const Vector<T>& other) const
 
         // Compute the dot product by segmenting the arrays into
         // a predetermined number of sub arrays in parallel and
-        // accumulate the finial result in series.
+        // accumulate the final result in series.
 
         const SizeType binCount = 100;
         T partialSums[100];
diff --git a/openvdb/openvdb/math/FiniteDifference.h b/openvdb/openvdb/math/FiniteDifference.h
index f269f46a10..c4cf8d018a 100644
--- a/openvdb/openvdb/math/FiniteDifference.h
+++ b/openvdb/openvdb/math/FiniteDifference.h
@@ -42,8 +42,8 @@ enum DScheme {
     BD_3RD,         // backward difference,  3rd order
     FD_WENO5,       // forward difference,   weno5
     BD_WENO5,       // backward difference,  weno5
-    FD_HJWENO5,     // forward differene,   HJ-weno5
-    BD_HJWENO5      // backward difference, HJ-weno5
+    FD_HJWENO5,     // forward difference,   HJ-weno5
+    BD_HJWENO5      // backward difference,  HJ-weno5
 };
 
 enum { NUM_DS_SCHEMES = BD_HJWENO5 + 1 };
@@ -438,7 +438,7 @@ struct D1
 template<>
 struct D1<CD_2NDT>
 {
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp1, const ValueType& xm1) {
         return xp1 - xm1;
@@ -493,7 +493,7 @@ template<>
 struct D1<CD_2ND>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp1, const ValueType& xm1) {
         return (xp1 - xm1)*ValueType(0.5);
@@ -553,7 +553,7 @@ template<>
 struct D1<CD_4TH>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference( const ValueType& xp2, const ValueType& xp1,
                                  const ValueType& xm1, const ValueType& xm2 ) {
@@ -622,7 +622,7 @@ template<>
 struct D1<CD_6TH>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference( const ValueType& xp3, const ValueType& xp2, const ValueType& xp1,
                                  const ValueType& xm1, const ValueType& xm2, const ValueType& xm3 )
@@ -702,7 +702,7 @@ template<>
 struct D1<FD_1ST>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp1, const ValueType& xp0) {
         return xp1 - xp0;
@@ -752,7 +752,7 @@ struct D1<FD_1ST>
 template<>
 struct D1<FD_2ND>
 {
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp2, const ValueType& xp1, const ValueType& xp0)
     {
@@ -821,7 +821,7 @@ template<>
 struct D1<FD_3RD>
 {
 
-    // the difference opperator
+    // the difference operator
     template<typename ValueType>
     static ValueType difference(const ValueType& xp3, const ValueType& xp2,
         const ValueType& xp1, const ValueType& xp0)
@@ -893,7 +893,7 @@ template<>
 struct D1<BD_1ST>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xm1, const ValueType& xm0) {
         return -D1<FD_1ST>::difference(xm1, xm0);
@@ -945,7 +945,7 @@ template<>
 struct D1<BD_2ND>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xm2, const ValueType& xm1, const ValueType& xm0)
     {
@@ -1009,7 +1009,7 @@ template<>
 struct D1<BD_3RD>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xm3, const ValueType& xm2,
         const ValueType& xm1, const ValueType& xm0)
@@ -1178,7 +1178,7 @@ template<>
 struct D1<FD_HJWENO5>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp3, const ValueType& xp2,
                                 const ValueType& xp1, const ValueType& xp0,
@@ -1805,7 +1805,7 @@ template<>
 struct D2<CD_SECOND>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp1, const ValueType& xp0, const ValueType& xm1)
     {
@@ -1919,7 +1919,7 @@ template<>
 struct D2<CD_FOURTH>
 {
 
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp2, const ValueType& xp1, const ValueType& xp0,
                                 const ValueType& xm1, const ValueType& xm2) {
@@ -2089,7 +2089,7 @@ struct D2<CD_FOURTH>
 template<>
 struct D2<CD_SIXTH>
 {
-    // the difference opperator
+    // the difference operator
     template <typename ValueType>
     static ValueType difference(const ValueType& xp3, const ValueType& xp2, const ValueType& xp1,
                                 const ValueType& xp0,
diff --git a/openvdb/openvdb/math/Half.cc b/openvdb/openvdb/math/Half.cc
index bbcc70cf67..058a572a2f 100644
--- a/openvdb/openvdb/math/Half.cc
+++ b/openvdb/openvdb/math/Half.cc
@@ -56,10 +56,10 @@ operator>> (std::istream& is, half& h)
     return is;
 }
 
-//---------------------------------------
+//----------------------------------------
 // Functions to print the bit-layout of
-// floats and halfs, mostly for debugging
-//---------------------------------------
+// floats and halves, mostly for debugging
+//----------------------------------------
 
 IMATH_EXPORT void
 printBits (std::ostream& os, half h)
diff --git a/openvdb/openvdb/math/Maps.cc b/openvdb/openvdb/math/Maps.cc
index a6ed7e4411..2f3071f678 100644
--- a/openvdb/openvdb/math/Maps.cc
+++ b/openvdb/openvdb/math/Maps.cc
@@ -116,7 +116,7 @@ createSymmetricMap(const Mat3d& m)
 PolarDecomposedMap::Ptr
 createPolarDecomposedMap(const Mat3d& m)
 {
-    // Because our internal libary left-multiplies vectors against matrices
+    // Because our internal library left-multiplies vectors against matrices
     // we are constructing  M  = Symmetric * Unitary instead of the more
     // standard M = Unitary * Symmetric
     Mat3d unitary, symmetric, mat3 = m.transpose();
diff --git a/openvdb/openvdb/math/Maps.h b/openvdb/openvdb/math/Maps.h
index 03ee7f1f1d..5efb315542 100644
--- a/openvdb/openvdb/math/Maps.h
+++ b/openvdb/openvdb/math/Maps.h
@@ -154,7 +154,7 @@ class OPENVDB_API MapBase
 
     /// Return @c true if this map is linear.
     virtual bool isLinear() const = 0;
-    /// Return @c true if the spacing between the image of latice is uniform in all directions
+    /// Return @c true if the spacing between the image of lattice is uniform in all directions
     virtual bool hasUniformScale() const = 0;
 
     virtual Vec3d applyMap(const Vec3d& in) const = 0;
@@ -429,7 +429,7 @@ class OPENVDB_API AffineMap final: public MapBase
     }
 
     /// Return the Jacobian Transpose of the map applied to @a in.
-    /// This tranforms range-space gradients to domain-space gradients
+    /// This transforms range-space gradients to domain-space gradients
     Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
     Vec3d applyJT(const Vec3d& in) const override {
@@ -552,7 +552,7 @@ class OPENVDB_API AffineMap final: public MapBase
 
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of prepending the appropraite operation.
+    /// of prepending the appropriate operation.
     MapBase::Ptr preRotate(double radians, Axis axis = X_AXIS) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
@@ -582,7 +582,7 @@ class OPENVDB_API AffineMap final: public MapBase
 
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of postfixing the appropraite operation.
+    /// of postfixing the appropriate operation.
     MapBase::Ptr postRotate(double radians, Axis axis = X_AXIS) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
@@ -757,7 +757,7 @@ class OPENVDB_API ScaleMap: public MapBase
     }
 
     /// @brief Return the Jacobian Transpose of the map applied to @a in.
-    /// @details This tranforms range-space gradients to domain-space gradients
+    /// @details This transforms range-space gradients to domain-space gradients
     Vec3d applyJT(const Vec3d& in, const Vec3d&) const final { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
     Vec3d applyJT(const Vec3d& in) const final { return applyMap(in); }
@@ -827,7 +827,7 @@ class OPENVDB_API ScaleMap: public MapBase
         mInvScaleSqr.write(os);
         mInvTwiceScale.write(os);
     }
-    /// string serialization, useful for debuging
+    /// string serialization, useful for debugging
     std::string str() const override
     {
         std::ostringstream buffer;
@@ -857,7 +857,7 @@ class OPENVDB_API ScaleMap: public MapBase
 
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of prepending the appropraite operation to the existing map
+    /// of prepending the appropriate operation to the existing map
     MapBase::Ptr preRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
@@ -878,7 +878,7 @@ class OPENVDB_API ScaleMap: public MapBase
 
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of prepending the appropraite operation to the existing map.
+    /// of prepending the appropriate operation to the existing map.
     MapBase::Ptr postRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
@@ -1034,7 +1034,7 @@ class OPENVDB_API TranslationMap final: public MapBase
 
 
     /// @brief Return the Jacobian Transpose of the map applied to @a in.
-    /// @details This tranforms range-space gradients to domain-space gradients
+    /// @details This transforms range-space gradients to domain-space gradients
     Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
     Vec3d applyJT(const Vec3d& in) const override { return in; }
@@ -1068,7 +1068,7 @@ class OPENVDB_API TranslationMap final: public MapBase
     void read(std::istream& is) override { mTranslation.read(is); }
     /// write serialization
     void write(std::ostream& os) const override { mTranslation.write(os); }
-    /// string serialization, useful for debuging
+    /// string serialization, useful for debugging
     std::string str() const override
     {
         std::ostringstream buffer;
@@ -1289,7 +1289,7 @@ class OPENVDB_API ScaleTranslateMap: public MapBase
     }
 
     /// @brief Return the Jacobian Transpose of the map applied to @a in.
-    /// @details This tranforms range-space gradients to domain-space gradients
+    /// @details This transforms range-space gradients to domain-space gradients
     Vec3d applyJT(const Vec3d& in, const Vec3d&) const final { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
     Vec3d applyJT(const Vec3d& in) const final { return applyJacobian(in); }
@@ -1366,7 +1366,7 @@ class OPENVDB_API ScaleTranslateMap: public MapBase
         mInvScaleSqr.write(os);
         mInvTwiceScale.write(os);
     }
-    /// string serialization, useful for debuging
+    /// string serialization, useful for debugging
     std::string str() const override
     {
         std::ostringstream buffer;
@@ -1398,7 +1398,7 @@ class OPENVDB_API ScaleTranslateMap: public MapBase
 
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of prepending the appropraite operation.
+    /// of prepending the appropriate operation.
     MapBase::Ptr preRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
@@ -1426,7 +1426,7 @@ class OPENVDB_API ScaleTranslateMap: public MapBase
 
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of postfixing the appropraite operation.
+    /// of postfixing the appropriate operation.
     MapBase::Ptr postRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
@@ -1615,7 +1615,7 @@ ScaleTranslateMap::postScale(const Vec3d& v) const
 ////////////////////////////////////////
 
 
-/// @brief A specialized linear transform that performs a unitary maping
+/// @brief A specialized linear transform that performs a unitary mapping
 /// i.e. rotation  and or reflection.
 class OPENVDB_API UnitaryMap final: public MapBase
 {
@@ -1623,7 +1623,7 @@ class OPENVDB_API UnitaryMap final: public MapBase
     using Ptr = SharedPtr<UnitaryMap>;
     using ConstPtr = SharedPtr<const UnitaryMap>;
 
-    /// default constructor makes an Idenity.
+    /// default constructor makes an Identity.
     UnitaryMap(): mAffineMap(Mat4d::identity())
     {
     }
@@ -1753,7 +1753,7 @@ class OPENVDB_API UnitaryMap final: public MapBase
     }
 
     /// @brief Return the Jacobian Transpose of the map applied to @a in.
-    /// @details This tranforms range-space gradients to domain-space gradients
+    /// @details This transforms range-space gradients to domain-space gradients
     Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
     Vec3d applyJT(const Vec3d& in) const override {
@@ -1796,7 +1796,7 @@ class OPENVDB_API UnitaryMap final: public MapBase
     {
         mAffineMap.write(os);
     }
-    /// string serialization, useful for debuging
+    /// string serialization, useful for debugging
     std::string str() const override
     {
         std::ostringstream buffer;
@@ -1915,7 +1915,7 @@ class OPENVDB_API NonlinearFrustumMap final: public MapBase
     /// @brief Constructor that takes an index-space bounding box
     /// to be mapped into a frustum with a given @a depth and @a taper
     /// (defined as ratio of nearplane/farplane).
-    /// @details This frustum is further modifed by the @a secondMap,
+    /// @details This frustum is further modified by the @a secondMap,
     /// intended to be a simple translation and rotation and uniform scale
    NonlinearFrustumMap(const BBoxd& bb, double taper, double depth,
         const MapBase::Ptr& secondMap):
@@ -1923,7 +1923,7 @@ class OPENVDB_API NonlinearFrustumMap final: public MapBase
     {
         if (!secondMap->isLinear() ) {
               OPENVDB_THROW(ArithmeticError,
-                "The second map in the Frustum transfrom must be linear");
+                "The second map in the Frustum transform must be linear");
         }
         mSecondMap = *( secondMap->getAffineMap() );
         init();
@@ -2162,7 +2162,7 @@ class OPENVDB_API NonlinearFrustumMap final: public MapBase
     }
 
     /// @brief Return the Jacobian Transpose of the map applied to vector @c in at @c indexloc.
-    /// @details This tranforms range-space gradients to domain-space gradients.
+    /// @details This transforms range-space gradients to domain-space gradients.
     Vec3d applyJT(const Vec3d& in, const Vec3d& isloc) const override {
         const Vec3d tmp = mSecondMap.applyJT(in);
         // Move the center of the x-face of the bbox
@@ -2365,7 +2365,7 @@ class OPENVDB_API NonlinearFrustumMap final: public MapBase
     /// Return MapBase::Ptr& to the second map
     const AffineMap& secondMap() const { return mSecondMap; }
     /// Return @c true if the  the bounding box in index space that defines the region that
-    /// is maped into the frustum is non-zero, otherwise @c false
+    /// is mapped into the frustum is non-zero, otherwise @c false
     bool isValid() const { return !mBBox.empty();}
 
     /// Return @c true if the second map is a uniform scale, Rotation and translation
@@ -2412,7 +2412,7 @@ class OPENVDB_API NonlinearFrustumMap final: public MapBase
         mSecondMap.write(os);
     }
 
-    /// string serialization, useful for debuging
+    /// string serialization, useful for debugging
     std::string str() const override
     {
         std::ostringstream buffer;
diff --git a/openvdb/openvdb/math/Mat.h b/openvdb/openvdb/math/Mat.h
index d48caced5f..7e546083c2 100644
--- a/openvdb/openvdb/math/Mat.h
+++ b/openvdb/openvdb/math/Mat.h
@@ -654,7 +654,7 @@ unit(const MatType &mat, typename MatType::value_type eps = 1.0e-8)
 
 /// @brief Return a copy of the given matrix with its upper 3&times;3 rows normalized,
 /// and return the length of each of these rows in @a scaling.
-/// @details This can be geometrically interpretted as a matrix with no scaling
+/// @details This can be geometrically interpreted as a matrix with no scaling
 /// along its major axes, and the scaling in the input vector
 template<class MatType>
 MatType
@@ -767,7 +767,7 @@ snapMatBasis(const MatType& source, Axis axis, const Vec3<typename MatType::valu
 
     // Find angle between our basis and the one specified
     T angleBetween(angle(unitDir, ourUnitAxis));
-    // Caclulate axis to rotate along
+    // Calculate axis to rotate along
     Vec3<T> rotationAxis = unitDir.cross(ourUnitAxis);
 
     MatType rotation;
diff --git a/openvdb/openvdb/math/Mat3.h b/openvdb/openvdb/math/Mat3.h
index 01c66d8868..3c61d4033b 100644
--- a/openvdb/openvdb/math/Mat3.h
+++ b/openvdb/openvdb/math/Mat3.h
@@ -492,7 +492,7 @@ class Mat3: public Mat<3, T>
 
     /// This function snaps a specific axis to a specific direction,
     /// preserving scaling. It does this using minimum energy, thus
-    /// posing a unique solution if basis & direction arent parralel.
+    /// posing a unique solution if basis & direction are not parallel.
     /// Direction need not be unit.
     Mat3 snapBasis(Axis axis, const Vec3<T> &direction)
     {
@@ -738,7 +738,7 @@ diagonalizeSymmetricMatrix(const Mat3<T>& input, Mat3<T>& Q, Vec3<T>& D,
     unsigned int MAX_ITERATIONS=250)
 {
     /// use Givens rotation matrix to eliminate off-diagonal entries.
-    /// initialize the rotation matrix as idenity
+    /// initialize the rotation matrix as identity
     Q  = Mat3<T>::identity();
     int n = Mat3<T>::size;  // should be 3
 
@@ -750,7 +750,7 @@ diagonalizeSymmetricMatrix(const Mat3<T>& input, Mat3<T>& Q, Vec3<T>& D,
     }
 
     unsigned int iterations(0);
-    /// Just iterate over all the non-diagonal enteries
+    /// Just iterate over all the non-diagonal entries
     /// using the largest as a pivot.
     do {
         /// check for absolute convergence
diff --git a/openvdb/openvdb/math/Mat4.h b/openvdb/openvdb/math/Mat4.h
index 91a256b7ba..fcdfc5c392 100644
--- a/openvdb/openvdb/math/Mat4.h
+++ b/openvdb/openvdb/math/Mat4.h
@@ -986,7 +986,7 @@ class Mat4: public Mat<4, T>
         int index0 = static_cast<int>(axis0);
         int index1 = static_cast<int>(axis1);
 
-        // to collumn "index0" add a multiple of the index1 row
+        // to column "index0" add a multiple of the index1 row
         MyBase::mm[index0 +  0] += shear * MyBase::mm[index1 +  0];
         MyBase::mm[index0 +  4] += shear * MyBase::mm[index1 +  4];
         MyBase::mm[index0 +  8] += shear * MyBase::mm[index1 +  8];
@@ -1022,7 +1022,7 @@ class Mat4: public Mat<4, T>
         return static_cast< Vec3<T0> >(*this * v);
     }
 
-    /// Transform a Vec3 by post-multiplication, doing homogenous divison.
+    /// Transform a Vec3 by post-multiplication, doing homogenous division.
     template<typename T0>
     Vec3<T0> transformH(const Vec3<T0> &p) const
     {
diff --git a/openvdb/openvdb/math/Operators.h b/openvdb/openvdb/math/Operators.h
index 53f4eb19d6..28d90895d3 100644
--- a/openvdb/openvdb/math/Operators.h
+++ b/openvdb/openvdb/math/Operators.h
@@ -1774,7 +1774,7 @@ struct MeanCurvature
          Vec3d d1_is(static_cast<double>(D1<DiffScheme1>::inX(grid, ijk)),
                      static_cast<double>(D1<DiffScheme1>::inY(grid, ijk)),
                      static_cast<double>(D1<DiffScheme1>::inZ(grid, ijk))), d1_ws;
-         if (is_linear<MapType>::value) {//resolved at compiletime
+         if (is_linear<MapType>::value) {//resolved at compile time
              d1_ws = map.applyIJT(d1_is);
          } else {
              d1_ws = map.applyIJT(d1_is, ijk.asVec3d());
@@ -1804,7 +1804,7 @@ struct MeanCurvature
 
          // convert second derivatives to world space
          Mat3d d2_ws;
-         if (is_linear<MapType>::value) {//resolved at compiletime
+         if (is_linear<MapType>::value) {//resolved at compile time
              d2_ws = map.applyIJC(d2_is);
          } else {
              d2_ws = map.applyIJC(d2_is, d1_is, ijk.asVec3d());
@@ -1853,7 +1853,7 @@ struct MeanCurvature
          Vec3d d1_is(D1<DiffScheme1>::inX(stencil),
                      D1<DiffScheme1>::inY(stencil),
                      D1<DiffScheme1>::inZ(stencil) ), d1_ws;
-         if (is_linear<MapType>::value) {//resolved at compiletime
+         if (is_linear<MapType>::value) {//resolved at compile time
              d1_ws = map.applyIJT(d1_is);
          } else {
              d1_ws = map.applyIJT(d1_is, stencil.getCenterCoord().asVec3d());
@@ -1883,7 +1883,7 @@ struct MeanCurvature
 
          // convert second derivatives to world space
          Mat3d d2_ws;
-         if (is_linear<MapType>::value) {//resolved at compiletime
+         if (is_linear<MapType>::value) {//resolved at compile time
              d2_ws = map.applyIJC(d2_is);
          } else {
              d2_ws = map.applyIJC(d2_is, d1_is, stencil.getCenterCoord().asVec3d());
diff --git a/openvdb/openvdb/math/QuantizedUnitVec.h b/openvdb/openvdb/math/QuantizedUnitVec.h
index 6373a36ca7..633e240a70 100644
--- a/openvdb/openvdb/math/QuantizedUnitVec.h
+++ b/openvdb/openvdb/math/QuantizedUnitVec.h
@@ -64,11 +64,11 @@ QuantizedUnitVec::pack(const Vec3<T>& vec)
     uint16_t xbits = static_cast<uint16_t>((x * w));
     uint16_t ybits = static_cast<uint16_t>((y * w));
 
-    // The remaining 13 bits in our 16 bit word are dividied into a
+    // The remaining 13 bits in our 16 bit word are divided into a
     // 6-bit x-slot and a 7-bit y-slot. Both the xbits and the ybits
     // can still be represented using (2^7 - 1) quantization levels.
 
-    // If the xbits requre more than 6-bits, store the complement.
+    // If the xbits require more than 6-bits, store the complement.
     // (xbits + ybits < 127, thus if xbits > 63 => ybits <= 63)
     if (xbits > 63) {
         xbits = static_cast<uint16_t>(127 - xbits);
diff --git a/openvdb/openvdb/math/Quat.h b/openvdb/openvdb/math/Quat.h
index d16522f65e..4e9946a98f 100644
--- a/openvdb/openvdb/math/Quat.h
+++ b/openvdb/openvdb/math/Quat.h
@@ -454,7 +454,7 @@ class Quat
         return (mm[0]*q.mm[0] + mm[1]*q.mm[1] + mm[2]*q.mm[2] + mm[3]*q.mm[3]);
     }
 
-    /// Return the quaternion rate corrsponding to the angular velocity omega
+    /// Return the quaternion rate corresponding to the angular velocity omega
     /// and "this" current rotation
     Quat derivative(const Vec3<T>& omega) const
     {
diff --git a/openvdb/openvdb/math/Stencils.h b/openvdb/openvdb/math/Stencils.h
index 0c4ed2c0c8..5fe7680303 100644
--- a/openvdb/openvdb/math/Stencils.h
+++ b/openvdb/openvdb/math/Stencils.h
@@ -182,7 +182,7 @@ class BaseStencil
     ///
     /// @details The ordering of bit mask is ( -x, +x, -y, +y, -z, +z ), so to
     /// check if there is an intersection in -y use mask.test(2) where mask is
-    /// ther return value from this function. To check if there are any
+    /// the return value from this function. To check if there are any
     /// intersections use mask.any(), and for no intersections use mask.none().
     /// To count the number of intersections use mask.count().
     inline std::bitset<6> intersectionMask(const ValueType &isoValue = zeroVal<ValueType>()) const
@@ -332,7 +332,7 @@ class BoxStencil: public BaseStencil<BoxStencil<GridT, IsSafe>, GridT, IsSafe>
     /// @param xyz Floating point coordinate position.
     /// @warning It is assumed that the stencil has already been moved
     /// to the relevant voxel position, e.g. using moveTo(xyz).
-    /// @note Trilinear interpolation kernal reads as:
+    /// @note Trilinear interpolation kernel reads as:
     ///       v000 (1-u)(1-v)(1-w) + v001 (1-u)(1-v)w + v010 (1-u)v(1-w) + v011 (1-u)vw
     ///     + v100 u(1-v)(1-w)     + v101 u(1-v)w     + v110 uv(1-w)     + v111 uvw
     inline ValueType interpolation(const math::Vec3<ValueType>& xyz) const
@@ -1315,7 +1315,7 @@ class GradStencil : public BaseStencil<GradStencil<GridT, IsSafe>, GridT, IsSafe
     /// from which the level set was derived.
     ///
     /// @note This method assumes that the grid represents a level set
-    /// with distances in world units and a simple affine transfrom
+    /// with distances in world units and a simple affine transform
     /// with uniform scaling.
     inline math::Vec3<ValueType> cpt()
     {
diff --git a/openvdb/openvdb/math/Transform.h b/openvdb/openvdb/math/Transform.h
index a44c0bfb3c..a76af4bc58 100644
--- a/openvdb/openvdb/math/Transform.h
+++ b/openvdb/openvdb/math/Transform.h
@@ -60,7 +60,7 @@ class OPENVDB_API Transform
     /// Return @c true if the transformation map is exclusively linear/affine.
     bool isLinear() const { return mMap->isLinear(); }
 
-    /// Return @c true if the transform is equivalent to an idenity.
+    /// Return @c true if the transform is equivalent to an identity.
     bool isIdentity() const ;
     /// Return the transformation map's type-name
     Name mapType() const { return mMap->type(); }
@@ -71,7 +71,7 @@ class OPENVDB_API Transform
     /// postfixing the appropriate operation.  In the case of
     /// a frustum, the pre-operations apply to the linear part
     /// of the transform and not the entire transform, while the
-    /// post-operations are allways applied last.
+    /// post-operations are always applied last.
     void preRotate(double radians, const Axis axis = X_AXIS);
     void preTranslate(const Vec3d&);
     void preScale(const Vec3d&);
@@ -215,7 +215,7 @@ doProcessTypedMap(const Transform& transform, OpType& op)
 
 
 /// @brief Utility function that, given a generic map pointer,
-/// calls a functor on the fully-resoved map
+/// calls a functor on the fully-resolved map
 ///
 /// Usage:
 /// @code
diff --git a/openvdb/openvdb/math/Vec2.h b/openvdb/openvdb/math/Vec2.h
index a4abf85a74..6fdfdffd96 100644
--- a/openvdb/openvdb/math/Vec2.h
+++ b/openvdb/openvdb/math/Vec2.h
@@ -184,7 +184,7 @@ class Vec2: public Tuple<2, T>
     /// does not involve square root
     T lengthSqr() const { return (this->mm[0]*this->mm[0] + this->mm[1]*this->mm[1]); }
 
-    /// Return a reference to itsef after the exponent has been
+    /// Return a reference to itself after the exponent has been
     /// applied to all the vector components.
     inline const Vec2<T>& exp()
     {
diff --git a/openvdb/openvdb/openvdb.h b/openvdb/openvdb/openvdb.h
index 1e47cae1a9..79bbad5372 100644
--- a/openvdb/openvdb/openvdb.h
+++ b/openvdb/openvdb/openvdb.h
@@ -46,7 +46,7 @@ OPENVDB_API void initialize();
 OPENVDB_API void uninitialize();
 
 
-// foward declare some default types
+// forward declare some default types
 namespace io { class DelayedLoadMetadata; }
 
 /// Common tree types
diff --git a/openvdb/openvdb/points/AttributeArray.h b/openvdb/openvdb/points/AttributeArray.h
index f09b58821f..38b62f28e4 100644
--- a/openvdb/openvdb/points/AttributeArray.h
+++ b/openvdb/openvdb/points/AttributeArray.h
@@ -1024,7 +1024,7 @@ void AttributeArray::copyValues(const AttributeArray& sourceArray, const IterT&
 {
     const Index bytes = sourceArray.storageTypeSize();
     if (bytes != this->storageTypeSize()) {
-        OPENVDB_THROW(TypeError, "Cannot copy array data due to mis-match in storage type sizes.");
+        OPENVDB_THROW(TypeError, "Cannot copy array data due to mismatch in storage type sizes.");
     }
 
     // ensure both arrays have been loaded from disk
diff --git a/openvdb/openvdb/points/AttributeSet.cc b/openvdb/openvdb/points/AttributeSet.cc
index 1eebe436ff..43be29ce44 100644
--- a/openvdb/openvdb/points/AttributeSet.cc
+++ b/openvdb/openvdb/points/AttributeSet.cc
@@ -452,7 +452,7 @@ AttributeSet::reorderAttributes(const DescriptorPtr& replacement)
 
     AttrArrayVec attrs(replacement->size());
 
-    // compute target indices for attributes from the given decriptor
+    // compute target indices for attributes from the given descriptor
     for (const auto& namePos : mDescr->map()) {
         const size_t index = replacement->find(namePos.first);
         attrs[index] = AttributeArray::Ptr(mAttrs[namePos.second]);
diff --git a/openvdb/openvdb/points/AttributeSet.h b/openvdb/openvdb/points/AttributeSet.h
index 3137eb7413..de04c51bb6 100644
--- a/openvdb/openvdb/points/AttributeSet.h
+++ b/openvdb/openvdb/points/AttributeSet.h
@@ -220,7 +220,7 @@ class OPENVDB_API AttributeSet
     /// In cases where the AttributeSet is due to be destroyed, a small performance
     /// advantage can be gained by leaving the attribute array as a nullptr and not
     /// updating the descriptor. However, this leaves the AttributeSet in an invalid
-    /// state making it unsafe to call any methods that implicitly derefence the attribute array.
+    /// state making it unsafe to call any methods that implicitly dereference the attribute array.
     /// @note AttributeArrays are stored as shared pointers, so they are not guaranteed
     /// to be unique. Check the reference count before blindly re-using in a new AttributeSet.
     /// @warning Only use this method if you're an expert and know the risks of not
diff --git a/openvdb/openvdb/points/IndexIterator.h b/openvdb/openvdb/points/IndexIterator.h
index affddef9eb..166fc0b0e4 100644
--- a/openvdb/openvdb/points/IndexIterator.h
+++ b/openvdb/openvdb/points/IndexIterator.h
@@ -249,7 +249,7 @@ class IndexIter
 
     Index32 end() const { return mIterator.end(); }
 
-    /// @brief Reset the begining and end of the iterator.
+    /// @brief Reset the beginning and end of the iterator.
     void reset(Index32 begin, Index32 end) {
         mIterator.reset(begin, end);
         while (mIterator.test() && !mFilter.template valid<ValueIndexIter>(mIterator)) {
diff --git a/openvdb/openvdb/points/PointAttribute.h b/openvdb/openvdb/points/PointAttribute.h
index 0710ed3c47..230bbb6b6b 100644
--- a/openvdb/openvdb/points/PointAttribute.h
+++ b/openvdb/openvdb/points/PointAttribute.h
@@ -40,7 +40,7 @@ struct Default
 ///
 /// @param tree               the PointDataTree to be appended to.
 /// @param name               name for the new attribute.
-/// @param type               the type of the attibute.
+/// @param type               the type of the attribute.
 /// @param strideOrTotalSize  the stride of the attribute
 /// @param constantStride     if @c false, stride is interpreted as total size of the array
 /// @param defaultValue       metadata default attribute value
diff --git a/openvdb/openvdb/points/PointDataGrid.h b/openvdb/openvdb/points/PointDataGrid.h
index 9852796753..adf72d52fb 100644
--- a/openvdb/openvdb/points/PointDataGrid.h
+++ b/openvdb/openvdb/points/PointDataGrid.h
@@ -1703,7 +1703,7 @@ struct PointDataNodeChain<tree::InternalNode<ChildT, Log2Dim>, /*HeadLevel=*/1>
 } // namespace internal
 
 
-/// @brief Similiar to ValueConverter, but allows for tree configuration conversion
+/// @brief Similar to ValueConverter, but allows for tree configuration conversion
 /// to a PointDataTree. ValueConverter<PointDataIndex32> cannot be used as a
 /// PointDataLeafNode is not a specialization of LeafNode
 template <typename TreeType>
diff --git a/openvdb/openvdb/points/PointReplicate.h b/openvdb/openvdb/points/PointReplicate.h
index e345e759a1..496653145c 100644
--- a/openvdb/openvdb/points/PointReplicate.h
+++ b/openvdb/openvdb/points/PointReplicate.h
@@ -20,7 +20,7 @@ namespace OPENVDB_VERSION_NAME {
 namespace points {
 
 /// @brief Replicates points provided in a source grid into a new grid,
-///        transfering and creating attributes found in a provided
+///        transferring and creating attributes found in a provided
 ///        attribute vector. If an attribute doesn't exist, it is ignored.
 ///        Position is always replicated, leaving the new points exactly
 ///        over the top of the source points.
@@ -43,7 +43,7 @@ replicate(const PointDataGridT& source,
           const std::string& replicationIndex = "");
 
 /// @brief Replicates points provided in a source grid into a new grid,
-///        transfering and creating all attributes from the source grid.
+///        transferring and creating all attributes from the source grid.
 ///        Position is always replicated, leaving the new points exactly
 ///        over the top of the source points.
 /// @note  The position attribute must exist
diff --git a/openvdb/openvdb/points/PointStatistics.h b/openvdb/openvdb/points/PointStatistics.h
index 0ad180bb71..acbdf51d99 100644
--- a/openvdb/openvdb/points/PointStatistics.h
+++ b/openvdb/openvdb/points/PointStatistics.h
@@ -33,7 +33,7 @@ namespace points {
 /// @brief Evaluates the minimum and maximum values of a point attribute.
 /// @details Performs parallel reduction by comparing values using their less
 ///   than and greater than operators. If the PointDataGrid is empty or the
-///   filter evalutes to empty, zeroVal<ValueT>() is returned for both values.
+///   filter evaluates to empty, zeroVal<ValueT>() is returned for both values.
 /// @note The ValueT of the attribute must be copy constructible. This method
 ///   will throw if the templated ValueT does not match the given attribute.
 ///   For vectors and matrices, this results in per component comparisons.
@@ -57,7 +57,7 @@ evalMinMax(const PointDataTreeT& points,
 ///   reduction arithmetic and return value precision evaluates to:
 ///      ConvertElementType<ValueT, double>::Type
 ///   which, for POD and VDB math types, is ValueT at double precision. If the
-///   PointDataGrid is empty or the filter evalutes to empty, zeroVal<ValueT>()
+///   PointDataGrid is empty or the filter evaluates to empty, zeroVal<ValueT>()
 ///   is returned.
 /// @note The ConvertElementType of the attribute must be copy constructible,
 ///   support the same type + - * operators and * / operators from a double.
@@ -82,7 +82,7 @@ evalAverage(const PointDataTreeT& points,
 ///   arithmetic and return value precision evaluates to:
 ///      PromoteType<ValueT>::Highest
 ///   which, for POD and VDB math types, is ValueT at its highest bit precision.
-///   If the PointDataGrid is empty or the filter evalutes to empty,
+///   If the PointDataGrid is empty or the filter evaluates to empty,
 ///   zeroVal<ValueT>() is returned.
 /// @note The PromoteType of the attribute must be copy constructible, support
 ///   the same type + operator. This method will throw if ValueT does not match
diff --git a/openvdb/openvdb/points/PointTransfer.h b/openvdb/openvdb/points/PointTransfer.h
index 1a7f42fc59..ccfcb892c1 100644
--- a/openvdb/openvdb/points/PointTransfer.h
+++ b/openvdb/openvdb/points/PointTransfer.h
@@ -14,7 +14,7 @@
 ///   transform, but this transform can differ from the source PointDataGrid
 ///   (multiple instantiations of rasterize() should instead be invoked to
 ///   transfer to grids of different transforms). Arbitrary attributes can be
-///   accessed and transfered to arbitrary trees.
+///   accessed and transferred to arbitrary trees.
 ///
 
 #ifndef OPENVEB_POINTS_TRANSFER_HAS_BEEN_INCLUDED
diff --git a/openvdb/openvdb/points/StreamCompression.h b/openvdb/openvdb/points/StreamCompression.h
index c7dcd4a8e9..48d26b8651 100644
--- a/openvdb/openvdb/points/StreamCompression.h
+++ b/openvdb/openvdb/points/StreamCompression.h
@@ -35,7 +35,7 @@ namespace compression {
 
 
 // This is the minimum number of bytes below which Blosc compression is not used to
-// avoid unecessary computation, as Blosc offers minimal compression until this limit
+// avoid unnecessary computation, as Blosc offers minimal compression until this limit
 static const int BLOSC_MINIMUM_BYTES = 48;
 
 // This is the minimum number of bytes below which the array is padded with zeros up
diff --git a/openvdb/openvdb/points/impl/PointRasterizeSDFImpl.h b/openvdb/openvdb/points/impl/PointRasterizeSDFImpl.h
index 1040e35e9d..8699e3283f 100644
--- a/openvdb/openvdb/points/impl/PointRasterizeSDFImpl.h
+++ b/openvdb/openvdb/points/impl/PointRasterizeSDFImpl.h
@@ -484,7 +484,7 @@ struct AveragePositionTransfer :
                     }
 
                     x2y2z2 *= invsq; // x2y2z2 = (x - xi) / R
-                    // k(s) = max(0,(1s^2)^3). note that the max is unecessary
+                    // k(s) = max(0,(1s^2)^3). note that the max is unnecessary
                     // as we early terminate above with x2y2z2 >= mMaxSearchSqIS
                     x2y2z2 = math::Pow3(1.0 - x2y2z2);
                     OPENVDB_ASSERT(x2y2z2 >= 0.0);
@@ -643,9 +643,9 @@ struct SurfaceMaskOp
     const math::Transform& mSurfaceTransform;
     InterrupterT* mInterrupter;
     // add the size of a single points voxel at the surface resolution
-    // to the distance limits - this is becasue we don't query exact point
+    // to the distance limits - this is because we don't query exact point
     // positions in SurfaceMaskOp, which means we have to
-    // actviate the "worst case scenario" bounds. The closer the points
+    // activate the "worst case scenario" bounds. The closer the points
     // voxel size is to the target sdf voxel size the better the topology
     // estimate
     const int mVoxelOffset;
diff --git a/openvdb/openvdb/points/impl/PointReplicateImpl.h b/openvdb/openvdb/points/impl/PointReplicateImpl.h
index 190759e34c..76c1e67f1a 100644
--- a/openvdb/openvdb/points/impl/PointReplicateImpl.h
+++ b/openvdb/openvdb/points/impl/PointReplicateImpl.h
@@ -130,7 +130,7 @@ replicate(const PointDataGridT& source,
         using ValueType = PointDataTree::ValueType;
 
         const auto& sourceLeaf = sourceManager.leaf(pos);
-        // @note  This really shoudn't return uint64_t as AttributeArray's size is
+        // @note  This really shouldn't return uint64_t as AttributeArray's size is
         //  limited to the max of a uint32_t...
         OPENVDB_ASSERT(sourceLeaf.pointCount() < Index64(std::numeric_limits<Index>::max()));
         const Index sourceCount = static_cast<Index>(sourceLeaf.pointCount());
diff --git a/openvdb/openvdb/tools/Clip.h b/openvdb/openvdb/tools/Clip.h
index d01ffc31aa..9b883ebaf9 100644
--- a/openvdb/openvdb/tools/Clip.h
+++ b/openvdb/openvdb/tools/Clip.h
@@ -491,7 +491,7 @@ clip(const GridType& inGrid, const math::NonlinearFrustumMap& frustumMap, bool k
                 for (std::vector<CoordBBox> bboxVec = { tileBBox }; !bboxVec.empty(); ) {
                     // For efficiency, subdivide sufficiently large tiles and discard
                     // subregions based on additional bounding box intersection tests.
-                    // The mimimum subregion size is chosen so that cost of the
+                    // The minimum subregion size is chosen so that cost of the
                     // bounding box test is comparable to testing every voxel.
                     if (bboxVec.back().volume() > 64 && bboxVec.back().is_divisible()) {
                         // Subdivide this region in-place and append the other half to the list.
diff --git a/openvdb/openvdb/tools/Composite.h b/openvdb/openvdb/tools/Composite.h
index c0a594a22a..a40b36ff28 100644
--- a/openvdb/openvdb/tools/Composite.h
+++ b/openvdb/openvdb/tools/Composite.h
@@ -990,7 +990,7 @@ csgDifferenceCopy(const GridOrTreeT& a, const GridOrTreeT& b)
 ///          determined by a use-defined functor (OpT op) that operates on the
 ///          source and destination values. The only exception is when
 ///          the tree type is MaskTree, in which case no functor is
-///          needed since by defintion a MaskTree has no values (only topology).
+///          needed since by definition a MaskTree has no values (only topology).
 ///
 /// @warning This function only operated on leaf node values,
 ///          i.e. tile values are ignored.
diff --git a/openvdb/openvdb/tools/DenseSparseTools.h b/openvdb/openvdb/tools/DenseSparseTools.h
index 12afb94e94..310f1e2054 100644
--- a/openvdb/openvdb/tools/DenseSparseTools.h
+++ b/openvdb/openvdb/tools/DenseSparseTools.h
@@ -144,7 +144,7 @@ template<typename ValueT, typename OpType>
 void transformDense(Dense<ValueT, openvdb::tools::LayoutZYX>& dense,
                     const openvdb::CoordBBox& bbox, const OpType& op, bool parallel=true);
 
-/// We currrently support the following operations when compositing sparse
+/// We currently support the following operations when compositing sparse
 /// data into a dense grid.
 enum DSCompositeOp {
     DS_OVER, DS_ADD, DS_SUB, DS_MIN, DS_MAX, DS_MULT, DS_SET
diff --git a/openvdb/openvdb/tools/FastSweeping.h b/openvdb/openvdb/tools/FastSweeping.h
index b7d652a217..0585261995 100644
--- a/openvdb/openvdb/tools/FastSweeping.h
+++ b/openvdb/openvdb/tools/FastSweeping.h
@@ -90,7 +90,7 @@ enum class FastSweepingDomain {
 ///                 Each iteration performs 2^3 = 8 individual sweeps.
 ///
 /// @note Strictly speaking a fog volume is normalized to the range [0,1] but this
-///       method accepts a scalar volume with an arbritary range, as long as the it
+///       method accepts a scalar volume with an arbitrary range, as long as the it
 ///       includes the @a isoValue.
 ///
 /// @details Topology of output grid is identical to that of the input grid, except
@@ -180,7 +180,7 @@ sdfToSdf(const GridT &sdfGrid,
 ///                 is supplied as an argument for @a mode.
 ///
 /// @note Strictly speaking a fog volume is normalized to the range [0,1] but this
-///       method accepts a scalar volume with an arbritary range, as long as the it
+///       method accepts a scalar volume with an arbitrary range, as long as the it
 ///       includes the @a isoValue.
 ///
 /// @details Topology of output grid is identical to that of the input grid, except
@@ -298,7 +298,7 @@ sdfToExt(const SdfGridT &sdfGrid,
 ///                 is supplied as an argument for @a mode.
 ///
 /// @note Strictly speaking a fog volume is normalized to the range [0,1] but this
-///       method accepts a scalar volume with an arbritary range, as long as the it
+///       method accepts a scalar volume with an arbitrary range, as long as the it
 ///       includes the @a isoValue.
 ///
 /// @details Topology of output grids are identical to that of the input grid, except
@@ -361,7 +361,7 @@ fogToSdfAndExt(const FogGridT &fogGrid,
 ///                 is supplied as an argument for @a mode.
 ///
 /// @note Strictly speaking a fog volume is normalized to the range [0,1] but this
-///       method accepts a scalar volume with an arbritary range, as long as the it
+///       method accepts a scalar volume with an arbitrary range, as long as the it
 ///       includes the @a isoValue.
 ///
 /// @details Topology of output grids are identical to that of the input grid, except
@@ -395,7 +395,7 @@ sdfToSdfAndExt(const SdfGridT &sdfGrid,
 ///
 /// @param sdfGrid  Input signed distance field to be dilated.
 ///
-/// @param dilation Numer of voxels that the narrow band of the input SDF will be dilated.
+/// @param dilation Number of voxels that the narrow band of the input SDF will be dilated.
 ///
 /// @param nn       Stencil-pattern used for dilation
 ///
@@ -530,7 +530,7 @@ class FastSweeping
     /// @param isInputSdf Used to determine if @a sdfGrid is a sigend distance field (true)
     ///                   or a scalar fog volume (false).
     ///
-    /// @details This, or any of ther other initialization methods, should be called
+    /// @details This, or any of the other initialization methods, should be called
     ///          before any call to sweep(). Failure to do so will throw a RuntimeError.
     ///
     /// @warning Note, if this method fails, i.e. returns false, a subsequent call
@@ -578,7 +578,7 @@ class FastSweeping
     ///                 The opposite convention is implemented when SWEEP_LESS_THAN_ISOVALUE
     ///                 is supplied as an argument for @a mode.
     ///
-    /// @details This, or any of ther other initialization methods, should be called
+    /// @details This, or any of the other initialization methods, should be called
     ///          before any call to sweep(). Failure to do so will throw a RuntimeError.
     ///
     /// @warning Note, if this method fails, i.e. returns false, a subsequent call
@@ -598,7 +598,7 @@ class FastSweeping
     ///
     /// @param sdfGrid  Input signed distance field to to be dilated.
     ///
-    /// @param dilation Numer of voxels that the input SDF will be dilated.
+    /// @param dilation Number of voxels that the input SDF will be dilated.
     ///
     /// @param nn       Stencil-pattern used for dilation
     ///
@@ -608,7 +608,7 @@ class FastSweeping
     ///                 side of the iso-surface, SWEEP_LESS_THAN_ISOVALUE will dilate
     ///                 in the negative side of the iso-surface.
     ///
-    /// @details This, or any of ther other initialization methods, should be called
+    /// @details This, or any of the other initialization methods, should be called
     ///          before any call to sweep(). Failure to do so will throw a RuntimeError.
     ///
     /// @warning Note, if this method fails, i.e. returns false, a subsequent call
@@ -631,7 +631,7 @@ class FastSweeping
     /// @param ignoreActiveTiles If false, active tiles in the mask are treated
     ///                 as active voxels. Else they are ignored.
     ///
-    /// @details This, or any of ther other initialization methods, should be called
+    /// @details This, or any of the other initialization methods, should be called
     ///          before any call to sweep(). Failure to do so will throw a RuntimeError.
     ///
     /// @warning Note, if this method fails, i.e. returns false, a subsequent call
diff --git a/openvdb/openvdb/tools/Filter.h b/openvdb/openvdb/tools/Filter.h
index 94cdde016d..b70c92b6e2 100644
--- a/openvdb/openvdb/tools/Filter.h
+++ b/openvdb/openvdb/tools/Filter.h
@@ -229,7 +229,7 @@ struct Voxelizer
 
     /// @brief  Convert tiles to leaf nodes that exist at a particular
     ///         voxel distance away
-    /// @param width  distance in voxels to seach for tiles from each leaf
+    /// @param width  distance in voxels to search for tiles from each leaf
     /// @return  Returns how many search iterations were performed, which
     ///          also represents how many leaf node neighbors may have been
     ///          created. Returns 0 if the tree is already entirely voxelized
@@ -383,7 +383,7 @@ struct Voxelizer
                 // neighbor directly and use a flag buffer to test offsets in
                 // this node which need converting to leaf level topology.
                 // This is faster than the more general method which steps across
-                // faces (unecessary due to CHILDDIM == LEAFDIM) and provides
+                // faces (unnecessary due to CHILDDIM == LEAFDIM) and provides
                 // a simpler way of tracking new topology
 
                 std::vector<char> flags(NodeT::NUM_VALUES, char(0));
diff --git a/openvdb/openvdb/tools/FindActiveValues.h b/openvdb/openvdb/tools/FindActiveValues.h
index b528f8fc22..8c72be5377 100644
--- a/openvdb/openvdb/tools/FindActiveValues.h
+++ b/openvdb/openvdb/tools/FindActiveValues.h
@@ -15,7 +15,7 @@
 /// @warning For repeated calls to the free-standing functions defined below
 ///          consider instead creating an instance of FindActiveValues
 ///          and then repeatedly call its member methods. This assumes the tree
-///          to be constant between calls but is sightly faster.
+///          to be constant between calls but is slightly faster.
 ///
 ///////////////////////////////////////////////////////////////////////////
 
diff --git a/openvdb/openvdb/tools/Interpolation.h b/openvdb/openvdb/tools/Interpolation.h
index b3870c0838..2f6a6260c4 100644
--- a/openvdb/openvdb/tools/Interpolation.h
+++ b/openvdb/openvdb/tools/Interpolation.h
@@ -55,7 +55,7 @@ OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 namespace tools {
 
-/// @brief Provises a unified interface for sampling, i.e. interpolation.
+/// @brief Provides a unified interface for sampling, i.e. interpolation.
 /// @details Order = 0: closest point
 ///          Order = 1: tri-linear
 ///          Order = 2: tri-quadratic
@@ -476,7 +476,7 @@ class DualGridSampler
     {
     }
     /// @brief Return the value of the source grid at the index
-    /// coordinates, ijk, relative to the target grid (or its tranform).
+    /// coordinates, ijk, relative to the target grid (or its transform).
     inline ValueType operator()(const Coord& ijk) const
     {
         if (mAligned) return mSourceTree->getValue(ijk);
@@ -721,7 +721,7 @@ BoxSampler::trilinearInterpolation(ValueT (&data)[N][N][N], const Vec3R& uvw)
     };
 
     // Trilinear interpolation:
-    // The eight surrounding latice values are used to construct the result. \n
+    // The eight surrounding lattice values are used to construct the result. \n
     // result(x,y,z) =
     //     v000 (1-x)(1-y)(1-z) + v001 (1-x)(1-y)z + v010 (1-x)y(1-z) + v011 (1-x)yz
     //   + v100 x(1-y)(1-z)     + v101 x(1-y)z     + v110 xy(1-z)     + v111 xyz
diff --git a/openvdb/openvdb/tools/LevelSetAdvect.h b/openvdb/openvdb/tools/LevelSetAdvect.h
index 7d4787d09c..6eefa127db 100644
--- a/openvdb/openvdb/tools/LevelSetAdvect.h
+++ b/openvdb/openvdb/tools/LevelSetAdvect.h
@@ -373,7 +373,7 @@ advect(ValueType time0, ValueType time1)
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Advecting level set using TVD_RK1 (step 1 of 2)", 1);
 
-            // Convex combine explict Euler step: t2 = t0 + dt
+            // Convex combine explicit Euler step: t2 = t0 + dt
             // Phi_t2(1) = 1/2 * Phi_t0(1) + 1/2 * (Phi_t1(0) - dt * V.Grad_t1(0))
             mTask = std::bind(&Advect::euler12, ph::_1, ph::_2, dt);
 
@@ -388,14 +388,14 @@ advect(ValueType time0, ValueType time1)
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Advecting level set using TVD_RK3 (step 1 of 3)", 1);
 
-            // Convex combine explict Euler step: t2 = t0 + dt/2
+            // Convex combine explicit Euler step: t2 = t0 + dt/2
             // Phi_t2(2) = 3/4 * Phi_t0(1) + 1/4 * (Phi_t1(0) - dt * V.Grad_t1(0))
             mTask = std::bind(&Advect::euler34, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 2 such that Phi_t2(0) and Phi_t1(2)
             this->cook("Advecting level set using TVD_RK3 (step 2 of 3)", 2);
 
-            // Convex combine explict Euler step: t3 = t0 + dt
+            // Convex combine explicit Euler step: t3 = t0 + dt
             // Phi_t3(2) = 1/3 * Phi_t0(1) + 2/3 * (Phi_t2(0) - dt * V.Grad_t2(0)
             mTask = std::bind(&Advect::euler13, ph::_1, ph::_2, dt);
 
diff --git a/openvdb/openvdb/tools/LevelSetMorph.h b/openvdb/openvdb/tools/LevelSetMorph.h
index e455d07d25..11c403a2f1 100644
--- a/openvdb/openvdb/tools/LevelSetMorph.h
+++ b/openvdb/openvdb/tools/LevelSetMorph.h
@@ -398,7 +398,7 @@ advect(ValueType time0, ValueType time1)
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook(PARALLEL_FOR, 1);
 
-            // Convex combine explict Euler step: t2 = t0 + dt
+            // Convex combine explicit Euler step: t2 = t0 + dt
             // Phi_t2(1) = 1/2 * Phi_t0(1) + 1/2 * (Phi_t1(0) - dt * Speed(2) * |Grad[Phi(0)]|)
             mTask = std::bind(&Morph::euler12, ph::_1, ph::_2, dt);
 
@@ -413,14 +413,14 @@ advect(ValueType time0, ValueType time1)
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook(PARALLEL_FOR, 1);
 
-            // Convex combine explict Euler step: t2 = t0 + dt/2
+            // Convex combine explicit Euler step: t2 = t0 + dt/2
             // Phi_t2(2) = 3/4 * Phi_t0(1) + 1/4 * (Phi_t1(0) - dt * Speed(3) * |Grad[Phi(0)]|)
             mTask = std::bind(&Morph::euler34, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 2 such that Phi_t2(0) and Phi_t1(2)
             this->cook(PARALLEL_FOR, 2);
 
-            // Convex combine explict Euler step: t3 = t0 + dt
+            // Convex combine explicit Euler step: t3 = t0 + dt
             // Phi_t3(2) = 1/3 * Phi_t0(1) + 2/3 * (Phi_t2(0) - dt * Speed(3) * |Grad[Phi(0)]|)
             mTask = std::bind(&Morph::euler13, ph::_1, ph::_2, dt);
 
diff --git a/openvdb/openvdb/tools/MeshToVolume.h b/openvdb/openvdb/tools/MeshToVolume.h
index 6d85f23576..90179ce231 100644
--- a/openvdb/openvdb/tools/MeshToVolume.h
+++ b/openvdb/openvdb/tools/MeshToVolume.h
@@ -79,11 +79,11 @@ enum MeshToVolumeFlags {
 };
 
 
-/// @brief Different staregies how to determine sign of an SDF when using
+/// @brief Different strategies how to determine sign of an SDF when using
 /// interior test.
 enum InteriorTestStrategy {
 
-   /// Evaluates interior test at every voxel. This is usefull when we rebuild already
+   /// Evaluates interior test at every voxel. This is useful when we rebuild already
    /// existing SDF where evaluating previous grid is cheap
    EVAL_EVERY_VOXEL = 0,
 
@@ -2860,14 +2860,14 @@ struct TransformValues
 };
 
 
-// Inactivate values outside the (exBandWidth, inBandWidth) range.
+// Deactivate values outside the (exBandWidth, inBandWidth) range.
 template<typename TreeType>
-struct InactivateValues
+struct DeactivateValues
 {
     using LeafNodeType = typename TreeType::LeafNodeType;
     using ValueType = typename TreeType::ValueType;
 
-    InactivateValues(std::vector<LeafNodeType*>& nodes,
+    DeactivateValues(std::vector<LeafNodeType*>& nodes,
         ValueType exBandWidth, ValueType inBandWidth)
         : mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mExBandWidth(exBandWidth)
@@ -3185,7 +3185,7 @@ floodFillLeafNode(tree::LeafNode<T,Log2Dim>& leafNode, const InteriorTest& inter
             auto coord = leafNode.offsetToGlobalCoord(offset);
 
             if (interiorTest(coord)){
-                // Yes we assigne positive values to interior points
+                // Yes we assign positive values to interior points
                 // this is aligned with how meshToVolume works internally
                 offsetStack.push_back({offset, POSITIVE});
                 voxelState[offset] = POSITIVE;
@@ -3239,7 +3239,7 @@ floodFillLeafNode(tree::LeafNode<T,Log2Dim>& leafNode, const InteriorTest& inter
 /// inside of the mesh and false outside.
 ///
 /// Furthermore, InteriorTest does not have to be thread-safe, but it has to be
-/// copy constructible and evaluating different coppy has to be thread-safe.
+/// copy constructible and evaluating different copy has to be thread-safe.
 ///
 ///  Example of a interior test
 ///
@@ -3622,7 +3622,7 @@ meshToVolume(
         distTree.getNodes(nodes);
 
         tbb::parallel_for(tbb::blocked_range<size_t>(0, nodes.size()),
-            mesh_to_volume_internal::InactivateValues<TreeType>(
+            mesh_to_volume_internal::DeactivateValues<TreeType>(
                 nodes, exteriorWidth, computeSignedDistanceField ? interiorWidth : exteriorWidth));
 
         tools::pruneLevelSet(
diff --git a/openvdb/openvdb/tools/Morphology.h b/openvdb/openvdb/tools/Morphology.h
index c7c0590bea..5fcdf99667 100644
--- a/openvdb/openvdb/tools/Morphology.h
+++ b/openvdb/openvdb/tools/Morphology.h
@@ -620,7 +620,7 @@ void Morphology<TreeType>::dilateVoxels(const size_t iter,
     const bool threaded = this->getThreaded();
 
     // Actual dilation op. main implementation is single threaded. Note that this
-    // is templated (auto-ed) as the threaded implemenation may call this with a
+    // is templated (auto-ed) as the threaded implementation may call this with a
     // different value type to the source morphology class
     // @note  GCC 6.4.0 crashes trying to compile this lambda with [&] capture
     auto dilate = [iter, nn, threaded](auto& manager, const bool collapse) {
@@ -715,7 +715,7 @@ void Morphology<TreeType>::dilateVoxels(const size_t iter,
             topology.stealNodes(array);
         }
         else if (preserveMaskLeafNodes) {
-            mask = nullptr; // act as if theres no mask tree
+            mask = nullptr; // act as if there is no mask tree
             array.resize(mManager.leafCount());
             tbb::parallel_for(mManager.getRange(),
                 [&](const tbb::blocked_range<size_t>& r){
@@ -1143,7 +1143,7 @@ void erodeActiveValues(TreeOrLeafManagerT& treeOrLeafM,
 
     if (iterations <= 0) return;
 
-    // If the tile policiy is PRESERVE_TILES, peform the erosion on a
+    // If the tile policy is PRESERVE_TILES, perform the erosion on a
     // voxelized mask grid followed by a topology intersection such that
     // the original uneroded topology is preserved.
     if (mode == PRESERVE_TILES) {
diff --git a/openvdb/openvdb/tools/MultiResGrid.h b/openvdb/openvdb/tools/MultiResGrid.h
index 10eee0e1b4..22a4d07754 100644
--- a/openvdb/openvdb/tools/MultiResGrid.h
+++ b/openvdb/openvdb/tools/MultiResGrid.h
@@ -19,7 +19,7 @@
 /// @note Prolongation means interpolation from coarse -> fine
 /// @note Restriction means interpolation (or remapping) from fine -> coarse
 ///
-/// @todo Add option to define the level of the input grid (currenlty
+/// @todo Add option to define the level of the input grid (currently
 /// 0) so as to allow for super-sampling.
 
 #ifndef OPENVDB_TOOLS_MULTIRESGRID_HAS_BEEN_INCLUDED
@@ -688,7 +688,7 @@ struct MultiResGrid<TreeType>::MaskOp
     using VoxelIterT = typename ManagerT::LeafNodeType::ValueOnCIter;
 
     MaskOp(const TreeType& fineTree, TreeType& coarseTree, size_t grainSize = 1)
-        : mPool(new PoolType( coarseTree ) )// empty coarse tree acts as examplar
+        : mPool(new PoolType( coarseTree ) )// empty coarse tree acts as exemplar
     {
         OPENVDB_ASSERT( coarseTree.empty() );
 
@@ -746,8 +746,8 @@ struct MultiResGrid<TreeType>::FractionOp
         OPENVDB_ASSERT( mTree0 != mTree1 );
 
         // Create a pool of  thread-local masks
-        MaskT examplar( false );
-        mPool = new PoolType( examplar );
+        MaskT exemplar( false );
+        mPool = new PoolType( exemplar );
 
         {// create mask from re-mapping coarse tree to mid-level tree
             tree::LeafManager<const TreeType> manager( *mTree1 );
diff --git a/openvdb/openvdb/tools/PointsToMask.h b/openvdb/openvdb/tools/PointsToMask.h
index 33c936c460..72a7b63f1f 100644
--- a/openvdb/openvdb/tools/PointsToMask.h
+++ b/openvdb/openvdb/tools/PointsToMask.h
@@ -128,8 +128,8 @@ class PointsToMask
     {
         if (mInterrupter) mInterrupter->start("PointsToMask: adding points");
         if (grainSize > 0) {
-            typename GridT::Ptr examplar = mGrid->copyWithNewTree();
-            PoolType pool( *examplar );//thread local storage pool of grids
+            typename GridT::Ptr exemplar = mGrid->copyWithNewTree();
+            PoolType pool( *exemplar );//thread local storage pool of grids
             AddPoints<PointListT, VecT> tmp(points, pool, grainSize, *this );
             if ( this->interrupt() ) return;
             ReducePool reducePool(pool, mGrid, size_t(0));
diff --git a/openvdb/openvdb/tools/RayTracer.h b/openvdb/openvdb/tools/RayTracer.h
index fc11b34161..d09fb26ad1 100644
--- a/openvdb/openvdb/tools/RayTracer.h
+++ b/openvdb/openvdb/tools/RayTracer.h
@@ -110,7 +110,7 @@ class LevelSetRayTracer
     /// thread will get its only deep copy. For instance it could
     /// contains a ValueAccessor into another grid with auxiliary
     /// shading information. Thus, make sure it is relatively
-    /// light-weight and efficient to copy (which is the case for ValueAccesors).
+    /// light-weight and efficient to copy (which is the case for ValueAccessors).
     void setShader(const BaseShader& shader);
 
     /// @brief Set the camera derived from the abstract BaseCamera class.
@@ -181,10 +181,10 @@ class VolumeRender
     /// @brief Set the color of the directional light source.
     void setLightColor(Real r, Real g, Real b) { mLightColor = Vec3R(r,g,b); }
 
-    /// @brief Set the integration step-size in voxel units for the primay ray.
+    /// @brief Set the integration step-size in voxel units for the primary ray.
     void setPrimaryStep(Real primaryStep) { mPrimaryStep = primaryStep; }
 
-    /// @brief Set the integration step-size in voxel units for the primay ray.
+    /// @brief Set the integration step-size in voxel units for the primary ray.
     void setShadowStep(Real shadowStep) { mShadowStep  = shadowStep; }
 
     /// @brief Set Scattering coefficients.
@@ -462,7 +462,7 @@ class PerspectiveCamera: public BaseCamera
     }
 
     /// @brief Return the horizontal field of view in degrees given a
-    /// focal lenth in mm and the specified aperture in mm.
+    /// focal length in mm and the specified aperture in mm.
     static double focalLengthToFieldOfView(double length, double aperture)
     {
         return 360.0 / math::pi<double>() * atan(aperture/(2.0*length));
diff --git a/openvdb/openvdb/tools/TopologyToLevelSet.h b/openvdb/openvdb/tools/TopologyToLevelSet.h
index 372f740b53..5740a120d6 100644
--- a/openvdb/openvdb/tools/TopologyToLevelSet.h
+++ b/openvdb/openvdb/tools/TopologyToLevelSet.h
@@ -45,7 +45,7 @@ namespace tools {
 /// @param closingSteps    Number of morphological closing steps used to fill gaps
 ///                        in the active voxel region.
 /// @param dilation        Number of voxels to expand the active voxel region.
-/// @param smoothingSteps  Number of smoothing interations.
+/// @param smoothingSteps  Number of smoothing interactions.
 template<typename GridT>
 typename GridT::template ValueConverter<float>::Type::Ptr
 topologyToLevelSet(const GridT& grid,
@@ -66,7 +66,7 @@ topologyToLevelSet(const GridT& grid,
 /// @param closingSteps    Number of morphological closing steps used to fill gaps
 ///                        in the active voxel region.
 /// @param dilation        Number of voxels to expand the active voxel region.
-/// @param smoothingSteps  Number of smoothing interations.
+/// @param smoothingSteps  Number of smoothing interactions.
 /// @param interrupt       Optional object adhering to the util::NullInterrupter interface.
 template<typename GridT, typename InterrupterT>
 typename GridT::template ValueConverter<float>::Type::Ptr
@@ -165,7 +165,7 @@ smoothLevelSet(GridType& grid, int iterations, int halfBandWidthInVoxels,
     tbb::parallel_for(tbb::blocked_range<size_t>(0, nodes.size()),
         OffsetAndMinComp<TreeType>(nodes, filterGrid.tree(), -offset));
 
-    // Clean up any damanage that was done by the min operation
+    // Clean up any damage that was done by the min operation
     normalizeLevelSet(grid, halfBandWidthInVoxels, interrupt);
 }
 
diff --git a/openvdb/openvdb/tools/ValueTransformer.h b/openvdb/openvdb/tools/ValueTransformer.h
index 0d9af45858..e1294f620f 100644
--- a/openvdb/openvdb/tools/ValueTransformer.h
+++ b/openvdb/openvdb/tools/ValueTransformer.h
@@ -23,7 +23,7 @@
 ///
 /// Finally, tools::setValueOnMin(), tools::setValueOnMax(), tools::setValueOnSum()
 /// and tools::setValueOnMult() are wrappers around Tree::modifyValue() (or
-/// ValueAccessor::modifyValue()) for some commmon in-place operations.
+/// ValueAccessor::modifyValue()) for some common in-place operations.
 /// These are typically significantly faster than calling getValue() followed by setValue().
 
 #ifndef OPENVDB_TOOLS_VALUETRANSFORMER_HAS_BEEN_INCLUDED
diff --git a/openvdb/openvdb/tools/VolumeAdvect.h b/openvdb/openvdb/tools/VolumeAdvect.h
index aa7b856134..40f04008dc 100644
--- a/openvdb/openvdb/tools/VolumeAdvect.h
+++ b/openvdb/openvdb/tools/VolumeAdvect.h
@@ -58,7 +58,7 @@ namespace Scheme {
 /// @verbatim The supported integrations schemes:
 ///
 ///    ================================================================
-///    |  Lable | Accuracy |  Integration Scheme   |  Interpolations  |
+///    |  Label | Accuracy |  Integration Scheme   |  Interpolations  |
 ///    |        |Time/Space|                       |  velocity/volume |
 ///    ================================================================
 ///    |  SEMI  |   1/1    | Semi-Lagrangian       |        1/1       |
@@ -135,7 +135,7 @@ class VolumeAdvection
     /// @brief Set the limiter (see details above)
     void setLimiter(Scheme::Limiter limiter) { mLimiter = limiter; }
 
-    /// @brief Retrun the limiter (see details above)
+    /// @brief Return the limiter (see details above)
     Scheme::Limiter getLimiter() const { return mLimiter; }
 
     /// @brief Return @c true if a limiter will be applied based on
diff --git a/openvdb/openvdb/tree/InternalNode.h b/openvdb/openvdb/tree/InternalNode.h
index 534fc9553d..31cf1e4217 100644
--- a/openvdb/openvdb/tree/InternalNode.h
+++ b/openvdb/openvdb/tree/InternalNode.h
@@ -2354,7 +2354,7 @@ InternalNode<ChildT, Log2Dim>::copyToDense(const CoordBBox& bbox, DenseT& dense)
                 // Get max coordinates of the child node that contains voxel xyz.
                 max = this->offsetToGlobalCoord(n).offsetBy(ChildT::DIM-1);
 
-                // Get the bbox of the interection of bbox and the child node
+                // Get the bbox of the interaction of bbox and the child node
                 CoordBBox sub(xyz, Coord::minComponent(bbox.max(), max));
 
                 if (this->isChildMaskOn(n)) {//is a child
diff --git a/openvdb/openvdb/tree/LeafManager.h b/openvdb/openvdb/tree/LeafManager.h
index e8d427d025..3ff4ac53cc 100644
--- a/openvdb/openvdb/tree/LeafManager.h
+++ b/openvdb/openvdb/tree/LeafManager.h
@@ -9,7 +9,7 @@
 /// @details The leaf array is useful for multithreaded computations over
 /// leaf voxels in a tree with static topology but varying voxel values.
 /// The auxiliary buffers are convenient for temporal integration.
-/// Efficient methods are provided for multithreaded swapping and synching
+/// Efficient methods are provided for multithreaded swapping and syncing
 /// (i.e., copying the contents) of these buffers.
 
 #ifndef OPENVDB_TREE_LEAFMANAGER_HAS_BEEN_INCLUDED
diff --git a/openvdb/openvdb/tree/LeafNodeBool.h b/openvdb/openvdb/tree/LeafNodeBool.h
index 15145ae874..da1b9d8bb4 100644
--- a/openvdb/openvdb/tree/LeafNodeBool.h
+++ b/openvdb/openvdb/tree/LeafNodeBool.h
@@ -83,7 +83,7 @@ class LeafNode<bool, Log2Dim>
     /// @brief Deprecated topology copy constructor
     /// @note  This constructor initialises the bool buffer to the ValueMask
     ///   states (i.e. value will be true if the active state is on and
-    ///   vice-versa). This is not really a "TopologyCopy" and is therefor
+    ///   vice-versa). This is not really a "TopologyCopy" and is therefore
     ///   deprecated. Use the explicit mask/buffer constructor instead:
     /// @code
     ///    // build new leaf node with the mask of 'a', but with the mask of
diff --git a/openvdb/openvdb/tree/RootNode.h b/openvdb/openvdb/tree/RootNode.h
index 8bbf2ee618..ac3f76e7eb 100644
--- a/openvdb/openvdb/tree/RootNode.h
+++ b/openvdb/openvdb/tree/RootNode.h
@@ -2315,7 +2315,7 @@ RootNode<ChildT>::copyToDense(const CoordBBox& bbox, DenseT& dense) const
                 // Get the coordinate bbox of the child node that contains voxel xyz.
                 nodeBBox = CoordBBox::createCube(coordToKey(xyz), ChildT::DIM);
 
-                // Get the coordinate bbox of the interection of inBBox and nodeBBox
+                // Get the coordinate bbox of the interaction of inBBox and nodeBBox
                 CoordBBox sub(xyz, Coord::minComponent(bbox.max(), nodeBBox.max()));
 
                 MapCIter iter = this->findKey(nodeBBox.min());
diff --git a/openvdb/openvdb/tree/ValueAccessor.h b/openvdb/openvdb/tree/ValueAccessor.h
index 542ff0d1b3..2349be8451 100644
--- a/openvdb/openvdb/tree/ValueAccessor.h
+++ b/openvdb/openvdb/tree/ValueAccessor.h
@@ -141,7 +141,7 @@ using ValueAccessorRW =
 ///   insertion on creation and deletion on destruction) it is also unsafe if
 ///   the tree is modified. So unless you're an expert it is highly recommended
 ///   to set IsSafe = true, which is the default in all derived ValueAccessors
-///   defined below. However if you know that the tree is no being modifed for
+///   defined below. However if you know that the tree is no being modified for
 ///   the lifespan of the ValueAccessor AND the work performed per
 ///   ValueAccessor is small relative to overhead of registering it you should
 ///   consider setting IsSafe = false. If this turns out to improve performance
@@ -163,7 +163,7 @@ class ValueAccessorBase
     static constexpr bool isSafe() { return IsSafe; }
 
     /// @brief  Construct from a tree. Should rarely be invoked directly, the
-    ///   drived implementation class calls this. Remains public for backwards
+    ///   derived implementation class calls this. Remains public for backwards
     ///   compatibility.
     ValueAccessorBase(TreeType& tree)
         : mTree(&tree)
@@ -980,7 +980,7 @@ class ValueAccessorImpl final :
 
     /// @brief  Evaluate a predicate on each index I from [0,Size] until it
     ///   returns true, then executes the provided op function on the resolved
-    ///   node type. Helps in cases where std::get may be unecessarily invoked.
+    ///   node type. Helps in cases where std::get may be unnecessarily invoked.
     /// @param pred The predicate to run on the node index
     /// @param op   The function to run on the node where the pred returns true
     template <typename PredT, typename OpT>
diff --git a/openvdb/openvdb/unittest/TestAttributeArray.cc b/openvdb/openvdb/unittest/TestAttributeArray.cc
index 9ec63f3b7b..70c5295a55 100644
--- a/openvdb/openvdb/unittest/TestAttributeArray.cc
+++ b/openvdb/openvdb/unittest/TestAttributeArray.cc
@@ -74,7 +74,7 @@ class ProfileTimer
     {
         (void)msg;
 #ifdef PROFILE
-        // padd string to 50 characters
+        // pad string to 50 characters
         std::string newMsg(msg);
         if (newMsg.size() < 50)     newMsg.insert(newMsg.end(), 50 - newMsg.size(), ' ');
         std::cerr << newMsg << " ... ";
@@ -84,7 +84,7 @@ class ProfileTimer
 
     ~ProfileTimer() { this->stop(); }
 
-    /// Return Time diference in milliseconds since construction or start was called.
+    /// Return Time difference in milliseconds since construction or start was called.
     inline double delta() const
     {
         tbb::tick_count::interval_t dt = tbb::tick_count::now() - mT0;
diff --git a/openvdb/openvdb/unittest/TestCoord.cc b/openvdb/openvdb/unittest/TestCoord.cc
index 67e0a86b56..b79d2d2188 100644
--- a/openvdb/openvdb/unittest/TestCoord.cc
+++ b/openvdb/openvdb/unittest/TestCoord.cc
@@ -373,6 +373,6 @@ TEST_F(TestCoord, testCoordHash)
       EXPECT_EQ(h.size(), n);
       n = 0;
       for (const auto& ijk: bbox) EXPECT_EQ(h[ijk], n++);
-      EXPECT_TRUE(h.load_factor() <= 1.0f);// no hask key collisions!
+      EXPECT_TRUE(h.load_factor() <= 1.0f);// no hash key collisions!
     }
 }
diff --git a/openvdb/openvdb/unittest/TestDense.cc b/openvdb/openvdb/unittest/TestDense.cc
index 8d6ca3e90d..b4edf72062 100644
--- a/openvdb/openvdb/unittest/TestDense.cc
+++ b/openvdb/openvdb/unittest/TestDense.cc
@@ -43,7 +43,7 @@ TEST_F(TestDense, testDenseZYX)
                                   openvdb::Coord(-11, 7,22));
     openvdb::tools::Dense<float> dense(bbox);//LayoutZYX is the default
 
-    // Check Desne::origin()
+    // Check Dense::origin()
     EXPECT_TRUE(openvdb::Coord(-40,-5, 6) == dense.origin());
 
     // Check coordToOffset and offsetToCoord
@@ -118,7 +118,7 @@ TEST_F(TestDense, testDenseXYZ)
                                   openvdb::Coord(-11, 7,22));
     openvdb::tools::Dense<float, openvdb::tools::LayoutXYZ> dense(bbox);
 
-    // Check Desne::origin()
+    // Check Dense::origin()
     EXPECT_TRUE(openvdb::Coord(-40,-5, 6) == dense.origin());
 
     // Check coordToOffset and offsetToCoord
@@ -213,7 +213,7 @@ class CheckDense
     {
         openvdb::tree::ValueAccessor<const TreeT> acc(*mTree);
 
-        if (DenseT::memoryLayout() == openvdb::tools::LayoutZYX) {//resolved at compiletime
+        if (DenseT::memoryLayout() == openvdb::tools::LayoutZYX) {//resolved at compile time
             for (openvdb::Coord P(bbox.min()); P[0] <= bbox.max()[0]; ++P[0]) {
                 for (P[1] = bbox.min()[1]; P[1] <= bbox.max()[1]; ++P[1]) {
                     for (P[2] = bbox.min()[2]; P[2] <= bbox.max()[2]; ++P[2]) {
@@ -435,7 +435,7 @@ TestDense::testDense2Sparse()
     const CoordBBox bboxD = dense.bbox();
     // std::cerr <<  "\nDense bbox" << bboxD << std::endl;
 
-    // Verify that the CoordBBox is truely used as [inclusive, inclusive]
+    // Verify that the CoordBBox is truly used as [inclusive, inclusive]
     EXPECT_TRUE(int(dense.valueCount()) == int(sizeX * sizeY * sizeZ));
 
     // Fill the dense grid with constant value 1.
@@ -556,7 +556,7 @@ TestDense::testDense2Sparse2()
     const CoordBBox bboxD = dense.bbox();
     //std::cerr <<  "\nDense bbox" << bboxD << std::endl;
 
-    // Verify that the CoordBBox is truely used as [inclusive, inclusive]
+    // Verify that the CoordBBox is truly used as [inclusive, inclusive]
     EXPECT_EQ(sizeX * sizeY * sizeZ, static_cast<int>(dense.valueCount()));
 
     // Fill the dense grid with constant value 1.
diff --git a/openvdb/openvdb/unittest/TestDenseSparseTools.cc b/openvdb/openvdb/unittest/TestDenseSparseTools.cc
index 236fdafa12..e7921abf1e 100644
--- a/openvdb/openvdb/unittest/TestDenseSparseTools.cc
+++ b/openvdb/openvdb/unittest/TestDenseSparseTools.cc
@@ -216,7 +216,7 @@ TEST_F(TestDenseSparseTools, testExtractSparseMaskedTree)
 
     openvdb::FloatTree mask(0.f);
 
-    // turn on a point inside the bouding domain of the dense grid
+    // turn on a point inside the bounding domain of the dense grid
     mask.setValue(mijk, 5.f);
 
     // turn on a point outside the bounding domain of the dense grid
@@ -321,7 +321,7 @@ TEST_F(TestDenseSparseTools, testOver)
         EXPECT_NEAR(dense.getValue(openvdb::Coord(1,1,1) + ijk), value, 1.e-6);
     }
 
-    { // testing sparse explict sparse composite
+    { // testing sparse explicit sparse composite
         openvdb::tools::Dense<float> dense(domain, 0.f);
         dense.fill(value);
 
@@ -338,7 +338,7 @@ TEST_F(TestDenseSparseTools, testOver)
         EXPECT_NEAR(dense.getValue(openvdb::Coord(1,1,1) + ijk), value, 1.e-6);
     }
 
-    { // testing sparse explict dense composite
+    { // testing sparse explicit dense composite
         openvdb::tools::Dense<float> dense(domain, 0.f);
         dense.fill(value);
 
diff --git a/openvdb/openvdb/unittest/TestDivergence.cc b/openvdb/openvdb/unittest/TestDivergence.cc
index 38a2fde018..a5555b1624 100644
--- a/openvdb/openvdb/unittest/TestDivergence.cc
+++ b/openvdb/openvdb/unittest/TestDivergence.cc
@@ -87,7 +87,7 @@ TEST_F(TestDivergence, testDivergenceMaskedTool)
     EXPECT_TRUE(!inTree.empty());
     EXPECT_EQ(math::Pow3(2*dim), int(inTree.activeVoxelCount()));
 
-    /// maked region
+    /// masked region
     openvdb::CoordBBox maskBBox(openvdb::Coord(0), openvdb::Coord(dim));
     BoolGrid::Ptr maskGrid = BoolGrid::create(false);
     maskGrid->fill(maskBBox, true /*value*/, true /*activate*/);
diff --git a/openvdb/openvdb/unittest/TestFile.cc b/openvdb/openvdb/unittest/TestFile.cc
index dd344cb515..4730da6851 100644
--- a/openvdb/openvdb/unittest/TestFile.cc
+++ b/openvdb/openvdb/unittest/TestFile.cc
@@ -337,7 +337,7 @@ TestFile::testWriteMultipleGrids()
     EXPECT_EQ(1, grid_in->getValue(Coord(1000, 1000, 16000)));
 
     /////////////////////////////////////////////////////////////////
-    // Now read in the second grid descriptor. Make use of hte end offset.
+    // Now read in the second grid descriptor. Make use of the end offset.
     ///////////////////////////////////////////////////////////////
 
     gd_in.seekToEnd(istr);
diff --git a/openvdb/openvdb/unittest/TestFilter.cc b/openvdb/openvdb/unittest/TestFilter.cc
index 12f9cdedd6..1364b350bf 100644
--- a/openvdb/openvdb/unittest/TestFilter.cc
+++ b/openvdb/openvdb/unittest/TestFilter.cc
@@ -89,7 +89,7 @@ TEST_F(TestFilter, testMedian)
     const int width = 2;
     openvdb::math::DenseStencil<openvdb::FloatGrid> stencil(*referenceGrid, width);
     openvdb::tools::Filter<openvdb::FloatGrid> filter(*filteredGrid);
-    filter.median(width, /*interations=*/1);
+    filter.median(width, /*interactions=*/1);
     std::vector<float> tmp;
     for (int x=0; x<dim[0]; ++x) {
         xyz[0]=x;
@@ -132,7 +132,7 @@ TEST_F(TestFilter, testMean)
     const int width = 2;
     openvdb::math::DenseStencil<openvdb::FloatGrid> stencil(*referenceGrid, width);
     openvdb::tools::Filter<openvdb::FloatGrid> filter(*filteredGrid);
-    filter.mean(width,  /*interations=*/1);
+    filter.mean(width,  /*interactions=*/1);
     for (int x=0; x<dim[0]; ++x) {
         xyz[0]=x;
         for (int y=0; y<dim[1]; ++y) {
diff --git a/openvdb/openvdb/unittest/TestGradient.cc b/openvdb/openvdb/unittest/TestGradient.cc
index ce1bf47691..ce3fdd12f3 100644
--- a/openvdb/openvdb/unittest/TestGradient.cc
+++ b/openvdb/openvdb/unittest/TestGradient.cc
@@ -92,7 +92,7 @@ TEST_F(TestGradient, testISGradientStencil)
 
     // Index Space Gradients: stencil version
     Vec3f result;
-    // this stencil is large enough for all thie different schemes used
+    // this stencil is large enough for all the different schemes used
     // in this test
     math::NineteenPointStencil<FloatGrid> stencil(*grid);
     stencil.moveTo(xyz);
@@ -308,7 +308,7 @@ TEST_F(TestGradient, testWSGradientStencilFrustum)
     math::Vec3s result =
           math::Gradient<math::NonlinearFrustumMap, math::CD_2ND>::result(*map, acc, xyz);
 
-    // The Gradient should be unit lenght for this case
+    // The Gradient should be unit length for this case
     EXPECT_NEAR(1.0, result.length(), /*tolerance=*/0.01);
 
     math::Vec3d wsVec = transform->indexToWorld(xyz);
@@ -326,7 +326,7 @@ TEST_F(TestGradient, testWSGradientStencilFrustum)
     math::Vec3s result =
           math::Gradient<math::NonlinearFrustumMap, math::CD_2ND>::result(*map, acc, xyz);
 
-    // The Gradient should be unit lenght for this case
+    // The Gradient should be unit length for this case
     EXPECT_NEAR(1.0, result.length(), /*tolerance=*/0.01);
 
     math::Vec3d wsVec = transform->indexToWorld(xyz);
diff --git a/openvdb/openvdb/unittest/TestIndexFilter.cc b/openvdb/openvdb/unittest/TestIndexFilter.cc
index 3389511d85..754693765a 100644
--- a/openvdb/openvdb/unittest/TestIndexFilter.cc
+++ b/openvdb/openvdb/unittest/TestIndexFilter.cc
@@ -99,7 +99,7 @@ class ThresholdFilter
 ///
 /// @note This method is VERY SLOW and should only be used for debugging purposes!
 /// However it works for any transform and even with open level sets.
-/// A faster approch for closed narrow band generation is to only set voxels
+/// A faster approach for closed narrow band generation is to only set voxels
 /// sparsely and then use grid::signedFloodFill to define the sign
 /// of the background values and tiles! This is implemented in openvdb/tools/LevelSetSphere.h
 template<class GridType>
diff --git a/openvdb/openvdb/unittest/TestIndexIterator.cc b/openvdb/openvdb/unittest/TestIndexIterator.cc
index 0c7b8978ea..fdcc969ef4 100644
--- a/openvdb/openvdb/unittest/TestIndexIterator.cc
+++ b/openvdb/openvdb/unittest/TestIndexIterator.cc
@@ -40,7 +40,7 @@ class ProfileTimer
     {
         (void)msg;
 #ifdef PROFILE
-        // padd string to 50 characters
+        // pad string to 50 characters
         std::string newMsg(msg);
         if (newMsg.size() < 50)     newMsg.insert(newMsg.end(), 50 - newMsg.size(), ' ');
         std::cerr << newMsg << " ... ";
@@ -50,7 +50,7 @@ class ProfileTimer
 
     ~ProfileTimer() { this->stop(); }
 
-    /// Return Time diference in milliseconds since construction or start was called.
+    /// Return Time difference in milliseconds since construction or start was called.
     inline double delta() const
     {
         tbb::tick_count::interval_t dt = tbb::tick_count::now() - mT0;
diff --git a/openvdb/openvdb/unittest/TestLeafMask.cc b/openvdb/openvdb/unittest/TestLeafMask.cc
index 7597158f45..7f32b0887c 100644
--- a/openvdb/openvdb/unittest/TestLeafMask.cc
+++ b/openvdb/openvdb/unittest/TestLeafMask.cc
@@ -199,11 +199,11 @@ TEST_F(TestLeafMask, testEquivalence)
 
         leaf2.setValueOff(Coord(0, 0, 1), false);
 
-        EXPECT_TRUE(leaf == leaf2);//values and states coinside
+        EXPECT_TRUE(leaf == leaf2);//values and states coincide
 
         leaf2.setValueOn(Coord(0, 0, 1));
 
-        EXPECT_TRUE(leaf != leaf2);//values and states coinside
+        EXPECT_TRUE(leaf != leaf2);//values and states coincide
     }
     {// test LeafNode<bool>::operator==()
         LeafType leaf1(Coord(0            , 0, 0), true); // true and inactive
diff --git a/openvdb/openvdb/unittest/TestMaps.cc b/openvdb/openvdb/unittest/TestMaps.cc
index 28061b63f2..d2337293c8 100644
--- a/openvdb/openvdb/unittest/TestMaps.cc
+++ b/openvdb/openvdb/unittest/TestMaps.cc
@@ -521,7 +521,7 @@ TEST_F(TestMaps, testFrustum)
     center += frustumMap_from_camera.applyMap(Vec3d(500,250,5000));
     center = center /4.;
     EXPECT_TRUE( isApproxEqual(center, position + (z_near+depth) * direction));
-    // check that the frustum has the correct heigh on the near plane
+    // check that the frustum has the correct height on the near plane
     Vec3d corner1  = frustumMap_from_camera.applyMap(Vec3d(0,0,0));
     Vec3d corner2  = frustumMap_from_camera.applyMap(Vec3d(0,250,0));
     Vec3d side = corner2-corner1;
diff --git a/openvdb/openvdb/unittest/TestMorphology.cc b/openvdb/openvdb/unittest/TestMorphology.cc
index a03e1db857..f86edf0e8a 100644
--- a/openvdb/openvdb/unittest/TestMorphology.cc
+++ b/openvdb/openvdb/unittest/TestMorphology.cc
@@ -64,7 +64,7 @@ TestMorphologyInternal<TreeT, NN>::testMorphActiveLeafValues()
     const Coord* const end = start + offsets;
 
     // Small methods to check neighbour activity from an xyz coordinate. Recurse
-    // parameter allows for recursively checking the acitvity of the xyz
+    // parameter allows for recursively checking the activity of the xyz
     // neighbours, with recurse=0 only checking the immediate neighbours.
     std::function<void(const TreeT&, const Coord&, const size_t)> CheckActiveNeighbours;
     CheckActiveNeighbours = [start, end, &CheckActiveNeighbours]
@@ -407,7 +407,7 @@ TestMorphologyInternal<TreeT, NN>::testMorphActiveValues()
     const Coord* const end = start + offsets;
 
     // Small method to check neighbour activity from an xyz coordinate. Recurse
-    // parameter allows for recursively checking the acitvity of the xyz
+    // parameter allows for recursively checking the activity of the xyz
     // neighbours, with recurse=0 only checking the immediate neighbours.
     std::function<void(const TreeT&, const Coord&, const size_t)> CheckActiveNeighbours;
     CheckActiveNeighbours = [start, end, &CheckActiveNeighbours]
diff --git a/openvdb/openvdb/unittest/TestNodeMask.cc b/openvdb/openvdb/unittest/TestNodeMask.cc
index b501e12ea2..7f893876f1 100644
--- a/openvdb/openvdb/unittest/TestNodeMask.cc
+++ b/openvdb/openvdb/unittest/TestNodeMask.cc
@@ -65,13 +65,13 @@ void TestAll()
         EXPECT_TRUE(!m.isOff());
         EXPECT_TRUE(m.countOn() == MaskType::SIZE);
         EXPECT_TRUE(m.countOff()== 0);
-        m = MaskType();//copy asignment
+        m = MaskType();//copy assignment
         EXPECT_TRUE(m.isOff());
         EXPECT_TRUE(!m.isOn());
         EXPECT_TRUE(m.countOn() == 0);
         EXPECT_TRUE(m.countOff()== MaskType::SIZE);
     }
-    {// test setOn, setOff, findFirstOn and findFiratOff
+    {// test setOn, setOff, findFirstOn and findFirstOff
         MaskType m;
         for (Index i=0; i<SIZE; ++i) {
             m.setOn(i);
@@ -255,7 +255,7 @@ TEST_F(TestNodeMask, testCompress)
         EXPECT_EQ(maskCompress.inactiveVal[1], background);
     }
 
-    { // mask selects between backgd and one other inactive val
+    { // mask selects between background and one other inactive value
         MaskT valueMask;
         MaskT childMask;
         std::vector<int> values = {0,500,500,10,4,500,10,500};
diff --git a/openvdb/openvdb/unittest/TestParticlesToLevelSet.cc b/openvdb/openvdb/unittest/TestParticlesToLevelSet.cc
index afe381ebb4..19df1ff580 100644
--- a/openvdb/openvdb/unittest/TestParticlesToLevelSet.cc
+++ b/openvdb/openvdb/unittest/TestParticlesToLevelSet.cc
@@ -61,7 +61,7 @@ class MyParticleList
         pa.v = v;
         mParticleList.push_back(pa);
     }
-    /// @return coordinate bbox in the space of the specified transfrom
+    /// @return coordinate bbox in the space of the specified transform
     openvdb::CoordBBox getBBox(const openvdb::GridBase& grid) {
         openvdb::CoordBBox bbox;
         openvdb::Coord &min= bbox.min(), &max = bbox.max();
diff --git a/openvdb/openvdb/unittest/TestPointCount.cc b/openvdb/openvdb/unittest/TestPointCount.cc
index 58ea887907..58b0b103b5 100644
--- a/openvdb/openvdb/unittest/TestPointCount.cc
+++ b/openvdb/openvdb/unittest/TestPointCount.cc
@@ -157,7 +157,7 @@ TEST_F(TestPointCount, testCount)
     LeafType* leaf2Ptr = tree.touchLeaf(openvdb::Coord(0, 0, 8));
     LeafType& leaf2(*leaf2Ptr);
 
-    // on adding, tree now obtains ownership and is reponsible for deletion
+    // on adding, tree now obtains ownership and is responsible for deletion
 
     for (unsigned int i = 0; i < LeafType::SIZE; i++) {
         leaf2.setOffsetOn(i, i);
@@ -459,7 +459,7 @@ TEST_F(TestPointCount, testOffsets)
         EXPECT_EQ(total, Index64(5));
     }
 
-    { // all point offsets when using a non-existant exclude group
+    { // all point offsets when using a non-existent exclude group
 
         std::vector<Index64> offsets;
 
diff --git a/openvdb/openvdb/unittest/TestPointMove.cc b/openvdb/openvdb/unittest/TestPointMove.cc
index cf165a9998..25738b0c82 100644
--- a/openvdb/openvdb/unittest/TestPointMove.cc
+++ b/openvdb/openvdb/unittest/TestPointMove.cc
@@ -248,7 +248,7 @@ void TestPointMove::testCachedDeformer()
     cachedDeformer.apply(newPosition, indexIter);
     EXPECT_TRUE(math::isApproxEqual(position, newPosition));
 
-    // insert a new value into the leaf vector and verify tbe position is deformed
+    // insert a new value into the leaf vector and verify the position is deformed
     Vec3d deformedPosition(5,10,15);
     leaf.vecData.push_back(deformedPosition);
     cachedDeformer.apply(newPosition, indexIter);
diff --git a/openvdb/openvdb/unittest/TestPointRasterizeSDF.cc b/openvdb/openvdb/unittest/TestPointRasterizeSDF.cc
index 3af09c8288..1f49447b9c 100644
--- a/openvdb/openvdb/unittest/TestPointRasterizeSDF.cc
+++ b/openvdb/openvdb/unittest/TestPointRasterizeSDF.cc
@@ -977,7 +977,7 @@ TEST_F(TestPointRasterizeSDF, testAttrTransfer)
             EXPECT_TRUE(sdf->tree().hasSameTopology(test1->tree()));
             EXPECT_TRUE(sdf->tree().hasSameTopology(test2->tree()));
 
-            // check atributes that have been transfered are correct
+            // check attributes that have been transferred are correct
             for (auto iter = sdf->cbeginValueOn(); iter; ++iter) {
                 const Coord ijk = iter.getCoord();
                 const Vec3d ws = sdf->transform().indexToWorld(ijk);
@@ -1053,7 +1053,7 @@ TEST_F(TestPointRasterizeSDF, testVariableAttrTransfer)
         //   contributions to match normal sphere attribute transfer
         const float radscale = 0.5, search = 3.0;
 
-        // test cloest point transfer
+        // test closest point transfer
         s.halfband = 3;
         s.transform = math::Transform::createLinearTransform(0.3);
         s.points = PointBuilder(positions)
@@ -1104,7 +1104,7 @@ TEST_F(TestPointRasterizeSDF, testVariableAttrTransfer)
             EXPECT_TRUE(sdf->tree().hasSameTopology(test1->tree()));
             EXPECT_TRUE(sdf->tree().hasSameTopology(test2->tree()));
 
-            // check atributes that have been transfered are correct
+            // check attributes that have been transferred are correct
             for (auto iter = sdf->cbeginValueOn(); iter; ++iter) {
                 const Coord ijk = iter.getCoord();
                 const Vec3d ws = sdf->transform().indexToWorld(ijk);
diff --git a/openvdb/openvdb/unittest/TestPrePostAPI.cc b/openvdb/openvdb/unittest/TestPrePostAPI.cc
index 0cc935188c..f2db97b158 100644
--- a/openvdb/openvdb/unittest/TestPrePostAPI.cc
+++ b/openvdb/openvdb/unittest/TestPrePostAPI.cc
@@ -442,8 +442,8 @@ TEST_F(TestPrePostAPI, testLinearTransform)
         tinv->postTranslate(-Vec3d(2, 2, 2));
 
 
-        // test this by verifying that equvilent interal matrix
-        // represenations are inverses
+        // test this by verifying that equivalent internal matrix
+        // representations are inverses
         Mat4d m = t->baseMap()->getAffineMap()->getMat4();
         Mat4d minv = tinv->baseMap()->getAffineMap()->getMat4();
 
@@ -561,8 +561,8 @@ TEST_F(TestPrePostAPI, testFrustumTransform)
         tinv->postTranslate(-Vec3d(2, 2, 2));
 
 
-        // test this by verifying that equvilent interal matrix
-        // represenations are inverses
+        // test this by verifying that equivalent internal matrix
+        // representations are inverses
         NonlinearFrustumMap::Ptr frustum =
             openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(t->baseMap());
         NonlinearFrustumMap::Ptr frustuminv =
diff --git a/openvdb/openvdb/unittest/TestStreamCompression.cc b/openvdb/openvdb/unittest/TestStreamCompression.cc
index 79cf6a2b4c..1bebf25c65 100644
--- a/openvdb/openvdb/unittest/TestStreamCompression.cc
+++ b/openvdb/openvdb/unittest/TestStreamCompression.cc
@@ -262,7 +262,7 @@ TEST_F(TestStreamCompression, testBlosc)
 #endif
     }
 
-    { // uncompressible buffer
+    { // incompressible buffer
         const int uncompressedCount = 32;
 
         std::vector<int> values;
diff --git a/openvdb/openvdb/unittest/TestTools.cc b/openvdb/openvdb/unittest/TestTools.cc
index df17050a06..e8d732984f 100644
--- a/openvdb/openvdb/unittest/TestTools.cc
+++ b/openvdb/openvdb/unittest/TestTools.cc
@@ -937,12 +937,12 @@ TEST_F(TestTools, testPointAdvect)
     {
         // Setup:    Advect a number of points in a uniform velocity field (1,1,1).
         //           over a time dt=1 with each of the 4 different advection schemes.
-        //           Points initialized at latice points.
+        //           Points initialized at lattice points.
         //
         // Uses:     FloatTree (velocity), collocated sampling, advection
         //
         // Expected: All advection schemes will have the same result.  Each point will
-        //           be advanced to a new latice point.  The i-th point will be at (i+1,i+1,i+1)
+        //           be advanced to a new lattice point.  The i-th point will be at (i+1,i+1,i+1)
         //
 
         const size_t numPoints = 2000000;
@@ -983,12 +983,12 @@ TEST_F(TestTools, testPointAdvect)
         // Setup:    Advect a number of points in a uniform velocity field (1,1,1).
         //           over a time dt=1 with each of the 4 different advection schemes.
         //           And then project the point location onto the x-y plane
-        //           Points initialized at latice points.
+        //           Points initialized at lattice points.
         //
         // Uses:     DoubleTree (velocity), staggered sampling, constraint projection, advection
         //
         // Expected: All advection schemes will have the same result.  Modes 1-4: Each point will
-        //           be advanced to a new latice point and projected to x-y plane.
+        //           be advanced to a new lattice point and projected to x-y plane.
         //           The i-th point will be at (i+1,i+1,0).  For mode 0 (no advection), i-th point
         //           will be found at (i, i, 0)
 
@@ -1028,13 +1028,13 @@ TEST_F(TestTools, testPointAdvect)
             std::vector<openvdb::Vec3d>, true> constrainedAdvectionTool(*velocityGrid, *cptGrid, 0);
         constrainedAdvectionTool.setThreaded(false);
 
-        // change the number of constraint interation from default 0 to 5
+        // change the number of constraint interaction from default 0 to 5
         constrainedAdvectionTool.setConstraintIterations(5);
 
         // test the pure-projection mode (order = 0)
         constrainedAdvectionTool.setIntegrationOrder(0);
 
-        // change the number of constraint interation (from 0 to 5)
+        // change the number of constraint interaction (from 0 to 5)
         constrainedAdvectionTool.setConstraintIterations(5);
 
         constrainedAdvectionTool.advect(pointList, /*dt=*/1.0, /*iterations=*/1);
diff --git a/openvdb/openvdb/unittest/TestTree.cc b/openvdb/openvdb/unittest/TestTree.cc
index a5ac2afade..98e7b7bc36 100644
--- a/openvdb/openvdb/unittest/TestTree.cc
+++ b/openvdb/openvdb/unittest/TestTree.cc
@@ -1528,7 +1528,7 @@ TEST_F(TestTree, testTopologyIntersection)
         EXPECT_EQ(openvdb::Index64(7), tree3.leafCount());
 
 
-        //tree1.topologyInterection(tree2);//should make tree1 = tree0
+        //tree1.topologyIntersection(tree2);//should make tree1 = tree0
         tree1.topologyIntersection(tree3);//should make tree1 = tree0
 
         EXPECT_TRUE(tree0.leafCount()==tree1.leafCount());
@@ -1616,7 +1616,7 @@ TEST_F(TestTree, testTopologyIntersection)
         EXPECT_EQ(0, int(gridSmall->tree().activeTileCount()));
         EXPECT_EQ((10 * 10 * 10), int(gridSmall->activeVoxelCount()));
 
-        // In this case the interesection should be exactly "small"
+        // In this case the intersection should be exactly "small"
         EXPECT_EQ(0, int(gridBig->tree().activeTileCount()));
         EXPECT_EQ((10 * 10 * 10), int(gridBig->activeVoxelCount()));
 
@@ -1812,7 +1812,7 @@ TEST_F(TestTree, testTopologyDifference)
         EXPECT_EQ(openvdb::Index64(7), tree3.leafCount());
 
 
-        //tree1.topologyInterection(tree2);//should make tree1 = tree0
+        //tree1.topologyIntersection(tree2);//should make tree1 = tree0
         tree1.topologyIntersection(tree3);//should make tree1 = tree0
 
         EXPECT_TRUE(tree0.leafCount()==tree1.leafCount());
@@ -2177,7 +2177,7 @@ TEST_F(TestTree, testPruneLevelSet)
     }
     // The following version is slower since it employs
     // FloatTree::ValueOnIter that visits both tiles and voxels and
-    // also uses random acceess to set the voxels off.
+    // also uses random access to set the voxels off.
     /*
       for (openvdb::FloatTree::ValueOnIter i = tree.beginValueOn(); i; ++i) {
       if (fabs(*i)<new_width) continue;
@@ -2652,7 +2652,7 @@ TEST_F(TestTree, testStealNode)
     const float background=0.0f, value = 5.6f, epsilon=0.000001f;
     const openvdb::Coord xyz(-23,42,70);
 
-    {// stal a LeafNode
+    {// steal a LeafNode
         using NodeT = FloatTree::LeafNodeType;
         EXPECT_EQ(Index(0), NodeT::getLevel());
 
diff --git a/openvdb/openvdb/unittest/TestVolumeToSpheres.cc b/openvdb/openvdb/unittest/TestVolumeToSpheres.cc
index 7d7979b6be..0dfcf22c6e 100644
--- a/openvdb/openvdb/unittest/TestVolumeToSpheres.cc
+++ b/openvdb/openvdb/unittest/TestVolumeToSpheres.cc
@@ -138,7 +138,7 @@ TEST_F(TestVolumeToSpheres, testMinimumSphereCount)
                 /*overlapping=*/true, /*minRadius=*/2.0f);
 
             // Given the relatively large minimum radius, the actual sphere count
-            // should be no larger than the requested mimimum count.
+            // should be no larger than the requested minimum count.
             EXPECT_EQ(minSphereCount, int(spheres.size()));
             //EXPECT_TRUE(int(spheres.size()) >= minSphereCount);
             EXPECT_TRUE(int(spheres.size()) <= maxSphereCount);
diff --git a/openvdb/openvdb/unittest/util.h b/openvdb/openvdb/unittest/util.h
index 110a8e7290..f262a5c42f 100644
--- a/openvdb/openvdb/unittest/util.h
+++ b/openvdb/openvdb/unittest/util.h
@@ -20,7 +20,7 @@ enum SphereMode { SPHERE_DENSE, SPHERE_DENSE_NARROW_BAND, SPHERE_SPARSE_NARROW_B
 ///
 /// @note This method is VERY SLOW and should only be used for debugging purposes!
 /// However it works for any transform and even with open level sets.
-/// A faster approch for closed narrow band generation is to only set voxels
+/// A faster approach for closed narrow band generation is to only set voxels
 /// sparsely and then use grid::signedFloodFill to define the sign
 /// of the background values and tiles! This is implemented in openvdb/tools/LevelSetSphere.h
 template<class GridType>
diff --git a/openvdb/openvdb/util/CpuTimer.h b/openvdb/openvdb/util/CpuTimer.h
index 774c4f7531..e71eaa53e2 100644
--- a/openvdb/openvdb/util/CpuTimer.h
+++ b/openvdb/openvdb/util/CpuTimer.h
@@ -170,7 +170,7 @@ class CpuTimer
     {
         // steady_clock is a monotonically increasing clock designed for timing duration
         // note that high_resolution_clock is aliased to either steady_clock or system_clock
-        // depending on the platform, so it is preferrable to use steady_clock
+        // depending on the platform, so it is preferable to use steady_clock
         const auto time_since_epoch =
             std::chrono::steady_clock::now().time_since_epoch();
         // cast time since epoch into microseconds (1 / 1000000 seconds)
diff --git a/openvdb/openvdb/util/NodeMasks.h b/openvdb/openvdb/util/NodeMasks.h
index 370f3b0555..2c3cb29ab6 100644
--- a/openvdb/openvdb/util/NodeMasks.h
+++ b/openvdb/openvdb/util/NodeMasks.h
@@ -1062,7 +1062,7 @@ class NodeMask<2>
 // Unlike NodeMask above this RootNodeMask has a run-time defined size.
 // It is only included for backward compatibility and will likely be
 // deprecated in the future!
-// This class is 32-bit specefic, hence the use if Index32 vs Index!
+// This class is 32-bit specific, hence the use if Index32 vs Index!
 class RootNodeMask
 {
 protected:
@@ -1207,7 +1207,7 @@ class RootNodeMask
         DenseIterator(Index32 pos,const RootNodeMask *parent) : BaseIterator(pos,parent) {}
         void increment() {
             OPENVDB_ASSERT(mParent != nullptr);
-            mPos += 1;//carefull - the increament might go beyond the end
+            mPos += 1;//careful - the increment might go beyond the end
             OPENVDB_ASSERT(mPos<= mBitSize);
         }
         void increment(Index n) {
diff --git a/openvdb/openvdb/util/PagedArray.h b/openvdb/openvdb/util/PagedArray.h
index bf9bedf2af..0d5daa8de6 100644
--- a/openvdb/openvdb/util/PagedArray.h
+++ b/openvdb/openvdb/util/PagedArray.h
@@ -9,7 +9,7 @@
 ///         structure with O(1) random access and STL-compliant
 ///         iterators. It is primarily intended for applications
 ///         that involve multi-threading push_back of (a possibly
-///         unkown number of) elements into a dynamically growing
+///         unknown number of) elements into a dynamically growing
 ///         linear array, and fast random access to said elements.
 
 #ifndef OPENVDB_UTIL_PAGED_ARRAY_HAS_BEEN_INCLUDED
@@ -38,7 +38,7 @@ namespace util {
 /// @brief   Concurrent, page-based, dynamically-sized linear data structure
 ///          with O(1) random access and STL-compliant iterators. It is
 ///          primarily intended for applications that concurrently insert
-///          (a possibly unkown number of) elements into a dynamically
+///          (a possibly unknown number of) elements into a dynamically
 ///          growing linear array, and fast random access to said elements.
 ///
 /// @note    Multiple threads can grow the page-table and push_back
@@ -46,14 +46,14 @@ namespace util {
 ///          and threadsafe push_back at the cost of potentially re-ordering
 ///          elements (when multiple instances are used).
 ///
-/// @details This data structure employes contiguous pages of elements
+/// @details This data structure employs contiguous pages of elements
 ///          (a std::deque) which avoids moving data when the
 ///          capacity is out-grown and new pages are allocated. The
 ///          size of the pages can be controlled with the Log2PageSize
 ///          template parameter (defaults to 1024 elements of type ValueT).
 ///
 /// There are three fundamentally different ways to insert elements to
-/// this container - each with different advanteges and disadvanteges.
+/// this container - each with different advantages and disadvantages.
 ///
 /// The simplest way to insert elements is to use PagedArray::push_back_unsafe
 /// which is @a not thread-safe:
@@ -114,7 +114,7 @@ namespace util {
 /// PagedArray::ValueBuffer are employed. This is typically the case
 /// in the context of multi-threading, where the
 /// ordering of inserts are undefined anyway. Note that a local scope
-/// can be used to guarentee that the ValueBuffer has inserted all its
+/// can be used to guarantee that the ValueBuffer has inserted all its
 /// elements by the time the scope ends. Alternatively the ValueBuffer
 /// can be explicitly flushed by calling ValueBuffer::flush.
 ///
@@ -146,7 +146,7 @@ class PagedArray
     static_assert(Log2PageSize > 1UL, "Expected Log2PageSize > 1");
     class Page;
 
-    // must allow mutiple threads to call operator[] as long as only one thread calls push_back
+    // must allow multiple threads to call operator[] as long as only one thread calls push_back
     using PageTableT = std::deque<Page*>;
 
 public:
@@ -554,7 +554,7 @@ ValueBuffer
     /// @brief Add a value to the buffer and increment the size.
     ///
     /// @details If the internal memory page is full it will
-    /// automaically flush the page to the parent PagedArray.
+    /// automatically flush the page to the parent PagedArray.
     void push_back(const ValueT& v) {
         (*mPage)[mSize++] = v;
         if (mSize == Page::Size) this->flush();
diff --git a/openvdb_ax/openvdb_ax/ast/AST.h b/openvdb_ax/openvdb_ax/ast/AST.h
index 8b0fe3435e..fadf027852 100644
--- a/openvdb_ax/openvdb_ax/ast/AST.h
+++ b/openvdb_ax/openvdb_ax/ast/AST.h
@@ -466,7 +466,7 @@ struct StatementList : public Statement
 /// @brief  A Block node represents a scoped list of statements. It may comprise
 ///         of 0 or more statements, and specifically indicates that a new scope
 ///         is activated, typically represented by curly braces. Note that a
-///         block does not alway have to be encapsulated by curly braces, but
+///         block does not always have to be encapsulated by curly braces, but
 ///         always represents a new scope.
 /// @note   Statements held by the block are guaranteed to be valid (non null).
 ///         nullptrs added to the block are implicitly dropped.
@@ -2246,7 +2246,7 @@ struct DeclareLocal : public Statement
 ///         the AX parser). Negative values are represented by a combination of
 ///         a UnaryOperator holding a Value AST node.
 /// @note   Note that Value AST nodes representing strings are specialized and
-///         are guranteed to be "well-formed" (there is no numerical conversion)
+///         are guaranteed to be "well-formed" (there is no numerical conversion)
 /// @note   A Value is a complete "leaf-level" AST node. It has no children and
 ///         nothing derives from it.
 template <typename T>
diff --git a/openvdb_ax/openvdb_ax/ast/Parse.h b/openvdb_ax/openvdb_ax/ast/Parse.h
index dc2178480a..8acd4c77f0 100644
--- a/openvdb_ax/openvdb_ax/ast/Parse.h
+++ b/openvdb_ax/openvdb_ax/ast/Parse.h
@@ -28,7 +28,7 @@ namespace ast {
 ///   attempts to construct a complete abstract syntax tree (AST) which can be
 ///   passed to the AX Compiler. If the code is not well formed (as defined by
 ///   the AX grammar) a nullptr is returned and instances of any errors
-///   encoutered are stored to the provided logger.
+///   encountered are stored to the provided logger.
 /// @note   The returned AST is const as the logger uses this to determine line
 ///   and column numbers of errors/warnings in later stages. If you need to
 ///   modify the tree, take a copy.
diff --git a/openvdb_ax/openvdb_ax/ast/PrintTree.cc b/openvdb_ax/openvdb_ax/ast/PrintTree.cc
index 91d5586b29..8c6c1f4e7c 100644
--- a/openvdb_ax/openvdb_ax/ast/PrintTree.cc
+++ b/openvdb_ax/openvdb_ax/ast/PrintTree.cc
@@ -567,7 +567,7 @@ struct ReprintVisitor : public ast::Visitor<ReprintVisitor>
             return true;
         }
 
-        // multiple statments
+        // multiple statements
 
         if (stmtl->child(0)->nodetype() == ast::Node::DeclareLocalNode) {
             // it's a declaration list, manually handle the child nodes.
diff --git a/openvdb_ax/openvdb_ax/ax.cc b/openvdb_ax/openvdb_ax/ax.cc
index 561f73f53f..a4d34eea7e 100644
--- a/openvdb_ax/openvdb_ax/ax.cc
+++ b/openvdb_ax/openvdb_ax/ax.cc
@@ -24,7 +24,7 @@ namespace OPENVDB_VERSION_NAME {
 namespace ax {
 
 /// @note Implementation for initialize, isInitialized and uninitialized
-///       reamins in compiler/Compiler.cc
+///       remains in compiler/Compiler.cc
 
 void run(const char* ax, openvdb::GridBase& grid, const AttributeBindings& bindings)
 {
diff --git a/openvdb_ax/openvdb_ax/codegen/Codecs.cc b/openvdb_ax/openvdb_ax/codegen/Codecs.cc
index b56a0dfeda..4519d7c016 100644
--- a/openvdb_ax/openvdb_ax/codegen/Codecs.cc
+++ b/openvdb_ax/openvdb_ax/codegen/Codecs.cc
@@ -309,7 +309,7 @@ const CodecTypeMap& getCodecTypeMap()
 {
     // Initialise the static codec registry of supported types.
     // This can easily be exposed to users so they can write their own codecs,
-    // but it would turn into either another static mutex regitry or another
+    // but it would turn into either another static mutex registry or another
     // object that would have to be passed from the codegen to the executables.
     // When we have AX pipelines we should expose this
 
diff --git a/openvdb_ax/openvdb_ax/codegen/ComputeGenerator.cc b/openvdb_ax/openvdb_ax/codegen/ComputeGenerator.cc
index fe6851213d..ec4e06c3a0 100644
--- a/openvdb_ax/openvdb_ax/codegen/ComputeGenerator.cc
+++ b/openvdb_ax/openvdb_ax/codegen/ComputeGenerator.cc
@@ -651,7 +651,7 @@ bool ComputeGenerator::visit(const ast::BinaryOperator* node)
 bool ComputeGenerator::visit(const ast::UnaryOperator* node)
 {
     // If the unary operation is a +, keep the value ptr on the stack and
-    // continue (avoid any new allocations or unecessary loads)
+    // continue (avoid any new allocations or unnecessary loads)
 
     const ast::tokens::OperatorToken token = node->operation();
     if (token == ast::tokens::PLUS) return true;
@@ -1106,7 +1106,7 @@ bool ComputeGenerator::visit(const ast::ArrayUnpack* node)
     }
     else {
         // component0 = row, component1 = column. Index into the matrix array
-        // which is layed out in row major = (component0*dim + component1)
+        // which is laid out in row major = (component0*dim + component1)
         OPENVDB_ASSERT(size == 9 || size == 16);
         const int32_t dim = size == 9 ? 3 : 4;
         llvm::Value* offset =
diff --git a/openvdb_ax/openvdb_ax/codegen/FunctionRegistry.h b/openvdb_ax/openvdb_ax/codegen/FunctionRegistry.h
index 617f73f6f7..a1626724de 100644
--- a/openvdb_ax/openvdb_ax/codegen/FunctionRegistry.h
+++ b/openvdb_ax/openvdb_ax/codegen/FunctionRegistry.h
@@ -58,7 +58,7 @@ class OPENVDB_AX_API FunctionRegistry
         /// @brief Return a pointer to this function definition
         inline const FunctionGroup* function() const { return mFunction.get(); }
 
-        /// @brief Check whether this function should be only internally accesible
+        /// @brief Check whether this function should be only internally accessible
         inline bool isInternal() const { return mInternal; }
 
     private:
diff --git a/openvdb_ax/openvdb_ax/codegen/PointComputeGenerator.cc b/openvdb_ax/openvdb_ax/codegen/PointComputeGenerator.cc
index 09f35c13ed..4bf1f118f6 100644
--- a/openvdb_ax/openvdb_ax/codegen/PointComputeGenerator.cc
+++ b/openvdb_ax/openvdb_ax/codegen/PointComputeGenerator.cc
@@ -356,7 +356,7 @@ decode(llvm::Value* buffer,
             OPENVDB_ASSERT(encodedType);
             encodedType = encodedType->getPointerTo();
 
-            // guranteed to be castable
+            // guaranteed to be castable
             llvm::Value* typedBuffer = B.CreatePointerCast(buffer, encodedType);
             llvm::Value* encoded = ir_gep(B, typedBuffer, pid);
             OPENVDB_ASSERT(F->match({store->getType(), encoded->getType()}, C));
@@ -368,7 +368,7 @@ decode(llvm::Value* buffer,
     }
 
     // if we're here (the final else), the value is not encoded
-    // @todo  We could instead register all vaid nullcodecs which would give
+    // @todo  We could instead register all valid nullcodecs which would give
     //   guarantees should a codec not exist
     llvm::Value* typedBuffer = B.CreatePointerCast(buffer, type->getPointerTo());
     llvm::Value* value = ir_gep(B, typedBuffer, pid);
@@ -439,7 +439,7 @@ encode(llvm::Value* in,
     }
 
     // if we're here (the final else), the value is not encodable
-    // @todo  We could instead register all vaid nullcodecs which would give
+    // @todo  We could instead register all valid nullcodecs which would give
     //   guarantees should a codec not exist
     llvm::Value* typedBuffer = B.CreatePointerCast(buffer, type->getPointerTo());
     llvm::Value* loc = ir_gep(B, typedBuffer, pid);
@@ -830,7 +830,7 @@ AttributeRegistry::Ptr PointComputeGenerator::generate(const ast::Tree& tree)
 
     AttributeRegistry::Ptr registry = AttributeRegistry::create(tree);
 
-    // intialise the global indices - do this here so it's only done once
+    // initialise the global indices - do this here so it's only done once
 
     for (const AttributeRegistry::AccessData& access : registry->data()) {
         const std::string token = access.tokenname();
diff --git a/openvdb_ax/openvdb_ax/codegen/StandardFunctions.cc b/openvdb_ax/openvdb_ax/codegen/StandardFunctions.cc
index 54bb07c49b..2712f5aad4 100644
--- a/openvdb_ax/openvdb_ax/codegen/StandardFunctions.cc
+++ b/openvdb_ax/openvdb_ax/codegen/StandardFunctions.cc
@@ -967,7 +967,7 @@ inline FunctionGroup::UniquePtr axrand32(const FunctionOptions& op)
             // So, we must convert it. I should note that the OpenVDB math libraries will
             // do this for us, but its implementation static_casts `size_t` to `unsigned int`,
             // and because `std::hash` returns a binary copy of the original
-            // double-precision number in almost all cases, this ends up producing noticable
+            // double-precision number in almost all cases, this ends up producing noticeable
             // patterns in the result (e.g. by truncating the upper 4 bytes, values of 1.0,
             // 2.0, 3.0, and 4.0 all return the same hash value because their lower 4 bytes
             // are all zero).
@@ -2545,7 +2545,7 @@ inline FunctionGroup::UniquePtr axatan2(const FunctionOptions& op)
 
 inline FunctionGroup::UniquePtr axatoi(const FunctionOptions& op)
 {
-    // WARNING: decltype removes the throw identifer from atoi. We should
+    // WARNING: decltype removes the throw identifier from atoi. We should
     // use this are automatically update the function attributes as appropriate
     return FunctionBuilder("atoi")
         .addSignature<decltype(std::atoi)>(std::atoi)
@@ -2564,7 +2564,7 @@ inline FunctionGroup::UniquePtr axatoi(const FunctionOptions& op)
 
 inline FunctionGroup::UniquePtr axatof(const FunctionOptions& op)
 {
-    // WARNING: decltype removes the throw identifer from atof. We should
+    // WARNING: decltype removes the throw identifier from atof. We should
     // use this are automatically update the function attributes as appropriate
     return FunctionBuilder("atof")
         .addSignature<decltype(std::atof)>(std::atof)
@@ -2863,7 +2863,7 @@ inline FunctionGroup::UniquePtr axhsvtorgb(const FunctionOptions& op)
             B.SetInsertPoint(el);
         }
 
-        // Final case (hue > 1 || hue < 0), zero intialize
+        // Final case (hue > 1 || hue < 0), zero initialize
         B.CreateStore(zero, rgb[0]);
         B.CreateStore(zero, rgb[1]);
         B.CreateStore(zero, rgb[2]);
@@ -3189,7 +3189,7 @@ void insertStandardFunctions(FunctionRegistry& registry,
     add("axfree", axfree, true);
     add("axrealloc", axrealloc, true);
 
-    // llvm instrinsics
+    // llvm intrinsics
 
     add("ceil", llvm_ceil);
     add("cos", llvm_cos);
diff --git a/openvdb_ax/openvdb_ax/codegen/SymbolTable.h b/openvdb_ax/openvdb_ax/codegen/SymbolTable.h
index ca5e071b82..3975deb0a7 100644
--- a/openvdb_ax/openvdb_ax/codegen/SymbolTable.h
+++ b/openvdb_ax/openvdb_ax/codegen/SymbolTable.h
@@ -200,7 +200,7 @@ struct SymbolTableBlocks
         return this->find(name, mTables.crbegin()->first);
     }
 
-    /// @brief  Replace the first occurrance of a variable with a given name with a
+    /// @brief  Replace the first occurrence of a variable with a given name with a
     ///         replacement value. Returns true if a replacement occurred.
     ///
     /// @param  name   The variable name to find and replace
diff --git a/openvdb_ax/openvdb_ax/codegen/Utils.h b/openvdb_ax/openvdb_ax/codegen/Utils.h
index cfb7050008..f4eed285d3 100644
--- a/openvdb_ax/openvdb_ax/codegen/Utils.h
+++ b/openvdb_ax/openvdb_ax/codegen/Utils.h
@@ -39,7 +39,7 @@ namespace ax {
 namespace codegen {
 
 /// @note Function definitions for some types returned from automatic token to
-/// llvm IR operations. See llvmArithmeticConversion and llvmBianryConversion
+/// llvm IR operations. See llvmArithmeticConversion and llvmBinaryConversion
 
 using CastFunction = std::function<llvm::Value*
     (llvm::IRBuilder<>&, llvm::Value*, llvm::Type*)>;
@@ -426,7 +426,7 @@ llvmBinaryConversion(const llvm::Type* const type,
         if (token == ast::tokens::PLUS)                  return BIND_BINARY_OP(CreateAdd); // No Unsigned/Signed Wrap
         else if (token == ast::tokens::MINUS)            return BIND_BINARY_OP(CreateSub); // No Unsigned/Signed Wrap
         else if (token == ast::tokens::MULTIPLY)         return BIND_BINARY_OP(CreateMul); // No Unsigned/Signed Wrap
-        else if (token == ast::tokens::DIVIDE)           return BIND_BINARY_OP(CreateSDiv); // IsExact = false - when true, poison value if the reuslt is rounded
+        else if (token == ast::tokens::DIVIDE)           return BIND_BINARY_OP(CreateSDiv); // IsExact = false - when true, poison value if the result is rounded
         else if (token == ast::tokens::MODULO)           return BIND_BINARY_OP(CreateSRem); // Note this is NOT a%b in AX.
         else if (token == ast::tokens::EQUALSEQUALS)     return BIND_BINARY_OP(CreateICmpEQ);
         else if (token == ast::tokens::NOTEQUALS)        return BIND_BINARY_OP(CreateICmpNE);
@@ -596,7 +596,7 @@ arithmeticConversion(std::vector<llvm::Value*>& values,
 
 /// @brief  Chooses the highest order llvm Type as defined by typePrecedence
 ///         from either of the two incoming values and casts the other value to
-///         the choosen type if it is not already. The types of valueA and valueB
+///         the chosen type if it is not already. The types of valueA and valueB
 ///         are guaranteed to match. Both values must be scalar LLVM types
 /// @warning  This assumes any integer types are signed.
 /// @param valueA   The first llvm value
diff --git a/openvdb_ax/openvdb_ax/codegen/VolumeFunctions.cc b/openvdb_ax/openvdb_ax/codegen/VolumeFunctions.cc
index c73370b643..17d83bb9d0 100644
--- a/openvdb_ax/openvdb_ax/codegen/VolumeFunctions.cc
+++ b/openvdb_ax/openvdb_ax/codegen/VolumeFunctions.cc
@@ -191,7 +191,7 @@ inline FunctionGroup::UniquePtr axoffsettoglobalcoord(const FunctionOptions& op)
     /// @warning This function assumes that the node in question is a LeafNode!
     ///   This means that the result of this method is ONLY correct if the
     ///   origin points to an existing leaf node, OR if the offset is zero.
-    ///   Currently the VolumeExectuable processes non-leaf nodes (active tiles)
+    ///   Currently the VolumeExecutable processes non-leaf nodes (active tiles)
     ///   individually, so the offset for these nodes is always zero. Should
     ///   we need to processes a non-leaf node with a non-zero offset, this
     ///   function should be extended to take a "level" param from the parent
@@ -272,7 +272,7 @@ inline FunctionGroup::UniquePtr axindextoworld(const FunctionOptions& op)
         .addFunctionAttribute(llvm::Attribute::AlwaysInline)
         .setConstantFold(false)
         .setPreferredImpl(op.mPrioritiseIR ? FunctionBuilder::IR : FunctionBuilder::C)
-        .setDocumentation("Converted the given index space coordiante to a world space value based on the currently executing volume.")
+        .setDocumentation("Converted the given index space coordinate to a world space value based on the currently executing volume.")
         .get();
 }
 
@@ -295,7 +295,7 @@ inline FunctionGroup::UniquePtr axgetcoord(const FunctionOptions& op)
         .setConstantFold(false)
         .addDependency("offsettoglobalcoord")
         .setPreferredImpl(op.mPrioritiseIR ? FunctionBuilder::IR : FunctionBuilder::C)
-        .setDocumentation("Returns the current voxel's ijk index space coordiante.")
+        .setDocumentation("Returns the current voxel's ijk index space coordinate.")
         .get();
 }
 
diff --git a/openvdb_ax/openvdb_ax/compiler/AttributeRegistry.h b/openvdb_ax/openvdb_ax/compiler/AttributeRegistry.h
index 1f03655f54..51f91a9960 100644
--- a/openvdb_ax/openvdb_ax/compiler/AttributeRegistry.h
+++ b/openvdb_ax/openvdb_ax/compiler/AttributeRegistry.h
@@ -156,7 +156,7 @@ class AttributeRegistry
         return nullptr;
     }
 
-    /// @brief  Returns a const reference to the vector of registered accesss
+    /// @brief  Returns a const reference to the vector of registered accesses
     inline const AccessDataVec& data() const { return mAccesses; }
 
     void print(std::ostream& os) const;
diff --git a/openvdb_ax/openvdb_ax/compiler/Compiler.cc b/openvdb_ax/openvdb_ax/compiler/Compiler.cc
index 13ba59339f..8e2723335f 100644
--- a/openvdb_ax/openvdb_ax/compiler/Compiler.cc
+++ b/openvdb_ax/openvdb_ax/compiler/Compiler.cc
@@ -67,7 +67,7 @@ namespace
 /// @brief  Initialize a target machine for the host platform. Returns a nullptr
 ///         if a target could not be created.
 /// @note   This logic is based off the Kaleidoscope tutorial below with extensions
-///         for CPU and CPU featrue set targetting
+///         for CPU and CPU feature set targeting
 ///         https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html
 inline std::unique_ptr<llvm::ExecutionEngine>
 initializeExecutionEngine(std::unique_ptr<llvm::Module> M, Logger& logger)
diff --git a/openvdb_ax/openvdb_ax/compiler/PointExecutable.cc b/openvdb_ax/openvdb_ax/compiler/PointExecutable.cc
index 2f5722c135..2a11e50383 100644
--- a/openvdb_ax/openvdb_ax/compiler/PointExecutable.cc
+++ b/openvdb_ax/openvdb_ax/compiler/PointExecutable.cc
@@ -113,7 +113,7 @@ struct PointExecutable::Settings
             .addOpt("--bindings [\"ax_name:point_attr_name,...\"]")
             .setDoc("attribute bindings for points. The argument accepts a quoted string list of "
                     "AX (source code) name to data (vdb attribute) name pairs joined by colons and "
-                    "seperated by commas. For example:\n"
+                    "separated by commas. For example:\n"
                     "  --bindings \"velocity:v,density:s\"\n"
                     "binds velocity AX accesses to a 'v' attribute and density AX accesses to a 's' "
                     "attribute. The following snippet would then alias these attributes:\n"
diff --git a/openvdb_ax/openvdb_ax/compiler/PointExecutable.h b/openvdb_ax/openvdb_ax/compiler/PointExecutable.h
index 5d2efb781c..a6c9416432 100644
--- a/openvdb_ax/openvdb_ax/compiler/PointExecutable.h
+++ b/openvdb_ax/openvdb_ax/compiler/PointExecutable.h
@@ -129,7 +129,7 @@ class OPENVDB_AX_API PointExecutable
     ///   for a subset of the attributes will leave the others unchanged.
     ///   AX attributes can only bind to a single point attribute and vice versa.
     ///   However, in a single set call these can be swapped e.g. a -> b and b -> a.
-    ///   When bindings are overriden through subsequent calls to this function,
+    ///   When bindings are overridden through subsequent calls to this function,
     ///   any dangling point attributes will be automatically bound by name.
     ///   To reset these bindings call get function and create a target set of bindings
     ///   for each attribute of name -> name.
@@ -139,7 +139,7 @@ class OPENVDB_AX_API PointExecutable
 
     ////////////////////////////////////////////////////////
 
-    // foward declaration of settings for this executable
+    // forward declaration of settings for this executable
     template <bool> struct Settings;
 
     /// @brief Command Line Interface handling for the PointExecutable.
@@ -159,7 +159,7 @@ class OPENVDB_AX_API PointExecutable
         std::unique_ptr<Settings<true>> mSettings;
     };
 
-    /// @brief  Intialize the Settings of this executables from the CLI object
+    /// @brief  Initialize the Settings of this executables from the CLI object
     /// @param cli The CLI object
     void setSettingsFromCLI(const CLI& cli);
 
diff --git a/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.cc b/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.cc
index cb2d347a73..400338f938 100644
--- a/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.cc
+++ b/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.cc
@@ -178,7 +178,7 @@ struct VolumeExecutable::Settings
             .addOpt("--bindings [\"ax_name:volume_name,...\"]")
             .setDoc("attribute bindings for volumes. The argument accepts a quoted string list of "
                     "AX (source code) name to data (vdb attribute) name pairs joined by colons and "
-                    "seperated by commas. For example:\n"
+                    "separated by commas. For example:\n"
                     "  --bindings \"velocity:v,density:s\"\n"
                     "binds velocity AX accesses to a 'v' attribute and density AX accesses to a 's' "
                     "attribute. The following snippet would then alias these attributes:\n"
diff --git a/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.h b/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.h
index 0fc7e220eb..c6458702ff 100644
--- a/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.h
+++ b/openvdb_ax/openvdb_ax/compiler/VolumeExecutable.h
@@ -72,7 +72,7 @@ class Compiler;
 ///       @sa setGrainSize
 ///       @sa setActiveTileStreamingGrainSize
 ///   - AttributeBindings: None
-///       Whether to indriect any AX accesses to different grid names.
+///       Whether to indirect any AX accesses to different grid names.
 ///       @sa setAttributeBindings
 ///
 ///  For more in depth information, see the @ref vdbaxcompilerexe documentation.
@@ -249,7 +249,7 @@ class OPENVDB_AX_API VolumeExecutable
     ///   for a subset of the attributes will leave the others unchanged.
     ///   AX attributes can only bind to a single volume and vice versa.
     ///   However, in a single set call these can be swapped e.g. a -> b and b -> a.
-    ///   When bindings are overriden through subsequent calls to this function,
+    ///   When bindings are overridden through subsequent calls to this function,
     ///   any dangling volumes will be automatically bound by name.
     ///   To reset these bindings call get function and create a target set of bindings
     ///   for each attribute of name -> name.
@@ -259,7 +259,7 @@ class OPENVDB_AX_API VolumeExecutable
 
     ////////////////////////////////////////////////////////
 
-    // foward declaration of settings for this executable
+    // forward declaration of settings for this executable
     template <bool> struct Settings;
 
     /// @brief Command Line Interface handling for the VolumeExecutable.
@@ -279,7 +279,7 @@ class OPENVDB_AX_API VolumeExecutable
         std::unique_ptr<Settings<true>> mSettings;
     };
 
-    /// @brief  Intialize the Settings of this executables from the CLI object
+    /// @brief  Initialize the Settings of this executables from the CLI object
     /// @param cli The CLI object
     /// @{
     void setSettingsFromCLI(const CLI& cli);
diff --git a/openvdb_ax/openvdb_ax/grammar/axparser.y b/openvdb_ax/openvdb_ax/grammar/axparser.y
index 81b1eb8364..e78ec030b8 100644
--- a/openvdb_ax/openvdb_ax/grammar/axparser.y
+++ b/openvdb_ax/openvdb_ax/grammar/axparser.y
@@ -162,7 +162,7 @@
 %destructor { for (auto& ptr : *$$) delete ptr; delete $$; } <explist>
 %destructor { delete $$; } <*> // all other AST nodes
 
-/*  Operator Precedence Definitions. Precendence goes from lowest to
+/*  Operator Precedence Definitions. Precedence goes from lowest to
  *  highest, e.g. assignment operations are generally lowest. Note
  *  that this precedence and associativity is heavily based off of C++:
  *  https://en.cppreference.com/w/cpp/language/operator_precedence
diff --git a/openvdb_ax/openvdb_ax/math/OpenSimplexNoise.cc b/openvdb_ax/openvdb_ax/math/OpenSimplexNoise.cc
index d7b7d3bc1f..fa63fb5621 100644
--- a/openvdb_ax/openvdb_ax/math/OpenSimplexNoise.cc
+++ b/openvdb_ax/openvdb_ax/math/OpenSimplexNoise.cc
@@ -183,7 +183,7 @@ T OSNoise::eval(const T x, const T y, const T z) const
   T inSum = xins + yins + zins;
 
   if (inSum > (T)1.0 && inSum < (T)2.0) {
-    // The point is inside the octahedron (rectified 3-Simplex) inbetween.
+    // The point is inside the octahedron (rectified 3-Simplex) in between.
 
     T aScore;
     uint_fast8_t aPoint;
diff --git a/openvdb_ax/openvdb_ax/test/CMakeLists.txt b/openvdb_ax/openvdb_ax/test/CMakeLists.txt
index a5997e2099..2b824acdb4 100644
--- a/openvdb_ax/openvdb_ax/test/CMakeLists.txt
+++ b/openvdb_ax/openvdb_ax/test/CMakeLists.txt
@@ -114,7 +114,7 @@ add_executable(vdb_ax_test ${TEST_SOURCE_FILES})
 
 # @note  From Clang 14, fp-contract has been switched to ON by default. Docs in
 #  Clang versions before 14 state that fp-contract is ON, but it is in fact off.
-#  This options effects the emmission on fmuladd instructions in the Clang
+#  This options effects the emission on fmuladd instructions in the Clang
 #  driver. Because this behaviour requires statement contexts (these instructions
 #  are only emitted on intermediate floating point results, not across statements)
 #  it cannot be an optimization pass in LLVM and must be emitted in the Clang
diff --git a/openvdb_ax/openvdb_ax/test/backend/TestCodecs.cc b/openvdb_ax/openvdb_ax/test/backend/TestCodecs.cc
index d65593a453..c2281264f0 100644
--- a/openvdb_ax/openvdb_ax/test/backend/TestCodecs.cc
+++ b/openvdb_ax/openvdb_ax/test/backend/TestCodecs.cc
@@ -120,7 +120,7 @@ void TestCodecs::testRegisteredCodecs()
             llvm::Type* ret = F->types(types, C);
             // currently expect codecs to ret void
             CPPUNIT_ASSERT_EQUAL(ret, codegen::LLVMType<void>::get(C));
-            // signature should be unqiue
+            // signature should be unique
             CPPUNIT_ASSERT(!decoderSignatures.count(types));
             decoderSignatures.insert(types);
         }
@@ -133,7 +133,7 @@ void TestCodecs::testRegisteredCodecs()
             llvm::Type* ret = F->types(types, C);
             // currently expect codecs to ret void
             CPPUNIT_ASSERT_EQUAL(ret, codegen::LLVMType<void>::get(C));
-            // signature should be unqiue
+            // signature should be unique
             CPPUNIT_ASSERT(!encoderSignatures.count(types));
             encoderSignatures.insert(types);
         }
diff --git a/openvdb_ax/openvdb_ax/test/backend/TestFunctionTypes.cc b/openvdb_ax/openvdb_ax/test/backend/TestFunctionTypes.cc
index 4e3289ffbf..e58c410134 100644
--- a/openvdb_ax/openvdb_ax/test/backend/TestFunctionTypes.cc
+++ b/openvdb_ax/openvdb_ax/test/backend/TestFunctionTypes.cc
@@ -992,7 +992,7 @@ TestFunctionTypes::testFunctionCall()
     call->eraseFromParent();
     VERIFY_MODULE_IR(&M);
 
-    // Test called with non castable args, but matchign signature size.
+    // Test called with non castable args, but matching signature size.
     // Test IR is invalid due to cast being off
 
     result = test->call(argsToCast, B, /*cast*/false);
@@ -1886,7 +1886,7 @@ TestFunctionTypes::testIRFunctions()
 
     CPPUNIT_ASSERT(!M.getFunction("ax.ir.retnull.test"));
     // will throw as the function expects a float ret, not void or null
-    // NOTE: The function will still be created, but be in an invaid state
+    // NOTE: The function will still be created, but be in an invalid state
     CPPUNIT_ASSERT_THROW(test->create(M), openvdb::AXCodeGenError);
     function = M.getFunction("ax.ir.retnull.test");
     CPPUNIT_ASSERT(function);
diff --git a/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_19 b/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_19
index 5b46be0f1b..a81a35d05b 100644
--- a/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_19
+++ b/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_19
@@ -1 +1 @@
-FATAL: CLIError: Unable to convert argument: 'nan' to a valid interger. See 'vdb_ax --help'
+FATAL: CLIError: Unable to convert argument: 'nan' to a valid integer. See 'vdb_ax --help'
diff --git a/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_20 b/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_20
index 5b46be0f1b..a81a35d05b 100644
--- a/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_20
+++ b/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_fail_20
@@ -1 +1 @@
-FATAL: CLIError: Unable to convert argument: 'nan' to a valid interger. See 'vdb_ax --help'
+FATAL: CLIError: Unable to convert argument: 'nan' to a valid integer. See 'vdb_ax --help'
diff --git a/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_pass_15 b/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_pass_15
index 054c0b0064..13271a17d6 100644
--- a/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_pass_15
+++ b/openvdb_ax/openvdb_ax/test/cmd/vdb_ax_test_pass_15
@@ -23,7 +23,7 @@ usage: vdb_ax [execute] [<args>]
                               code).
     --opt [NONE|O0|O1|O2|Os|Oz|O3]
                               compilation optimization level (Default: 03). [03] ensures the most
-                              vigorus optimization passes are enabled. This should very rarely be
+                              vigorous optimization passes are enabled. This should very rarely be
                               changed but is useful for identifying issues with particular
                               optimization passes.
     --threads [n]             number of threads to use, 0 uses all available (Default: 0).
@@ -59,7 +59,7 @@ usage: vdb_ax [execute] [<args>]
     --bindings ["ax_name:volume_name,..."]
                               attribute bindings for volumes. The argument accepts a quoted string
                               list of AX (source code) name to data (vdb attribute) name pairs
-                              joined by colons and seperated by commas. For example:
+                              joined by colons and separated by commas. For example:
                                 --bindings "velocity:v,density:s"
                               binds velocity AX accesses to a 'v' attribute and density AX accesses
                               to a 's' attribute. The following snippet would then alias these
@@ -80,7 +80,7 @@ usage: vdb_ax [execute] [<args>]
     --bindings ["ax_name:point_attr_name,..."]
                               attribute bindings for points. The argument accepts a quoted string
                               list of AX (source code) name to data (vdb attribute) name pairs
-                              joined by colons and seperated by commas. For example:
+                              joined by colons and separated by commas. For example:
                                 --bindings "velocity:v,density:s"
                               binds velocity AX accesses to a 'v' attribute and density AX accesses
                               to a 's' attribute. The following snippet would then alias these
diff --git a/openvdb_ax/openvdb_ax/test/compiler/TestAXRun.cc b/openvdb_ax/openvdb_ax/test/compiler/TestAXRun.cc
index 9ee04489ab..cb8bbaa56f 100644
--- a/openvdb_ax/openvdb_ax/test/compiler/TestAXRun.cc
+++ b/openvdb_ax/openvdb_ax/test/compiler/TestAXRun.cc
@@ -159,7 +159,7 @@ TestAXRun::regressions()
         CPPUNIT_ASSERT_THROW(openvdb::ax::run("@a = 1.0f;", v2), openvdb::AXCompilerError);
     }
 
-    // Various tests which have been caught during developement
+    // Various tests which have been caught during development
 
     CPPUNIT_ASSERT_THROW(openvdb::ax::run("{} =", g1), openvdb::AXSyntaxError);
     CPPUNIT_ASSERT_THROW(openvdb::ax::run("{} =", g2), openvdb::AXSyntaxError);
diff --git a/openvdb_ax/openvdb_ax/test/integration/CompareGrids.cc b/openvdb_ax/openvdb_ax/test/integration/CompareGrids.cc
index a3e1388587..536389e466 100644
--- a/openvdb_ax/openvdb_ax/test/integration/CompareGrids.cc
+++ b/openvdb_ax/openvdb_ax/test/integration/CompareGrids.cc
@@ -411,7 +411,7 @@ compareAttributes<openvdb::points::PointDataTree::LeafNodeType>
 
         const std::string& type = array1.type().first;
         if (type != array2.type().first) {
-            // this mismatch is also loged by differing descriptors
+            // this mismatch is also logged by differing descriptors
             auto& arrayData = data.getDiagnosticArrayData(name);
             arrayData.mTypesMatch = false;
             continue;
@@ -601,7 +601,7 @@ bool compareGrids(ComparisonResult& resultData,
     differingTopology.setName("different_topology");
     differingValues.setName("different_values");
 
-    // Print diagnostic info to the stream and intialise the result topologies
+    // Print diagnostic info to the stream and initialise the result topologies
 
     openvdb::MaskGrid::Accessor accessorTopology = differingTopology.getAccessor();
     openvdb::MaskGrid::Accessor accessorValues = differingValues.getAccessor();
diff --git a/openvdb_ax/openvdb_ax/test/integration/TestHarness.h b/openvdb_ax/openvdb_ax/test/integration/TestHarness.h
index dc707b879e..5c4a6d2a7f 100644
--- a/openvdb_ax/openvdb_ax/test/integration/TestHarness.h
+++ b/openvdb_ax/openvdb_ax/test/integration/TestHarness.h
@@ -142,7 +142,7 @@ struct AXTestHarness
         addExpectedAttributes<T>({name}, {expVal});
     }
 
-    /// @brief excecutes a snippet of code contained in a file to the input data sets
+    /// @brief executes a snippet of code contained in a file to the input data sets
     bool executeCode(const std::string& codeFile,
                      const std::string* const group = nullptr,
                      const bool createMissing = false);
diff --git a/openvdb_ax/openvdb_ax/test/integration/TestVDBFunctions.cc b/openvdb_ax/openvdb_ax/test/integration/TestVDBFunctions.cc
index bcd84106da..201f890727 100644
--- a/openvdb_ax/openvdb_ax/test/integration/TestVDBFunctions.cc
+++ b/openvdb_ax/openvdb_ax/test/integration/TestVDBFunctions.cc
@@ -67,7 +67,7 @@ TestVDBFunctions::addremovefromgroup()
 
     openvdb::points::PointDataTree& dataTree = dataGrid->tree();
 
-    // apppend a new attribute for stress testing
+    // append a new attribute for stress testing
 
     openvdb::points::appendAttribute(dataTree, "existingTestAttribute", 2);
     openvdb::points::appendGroup(dataTree, "existingTestGroup");
@@ -113,7 +113,7 @@ TestVDBFunctions::addremovefromgroup()
     CPPUNIT_ASSERT(existingTestGroupHandle.get(2));
     CPPUNIT_ASSERT(!existingTestGroupHandle.get(3));
 
-    // membership of this group should now mirror exisingTestGroup
+    // membership of this group should now mirror existingTestGroup
     openvdb::points::GroupHandle existingTestGroup2Handle = leafIter->groupHandle("existingTestGroup2");
     CPPUNIT_ASSERT(existingTestGroup2Handle.get(0));
     CPPUNIT_ASSERT(!existingTestGroup2Handle.get(1));
diff --git a/openvdb_ax/openvdb_ax/test/main.cc b/openvdb_ax/openvdb_ax/test/main.cc
index d777907976..19aeacb8c2 100644
--- a/openvdb_ax/openvdb_ax/test/main.cc
+++ b/openvdb_ax/openvdb_ax/test/main.cc
@@ -265,7 +265,7 @@ main(int argc, char *argv[])
     openvdb::ax::initialize();
     openvdb::logging::initialize(argc, argv);
 
-    // Also intialize Vec2/4 point attributes
+    // Also initialize Vec2/4 point attributes
 
     registerType<openvdb::math::Vec2<int32_t>>();
     registerType<openvdb::math::Vec2<float>>();
diff --git a/openvdb_cmd/vdb_ax/cli.h b/openvdb_cmd/vdb_ax/cli.h
index 12c666c6ae..74c8a21405 100644
--- a/openvdb_cmd/vdb_ax/cli.h
+++ b/openvdb_cmd/vdb_ax/cli.h
@@ -39,7 +39,7 @@ template <typename T> struct BasicParamBuilder;
 /// @param maxWidth  column number of max output
 /// @param indent    function that returns an indent for each line
 /// @param ignoreNewLines  whether to ignore new lines in str
-/// @param trimWhitespace  whether to ignore whitespce at the start of lines
+/// @param trimWhitespace  whether to ignore whitespace at the start of lines
 inline void oswrap(std::ostream& os,
     const char* str,
     const size_t nchars,
@@ -70,7 +70,7 @@ inline void oswrap(std::ostream& os,
         const size_t endpos = pos + lineMaxWidth; // set new end
 
         if (!ignoreNewLines) {
-            // scane for new line in this range (memchr doesn't stop on \0)
+            // scan for new line in this range (memchr doesn't stop on \0)
             // hence the std::min on the max width
             const char* nl = (const char*)std::memchr(start, '\n',
                 std::min(lineMaxWidth, nchars-pos));
@@ -100,7 +100,7 @@ inline void oswrap(std::ostream& os,
 /// @param os        output stream
 /// @param opts      parameter options
 /// @param doc       parameter docs
-/// @param verbose   when false, only outputs the docs first sentance
+/// @param verbose   when false, only outputs the docs first sentence
 /// @param argSpace  minimum allowed whitespace between opts end and doc start
 /// @param docBegin  column number where doc printing should start
 /// @param maxWidth  column number of max output
@@ -137,7 +137,7 @@ inline void usage(std::ostream& os,
         current = 0;
     }
 
-    // doc chars to output. If not verbose, only first sentance
+    // doc chars to output. If not verbose, only first sentence
     size_t doclen = std::strlen(doc);
     if (!verbose) {
         // memchr doesn't stop on '\0' so needs max size
@@ -284,7 +284,7 @@ struct DefaultCallback<T,
             try { v = T(std::stol(arg)); }
             catch(...) {
                 OPENVDB_THROW(CLIError, "Unable to convert argument: '"
-                    << arg << "' to a valid interger");
+                    << arg << "' to a valid integer");
             }
         };
     }
diff --git a/openvdb_cmd/vdb_ax/main.cc b/openvdb_cmd/vdb_ax/main.cc
index 9543d9fe6c..fe22757a07 100644
--- a/openvdb_cmd/vdb_ax/main.cc
+++ b/openvdb_cmd/vdb_ax/main.cc
@@ -271,7 +271,7 @@ struct ProgOptions
         openvdb::ax::cli::ParamBuilder<openvdb::ax::CompilerOptions::OptLevel>()
             .addOpt("--opt [NONE|O0|O1|O2|Os|Oz|O3]")
             .setDoc("compilation optimization level (Default: 03). [03] ensures the most "
-                "vigorus optimization passes are enabled. This should very rarely be changed "
+                "vigorous optimization passes are enabled. This should very rarely be changed "
                 "but is useful for identifying issues with particular optimization passes.")
             .setCB([](openvdb::ax::CompilerOptions::OptLevel& v, const char* arg)
             {
diff --git a/openvdb_cmd/vdb_tool/include/Parser.h b/openvdb_cmd/vdb_tool/include/Parser.h
index 08b08599f5..0838e6a70b 100644
--- a/openvdb_cmd/vdb_tool/include/Parser.h
+++ b/openvdb_cmd/vdb_tool/include/Parser.h
@@ -242,17 +242,17 @@ class Processor
             [&](){mCallStack.top()=getExt(mCallStack.top());});
 
         // boolean operations
-        add("==","returns true if the two top enteries on the stack compare equal, e.g. {1:2:==} -> {0}",
+        add("==","returns true if the two top entries on the stack compare equal, e.g. {1:2:==} -> {0}",
             [&](){this->boolean(std::equal_to<>());});
-        add("!=","returns true if the two top enteries on the stack are not equal, e.g. {1:2:!=} -> {1}",
+        add("!=","returns true if the two top entries on the stack are not equal, e.g. {1:2:!=} -> {1}",
             [&](){this->boolean(std::not_equal_to<>());});
-        add("<=","returns true if the two top enteries on the stack are less than or equal, e.g. {1:2:<=} -> {1}",
+        add("<=","returns true if the two top entries on the stack are less than or equal, e.g. {1:2:<=} -> {1}",
             [&](){this->boolean(std::less_equal<>());});
-        add(">=","returns true if the two top enteries on the stack are greater than or equal, e.g. {1:2:>=} -> {0}",
+        add(">=","returns true if the two top entries on the stack are greater than or equal, e.g. {1:2:>=} -> {0}",
             [&](){this->boolean(std::greater_equal<>());});
-        add("<","returns true if the two top enteries on the stack are less than, e.g. {1:2:<} -> {1}",
+        add("<","returns true if the two top entries on the stack are less than, e.g. {1:2:<} -> {1}",
             [&](){this->boolean(std::less<>());});
-        add(">","returns true if the two top enteries on the stack are less than or equal, e.g. {1:2:<=} -> {1}",
+        add(">","returns true if the two top entries on the stack are less than or equal, e.g. {1:2:<=} -> {1}",
             [&](){this->boolean(std::greater<>());});
         add("!","logical negation, e.g. {1:!} -> {0}",
             [&](){this->set(!strToBool(mCallStack.top()));});
@@ -917,7 +917,7 @@ Parser::Parser(std::vector<Option> &&def)
     this->addAction(
         "end", "", "marks the end scope of \"-for,-each,and -if\" control actions", {},
         [&](){
-            if (counter<=0) throw std::invalid_argument("Parser: -end must be preceeded by -for,-each, or -if");
+            if (counter<=0) throw std::invalid_argument("Parser: -end must be preceded by -for,-each, or -if");
             --counter;},
         [&](){
             OPENVDB_ASSERT(iter->name == "end");
diff --git a/openvdb_cmd/vdb_tool/include/Tool.h b/openvdb_cmd/vdb_tool/include/Tool.h
index b24e71696e..f3bce42193 100644
--- a/openvdb_cmd/vdb_tool/include/Tool.h
+++ b/openvdb_cmd/vdb_tool/include/Tool.h
@@ -142,7 +142,7 @@ class Tool
     GridBase::Ptr clip(const VecF &v, int age, const GridType &input);
     void clip();
 
-    /// @brief composit two grids, e.g. min, max, sum
+    /// @brief composite two grids, e.g. min, max, sum
     void composite();
 
     /// @brief generate a grid of selected properties from another grid
@@ -356,14 +356,14 @@ void Tool::init()
   mParser.addAction(
       "config", "c", "Import and process one or more configuration files",
     {{"files", "",  "config1.txt,config2.txt...", "list of configuration files to load and execute"},
-     {"execute", "true", "1|0|true|false", "toggle wether to execute the actions in the config file"},
-     {"update", "false", "1|0|true|false", "toggle wether to update the version number of the config file"}},
+     {"execute", "true", "1|0|true|false", "toggle whether to execute the actions in the config file"},
+     {"update", "false", "1|0|true|false", "toggle whether to update the version number of the config file"}},
      [&](){this->config();}, [](){}, 0); // anonymous options are appended to "files"
 
   mParser.addAction(
       "help", "h", "Print documentation for one, multiple or all available actions",
     {{"actions", "", "read,write,...", "list of actions to document. If the list is empty documentation is printed for all available actions and if other actions proceed this action, documentation is printed for those actions only"},
-     {"exit", "true", "1|0|true|false", "toggle wether to terminate after this action or not"},
+     {"exit", "true", "1|0|true|false", "toggle whether to terminate after this action or not"},
      {"brief", "false", "1|0|true|false", "toggle brief or detailed documentation"}},
      [](){}, [&](){this->help();}, 0); // anonymous options are appended to "actions"
 
@@ -379,7 +379,7 @@ void Tool::init()
     {{"files", "", "{file|stdout}.{obj|ply|stl|off|vdb|nvdb}", "list of files or the output stream, e.g. file.vdb or stdin.vdb. Note that \"files=\" is optional since any argument without the \"=\" character is intrepreted as a file and appended to \"files\"."},
      {"geo", "0", "0|1...", "geometry to write (defaults to \"0\" which is the latest)."},
      {"vdb", "*", "0,1,...", "list of VDB grids to write (defaults to \"*\", i.e. all available grids)."},
-     {"keep", "", "1|0|true|false", "toggle wether to preserved or deleted geometry and grids after they have been written."},
+     {"keep", "", "1|0|true|false", "toggle whether to preserved or deleted geometry and grids after they have been written."},
      {"codec", "", "none|zip|blosc|active", "compression codec for the file or stream"},
      {"bits", "32", "32|16|8|4|N", "bit-width of floating point numbers during quantization of VDB and NanoVDB grids, i.e. 32 is full, 16, is half (defaults to 32). NanoVDB also supports 8, 4 and N which is adaptive bit-width"},// VDB: 32, 16 + for NVDB 8, 4 or N
      {"dither", "false", "1|0|true|false", "toggle dithering of quantized NanoVDB grids (disabled by default)"},
@@ -413,7 +413,7 @@ void Tool::init()
      {"width", "", "3.0", "half-width in voxel units of the output narrow-band level set (defaults to 3 units on either side of the zero-crossing)"},
      {"geo", "0", "0", "age (i.e. stack index) of the geometry to be processed. Defaults to 0, i.e. most recently inserted geometry."},
      {"vdb", "-1", "0", "age (i.e. stack index) of reference grid used to define the transform. Defaults to -1, i.e. disabled. If specified this option takes precedence over \"dim\" and \"voxel\"!"},
-     {"keep", "", "1|0|true|false", "toggle wether the input geometry is preserved or deleted after the conversion"},
+     {"keep", "", "1|0|true|false", "toggle whether the input geometry is preserved or deleted after the conversion"},
      {"name", "", "mesh2ls_input", "specify the name of the resulting vdb (by default it's derived from the input geometry)"}},
      [&](){mParser.setDefaults();}, [&](){this->meshToLevelSet();});
 
@@ -424,14 +424,14 @@ void Tool::init()
      {"vdb", "0", "0", "age (i.e. stack index) of the level set VDB grid to be meshed. Defaults to 0, i.e. most recently inserted VDB."},
      {"mask","-1", "1", "age (i.e. stack index) of the level set VDB grid used as a surface mask during meshing. Defaults to -1, i.e. it's disabled."},
      {"invert", "false", "1|0|true|false", "boolean toggle to mesh the complement of the mask. Defaults to false and ignored if no mask is specified."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing. The mask is never removed!"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing. The mask is never removed!"},
      {"name", "", "ls2mesh_input", "specify the name of the resulting vdb (by default it's derived from the input VDB)"}},
      [&](){mParser.setDefaults();}, [&](){this->levelSetToMesh();});
 
   mParser.addAction(
       "ls2fog", "l2f", "Convert a level set VDB into a VDB with a fog volume, i.e. normalized density.",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
      {"name", "", "ls2fog_input", "specify the name of the resulting VDB (by default it's derived from the input VDB)"}},
      [&](){mParser.setDefaults();}, [&](){this->levelSetToFog();});
 
@@ -442,7 +442,7 @@ void Tool::init()
      {"width", "", "3.0", "half-width in voxel units of the output narrow-band level set (defaults to 3 units on either side of the zero-crossing)"},
      {"radius", "2.0", "2.0", "radius in voxel units of the input points"},
      {"geo", "0", "0", "age (i.e. stack index) of the geometry to be processed. Defaults to 0, i.e. most recently inserted geometry."},
-     {"keep", "", "1|0|true|false", "toggle wether the input points are preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input points are preserved or deleted after the processing"},
      {"name", "", "points2ls_input", "specify the name of the resulting VDB (by default it's derived from the input points)"}},
      [&](){mParser.setDefaults();}, [&](){this->particlesToLevelSet();});
 
@@ -452,14 +452,14 @@ void Tool::init()
      {"iso", "0.0", "0.0", "value of the iso-surface from which to compute the level set"},
      {"voxel", "", "0.0", "voxel size in world units (defaults to zero, i.e the transform out the output matches the input)"},
      {"width", "", "3.0", "half-width in voxel units of the output narrow-band level set (defaults to 3 units on either side of the zero-crossing)"},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
      {"name", "", "iso2ls_input", "specify the name of the resulting VDB (by default it's derived from the input VDB)"}},
      [&](){mParser.setDefaults();}, [&](){this->isoToLevelSet();});
 
   mParser.addAction(
       "points2vdb", "p2v", "Encode geometry points into a VDB grid",
     {{"geo", "0", "0", "age (i.e. stack index) of the geometry to be processed. Defaults to 0, i.e. most recently inserted geometry."},
-     {"keep", "", "1|0|true|false", "toggle wether the input points are preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input points are preserved or deleted after the processing"},
      {"ppv", "8", "8", "the number of points per voxel in the output VDB grid (defaults to 8)"},
      {"bits", "16", "16|8|32", "the number of bits used to represent a single point in the VDB grid (defaults to 16, i.e. half precision)"},
      {"name", "", "points_2vdb_input", "specify the name of the resulting VDB (by default it's derived from the input geometry)"}},
@@ -468,7 +468,7 @@ void Tool::init()
   mParser.addAction(
       "vdb2points", "v2p", "Extract points encoded in a VDB to points in a geometry format",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
      {"name", "", "vdb2points_input", "specify the name of the resulting points (by default it's derived from the input VDB)"}},
      [&](){mParser.setDefaults();}, [&](){this->vdbToPoints();});
 
@@ -478,7 +478,7 @@ void Tool::init()
      {"density", "0.0", "0.0", "uniform density of points per active voxel (disabled by default)"},
      {"ppv", "8", "8", "number of points per active voxel (defaults to 8)"},
      {"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be scatter points into. Defaults to 0, i.e. most recently inserted VDB"},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
      {"name", "", "scatter_input", "specify the name of the resulting points (by default it's derived from the input VDB)"}},
      [&](){mParser.setDefaults();}, [&](){this->scatter();});
 
@@ -499,7 +499,7 @@ void Tool::init()
      {"scale", "1.0", "1.0", "defined the scale of the Enright velocity field"},
      {"dt", "0.05", "0.05", "time-step the input level set is advected"},
      {"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->enright();});
 
   mParser.addAction(
@@ -564,86 +564,86 @@ void Tool::init()
   mParser.addAction(
       "cpt", "", "generate a vector grid with the closest-point-transform to a level set surface",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->compute();});
 
   mParser.addAction(
       "div", "", "generate a scalar grid with the divergence of a vector grid",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->compute();});
 
   mParser.addAction(
       "curl", "", "generate a vector grid with the curl of another vector grid",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->compute();});
 
   mParser.addAction(
       "grad", "", "generate a vector grid with the gradient of a scalar grid",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->compute();});
 
   mParser.addAction(
       "curvature", "", "generate scalar grid with the mean curvature of a level set surface",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->compute();});
 
   mParser.addAction(
       "length", "", "generate a scalar grid with the magnitude of a vector grid",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->compute();});
 
   mParser.addAction(
       "union", "", "CSG union of two level sets surfaces",
     {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to union. Defaults to 0,1, i.e. two most recently inserted VDBs."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
-     {"prune", "true", "true", "toggle wether to prune the tree after the boolean operation (enabled by default)"},
-     {"rebuild", "true", "true", "toggle wether to re-build the level set after the boolean operation (enabled by default)"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
+     {"prune", "true", "true", "toggle whether to prune the tree after the boolean operation (enabled by default)"},
+     {"rebuild", "true", "true", "toggle whether to re-build the level set after the boolean operation (enabled by default)"}},
      [&](){mParser.setDefaults();}, [&](){this->csg();});
 
   mParser.addAction(
       "intersection", "", "CSG intersection of two level sets surfaces",
     {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to intersect. Defaults to 0,1, i.e. two most recently inserted VDBs."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
-     {"prune", "true", "true", "toggle wether to prune the tree after the boolean operation (enabled by default)"},
-     {"rebuild", "true", "true", "toggle wether to re-build the level set after the boolean operation (enabled by default)"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
+     {"prune", "true", "true", "toggle whether to prune the tree after the boolean operation (enabled by default)"},
+     {"rebuild", "true", "true", "toggle whether to re-build the level set after the boolean operation (enabled by default)"}},
      [&](){mParser.setDefaults();}, [&](){this->csg();});
 
   mParser.addAction(
       "difference", "", "CSG difference of two level sets surfaces",
     {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to difference. Defaults to 0,1, i.e. two most recently inserted VDBs."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
-     {"prune", "true", "true", "toggle wether to prune the tree after the boolean operation (enabled by default)"},
-     {"rebuild", "true",  "true", "toggle wether to re-build the level set after the boolean operation (enabled by default)"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
+     {"prune", "true", "true", "toggle whether to prune the tree after the boolean operation (enabled by default)"},
+     {"rebuild", "true",  "true", "toggle whether to re-build the level set after the boolean operation (enabled by default)"}},
      [&](){mParser.setDefaults();}, [&](){this->csg();});
 
   mParser.addAction(
       "min", "", "Given grids A and B, compute min(a, b) per voxel",
-    {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to composit. Defaults to 0,1, i.e. two most recently inserted VDBs."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDBs is preserved or deleted after the processing"}},
+    {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to composite. Defaults to 0,1, i.e. two most recently inserted VDBs."},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDBs is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->composite();});
 
   mParser.addAction(
       "max", "", "Given grids A and B, compute max(a, b) per voxel",
-    {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to composit. Defaults to 0,1, i.e. two most recently inserted VDBs."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDBs is preserved or deleted after the processing"}},
+    {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to composite. Defaults to 0,1, i.e. two most recently inserted VDBs."},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDBs is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->composite();});
 
   mParser.addAction(
       "sum", "", "Given grids A and B, compute sum(a, b) per voxel",
-    {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to composit. Defaults to 0,1, i.e. two most recently inserted VDBs."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDBs is preserved or deleted after the processing"}},
+    {{"vdb", "0,1", "0,1", "ages (i.e. stack indices) of the two VDB grids to composite. Defaults to 0,1, i.e. two most recently inserted VDBs."},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDBs is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->composite();});
 
   mParser.addAction(
       "multires", "", "construct a LoD sequences of VDB trees with powers of two refinements",
     {{"levels", "2", "2", "number of multi-resolution grids in the output LoD sequence"},
      {"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->multires();});
 
   mParser.addAction(
@@ -652,13 +652,13 @@ void Tool::init()
      {"scale", "0", "0", "scale use to transform the input grid (ignored if two grids are specified with vdb)"},
      {"translate", "(0,0,0)", "(0,0,0)", "translation use to transform the input grid (ignored if two grids are specified with vdb)"},
      {"order", "1", "1", "order of the polynomial interpolation kernel used during resampling"},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->resample();});
 
   mParser.addAction(
       "clip", "", "Clip a VDB grid against another grid, a bbox or frustum",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"},
      {"bbox", "", "(0,0,0),(1,1,1)", "min and max of the world-space bounding-box used for clipping. Defaults to empty, i.e. disabled"},
      {"taper", "-1", "1", "taper of the frustum (requires bbox and depth to be specified). Defaults to -1, i.e. disabled"},
      {"depth", "-1", "1", "depth in world units of the frustum (requires bbox and taper to be specified). Defaults to -1, i.e. disabled"},
@@ -680,13 +680,13 @@ void Tool::init()
     {{"dilate", "1", "1", "number of integer voxels that the narrow band of the input SDF will be dilated"},
      {"iter", "1", "1", "number of iterations of the fast sweeping algorithm (each using 8 sweeps)"},
      {"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->expandLevelSet();});
 
   mParser.addAction(
       "segment", "", "segment an input VDB into a list if topologically disconnected VDB grids",
     {{"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the processing"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the processing"}},
      [&](){mParser.setDefaults();}, [&](){this->segment();});
 
   mParser.addAction(
@@ -696,14 +696,14 @@ void Tool::init()
      {"scale", "1.0", "1.0", "uniform scaling in world units"},
      {"vdb", "", "0,2,..", "age (i.e. stack index) of the VDB grid to be processed. Defaults to empty."},
      {"geo", "", "0,2,..", "age (i.e. stack index) of the Geometry to be processed. Defaults to empty."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or overwritten"}},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or overwritten"}},
      [&](){mParser.setDefaults();}, [&](){this->transform();});
 
   mParser.addAction(
       "render", "", "ray-tracing of level set surfaces and volume rendering of fog volumes",
     {{"files", "", "output.{jpg|png|ppm|exr}", "file used to save the rendered image to disk"},
      {"vdb", "0", "0", "age (i.e. stack index) of the VDB grid to be processed. Defaults to 0, i.e. most recently inserted VDB."},
-     {"keep", "", "1|0|true|false", "toggle wether the input VDB is preserved or deleted after the rendering"},
+     {"keep", "", "1|0|true|false", "toggle whether the input VDB is preserved or deleted after the rendering"},
      {"camera", "perspective", "persp|ortho", "perspective or orthographic camera"},
      {"aperture", "41.2136", "41.2136", "width in mm of the frame of a perspective camera, i.e., the visible field (defaults to 41.2136mm)"},
      {"focal", "50", "50", "focal length of a perspective camera in mm (defaults to 50mm)"},
@@ -2474,8 +2474,8 @@ GridBase::Ptr Tool::clip(const VecF &v, int age, const GridType &input)
     BBoxd bbox(Vec3T(v[0],v[1],v[2]), Vec3T(v[3],v[4],v[5]));
     output = tools::clip(input, bbox);
     break;
-  } case 8: {// clip against a frustrum
-  if (age>=0) throw std::invalid_argument("clip: both mask and frustrum were specified");
+  } case 8: {// clip against a frustum
+  if (age>=0) throw std::invalid_argument("clip: both mask and frustum were specified");
     BBoxd bbox(Vec3T(v[0],v[1],v[2]), Vec3T(v[3],v[4],v[5]));
     math::NonlinearFrustumMap frustum(bbox,v[6],v[7]);
     output = tools::clip(input, frustum);
diff --git a/openvdb_cmd/vdb_view/RenderModules.cc b/openvdb_cmd/vdb_view/RenderModules.cc
index 74ba5eb8dc..9844299da1 100644
--- a/openvdb_cmd/vdb_view/RenderModules.cc
+++ b/openvdb_cmd/vdb_view/RenderModules.cc
@@ -557,7 +557,7 @@ ViewportModule::render()
     GLfloat modelview[16];
     glGetFloatv(GL_MODELVIEW_MATRIX, &modelview[0]);
 
-    // Stash current viewport settigs.
+    // Stash current viewport settings.
     GLint viewport[4];
     glGetIntegerv(GL_VIEWPORT, &viewport[0]);
 
diff --git a/openvdb_houdini/openvdb_houdini/AXUtils.h b/openvdb_houdini/openvdb_houdini/AXUtils.h
index ebbff04088..c37727be04 100644
--- a/openvdb_houdini/openvdb_houdini/AXUtils.h
+++ b/openvdb_houdini/openvdb_houdini/AXUtils.h
@@ -226,7 +226,7 @@ struct ConvertFromVEX :
         return true;
     }
 
-    /// @brief  Convert Houdini instrinsic volume attribute read accesses
+    /// @brief  Convert Houdini intrinsic volume attribute read accesses
     /// @param  node  The AttributeValue AST node being visited
     bool visit(openvdb::ax::ast::Attribute* node)
     {
diff --git a/openvdb_houdini/openvdb_houdini/AttributeTransferUtil.h b/openvdb_houdini/openvdb_houdini/AttributeTransferUtil.h
index 387b3b260d..5eb299af0e 100644
--- a/openvdb_houdini/openvdb_houdini/AttributeTransferUtil.h
+++ b/openvdb_houdini/openvdb_houdini/AttributeTransferUtil.h
@@ -650,7 +650,7 @@ MeshAttrTransfer::operator()(IterRange &range) const
 
             const GA_Size vtxn = primRef->getVertexCount();
 
-            // Get vertex and point offests
+            // Get vertex and point offsets
             for (GA_Size vtx = 0; vtx < vtxn; ++vtx) {
                 const GA_Offset vtxoff = primRef->getVertexOffset(vtx);
                 ptnOffsetList[vtx] = mMeshGdp.vertexPoint(vtxoff);
diff --git a/openvdb_houdini/openvdb_houdini/CMakeLists.txt b/openvdb_houdini/openvdb_houdini/CMakeLists.txt
index 204a153f9c..6e1ba51a33 100644
--- a/openvdb_houdini/openvdb_houdini/CMakeLists.txt
+++ b/openvdb_houdini/openvdb_houdini/CMakeLists.txt
@@ -52,7 +52,7 @@ houdini_get_default_install_dir():
   Windows: $ENV{HOMEDRIVE}$ENV{HOMEPATH}\Documents\houdiniX.X
 If OFF, CMAKE_INSTALL_PREFIX is used.]=] ON)
 option(OPENVDB_INSTALL_HOUDINI_PYTHONRC [=[Install a Houdini startup script that sets
-the visibilty of OpenVDB nodes and their native equivalents.]=] OFF)
+the visibility of OpenVDB nodes and their native equivalents.]=] OFF)
 
 set(_OPENVDB_HOUDINI_OPHIDE_POLICY_OPTIONS none aswf native)
 if(NOT OPENVDB_HOUDINI_OPHIDE_POLICY)
@@ -311,7 +311,7 @@ foreach(DSO_NAME ${OPENVDB_DSO_NAMES})
   endif()
 
   # Call houdini_configure_target to setup the sesi tag information. We set
-  # INSTDIR to the project build directory and configure the actuall install
+  # INSTDIR to the project build directory and configure the actual install
   # paths ourselves (otherwise cmake will configure the build to build directly
   # to the install dir)
 
diff --git a/openvdb_houdini/openvdb_houdini/ParmFactory.h b/openvdb_houdini/openvdb_houdini/ParmFactory.h
index 01abda8e2a..bf34d60d11 100644
--- a/openvdb_houdini/openvdb_houdini/ParmFactory.h
+++ b/openvdb_houdini/openvdb_houdini/ParmFactory.h
@@ -544,7 +544,7 @@ class OPENVDB_HOUDINI_API OpPolicy
     /// factory.@link OpFactory::english() english()@endlink.
     virtual std::string getLabelName(const OpFactory&);
 
-    /// @brief Return the inital default name of the operator.
+    /// @brief Return the initial default name of the operator.
     /// @note An empty first name will disable, reverting to the usual rules.
     virtual std::string getFirstName(const OpFactory&) { return ""; }
 
diff --git a/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc b/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc
index 7aaad72278..bdc01ac1fd 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc
@@ -114,7 +114,7 @@ struct LockedInfoTextRegistry
 // Declare this at file scope to ensure thread-safe initialization
 static std::mutex theInitInfoTextRegistryMutex;
 
-// Global function for accessing the regsitry
+// Global function for accessing the registry
 static LockedInfoTextRegistry*
 getInfoTextRegistry()
 {
diff --git a/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.h b/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.h
index 3ad09ade51..3bca3e7c78 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.h
+++ b/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.h
@@ -134,14 +134,14 @@ class OPENVDB_HOUDINI_API SOP_NodeVDB: public SOP_Node
     /// @param gdh      handle to manage input locking
     /// @param clean    (forwarded to duplicateSource())
     ///
-    /// @note Prior to Houdini 13.0, this method peforms a duplicateSource() and unlocks the
+    /// @note Prior to Houdini 13.0, this method performs a duplicateSource() and unlocks the
     /// inputs to the SOP. From Houdini 13.0 on, this method will insert the existing data
     /// into the detail and update the detail handle in the SOP.
     ///
     /// @warning No attempt to call duplicateSource() or inputGeo() should be made after
     /// calling this method, as there will be no data on the input stream if isSourceStealable()
     /// returns @c true.
-    /// @deprecated     verbification renders this redundant
+    /// @deprecated     verification renders this redundant
     [[deprecated]]
     OP_ERROR duplicateSourceStealable(const unsigned index,
         OP_Context& context, GU_Detail **pgdp, GU_DetailHandle& gdh, bool clean = true);
@@ -157,13 +157,13 @@ class OPENVDB_HOUDINI_API SOP_NodeVDB: public SOP_Node
     /// this method falls back to copying the shared pointer, effectively performing
     /// a duplicateSource().
     ///
-    /// @note Prior to Houdini 13.0, this method peforms a duplicateSource() and unlocks the
+    /// @note Prior to Houdini 13.0, this method performs a duplicateSource() and unlocks the
     /// inputs to the SOP. From Houdini 13.0 on, this method will insert the existing data
     /// into the detail and update the detail handle in the SOP.
     ///
     /// @param index    the index of the input from which to perform this operation
     /// @param context  the current SOP context is used for cook time for network traversal
-    /// @deprecated     verbification renders this redundant
+    /// @deprecated     verification renders this redundant
     [[deprecated]]
     OP_ERROR duplicateSourceStealable(const unsigned index, OP_Context& context);
 
@@ -173,13 +173,13 @@ class OPENVDB_HOUDINI_API SOP_NodeVDB: public SOP_Node
     /// @brief Traverse the upstream network to determine if the source input can be stolen.
     ///
     /// An upstream SOP cannot be stolen if it is implicitly caching the data (no "unload" flag)
-    /// or explictly caching the data (using a Cache SOP)
+    /// or explicitly caching the data (using a Cache SOP)
     ///
     /// The traversal ignores pass through nodes such as null SOPs and bypassing.
     ///
     /// @param index    the index of the input from which to perform this operation
     /// @param context  the current SOP context is used for cook time for network traversal
-    /// @deprecated     verbification renders this redundant
+    /// @deprecated     verification renders this redundant
     [[deprecated]]
     bool isSourceStealable(const unsigned index, OP_Context& context) const;
 }; // class SOP_NodeVDB
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_AX.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_AX.cc
index f77803503a..43e352639e 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_AX.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_AX.cc
@@ -1326,7 +1326,7 @@ SOP_OpenVDB_AX::Cache::evaluateExternalExpressions(const double time,
         //        in this case return a vector filled with the single value.
         //        for example, if p = 1, return (1,1,1)
         //
-        //  -5) chramp(p) - as ramps are alwyas multi parms, we don't  have
+        //  -5) chramp(p) - as ramps are always multi parms, we don't  have
         //        to consider the case where it could be a channel
 
         const bool isCHRampLookup(type == "ramp");
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Activate.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Activate.cc
index c9ae6a40fe..3462984634 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Activate.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Activate.cc
@@ -167,7 +167,7 @@ initialized to a constant value.  This will be done to all voxels that are
 made active by the specification - including those that were already
 active.
 
-Thus, the Voxel Coordinats option will have the effect of setting a cube
+Thus, the Voxel Coordinates option will have the effect of setting a cube
 area to a constant value.)"));
 
     // Match REGIONTYPE
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Create.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Create.cc
index 173f1f7d7c..ce6ce16fc7 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Create.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Create.cc
@@ -585,7 +585,7 @@ SOP_OpenVDB_Create::updateParmsFlags()
             eType = TYPE_VEC3S;
         }
 
-        /// Disbale unused bg value options
+        /// Disable unused bg value options
         changed |= enableParmInst("bgFloat#", &i,
             !isLevelSet && (eType == TYPE_FLOAT || eType == TYPE_DOUBLE));
         changed |= enableParmInst("width#",   &i, isLevelSet);
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Filter_Level_Set.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Filter_Level_Set.cc
index 79da2d1666..1827bf017a 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Filter_Level_Set.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Filter_Level_Set.cc
@@ -835,7 +835,7 @@ SOP_OpenVDB_Filter_Level_Set::Cache::cookVDBSop(
                 continue;
             }
 
-            // Appply filters
+            // Apply filters
 
             bool wasFiltered = applyFilters<openvdb::FloatGrid>(
                 *it, filterParms, boss.interrupter(), context, *gdp, verbose);
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_From_Polygons.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_From_Polygons.cc
index f1458cc7fa..dcf67df6ef 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_From_Polygons.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_From_Polygons.cc
@@ -5,7 +5,7 @@
 ///
 /// @author FX R&D OpenVDB team
 ///
-/// @brief Converts a closed mesh of trinagles and/or quads into different VDB volumes.
+/// @brief Converts a closed mesh of triangles and/or quads into different VDB volumes.
 /// The supported volumes are: Signed distance field / level-set, closest primitive grid
 /// and grids with different mesh attributes (closest UVW, Normal etc.)
 
@@ -693,7 +693,7 @@ SOP_OpenVDB_From_Polygons::updateParmsFlags()
     changed |= enableParm("fogname", bool(evalInt("buildfog", 0, time)) && !unsignedDist);
     changed |= enableParm("buildfog", !unsignedDist);
 
-    // enable / diable vector type menu
+    // enable / disable vector type menu
     UT_String attrStr, attrName;
     GA_ROAttributeRef attrRef;
     int attrClass = POINT_ATTR;
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Noise.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Noise.cc
index fbd99c6f20..e41c366e23 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Noise.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Noise.cc
@@ -348,8 +348,8 @@ SOP_OpenVDB_Noise::Cache::applyNoise(
     float noise, alpha;
 
     // The use of the GenericMap is a performance compromise
-    // because the GenericMap holdds a base class pointer.
-    // This should be optimized by resolving the acutal map type
+    // because the GenericMap holds a base class pointer.
+    // This should be optimized by resolving the actual map type
     cvdb::math::GenericMap map(grid);
 
     if (!mask) {
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Points_Convert.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Points_Convert.cc
index 800ea0e636..8da374b766 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Points_Convert.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Points_Convert.cc
@@ -325,7 +325,7 @@ To Match Reference VDB:\n\
 
     parms.add(hutil::ParmFactory(PRM_HEADING, "transferheading", "Attribute Transfer"));
 
-     // Mode. Either convert all or convert specifc attributes
+     // Mode. Either convert all or convert specific attributes
     parms.add(hutil::ParmFactory(PRM_ORD, "mode", "Mode")
         .setDefault(PRMzeroDefaults)
         .setTooltip("Whether to transfer only specific attributes or all attributes found")
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Potential_Flow.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Potential_Flow.cc
index 5fb25e046d..1fc89f53c2 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Potential_Flow.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Potential_Flow.cc
@@ -239,7 +239,7 @@ newSopOperator(OP_OperatorTable* table)
     " The simplest workflow for multiple moving objects is to animate the polygonal geometry and"
     " then create SDFs and velocity VDBs by using the VDB from Polygons node."
     " The output can be fed directly into the first input of the Potential Flow SOP."
-    " The second input of the SOP allows a Mask VDB input for modifiying the solution domain"
+    " The second input of the SOP allows a Mask VDB input for modifying the solution domain"
     " created by the Potential Flow SOP."
     " The created domain can either be restricted to the active voxels of the Mask VDB, or"
     " restricted from creating a domain inside the active voxels."
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc
index 9276832c5f..112406be32 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc
@@ -1094,7 +1094,7 @@ struct ConstructCandidateVoxelMask
 
 /// Inactivates candidate leafnodes that have no particle overlap.
 /// (The ConstructCandidateVoxelMask scheme is overestimating the region
-///  of intrest when frustum transforms are used, this culls the regions.)
+///  of interest when frustum transforms are used, this culls the regions.)
 template <typename MaskLeafNodeType>
 struct CullFrustumLeafNodes
 {
diff --git a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Sample_Points.cc b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Sample_Points.cc
index d22eaced62..e035095142 100644
--- a/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Sample_Points.cc
+++ b/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Sample_Points.cc
@@ -454,7 +454,7 @@ SOP_OpenVDB_Sample_Points::Cache::cookVDBSop(OP_Context& context)
 
         // sanity checks - warn if there are no points on first input port.  Note that
         // each VDB primitive should have a single point associated with it so that we could
-        // theoretically only check if nPoints == 0, but we explictly check for 0 pointGrids
+        // theoretically only check if nPoints == 0, but we explicitly check for 0 pointGrids
         // for the sake of clarity
         if (nPoints == 0 && pointGrids.empty()) {
             const std::string msg = "Input 1 contains no points.";
diff --git a/openvdb_houdini/openvdb_houdini/reference/GU_PrimVDB.cc b/openvdb_houdini/openvdb_houdini/reference/GU_PrimVDB.cc
index 78509a12d2..ca05a9a42c 100644
--- a/openvdb_houdini/openvdb_houdini/reference/GU_PrimVDB.cc
+++ b/openvdb_houdini/openvdb_houdini/reference/GU_PrimVDB.cc
@@ -543,7 +543,7 @@ GU_PrimVDB::registerMyself(GA_PrimitiveFactory *factory)
     theDefinition->setMergeConstructor(&gaPrimitiveMergeConstructor);
     registerIntrinsics(*theDefinition);
 
-    // Register the GT tesselation too (now we know what type id we have)
+    // Register the GT tessellation too (now we know what type id we have)
     openvdb_houdini::GT_GEOPrimCollectVDB::registerPrimitive(theDefinition->getId());
 }
 #endif
diff --git a/openvdb_maya/openvdb_maya/AEOpenVDBToPolygonsTemplate.mel b/openvdb_maya/openvdb_maya/AEOpenVDBToPolygonsTemplate.mel
index a22f737da0..fb79cd1361 100644
--- a/openvdb_maya/openvdb_maya/AEOpenVDBToPolygonsTemplate.mel
+++ b/openvdb_maya/openvdb_maya/AEOpenVDBToPolygonsTemplate.mel
@@ -53,7 +53,7 @@ global proc replaceOpenVDBToPolygonsGridSelection(string $attr)
         for ($name in $gridNames) menuItem -l $name -parent vdbGridNameMenu;
     }
 
-    /// @todo re-select previous item if it exists, don't update VdbSelectedGridNames if the same item is selectd.
+    /// @todo re-select previous item if it exists, don't update VdbSelectedGridNames if the same item is selected.
 }
 
 global proc updateOpenVDBToPolygonsGridSelection(string $attr)
diff --git a/openvdb_maya/openvdb_maya/AEOpenVDBVisualizeTemplate.mel b/openvdb_maya/openvdb_maya/AEOpenVDBVisualizeTemplate.mel
index 995a07c190..0e0c7e17bd 100644
--- a/openvdb_maya/openvdb_maya/AEOpenVDBVisualizeTemplate.mel
+++ b/openvdb_maya/openvdb_maya/AEOpenVDBVisualizeTemplate.mel
@@ -64,7 +64,7 @@ global proc replaceOpenVDBVisualizeGridSelection(string $attr)
         for ($name in $gridNames) menuItem -l $name -parent vdbGridNameMenu;
     }
 
-    /// @todo re-select previous item if it exists, don't update VdbSelectedGridNames if the same item is selectd.
+    /// @todo re-select previous item if it exists, don't update VdbSelectedGridNames if the same item is selected.
 }
 
 global proc updateOpenVDBVisualizeGridSelection(string $attr)
diff --git a/openvdb_wolfram/OpenVDBLink/LTemplate/IncludeFiles/LTemplate.inc b/openvdb_wolfram/OpenVDBLink/LTemplate/IncludeFiles/LTemplate.inc
index 48880b2e09..7968261cfa 100644
--- a/openvdb_wolfram/OpenVDBLink/LTemplate/IncludeFiles/LTemplate.inc
+++ b/openvdb_wolfram/OpenVDBLink/LTemplate/IncludeFiles/LTemplate.inc
@@ -58,9 +58,9 @@ namespace detail { // private
 std::ostream mout(&detail::mbuf);
 
 
-// It would be natural for fatal_error() to take a messae argument that will be printed before returning.
+// It would be natural for fatal_error() to take a message argument that will be printed before returning.
 // However, that would create an incentive to construct a string object that would need to be freed.
-// longjmp() prevents calls to desctructors, thus freeing the string would be complicated.
+// longjmp() prevents calls to destructors, thus freeing the string would be complicated.
 void fatal_error() {
     std::longjmp(detail::jmpbuf, 1);
 }
diff --git a/openvdb_wolfram/OpenVDBLink/Messages.m b/openvdb_wolfram/OpenVDBLink/Messages.m
index ae32998e96..b9d64b0f85 100755
--- a/openvdb_wolfram/OpenVDBLink/Messages.m
+++ b/openvdb_wolfram/OpenVDBLink/Messages.m
@@ -410,7 +410,7 @@
 (*Messages*)
 
 
-General::bbox2d = "`1` does not represent valid 2D bunding box.";
+General::bbox2d = "`1` does not represent valid 2D bounding box.";
 
 
 (* ::Subsection::Closed:: *)
@@ -439,7 +439,7 @@
 (*Messages*)
 
 
-General::bbox3d = "`1` does not represent valid 3D bunding box.";
+General::bbox3d = "`1` does not represent valid 3D bounding box.";
 
 
 (* ::Section:: *)
diff --git a/openvdb_wolfram/OpenVDBLink/Readme.md b/openvdb_wolfram/OpenVDBLink/Readme.md
index 4857b1766d..018b948b3b 100644
--- a/openvdb_wolfram/OpenVDBLink/Readme.md
+++ b/openvdb_wolfram/OpenVDBLink/Readme.md
@@ -52,7 +52,7 @@ Compiling library code ...
 
 If compilation fails, you may need to add any include/link paths that are not currently in your path environment. These can be added in `BuildSettings.m`.
 
-* For example on MacOS one may need to explictly add include and link paths like `-I/usr/local/include` in the `"CompileOptions"` field in the `"MacOSX"` area.
+* For example on MacOS one may need to explicitly add include and link paths like `-I/usr/local/include` in the `"CompileOptions"` field in the `"MacOSX"` area.
 * On Windows `$vcpkgDir` might need to be changed if `vcpkg` is not in `$HomeDirectory`.
 
 Once these are set, reload and then recompile. Below the input `True` is optional and tells the system to print the compile command as well as any warnings or errors during compile:
