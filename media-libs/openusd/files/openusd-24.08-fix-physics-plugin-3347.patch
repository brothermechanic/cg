From 5985327fcc722e637777a82df4386cbeb45e4037 Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Fri, 4 Oct 2024 17:32:02 +0200
Subject: [PATCH 1/8] Physics parsing utilities

---
 pxr/usd/usdPhysics/CMakeLists.txt             |   15 +-
 pxr/usd/usdPhysics/module.cpp                 |    1 +
 pxr/usd/usdPhysics/parseDesc.h                |  812 +++++
 pxr/usd/usdPhysics/parsePrimIterator.h        |  274 ++
 pxr/usd/usdPhysics/parseUtils.cpp             | 2904 +++++++++++++++++
 pxr/usd/usdPhysics/parseUtils.h               |   88 +
 pxr/usd/usdPhysics/parsingUtils.dox           |  412 +++
 .../testenv/testUsdPhysicsParsing.py          | 1284 ++++++++
 pxr/usd/usdPhysics/wrapParseUtils.cpp         | 1178 +++++++
 9 files changed, 6967 insertions(+), 1 deletion(-)
 create mode 100644 pxr/usd/usdPhysics/parseDesc.h
 create mode 100644 pxr/usd/usdPhysics/parsePrimIterator.h
 create mode 100644 pxr/usd/usdPhysics/parseUtils.cpp
 create mode 100644 pxr/usd/usdPhysics/parseUtils.h
 create mode 100644 pxr/usd/usdPhysics/parsingUtils.dox
 create mode 100644 pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
 create mode 100644 pxr/usd/usdPhysics/wrapParseUtils.cpp

diff --git a/pxr/usd/usdPhysics/CMakeLists.txt b/pxr/usd/usdPhysics/CMakeLists.txt
index 936ea51993..74f38456fc 100644
--- a/pxr/usd/usdPhysics/CMakeLists.txt
+++ b/pxr/usd/usdPhysics/CMakeLists.txt
@@ -21,22 +21,28 @@ pxr_library(usdPhysics
 
     PUBLIC_CLASSES
         metrics
+        parseUtils
         
     PUBLIC_HEADERS
         api.h
         massProperties.h
+        parseUtils.h
+        parseDesc.h
+        parsePrimIterator.h
 
     PYTHON_CPPFILES
         moduleDeps.cpp
 
     PYMODULE_CPPFILES
         wrapMetrics.cpp
+        wrapParseUtils.cpp
 
     PYMODULE_FILES
         __init__.py
 
     DOXYGEN_FILES
-        overview.dox        
+        overview.dox
+        parsingUtils.dox        
         examples/usdPhysicsBoxOnBox.usda
         examples/usdPhysicsBoxOnQuad.usda
         examples/usdPhysicsDistanceJoint.usda
@@ -50,6 +56,7 @@ pxr_test_scripts(
     testenv/testUsdPhysicsMetrics.py
     testenv/testUsdPhysicsRigidBodyAPI.py
     testenv/testUsdPhysicsCollisionGroupAPI.py
+    testenv/testUsdPhysicsParsing.py
 )
 
 pxr_register_test(testUsdPhysicsMetrics
@@ -69,3 +76,9 @@ pxr_register_test(testUsdPhysicsCollisionGroupAPI
     COMMAND "${CMAKE_INSTALL_PREFIX}/tests/testUsdPhysicsCollisionGroupAPI"
     EXPECTED_RETURN_CODE 0
 )
+
+pxr_register_test(testUsdPhysicsCollisitestUsdPhysicsParsingonGroupAPI
+    PYTHON
+    COMMAND "${CMAKE_INSTALL_PREFIX}/tests/testUsdPhysicsParsing"
+    EXPECTED_RETURN_CODE 0
+)
diff --git a/pxr/usd/usdPhysics/module.cpp b/pxr/usd/usdPhysics/module.cpp
index 9bf14f1cd9..d176c3aff4 100644
--- a/pxr/usd/usdPhysics/module.cpp
+++ b/pxr/usd/usdPhysics/module.cpp
@@ -19,6 +19,7 @@ PXR_NAMESPACE_USING_DIRECTIVE
 TF_WRAP_MODULE
 {
 	TF_WRAP(Metrics);
+    TF_WRAP(ParseUtils);
 
     // Generated Schema classes.  Do not remove or edit the following line.
     #include "generatedSchema.module.h"
diff --git a/pxr/usd/usdPhysics/parseDesc.h b/pxr/usd/usdPhysics/parseDesc.h
new file mode 100644
index 0000000000..12897fb9d8
--- /dev/null
+++ b/pxr/usd/usdPhysics/parseDesc.h
@@ -0,0 +1,812 @@
+//
+// Copyright 2016 Pixar
+//
+// Licensed under the Apache License, Version 2.0 (the "Apache License")
+// with the following modification; you may not use this file except in
+// compliance with the Apache License and the following modification to it:
+// Section 6. Trademarks. is deleted and replaced with:
+//
+// 6. Trademarks. This License does not grant permission to use the trade
+//    names, trademarks, service marks, or product names of the Licensor
+//    and its affiliates, except as required to comply with Section 4(c) of
+//    the License and to reproduce the content of the NOTICE file.
+//
+// You may obtain a copy of the Apache License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the Apache License with the above modification is
+// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied. See the Apache License for the specific
+// language governing permissions and limitations under the Apache License.
+//
+#ifndef USDPHYSICS_PARSE_DESC_H
+#define USDPHYSICS_PARSE_DESC_H
+
+/// \file usdPhysics/parseDesc.h
+
+#include "pxr/pxr.h"
+#include "pxr/usd/usd/prim.h"
+#include "pxr/usd/usd/collectionMembershipQuery.h"
+
+#include "pxr/base/gf/vec3f.h"
+#include "pxr/base/gf/quatf.h"
+
+PXR_NAMESPACE_OPEN_SCOPE
+
+// -------------------------------------------------------------------------- //
+// PHYSICSPARSEDESC                                                           //
+// -------------------------------------------------------------------------- //
+
+/// Sentinel value for flt max compare
+const float physicsSentinelLimit = 0.5e38f;
+
+/// \struct PhysicsObjectType
+///
+/// Physics object type structure for type enumeration
+///
+struct PhysicsObjectType
+{
+    enum Enum
+    {
+        eUndefined,
+
+        eScene,
+
+        eRigidBody,
+
+        eSphereShape,
+        eCubeShape,
+        eCapsuleShape,
+        eCylinderShape,
+        eConeShape,
+        eMeshShape,
+        ePlaneShape,
+        eCustomShape,
+        eSpherePointsShape,
+
+        eFixedJoint,
+        eRevoluteJoint,
+        ePrismaticJoint,
+        eSphericalJoint,
+        eDistanceJoint,
+        eD6Joint,
+        eCustomJoint,
+
+        eRigidBodyMaterial,
+
+        eArticulation,
+
+        eCollisionGroup,
+
+        eLast,
+    };
+};
+
+/// \struct PhysicsAxis
+///
+/// Physics axis structure for type enumeration
+///
+struct PhysicsAxis
+{
+    enum Enum
+    {
+        eX,
+        eY,
+        eZ
+    };
+};
+
+/// \struct PhysicsJointDOF
+///
+/// Physics joint degree of freedom structure for type enumeration
+///
+struct PhysicsJointDOF
+{
+    enum Enum
+    {
+        eDistance,
+        eTransX,
+        eTransY,
+        eTransZ,
+        eRotX,
+        eRotY,
+        eRotZ
+    };
+};
+
+/// \struct PhysicsObjectDesc
+///
+/// Base physics object descriptor
+///
+struct PhysicsObjectDesc
+{
+    PhysicsObjectDesc() : type(PhysicsObjectType::eUndefined), isValid(true)
+    {
+    }
+
+    virtual ~PhysicsObjectDesc()
+    {
+    }
+
+    PhysicsObjectType::Enum type;   ///< Descriptor type
+    SdfPath primPath;                ///< SdfPath for the prim from which the descriptor was parsed
+    bool isValid;                   ///< Validity of a descriptor, the parsing may succeed, but the descriptor might be not valid
+};
+
+/// \struct RigidBodyMaterialDesc
+///
+/// Rigid body material descriptor
+///
+struct RigidBodyMaterialDesc : PhysicsObjectDesc
+{
+    RigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f), restitution(0.0f), density(-1.0f)
+    {
+        type = PhysicsObjectType::eRigidBodyMaterial;
+    }
+
+    bool operator == (const RigidBodyMaterialDesc&) const
+    {
+        return false;
+    }
+
+
+    float staticFriction;       ///< Static friction
+    float dynamicFriction;      ///< Dynamic friction
+    float restitution;          ///< Restitution
+    float density;              ///< Density
+};
+
+/// \struct SceneDesc
+///
+/// Scene descriptor
+///
+struct SceneDesc : PhysicsObjectDesc
+{
+    SceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
+    {
+        type = PhysicsObjectType::eScene;
+    }
+
+    bool operator == (const SceneDesc&) const
+    {
+        return false;
+    }
+
+    GfVec3f gravityDirection;   ///< Gravity direction, if default 0,0,0 was used negative upAxis direction will be returned
+    float gravityMagnitude;     ///< Gravity magnitude, -inf means Earth gravity adjusted by metersPerUnit will be returned
+};
+
+/// \struct CollisionGroupDesc
+///
+/// Collision group descriptor
+///
+struct CollisionGroupDesc : PhysicsObjectDesc
+{
+    CollisionGroupDesc()
+    {
+        type = PhysicsObjectType::eCollisionGroup;
+    }
+
+    bool operator == (const CollisionGroupDesc&) const
+    {
+        return false;
+    }
+
+    const SdfPathVector& getFilteredGroups() const
+    {
+        return filteredGroups;
+    }
+
+    const SdfPathVector& getMergedGroups() const
+    {
+        return mergedGroups;
+    }
+
+    bool invertFilteredGroups;                      ///< If filtering is inverted or not (default does not collide with)
+    SdfPathVector filteredGroups;                   ///< Filtered groups SdfPath vector
+    std::string mergeGroupName;                     ///< Merge group name
+    SdfPathVector mergedGroups;                     ///< List of merged collision groups
+};
+
+/// \struct ShapeDesc
+///
+/// Shape descriptor, base class should not be reported
+///
+/// Note as scale is not supported in most physics engines,
+/// the collision shape sizes already contain the scale.
+/// The exception are mesh collisions which do have geometry scale reported.
+///
+struct ShapeDesc : PhysicsObjectDesc
+{
+    ShapeDesc()
+        : localPos(0.0f, 0.0f, 0.0f),
+          localRot(1.0f, 0.0f, 0.0f, 0.0f),
+          localScale(1.0f, 1.0f, 1.0f),
+          collisionEnabled(true)
+    {
+    }
+
+    const SdfPathVector& getMaterials() const
+    {
+        return materials;
+    }
+
+    const SdfPathVector& getSimulationOwners() const
+    {
+        return simulationOwners;
+    }
+
+    const SdfPathVector& getFilteredCollisions() const
+    {
+        return filteredCollisions;
+    }
+
+    const SdfPathVector& getCollisionGroups() const
+    {
+        return collisionGroups;
+    }
+
+
+    SdfPath rigidBody;                      ///< Rigid body the collision shape belongs to, if not set its a static collider
+    GfVec3f localPos;                       ///< Local position of the shape relative to the body world pose
+    GfQuatf localRot;                       ///< Local orientation of the shape relative to the body world pose
+    GfVec3f localScale;                     ///< Local scale of the shape relative to the body world pose
+    SdfPathVector materials;                ///< Materials assigned to the collision geometry, can be multiple materials used on UsdGeomSubset
+    SdfPathVector simulationOwners;         ///< Simulation owners list
+    SdfPathVector filteredCollisions;       ///< Filtered collisions list
+    SdfPathVector collisionGroups;          ///< List of collision groups this collision belongs to, note that only collision groups that are part of the current range are checked.
+    bool collisionEnabled;                  ///< Collision enabled/disabled bool
+};
+
+/// \struct SphereShapeDesc
+///
+/// Sphere shape collision descriptor
+///
+struct SphereShapeDesc : ShapeDesc
+{
+    SphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
+    {
+        type = PhysicsObjectType::eSphereShape;
+    }
+
+    bool operator == (const SphereShapeDesc&) const
+    {
+        return false;
+    }
+
+    float radius;               ///< Sphere radius
+};
+
+/// \struct CapsuleShapeDesc
+///
+/// Capsule shape collision descriptor
+///
+struct CapsuleShapeDesc : ShapeDesc
+{
+    CapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, PhysicsAxis::Enum cap_axis = PhysicsAxis::eX)
+        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
+    {
+        type = PhysicsObjectType::eCapsuleShape;
+    }
+
+    bool operator == (const CapsuleShapeDesc&) const
+    {
+        return false;
+    }
+
+    float radius;               ///< Capsule radius
+    float halfHeight;           ///< Capsule half height
+    PhysicsAxis::Enum axis;     ///< Capsule axis
+};
+
+/// \struct CylinderShapeDesc
+///
+/// Cylinder shape collision descriptor
+///
+struct CylinderShapeDesc : ShapeDesc
+{
+    CylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, PhysicsAxis::Enum cap_axis = PhysicsAxis::eX)
+        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
+    {
+        type = PhysicsObjectType::eCylinderShape;
+    }
+
+    bool operator == (const CylinderShapeDesc&) const
+    {
+        return false;
+    }
+
+    float radius;               ///< Cylinder radius
+    float halfHeight;           ///< Cylinder half height
+    PhysicsAxis::Enum axis;     ///< Cylinder axis
+};
+
+/// \struct ConeShapeDesc
+///
+/// Cone shape collision descriptor
+///
+struct ConeShapeDesc : ShapeDesc
+{
+    ConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, PhysicsAxis::Enum cap_axis = PhysicsAxis::eX)
+        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
+    {
+        type = PhysicsObjectType::eConeShape;
+    }
+
+    bool operator == (const ConeShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    float radius;               ///< Cone radius
+    float halfHeight;           ///< Cone half height
+    PhysicsAxis::Enum axis;     ///< Cone axis
+};
+
+/// \struct PlaneShapeDesc
+///
+/// Plane shape collision descriptor
+///
+struct PlaneShapeDesc : ShapeDesc
+{
+    PlaneShapeDesc(PhysicsAxis::Enum up_axis = PhysicsAxis::eX)
+        : axis(up_axis)
+    {
+        type = PhysicsObjectType::ePlaneShape;
+    }
+    bool operator == (const PlaneShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    PhysicsAxis::Enum axis;     ///< Plane axis
+};
+
+
+/// \struct CustomShapeDesc
+///
+/// Custom shape collision descriptor
+///
+struct CustomShapeDesc : ShapeDesc
+{
+    CustomShapeDesc()
+    {
+        type = PhysicsObjectType::eCustomShape;
+    }
+    bool operator == (const CustomShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    TfToken customGeometryToken;    ///< Custom geometry token for this collision
+};
+
+/// \struct CubeShapeDesc
+///
+/// Cube shape collision descriptor
+///
+struct CubeShapeDesc : ShapeDesc
+{
+    CubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f)) : halfExtents(inHalfExtents)
+    {
+        type = PhysicsObjectType::eCubeShape;
+    }
+    bool operator == (const CubeShapeDesc&) const
+    {
+        return false;
+    }
+
+    GfVec3f halfExtents;        ///< Half extents of the cube
+};
+
+/// \struct MeshShapeDesc
+///
+/// Mesh shape collision descriptor
+///
+struct MeshShapeDesc : ShapeDesc
+{
+    MeshShapeDesc() : meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
+    {
+        type = PhysicsObjectType::eMeshShape;
+    }
+    bool operator == (const MeshShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    ~MeshShapeDesc()
+    {
+    }
+
+    const TfToken GetApproximation()
+    {
+        return approximation;
+    }
+
+    TfToken approximation;      ///< Desired approximation for the mesh collision
+    GfVec3f meshScale;          ///< Mesh scale
+    bool doubleSided;           ///< Bool to define whether mesh is double sided or not
+};
+
+/// \struct SpherePoint
+///
+/// This struct represents a single sphere-point
+/// which is a position and a radius
+///
+struct SpherePoint
+{
+    bool operator == (const SpherePoint&) const
+    {
+        return false;
+    }
+
+    GfVec3f center;
+    float radius;
+};
+
+/// \struct SpherePointsShapeDesc
+///
+/// This struct represents a collection of
+/// sphere points. Basically just an array of
+/// spheres which has been populated from a
+/// UsdGeomPoints primitive
+///
+struct SpherePointsShapeDesc : ShapeDesc
+{
+    SpherePointsShapeDesc(void)
+    {
+        type = PhysicsObjectType::eSpherePointsShape;
+    }
+    bool operator == (const SpherePointsShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    ~SpherePointsShapeDesc(void)
+    {
+    }
+
+    std::vector<SpherePoint> spherePoints;  ///< Lit of sphere points
+};
+
+/// \struct RigidBodyDesc
+///
+/// Rigid body descriptor
+///
+struct RigidBodyDesc : PhysicsObjectDesc
+{
+    RigidBodyDesc()
+        : position(0.0f, 0.0f, 0.0f),
+          rotation(1.0f, 0.0f, 0.0f, 0.0f),
+          scale(1.0f, 1.0f, 1.0f),
+          rigidBodyEnabled(true),
+          kinematicBody(false),
+          startsAsleep(false),
+          linearVelocity(0.0f, 0.0f, 0.0f),
+          angularVelocity(0.0f, 0.0f, 0.0f)
+    {
+        type = PhysicsObjectType::eRigidBody;
+    }
+    bool operator == (const RigidBodyDesc&) const
+    {
+        return false;
+    }
+
+    const SdfPathVector& getCollisions() const
+    {
+        return collisions;
+    }
+
+    const SdfPathVector& getFilteredCollisions() const
+    {
+        return filteredCollisions;
+    }
+
+    const SdfPathVector& getSimulationOwners() const
+    {
+        return simulationOwners;
+    }
+
+    SdfPathVector collisions;               ///< List of collision shapes that belong to this rigid body
+    SdfPathVector filteredCollisions;       ///< Filtered collisions
+    SdfPathVector simulationOwners;         ///< Simulation owners list
+    GfVec3f position;                       ///< Rigid body position in world space
+    GfQuatf rotation;                       ///< Rigid body orientation in world space
+    GfVec3f scale;                          ///< Rigid body scale
+
+    bool rigidBodyEnabled;                  ///< Defines whether body is enabled or not, if not enabled its a static body
+    bool kinematicBody;                     ///< Defines if the body is kinematic or not
+    bool startsAsleep;                      ///< Defines if body starts asleep or awake
+    GfVec3f linearVelocity;                 ///< Rigid body initial linear velocity
+    GfVec3f angularVelocity;                ///< Rigid body initial angular velocity
+};
+
+/// \struct JointLimit
+///
+/// Joint limit descriptor
+///
+struct JointLimit
+{
+    JointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
+    {
+    }
+
+    bool operator == (const JointLimit&) const
+    {
+        return false;
+    }
+
+
+    bool enabled;           ///< Defines whether limit is enabled or not
+    union                   ///< Min, lower, initial angle
+    {
+        float angle0;
+        float lower;
+        float minDist;
+    };
+    union                   ///< Max, upper, final angle
+    {
+        float angle1;
+        float upper;
+        float maxDist;
+    };
+};
+
+/// \struct JointDrive
+///
+/// Joint drive descriptor
+/// The expected drive formula:
+/// force = spring * (target position - position) + damping * (targetVelocity - velocity)
+///
+struct JointDrive
+{
+    JointDrive()
+        : enabled(false),
+          targetPosition(0.0f),
+          targetVelocity(0.0f),
+          forceLimit(FLT_MAX),
+          stiffness(0.0f),
+          damping(0.0f),
+          acceleration(false)
+    {
+    }
+
+    bool operator == (const JointDrive&) const
+    {
+        return false;
+    }
+
+    bool enabled;           ///< Defines whether limit is enabled or not
+    float targetPosition;   ///< Drive target position
+    float targetVelocity;   ///< Drive target velocity
+    float forceLimit;       ///< Force limit
+    float stiffness;        ///< Drive stiffness
+    float damping;          ///< Drive damping
+    bool acceleration;      ///< Drive mode is acceleration or force
+};
+
+
+/// \struct ArticulationDesc
+///
+/// Articulation description
+///
+struct ArticulationDesc : PhysicsObjectDesc
+{
+    ArticulationDesc()
+    {
+        type = PhysicsObjectType::eArticulation;
+    }
+    bool operator == (const ArticulationDesc&) const
+    {
+        return false;
+    }
+
+    const SdfPathVector& GetRootPrims() const
+    {
+        return rootPrims;
+    }
+
+    const SdfPathVector& GetFilteredCollisions() const
+    {
+        return filteredCollisions;
+    }
+
+    const SdfPathVector& GetArticulatedJoints() const
+    {
+        return articulatedJoints;
+    }
+
+    const SdfPathVector& GetArticulatedBodies() const
+    {
+        return articulatedBodies;
+    }
+
+    SdfPathVector rootPrims;            ///< List of articulation roots, this defines where the articulation topology starts
+    SdfPathVector filteredCollisions;   ///< Filtered collisions
+    SdfPathVector articulatedJoints;    ///< List of joints that can be part of this articulation
+    SdfPathVector articulatedBodies;    ///< List of bodies that can be part of this articulation
+};
+
+using JointLimits = std::vector<std::pair<PhysicsJointDOF::Enum, JointLimit>>;
+using JointDrives = std::vector<std::pair<PhysicsJointDOF::Enum, JointDrive>>;
+
+/// \struct JointDesc
+///
+/// Base UsdPhysics joint descriptor
+///
+struct JointDesc : public PhysicsObjectDesc
+{
+    JointDesc()
+        : localPose0Position(0.0f, 0.0f, 0.0f),
+          localPose0Orientation(1.0f, 0.0f, 0.0f, 0.0f),
+          localPose1Position(0.0f, 0.0f, 0.0f),
+          localPose1Orientation(1.0f, 0.0f, 0.0f, 0.0f),
+          jointEnabled(true),
+          breakForce(FLT_MAX), // USD default is none, which is not a float...
+          breakTorque(FLT_MAX),
+          excludeFromArticulation(false)
+    {
+    }
+
+    bool operator == (const JointDesc&) const
+    {
+        return false;
+    }
+
+    SdfPath rel0;                   ///< UsdPrim relationship 0 for the joint
+    SdfPath rel1;                   ///< UsdPrim relationship 1 for the joint
+    SdfPath body0;                  ///< Rigid body 0 that the joint is connected, does not have to match the rel0
+    SdfPath body1;                  ///< Rigid body 1 that the joint is connected, does not have to match the rel1
+    GfVec3f localPose0Position;     ///< Relative local position against the body0 world frame
+    GfQuatf localPose0Orientation;  ///< Relative local orientation against the body0 world frame
+    GfVec3f localPose1Position;     ///< Relative local position against the body1 world frame
+    GfQuatf localPose1Orientation;  ///< Relative local orientation against the body1 world frame
+    bool jointEnabled;              ///< Defines if joint is enabled or disabled
+    float breakForce;               ///< Joint break force
+    float breakTorque;              ///< Joint break torque
+    bool excludeFromArticulation;   ///< Defines if joints belongs to an articulation or if its a maximum coordinate joint
+    bool collisionEnabled;          ///< Defines if collision is enabled or disabled between the jointed bodies
+};
+
+/// \struct CustomJointDesc
+///
+/// Custom joint descriptor
+///
+struct CustomJointDesc : public JointDesc
+{
+    CustomJointDesc()
+    {
+        type = PhysicsObjectType::eCustomJoint;
+    }
+    bool operator == (const CustomJointDesc&) const
+    {
+        return false;
+    }
+
+};
+
+/// \struct FixedJointDesc
+///
+/// Fixed joint descriptor
+///
+struct FixedJointDesc : public JointDesc
+{
+    FixedJointDesc()
+    {
+        type = PhysicsObjectType::eFixedJoint;
+    }
+    bool operator == (const FixedJointDesc&) const
+    {
+        return false;
+    }
+};
+
+/// \struct D6JointDesc
+///
+/// Generic D6 joint descriptor
+///
+struct D6JointDesc : public JointDesc
+{
+    D6JointDesc()
+    {
+        type = PhysicsObjectType::eD6Joint;
+    }
+    bool operator == (const D6JointDesc&) const
+    {
+        return false;
+    }
+
+    JointLimits jointLimits;    ///< List of joint limits
+    JointDrives jointDrives;    ///< List of joint drives
+};
+
+/// \struct PrismaticJointDesc
+///
+/// Prismatic joint descriptor
+///
+struct PrismaticJointDesc : public JointDesc
+{
+    PrismaticJointDesc() : axis(PhysicsAxis::eX)
+    {
+        type = PhysicsObjectType::ePrismaticJoint;
+    }
+    bool operator == (const PrismaticJointDesc&) const
+    {
+        return false;
+    }
+
+
+    PhysicsAxis::Enum axis; ///< The joints axis
+    JointLimit limit;       ///< Joint linear limit
+    JointDrive drive;       ///< Joint linear drive
+};
+
+/// \struct SphericalJointDesc
+///
+/// Spherical joint descriptor
+///
+struct SphericalJointDesc : public JointDesc
+{
+    SphericalJointDesc() : axis(PhysicsAxis::eX)
+    {
+        type = PhysicsObjectType::eSphericalJoint;
+    }
+    bool operator == (const SphericalJointDesc&) const
+    {
+        return false;
+    }
+
+    PhysicsAxis::Enum axis; ///< The joints axis
+    JointLimit limit;       ///< The joint spherical limit
+};
+
+/// \struct RevoluteJointDesc
+///
+/// Revolute joint descriptor
+///
+struct RevoluteJointDesc : public JointDesc
+{
+    RevoluteJointDesc() : axis(PhysicsAxis::eX)
+    {
+        type = PhysicsObjectType::eRevoluteJoint;
+    }
+    bool operator == (const RevoluteJointDesc&) const
+    {
+        return false;
+    }
+
+    PhysicsAxis::Enum axis; ///< The joints axis
+    JointLimit limit;       ///< The angular limit
+    JointDrive drive;       ///< The angular drive
+};
+
+/// \struct DistanceJointDesc
+///
+/// Distance joint descriptor
+///
+struct DistanceJointDesc : public JointDesc
+{
+    DistanceJointDesc() : minEnabled(false), maxEnabled(false)
+    {
+        type = PhysicsObjectType::eDistanceJoint;
+    }
+    bool operator == (const DistanceJointDesc&) const
+    {
+        return false;
+    }
+    bool minEnabled;    ///< Defines if minimum limit is enabled
+    bool maxEnabled;    ///< Defines if maximum limit is enabled
+    JointLimit limit;   ///< The distance limit
+};
+
+
+PXR_NAMESPACE_CLOSE_SCOPE
+
+#endif
diff --git a/pxr/usd/usdPhysics/parsePrimIterator.h b/pxr/usd/usdPhysics/parsePrimIterator.h
new file mode 100644
index 0000000000..69d5fdfdc1
--- /dev/null
+++ b/pxr/usd/usdPhysics/parsePrimIterator.h
@@ -0,0 +1,274 @@
+//
+// Copyright 2016 Pixar
+//
+// Licensed under the Apache License, Version 2.0 (the "Apache License")
+// with the following modification; you may not use this file except in
+// compliance with the Apache License and the following modification to it:
+// Section 6. Trademarks. is deleted and replaced with:
+//
+// 6. Trademarks. This License does not grant permission to use the trade
+//    names, trademarks, service marks, or product names of the Licensor
+//    and its affiliates, except as required to comply with Section 4(c) of
+//    the License and to reproduce the content of the NOTICE file.
+//
+// You may obtain a copy of the Apache License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the Apache License with the above modification is
+// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied. See the Apache License for the specific
+// language governing permissions and limitations under the Apache License.
+//
+#ifndef USDPHYSICS_PARSE_PRIM_ITERATOR_H
+#define USDPHYSICS_PARSE_PRIM_ITERATOR_H
+
+/// \file usdPhysics/parseParsePrimIterator.h
+
+#include "pxr/pxr.h"
+#include "pxr/usd/usd/primRange.h"
+
+#include <unordered_set>
+
+PXR_NAMESPACE_OPEN_SCOPE
+
+
+// -------------------------------------------------------------------------- //
+// PHYSICSPARSEPRIMITERATOR                                                   //
+// -------------------------------------------------------------------------- //
+
+using UsdPrimMap = std::map<const SdfPath, UsdPrim>;
+
+/// \struct ParsePrimIteratorBase
+///
+/// Base class for iterator used by parsing
+///
+class ParsePrimIteratorBase
+{
+public:
+    virtual ~ParsePrimIteratorBase() = default;
+
+    /// Reset the iteration
+    virtual void reset() = 0;
+
+    /// Check if iterator is at the end
+    /// \return True if at the end
+    virtual bool atEnd() const = 0;
+
+    /// Get current iterator
+    /// \return Current iterator
+    virtual UsdPrimRange::const_iterator getCurrent() = 0;
+
+    /// Update iterator to next
+    virtual void next() = 0;
+
+    /// Prune all children of the current iterator
+    virtual void pruneChildren() = 0;
+};
+
+/// \struct ParsePrimIteratorRange
+///
+/// Class for standard UsdPrimRange iterator
+///
+class ParsePrimIteratorRange : public ParsePrimIteratorBase
+{
+public:
+    ParsePrimIteratorRange(UsdPrimRange range) : mRange(range)
+    {
+        reset();
+    }
+
+    virtual void reset() override
+    {
+        mIter = mRange.begin();
+    }
+
+    virtual void pruneChildren() override
+    {
+        if (!atEnd())
+            mIter.PruneChildren();
+    }
+
+    virtual bool atEnd() const override
+    {
+        return mIter == mRange.end();
+    }
+
+    virtual UsdPrimRange::const_iterator getCurrent() override
+    {
+        return mIter;
+    }
+
+    virtual void next() override
+    {
+        if (mIter != mRange.end())
+        {
+            mIter++;
+        }
+    }
+
+private:
+    UsdPrimRange mRange;
+    UsdPrimRange::const_iterator mIter;
+};
+
+/// \struct ParsePrimIteratorMapRange
+///
+/// Class for combined UsdPrimRange iterator that iterates over multiple hierarchies.
+/// This is required for processing newly added subtrees to be processed in one traverse.
+///
+class ParsePrimIteratorMapRange : public ParsePrimIteratorBase
+{
+public:
+    ParsePrimIteratorMapRange(const UsdPrimMap& primMap) : mPrimMap(primMap)
+    {
+        reset();
+    }
+
+    virtual void reset() override
+    {
+        mAtEnd = true;
+
+        mPrimMapIter = mPrimMap.begin();
+
+        if (mPrimMapIter != mPrimMap.end())
+        {
+            mRange = UsdPrimRange(mPrimMapIter->second, UsdTraverseInstanceProxies());
+            if (mRange.begin() != mRange.end())
+            {
+                mIter = mRange.begin();
+                mAtEnd = false;
+            }
+        }
+    }
+
+    virtual bool atEnd() const override
+    {
+        return mAtEnd;
+    }
+
+    virtual void pruneChildren() override
+    {
+        if (!atEnd())
+            mIter.PruneChildren();
+    }
+
+    virtual UsdPrimRange::const_iterator getCurrent() override
+    {
+        return mIter;
+    }
+
+    virtual void next() override
+    {
+        if (mIter != mRange.end())
+        {
+            mIter++;
+
+            if (mIter == mRange.end())
+            {
+                mPrimMapIter++;
+
+                if (mPrimMapIter == mPrimMap.end())
+                {
+                    mAtEnd = true;
+                }
+                else
+                {
+                    mRange = UsdPrimRange(mPrimMapIter->second);
+                    mIter = mRange.begin();
+                }
+            }
+        }
+    }
+
+private:
+    bool mAtEnd;
+
+    const UsdPrimMap& mPrimMap;
+    UsdPrimMap::const_iterator mPrimMapIter;
+
+    UsdPrimRange mRange;
+    UsdPrimRange::const_iterator mIter;
+};
+
+class ExcludeListPrimIteratorRange : public ParsePrimIteratorBase
+{
+public:
+    /// ExcludeListPrimIteratorRange constructor, this iterator
+    /// takes a regular range as input and exclude set for paths an
+    /// its descendants to get pruned. 
+    ///
+    /// \param[in] range      UsdPrimRange to traverse
+    /// \param[in] pathList   Paths to get pruned
+    ExcludeListPrimIteratorRange(pxr::UsdPrimRange range, const SdfPathVector& pathList)
+     : mRange(range)
+    {
+        for (const SdfPath& path : pathList)
+        {
+            mPathSet.insert(path);
+        }
+        reset();
+    }
+
+    virtual void reset() override
+    {
+        mIter = mRange.begin();
+    }
+
+    virtual void pruneChildren() override
+    {
+        mIter.PruneChildren();
+    }
+
+    virtual bool atEnd() const override
+    {
+        return mIter == mRange.end();
+    }
+
+    virtual pxr::UsdPrimRange::const_iterator getCurrent() override
+    {
+        return mIter;
+    }
+
+    virtual void next() override
+    {
+        if (mIter != mRange.end())
+        {
+            bool validPrim = false;
+            while (!validPrim)
+            {
+                mIter++;
+                if (mIter != mRange.end())
+                {
+                    const pxr::UsdPrim& prim = *mIter;
+                    if (prim)
+                    {
+                        std::unordered_set<pxr::SdfPath, pxr::SdfPath::Hash>::const_iterator fit = mPathSet.find(prim.GetPrimPath());
+                        if (fit != mPathSet.end())
+                        {
+                            mIter.PruneChildren();
+                        }
+                        else
+                        {
+                            validPrim = true;
+                        }
+                    }
+                }
+                else
+                {
+                    validPrim = true;
+                }
+            }
+        }
+    }
+
+private:
+    pxr::UsdPrimRange mRange;
+    pxr::UsdPrimRange::const_iterator mIter;
+    std::unordered_set<pxr::SdfPath, pxr::SdfPath::Hash> mPathSet;
+};
+
+PXR_NAMESPACE_CLOSE_SCOPE
+
+#endif
diff --git a/pxr/usd/usdPhysics/parseUtils.cpp b/pxr/usd/usdPhysics/parseUtils.cpp
new file mode 100644
index 0000000000..8fa2ec2b5c
--- /dev/null
+++ b/pxr/usd/usdPhysics/parseUtils.cpp
@@ -0,0 +1,2904 @@
+//
+// Copyright 2021 Pixar
+//
+// Licensed under the Apache License, Version 2.0 (the "Apache License")
+// with the following modification; you may not use this file except in
+// compliance with the Apache License and the following modification to it:
+// Section 6. Trademarks. is deleted and replaced with:
+//
+// 6. Trademarks. This License does not grant permission to use the trade
+//    names, trademarks, service marks, or product names of the Licensor
+//    and its affiliates, except as required to comply with Section 4(c) of
+//    the License and to reproduce the content of the NOTICE file.
+//
+// You may obtain a copy of the Apache License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the Apache License with the above modification is
+// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied. See the Apache License for the specific
+// language governing permissions and limitations under the Apache License.
+//
+
+#include "pxr/pxr.h"
+
+#include "pxr/base/gf/transform.h"
+
+#include "pxr/usd/usdGeom/gprim.h"
+#include "pxr/usd/usdGeom/mesh.h"
+#include "pxr/usd/usdGeom/sphere.h"
+#include "pxr/usd/usdGeom/cube.h"
+#include "pxr/usd/usdGeom/capsule.h"
+#include "pxr/usd/usdGeom/cylinder.h"
+#include "pxr/usd/usdGeom/cone.h"
+#include "pxr/usd/usdGeom/plane.h"
+#include "pxr/usd/usdGeom/points.h"
+
+#include "pxr/usd/usdGeom/metrics.h"
+
+#include "pxr/usd/usdShade/materialBindingAPI.h"
+
+#include "parseUtils.h"
+#include "parseDesc.h"
+
+#include "pxr/usd/usdPhysics/scene.h"
+#include "pxr/usd/usdPhysics/collisionGroup.h"
+#include "pxr/usd/usdPhysics/materialAPI.h"
+#include "pxr/usd/usdPhysics/rigidBodyAPI.h"
+#include "pxr/usd/usdPhysics/collisionAPI.h"
+#include "pxr/usd/usdPhysics/articulationRootAPI.h"
+
+#include "pxr/usd/usdPhysics/joint.h"
+#include "pxr/usd/usdPhysics/fixedJoint.h"
+#include "pxr/usd/usdPhysics/revoluteJoint.h"
+#include "pxr/usd/usdPhysics/prismaticJoint.h"
+#include "pxr/usd/usdPhysics/sphericalJoint.h"
+#include "pxr/usd/usdPhysics/distanceJoint.h"
+
+#include "pxr/usd/usdPhysics/limitAPI.h"
+#include "pxr/usd/usdPhysics/driveAPI.h"
+#include "pxr/usd/usdPhysics/filteredPairsAPI.h"
+#include "pxr/usd/usdPhysics/meshCollisionAPI.h"
+
+
+#include "pxr/usd/usdGeom/pointInstancer.h"
+
+PXR_NAMESPACE_OPEN_SCOPE
+
+void ParseFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
+{
+    UsdPhysicsFilteredPairsAPI filteredPairsAPI = UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
+    if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
+    {
+        filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
+    }
+}
+
+bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI, ArticulationDesc* articulationDesc)
+{
+    if (articulationDesc && articulationAPI)
+    {       
+        ParseFilteredPairs(articulationAPI.GetPrim(), articulationDesc->filteredCollisions);
+
+        articulationDesc->primPath = articulationAPI.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or ArticulationDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+PhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
+{
+    PhysicsObjectType::Enum retVal = PhysicsObjectType::eUndefined;
+
+    // custom shape handling
+    bool customShape = false;
+    if (customTokens)
+    {
+        const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
+
+        const TfToken& primType = prim.GetTypeName();
+        for (size_t i = 0; i < customTokens->size(); i++)
+        {
+            for (size_t j = 0; j < apis.size(); j++)
+            {
+                if (apis[j] == (*customTokens)[i])
+                {
+                    retVal = PhysicsObjectType::eCustomShape;
+                    if (customeGeometryToken)
+                        *customeGeometryToken = apis[j];
+                    break;
+                }
+            }
+            if(retVal == PhysicsObjectType::eCustomShape)
+            {
+                break;
+            }
+            if (primType == (*customTokens)[i])
+            {
+                    retVal = PhysicsObjectType::eCustomShape;
+                    if (customeGeometryToken)
+                        *customeGeometryToken = primType;                
+                break;
+            }
+        }
+    }
+
+    if (retVal == PhysicsObjectType::eCustomShape)
+        return retVal;
+
+    // geomgprim that belongs to that collision
+    if (prim.IsA<UsdGeomGprim>())
+    {
+        // If the primitive is a UsdGeomPoints *and* it has a widths attribute
+        // corresponding to the positions attribute, then we treat it as an
+        // array of spheres corresponding to the 'SpherePointsShapeDesc'
+        if (prim.IsA<UsdGeomMesh>())
+        {
+            retVal = PhysicsObjectType::eMeshShape;
+        }
+        else if (prim.IsA<UsdGeomCube>())
+        {
+            retVal = PhysicsObjectType::eCubeShape;
+        }
+        else if (prim.IsA<UsdGeomSphere>())
+        {
+            retVal = PhysicsObjectType::eSphereShape;
+        }
+        else if (prim.IsA<UsdGeomCapsule>())
+        {
+            retVal = PhysicsObjectType::eCapsuleShape;
+        }
+        else if (prim.IsA<UsdGeomCylinder>())
+        {
+            retVal = PhysicsObjectType::eCylinderShape;
+        }
+        else if (prim.IsA<UsdGeomCone>())
+        {
+            retVal = PhysicsObjectType::eConeShape;
+        }
+        else if (prim.IsA<UsdGeomPlane>())
+        {
+            retVal = PhysicsObjectType::ePlaneShape;
+        }
+        else if (prim.IsA<UsdGeomPoints>())
+        {
+            retVal = PhysicsObjectType::eSpherePointsShape;
+        }
+    }
+    
+    return retVal;
+}
+
+const double tolerance = 1e-4;
+
+void CheckNonUniformScale(const GfVec3d& scale, const SdfPath& primPath)
+{
+    if (abs(scale[0] - scale[1]) > tolerance || abs(scale[0] - scale[2]) > tolerance || abs(scale[2] - scale[1]) > tolerance)
+    {
+        TF_DIAGNOSTIC_WARNING("Non-uniform scale may result in a non matching collision representation on prim: %s", primPath.GetText());
+    }
+}
+
+
+pxr::SdfPath GetMaterialBinding(const pxr::UsdPrim& usdPrim)
+{
+    SdfPath materialPath = SdfPath();
+
+    const static TfToken physicsPurpose("physics");
+    UsdShadeMaterialBindingAPI materialBindingAPI = UsdShadeMaterialBindingAPI(usdPrim);
+    if (materialBindingAPI)
+    {
+        UsdShadeMaterial material = materialBindingAPI.ComputeBoundMaterial(physicsPurpose);
+        if (material)
+        {
+            materialPath = material.GetPrim().GetPrimPath();
+        }
+    }
+    else
+    {
+        // handle material through a direct binding rel search
+        std::vector<UsdPrim> prims;
+        prims.push_back(usdPrim);
+        std::vector<UsdShadeMaterial> materials =
+            UsdShadeMaterialBindingAPI::ComputeBoundMaterials(prims, physicsPurpose);
+        if (!materials.empty() && materials[0])
+        {
+            materialPath = materials[0].GetPrim().GetPrimPath();
+        }
+    }
+
+    return materialPath;
+}
+
+static void ParseColFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
+{    
+    UsdPhysicsFilteredPairsAPI filteredPairsAPI = UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
+    if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
+    {
+        filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
+    }
+}
+
+void FinalizeDesc(const UsdPhysicsCollisionAPI& colAPI, ShapeDesc& desc)
+{
+    // set the collider material as last
+    // set SdfPath() anyway, this would indicate default material should be used, this is required for trimesh subset materials
+    // as not alway all faces are covered with a subset material
+    const SdfPath& materialPath = GetMaterialBinding(colAPI.GetPrim());
+    if (materialPath != SdfPath())
+    {
+        const UsdPrim materialPrim = colAPI.GetPrim().GetStage()->GetPrimAtPath(materialPath);
+        if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
+            desc.materials.push_back(materialPath);
+        else
+            desc.materials.push_back(SdfPath());
+    }
+    else
+    {
+        desc.materials.push_back(SdfPath());
+    }
+
+    ParseColFilteredPairs(colAPI.GetPrim(), desc.filteredCollisions);
+    colAPI.GetCollisionEnabledAttr().Get(&desc.collisionEnabled);
+    const UsdRelationship ownerRel = colAPI.GetSimulationOwnerRel();
+    if (ownerRel)
+    {
+        ownerRel.GetTargets(&desc.simulationOwners);
+    }
+}
+
+
+bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, SphereShapeDesc* sphereShapeDesc)
+{
+    if (sphereShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomSphere shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+
+            // Check scale, its part of the collision size
+            {
+                const pxr::GfVec3d sc = tr.GetScale();
+                // as we dont support scale in physics and scale can be non uniform
+                // we pick the largest scale value as the sphere radius base
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                radius = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))), fabsf(float(sc[2])));
+            }
+
+            // Get shape parameters
+            {
+
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                radius *= (float)radiusAttr;
+            }
+
+            sphereShapeDesc->radius = fabsf(radius);
+            sphereShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *sphereShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomSphere.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or SphereShapeDesc is not valid.");
+        return false;
+    }
+    return true;
+}
+
+bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CubeShapeDesc* cubeShapeDesc)
+{
+    if (cubeShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCube shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            GfVec3f halfExtents;
+
+            // Add scale
+            {
+                const pxr::GfVec3d sc = tr.GetScale();
+                // scale is taken, its a part of the cube size, as the physics does not support scale
+                halfExtents = GfVec3f(sc);
+            }
+
+            // Get shape parameters
+            {
+                UsdGeomCube shape(usdPrim);
+                double sizeAttr;
+                shape.GetSizeAttr().Get(&sizeAttr);
+                sizeAttr = abs(sizeAttr) * 0.5f; // convert cube edge length to half extend
+                halfExtents *= (float)sizeAttr;
+            }
+
+            cubeShapeDesc->halfExtents = halfExtents;
+            cubeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *cubeShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCube.");
+            return false;
+        }        
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CubeShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CylinderShapeDesc* cylinderShapeDesc)
+{
+    if (cylinderShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCylinder shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+            float halfHeight = 1.0f;
+            PhysicsAxis::Enum axis = PhysicsAxis::eX;
+
+            // Get shape parameters
+            {
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                double heightAttr;
+                shape.GetHeightAttr().Get(&heightAttr);
+                radius = (float)radiusAttr;
+                halfHeight = (float)heightAttr * 0.5f;
+
+                TfToken capAxis;
+                if (shape.GetAxisAttr())
+                {
+                    shape.GetAxisAttr().Get(&capAxis);
+                    if (capAxis == UsdPhysicsTokens.Get()->y)
+                        axis = PhysicsAxis::eY;
+                    else if (capAxis == UsdPhysicsTokens.Get()->z)
+                        axis = PhysicsAxis::eZ;
+                }
+            }
+
+            {
+                // scale the radius and height based on the given axis token
+                const pxr::GfVec3d sc = tr.GetScale();
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                if (axis == PhysicsAxis::eX)
+                {
+                    halfHeight *= float(sc[0]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+                }
+                else if (axis == PhysicsAxis::eY)
+                {
+                    halfHeight *= float(sc[1]);
+                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+                }
+                else
+                {
+                    halfHeight *= float(sc[2]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+                }
+            }
+            cylinderShapeDesc->radius = fabsf(radius);
+            cylinderShapeDesc->axis = axis;
+            cylinderShapeDesc->halfHeight = fabsf(halfHeight);
+            cylinderShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *cylinderShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCylinder.");
+            return false;
+        }        
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CylinderShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CapsuleShapeDesc* capsuleShapeDesc)
+{
+    if (capsuleShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCapsule shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+            float halfHeight = 1.0f;
+            PhysicsAxis::Enum axis = PhysicsAxis::eX;
+
+            // Get shape parameters
+            {
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                double heightAttr;
+                shape.GetHeightAttr().Get(&heightAttr);
+                radius = (float)radiusAttr;
+                halfHeight = (float)heightAttr * 0.5f;
+
+                TfToken capAxis;
+                if (shape.GetAxisAttr())
+                {
+                    shape.GetAxisAttr().Get(&capAxis);
+                    if (capAxis == UsdPhysicsTokens.Get()->y)
+                        axis = PhysicsAxis::eY;
+                    else if (capAxis == UsdPhysicsTokens.Get()->z)
+                        axis = PhysicsAxis::eZ;
+                }
+            }
+
+            {
+                // scale the radius and height based on the given axis token
+                const pxr::GfVec3d sc = tr.GetScale();
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                if (axis == PhysicsAxis::eX)
+                {
+                    halfHeight *= float(sc[0]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+                }
+                else if (axis == PhysicsAxis::eY)
+                {
+                    halfHeight *= float(sc[1]);
+                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+                }
+                else
+                {
+                    halfHeight *= float(sc[2]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+                }
+            }
+            capsuleShapeDesc->radius = fabsf(radius);
+            capsuleShapeDesc->axis = axis;
+            capsuleShapeDesc->halfHeight = fabsf(halfHeight);
+            capsuleShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *capsuleShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCapsule.");
+            return false;
+        }        
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CapsuleShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, ConeShapeDesc* coneShapeDesc)
+{
+    if (coneShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCone shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+            float halfHeight = 1.0f;
+            PhysicsAxis::Enum axis = PhysicsAxis::eX;
+
+            // Get shape parameters
+            {
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                double heightAttr;
+                shape.GetHeightAttr().Get(&heightAttr);
+                radius = (float)radiusAttr;
+                halfHeight = (float)heightAttr * 0.5f;
+
+                TfToken capAxis;
+                if (shape.GetAxisAttr())
+                {
+                    shape.GetAxisAttr().Get(&capAxis);
+                    if (capAxis == UsdPhysicsTokens.Get()->y)
+                        axis = PhysicsAxis::eY;
+                    else if (capAxis == UsdPhysicsTokens.Get()->z)
+                        axis = PhysicsAxis::eZ;
+                }
+            }
+
+            {
+                // scale the radius and height based on the given axis token
+                const pxr::GfVec3d sc = tr.GetScale();
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                if (axis == PhysicsAxis::eX)
+                {
+                    halfHeight *= float(sc[0]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+                }
+                else if (axis == PhysicsAxis::eY)
+                {
+                    halfHeight *= float(sc[1]);
+                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+                }
+                else
+                {
+                    halfHeight *= float(sc[2]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+                }
+            }
+            coneShapeDesc->radius = fabsf(radius);
+            coneShapeDesc->axis = axis;
+            coneShapeDesc->halfHeight = fabsf(halfHeight);
+            coneShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *coneShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCone.");
+            return false;
+        }          
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or ConeShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, MeshShapeDesc* meshShapeDesc)
+{
+    if (meshShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomMesh shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            const pxr::GfVec3d sc = tr.GetScale();
+            meshShapeDesc->meshScale = GfVec3f(sc);
+
+            // Get approximation type
+            meshShapeDesc->approximation = UsdPhysicsTokens.Get()->none;
+            UsdPhysicsMeshCollisionAPI physicsColMeshAPI(usdPrim);
+            if (physicsColMeshAPI)
+            {
+                physicsColMeshAPI.GetApproximationAttr().Get(&meshShapeDesc->approximation);
+            }
+
+            shape.GetDoubleSidedAttr().Get(&meshShapeDesc->doubleSided);
+
+            // Gather materials through subsets
+            const std::vector<pxr::UsdGeomSubset> subsets = pxr::UsdGeomSubset::GetGeomSubsets(shape, pxr::UsdGeomTokens->face);
+            if (!subsets.empty())
+            {
+                for (const pxr::UsdGeomSubset& subset : subsets)
+                {
+                    const pxr::SdfPath material = GetMaterialBinding(subset.GetPrim());
+                    if (material != SdfPath())
+                    {
+                        const UsdPrim materialPrim = usdPrim.GetStage()->GetPrimAtPath(material);
+                        if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
+                        {
+                            meshShapeDesc->materials.push_back(material);
+                        }
+                    }
+                }
+            }
+
+            meshShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *meshShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomMesh.");
+            return false;
+        }         
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or MeshShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, PlaneShapeDesc* planeShapeDesc)
+{
+    if (planeShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomPlane shape(usdPrim);
+        if (shape)
+        {
+            PhysicsAxis::Enum axis = PhysicsAxis::eX;     
+
+            TfToken tfAxis;            
+            shape.GetAxisAttr().Get(&tfAxis);
+            if (tfAxis == UsdPhysicsTokens.Get()->y)
+            {
+                axis = PhysicsAxis::eY;
+            }
+            else if (tfAxis == UsdPhysicsTokens.Get()->z)
+            {
+                axis = PhysicsAxis::eZ;
+            }
+
+            planeShapeDesc->axis = axis;            
+            planeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *planeShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPlane.");
+            return false;
+        }           
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or PlaneShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, SpherePointsShapeDesc* spherePointsShapeDesc)
+{
+    if (spherePointsShapeDesc && collisionAPI)
+    {       
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomPoints shape(usdPrim);
+        if (shape)
+        {
+            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            VtArray<float> widths;
+            VtArray<GfVec3f> positions;
+            shape.GetWidthsAttr().Get(&widths);
+            if (widths.size())
+            {
+                shape.GetPointsAttr().Get(&positions);
+                if (positions.size() == widths.size())
+                {
+                    float sphereScale = 1.0f;
+                    {
+                        const pxr::GfVec3d sc = tr.GetScale();
+
+                        // as we don't support scale in physics and scale can be non uniform
+                        // we pick the largest scale value as the sphere radius base
+                        CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                        sphereScale = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))), fabsf(float(sc[2])));
+                    }
+                    
+                    const size_t scount = positions.size();
+                    spherePointsShapeDesc->spherePoints.resize(scount);
+                    for (size_t i=0; i<scount; i++)
+                    {
+                        spherePointsShapeDesc->spherePoints[i].radius = sphereScale * widths[i] * 0.5f;
+                        spherePointsShapeDesc->spherePoints[i].center = positions[i];
+                    }                                        
+                }
+                else
+                {
+                    TF_DIAGNOSTIC_WARNING("UsdGeomPoints width array size does not match position array size: %s", usdPrim.GetPrimPath().GetText());
+                    spherePointsShapeDesc->isValid = false;
+                }
+            }
+            else
+            {
+                TF_DIAGNOSTIC_WARNING("UsdGeomPoints width array not filled: %s", usdPrim.GetPrimPath().GetText());
+                spherePointsShapeDesc->isValid = false;
+            }
+            
+            spherePointsShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *spherePointsShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPoints.");
+            return false;
+        }        
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or SpherePointsShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CustomShapeDesc* customShapeDesc)
+{
+    if (customShapeDesc && collisionAPI)
+    {       
+
+        customShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+        FinalizeDesc(collisionAPI, *customShapeDesc);
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CustomShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+
+bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup, CollisionGroupDesc* collisionGroupDesc)
+{
+    if (collisionGroup && collisionGroupDesc)
+    {        
+        const UsdRelationship rel = collisionGroup.GetFilteredGroupsRel();
+        if (rel)
+        {
+            rel.GetTargets(&collisionGroupDesc->filteredGroups);
+        }
+
+        collisionGroup.GetInvertFilteredGroupsAttr().Get(&collisionGroupDesc->invertFilteredGroups);
+        collisionGroup.GetMergeGroupNameAttr().Get(&collisionGroupDesc->mergeGroupName);
+
+        collisionGroupDesc->primPath = collisionGroup.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionGroup or CollisionGroupDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+SdfPath GetRel(const pxr::UsdRelationship& ref, const pxr::UsdPrim& jointPrim)
+{
+    pxr::SdfPathVector targets;
+    ref.GetTargets(&targets);
+
+    if (targets.size() == 0)
+    {
+        return SdfPath();
+    }
+    if (targets.size() > 1)
+    {
+        TF_DIAGNOSTIC_WARNING("Joint prim does have relationship to multiple bodies this is not supported, jointPrim %s", jointPrim.GetPrimPath().GetText());
+        return targets.at(0);
+    }
+
+    return targets.at(0);
+}
+
+bool CheckJointRel(const SdfPath& relPath, const UsdPrim& jointPrim)
+{
+    if (relPath == SdfPath())
+        return true;
+
+    const UsdPrim relPrim = jointPrim.GetStage()->GetPrimAtPath(relPath);
+    if (!relPrim)
+    {
+        TF_RUNTIME_ERROR("Joint (%s) body relationship %s points to a non existent prim, joint will not be parsed.", jointPrim.GetPrimPath().GetText(), relPath.GetText());
+        return false;
+    }
+    return true;
+}
+
+pxr::UsdPrim GetBodyPrim(UsdStageWeakPtr stage, const SdfPath& relPath, UsdPrim& relPrim)
+{
+    UsdPrim parent = stage->GetPrimAtPath(relPath);
+    relPrim = parent;
+    UsdPrim collisionPrim = UsdPrim();
+    while (parent && parent != stage->GetPseudoRoot())
+    {        
+        if (parent.HasAPI<UsdPhysicsRigidBodyAPI>())
+        {
+            return parent;
+        }
+        if (parent.HasAPI<UsdPhysicsCollisionAPI>())
+        {
+            collisionPrim = parent;
+        }
+        parent = parent.GetParent();
+    }
+
+    return collisionPrim;
+}
+
+SdfPath GetLocalPose(UsdStageWeakPtr stage, const SdfPath& relPath, GfVec3f& t, GfQuatf& q)
+{
+    UsdPrim relPrim;    
+    const UsdPrim body = GetBodyPrim(stage, relPath, relPrim);    
+
+    // get scale and apply it into localPositions vectors
+    const UsdGeomXformable xform(relPrim);
+    const GfMatrix4d worldRel = relPrim ? xform.ComputeLocalToWorldTransform(UsdTimeCode::Default()) : GfMatrix4d(1.0);
+
+    // we need to apply scale to the localPose, the scale comes from the rigid body
+    GfVec3f sc;
+    // if we had a rel not to rigid body, we need to recompute the localPose
+    if (relPrim != body)
+    {
+        GfMatrix4d localAnchor;
+        localAnchor.SetIdentity();
+        localAnchor.SetTranslate(GfVec3d(t));
+        localAnchor.SetRotateOnly(GfQuatd(q));
+
+        GfMatrix4d bodyMat;
+        if (body)
+            bodyMat = UsdGeomXformable(body).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+        else
+            bodyMat.SetIdentity();
+        
+        const GfMatrix4d worldAnchor = localAnchor * worldRel;
+        GfMatrix4d bodyLocalAnchor = worldAnchor * bodyMat.GetInverse();
+        bodyLocalAnchor = bodyLocalAnchor.RemoveScaleShear();
+
+        t = GfVec3f(bodyLocalAnchor.ExtractTranslation());
+        q = GfQuatf(bodyLocalAnchor.ExtractRotationQuat());
+        q.Normalize();
+
+        const GfTransform tr(bodyMat);
+        sc = GfVec3f(tr.GetScale());
+    }
+    else
+    {
+        const GfTransform tr(worldRel);
+        sc = GfVec3f(tr.GetScale());
+    }
+
+    // apply the scale, this is not obvious, but in physics there is no scale, so we need to
+    // apply it before its send to physics
+    for (int i = 0; i < 3; i++)
+    {
+        t[i] *= sc[i];
+    }
+
+    return body ? body.GetPrimPath() : SdfPath();
+}
+
+void FinalizeJoint(const UsdPhysicsJoint& jointPrim, JointDesc* jointDesc)
+{
+    // joint bodies anchor point local transforms    
+    GfVec3f t0(0.f);
+    GfVec3f t1(0.f);
+    GfQuatf q0(1.f);
+    GfQuatf q1(1.f);
+    jointPrim.GetLocalPos0Attr().Get(&t0);
+    jointPrim.GetLocalRot0Attr().Get(&q0);
+    jointPrim.GetLocalPos1Attr().Get(&t1);
+    jointPrim.GetLocalRot1Attr().Get(&q1);
+
+    q0.Normalize();
+    q1.Normalize();
+
+    UsdStageWeakPtr stage = jointPrim.GetPrim().GetStage();
+
+    // get scale and apply it into localPositions vectors
+    if (jointDesc->rel0 != SdfPath())
+    {
+        jointDesc->body0 = GetLocalPose(stage, jointDesc->rel0, t0, q0);
+    }
+
+    if (jointDesc->rel1 != SdfPath())
+    {
+        jointDesc->body1 = GetLocalPose(stage, jointDesc->rel1, t1, q1);
+    }
+
+    jointDesc->localPose0Position = t0;
+    jointDesc->localPose0Orientation = q0;
+    jointDesc->localPose1Position = t1;
+    jointDesc->localPose1Orientation = q1;
+}
+
+bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, JointDesc* jointDesc)
+{
+    const UsdPrim prim = jointPrim.GetPrim();
+
+    jointDesc->primPath = prim.GetPrimPath();
+
+    // parse the joint common parameters
+    jointPrim.GetJointEnabledAttr().Get(&jointDesc->jointEnabled);
+    jointPrim.GetCollisionEnabledAttr().Get(&jointDesc->collisionEnabled);
+    jointPrim.GetBreakForceAttr().Get(&jointDesc->breakForce);            
+    jointPrim.GetBreakTorqueAttr().Get(&jointDesc->breakTorque);
+    jointPrim.GetExcludeFromArticulationAttr().Get(&jointDesc->excludeFromArticulation);
+
+    jointDesc->rel0 = GetRel(jointPrim.GetBody0Rel(), prim);
+    jointDesc->rel1 = GetRel(jointPrim.GetBody1Rel(), prim);
+
+    // check rel validity
+    if (!CheckJointRel(jointDesc->rel0, prim) || !CheckJointRel(jointDesc->rel1, prim))
+    {
+        return false;
+    }
+
+    FinalizeJoint(jointPrim, jointDesc);
+
+    return true;
+}
+
+bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint, DistanceJointDesc* distanceJointDesc)
+{
+    if (distanceJointDesc && distanceJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(distanceJoint, distanceJointDesc))
+        {
+            return false;
+        }
+
+        distanceJointDesc->maxEnabled = false;
+        distanceJointDesc->minEnabled = false;
+        distanceJoint.GetMinDistanceAttr().Get(&distanceJointDesc->limit.minDist);
+        distanceJoint.GetMaxDistanceAttr().Get(&distanceJointDesc->limit.maxDist);
+            
+        if (distanceJointDesc->limit.minDist >= 0.0f)
+        {
+            distanceJointDesc->minEnabled = true;
+                
+        }
+        if (distanceJointDesc->limit.maxDist >= 0.0f)
+        {
+            distanceJointDesc->maxEnabled = true;
+                
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsDistanceJoint or DistanceJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseDrive(const UsdPhysicsDriveAPI& drive, JointDrive* jointDrive)
+{
+    if (drive && jointDrive)
+    {
+        drive.GetTargetPositionAttr().Get(&jointDrive->targetPosition);
+        drive.GetTargetVelocityAttr().Get(&jointDrive->targetVelocity);
+        drive.GetMaxForceAttr().Get(&jointDrive->forceLimit);    
+
+        drive.GetDampingAttr().Get(&jointDrive->damping);
+        drive.GetStiffnessAttr().Get(&jointDrive->stiffness);    
+
+        TfToken typeToken;
+        drive.GetTypeAttr().Get(&typeToken);
+        if (typeToken == UsdPhysicsTokens->acceleration)
+            jointDrive->acceleration = true;
+        jointDrive->enabled = true;
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsDriveAPI or JointDrive is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint, FixedJointDesc* fixedJointDesc)
+{
+    if (fixedJointDesc && fixedJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(fixedJoint, fixedJointDesc))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsFixedJoint or FixedJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseLimit(const UsdPhysicsLimitAPI& limit, JointLimit* jointLimit)
+{
+    if (limit && jointLimit)
+    {
+        limit.GetLowAttr().Get(&jointLimit->lower);
+        limit.GetHighAttr().Get(&jointLimit->upper);
+        if ((isfinite(jointLimit->lower) && jointLimit->lower > -physicsSentinelLimit) ||
+            (isfinite(jointLimit->upper) && jointLimit->upper < physicsSentinelLimit))
+                jointLimit->enabled = true;
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsLimitAPI or JointLimit is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, D6JointDesc* jointDesc)
+{    
+    if (jointDesc && jointPrim)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(jointPrim, jointDesc))
+        {
+            return false;
+        }
+
+        // D6 joint        
+        const std::array<std::pair<PhysicsJointDOF::Enum, TfToken>, 7> axisVector = {
+            std::make_pair(PhysicsJointDOF::eDistance, UsdPhysicsTokens->distance), std::make_pair(PhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
+            std::make_pair(PhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),     std::make_pair(PhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
+            std::make_pair(PhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),         std::make_pair(PhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
+            std::make_pair(PhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
+        };
+
+        for (size_t i = 0; i < axisVector.size(); i++)
+        {
+            const TfToken& axisToken = axisVector[i].second;
+
+            const UsdPhysicsLimitAPI limitAPI = UsdPhysicsLimitAPI::Get(jointPrim.GetPrim(), axisToken);
+            if (limitAPI)
+            {
+                JointLimit limit;
+                if (ParseLimit(limitAPI, &limit))
+                {
+                    jointDesc->jointLimits.push_back(std::make_pair(axisVector[i].first, limit));
+                }                
+            }
+
+            const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(jointPrim.GetPrim(), axisToken);
+            if (driveAPI)
+            {
+                JointDrive drive;
+                if (ParseDrive(driveAPI, &drive))
+                {
+                    jointDesc->jointDrives.push_back(std::make_pair(axisVector[i].first, drive));
+                }
+            }
+        }    
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or JointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim, CustomJointDesc* customJointDesc)
+{
+    if (customJointDesc && jointPrim)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(jointPrim, customJointDesc))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or JointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial, RigidBodyMaterialDesc* rbMaterialDesc)
+{
+    if (rbMaterialDesc && usdMaterial)
+    {       
+        usdMaterial.GetDynamicFrictionAttr().Get(&rbMaterialDesc->dynamicFriction);
+        usdMaterial.GetStaticFrictionAttr().Get(&rbMaterialDesc->staticFriction);
+
+        usdMaterial.GetRestitutionAttr().Get(&rbMaterialDesc->restitution);
+
+        usdMaterial.GetDensityAttr().Get(&rbMaterialDesc->density);            
+
+        rbMaterialDesc->primPath = usdMaterial.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsMaterialAPI or RigidBodyMaterialDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseLinearDrive(JointDrive* dst, const UsdPrim& usdPrim)
+{
+    dst->enabled = false;
+    const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->linear);
+    if (driveAPI)
+    {
+        return ParseDrive(driveAPI, dst);
+    }
+
+    return true;
+}
+
+
+bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, PrismaticJointDesc* prismaticJointDesc)
+{
+    if (prismaticJointDesc && prismaticJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(prismaticJoint, prismaticJointDesc))
+        {
+            return false;
+        }
+
+        PhysicsAxis::Enum jointAxis = PhysicsAxis::eX;
+        TfToken axis = UsdPhysicsTokens->x;            
+        prismaticJoint.GetAxisAttr().Get(&axis);
+
+        if (axis == UsdPhysicsTokens->y)
+            jointAxis = PhysicsAxis::eY;
+        else if (axis == UsdPhysicsTokens->z)
+            jointAxis = PhysicsAxis::eZ;
+        prismaticJointDesc->axis = jointAxis;
+
+        prismaticJointDesc->limit.enabled = false;
+        prismaticJoint.GetLowerLimitAttr().Get(&prismaticJointDesc->limit.lower);
+        prismaticJoint.GetUpperLimitAttr().Get(&prismaticJointDesc->limit.upper);
+        if ((isfinite(prismaticJointDesc->limit.lower) && (prismaticJointDesc->limit.lower > -physicsSentinelLimit)) || 
+            (isfinite(prismaticJointDesc->limit.upper) && (prismaticJointDesc->limit.upper < physicsSentinelLimit)))
+        {
+            prismaticJointDesc->limit.enabled = true;
+        }
+
+        if (!ParseLinearDrive(&prismaticJointDesc->drive, prismaticJoint.GetPrim()))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsPrismaticJoint or PrismaticJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseAngularDrive(JointDrive* dst, const UsdPrim& usdPrim)
+{
+    dst->enabled = false;
+    const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->angular);
+    if (driveAPI)
+    {
+        return ParseDrive(driveAPI, dst);
+    }
+
+    return true;
+}
+
+
+bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, RevoluteJointDesc* revoluteJointDesc)
+{
+    if (revoluteJointDesc && revoluteJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(revoluteJoint, revoluteJointDesc))
+        {
+            return false;
+        }
+
+        PhysicsAxis::Enum jointAxis = PhysicsAxis::eX;
+        TfToken axis = UsdPhysicsTokens->x;
+        revoluteJoint.GetAxisAttr().Get(&axis);
+
+        if (axis == UsdPhysicsTokens->y)
+            jointAxis = PhysicsAxis::eY;
+        else if (axis == UsdPhysicsTokens->z)
+            jointAxis = PhysicsAxis::eZ;
+        revoluteJointDesc->axis = jointAxis;
+
+        revoluteJointDesc->limit.enabled = false;
+
+        
+        revoluteJoint.GetLowerLimitAttr().Get(&revoluteJointDesc->limit.lower);
+        revoluteJoint.GetUpperLimitAttr().Get(&revoluteJointDesc->limit.upper);
+        if (isfinite(revoluteJointDesc->limit.lower) && isfinite(revoluteJointDesc->limit.upper)
+            && revoluteJointDesc->limit.lower > -physicsSentinelLimit && revoluteJointDesc->limit.upper < physicsSentinelLimit)
+        {
+            revoluteJointDesc->limit.enabled = true;
+        }
+
+        if (!ParseAngularDrive(&revoluteJointDesc->drive, revoluteJoint.GetPrim()))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or JointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+template<typename T>
+inline bool ScaleIsUniform(T scaleX, T scaleY, T scaleZ, T eps = T(1.0e-5))
+{
+    // Find min and max scale values
+    T lo, hi;
+
+    if (scaleX < scaleY)
+    {
+        lo = scaleX;
+        hi = scaleY;
+    }
+    else
+    {
+        lo = scaleY;
+        hi = scaleX;
+    }
+    
+    if (scaleZ < lo)
+    {
+        lo = scaleZ;
+    }
+    else if (scaleZ > hi)
+    {
+        hi = scaleZ;
+    }
+    
+    if (lo*hi < 0.0)
+    {
+        return false;   // opposite signs
+    }
+
+    return hi > 0.0 ? hi - lo <= eps*lo : lo - hi >= eps*hi;
+}
+
+
+void GetRigidBodyTransformation(const UsdPrim& bodyPrim, RigidBodyDesc& desc)
+{
+    const GfMatrix4d mat = UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+    const GfTransform tr(mat);
+    const GfVec3d pos = tr.GetTranslation();
+    const GfQuatd rot = tr.GetRotation().GetQuat();
+    const GfVec3d sc = tr.GetScale();
+
+    if (!ScaleIsUniform(sc[0], sc[1], sc[2]) && tr.GetScaleOrientation().GetQuaternion() != GfQuaternion::GetIdentity())
+    {
+        TF_DIAGNOSTIC_WARNING("ScaleOrientation is not supported for rigid bodies, prim path: %s. You may ignore this if the scale is close to uniform.", bodyPrim.GetPrimPath().GetText());
+    }
+
+    desc.position = GfVec3f(pos);
+    desc.rotation = GfQuatf(rot);
+    desc.scale = GfVec3f(sc);
+}
+
+bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI, RigidBodyDesc* rigidBodyDesc)
+{
+    if (rigidBodyDesc && rigidBodyAPI)
+    {       
+        if (!rigidBodyAPI.GetPrim().IsA<UsdGeomXformable>())
+        {
+            TF_DIAGNOSTIC_WARNING("RigidBodyAPI applied to a non-xformable primitive. (%s)", rigidBodyAPI.GetPrim().GetPrimPath().GetText());
+            return false;
+        }
+
+        // check instancing
+        {
+            bool reportInstanceError = false;
+            if (rigidBodyAPI.GetPrim().IsInstanceProxy())
+            {
+                reportInstanceError = true;
+
+                bool kinematic = false;
+                rigidBodyAPI.GetKinematicEnabledAttr().Get(&kinematic);
+                if (kinematic)
+                    reportInstanceError = false;
+
+                bool enabled = false;
+                rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&enabled);
+                if (!enabled)
+                    reportInstanceError = false;
+
+                if (reportInstanceError)
+                {
+                    TF_DIAGNOSTIC_WARNING("RigidBodyAPI on an instance proxy not supported. %s", rigidBodyAPI.GetPrim().GetPrimPath().GetText());
+                    return false;
+                }
+            }
+        }
+
+        // transformation
+        GetRigidBodyTransformation(rigidBodyAPI.GetPrim(), *rigidBodyDesc);
+
+        // filteredPairs
+        ParseFilteredPairs(rigidBodyAPI.GetPrim(), rigidBodyDesc->filteredCollisions);
+
+        // velocity
+        rigidBodyAPI.GetVelocityAttr().Get(&rigidBodyDesc->linearVelocity);
+        rigidBodyAPI.GetAngularVelocityAttr().Get(&rigidBodyDesc->angularVelocity);
+
+        // rigid body flags
+        rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&rigidBodyDesc->rigidBodyEnabled);
+        rigidBodyAPI.GetKinematicEnabledAttr().Get(&rigidBodyDesc->kinematicBody);
+        rigidBodyAPI.GetStartsAsleepAttr().Get(&rigidBodyDesc->startsAsleep);
+
+        // simulation owner
+        const UsdRelationship ownerRel = rigidBodyAPI.GetSimulationOwnerRel();
+        if (ownerRel)
+        {
+            SdfPathVector owners;
+            ownerRel.GetTargets(&owners);
+            if (!owners.empty())
+            {
+                rigidBodyDesc->simulationOwners = owners;
+            }
+        }
+        rigidBodyDesc->primPath = rigidBodyAPI.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsRigidBodyAPI or RigidBodyDesc is not valid.");
+        return false;
+
+    }
+    return true;
+}
+
+bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint, SphericalJointDesc* sphericalJointDesc)
+{
+    if (sphericalJointDesc && sphericalJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(sphericalJoint, sphericalJointDesc))
+        {
+            return false;
+        }
+
+        PhysicsAxis::Enum jointAxis = PhysicsAxis::eX;
+        TfToken axis = UsdPhysicsTokens->x;
+        sphericalJoint.GetAxisAttr().Get(&axis);
+
+        if (axis == UsdPhysicsTokens->y)
+            jointAxis = PhysicsAxis::eY;
+        else if (axis == UsdPhysicsTokens->z)
+            jointAxis = PhysicsAxis::eZ;
+        sphericalJointDesc->axis = jointAxis;
+
+        sphericalJointDesc->limit.enabled = false;
+        sphericalJoint.GetConeAngle0LimitAttr().Get(&sphericalJointDesc->limit.angle0);
+        sphericalJoint.GetConeAngle1LimitAttr().Get(&sphericalJointDesc->limit.angle1);
+
+        if (isfinite(sphericalJointDesc->limit.angle0) && isfinite(sphericalJointDesc->limit.angle1)
+            && sphericalJointDesc->limit.angle0 >= 0.0 && sphericalJointDesc->limit.angle1 >= 0.0)
+        {
+            sphericalJointDesc->limit.enabled = true;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsSphericalJoint or SphericalJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
+}
+
+bool ParseSceneDesc(const UsdPhysicsScene& scene, SceneDesc* sceneDesc)
+{
+    if (sceneDesc && scene)
+    {
+        UsdStageWeakPtr stage = scene.GetPrim().GetStage();
+
+        GfVec3f gravityDirection;
+        scene.GetGravityDirectionAttr().Get(&gravityDirection);
+        if (gravityDirection == GfVec3f(0.0f))
+        {
+            TfToken upAxis = pxr::UsdGeomGetStageUpAxis(stage);
+            if (upAxis == pxr::UsdGeomTokens.Get()->x)
+                gravityDirection = GfVec3f(-1.0f, 0.0f, 0.0f);
+            else if (upAxis == pxr::UsdGeomTokens.Get()->y)
+                gravityDirection = GfVec3f(0.0f, -1.0f, 0.0f);
+            else
+                gravityDirection = GfVec3f(0.0f, 0.0f, -1.0f);
+        }
+        else
+        {
+            gravityDirection.Normalize();
+        }
+
+        float gravityMagnitude;
+        scene.GetGravityMagnitudeAttr().Get(&gravityMagnitude);
+        if (gravityMagnitude < -0.5e38f)
+        {
+            float metersPerUnit = (float)pxr::UsdGeomGetStageMetersPerUnit(stage);
+            gravityMagnitude = 9.81f / metersPerUnit;
+        }
+
+        sceneDesc->gravityMagnitude = gravityMagnitude;
+        sceneDesc->gravityDirection = gravityDirection;
+        sceneDesc->primPath = scene.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsScene or SceneDesc is not valid.");
+        return false;
+    }
+    return true;
+}
+
+struct SchemaAPIFlag
+{
+    enum Enum
+    {
+        eArticulationRootAPI = 1 << 0,
+        eCollisionAPI   = 1 << 1,
+        eRigidBodyAPI   = 1 << 2,
+        eMaterialAPI    = 1 << 3
+    };
+};
+
+bool CheckNestedArticulationRoot(const pxr::UsdPrim& usdPrim, const std::unordered_set<SdfPath, SdfPath::Hash>& articulationSet)
+{
+    UsdPrim parent = usdPrim.GetParent();
+    while (parent && parent != usdPrim.GetStage()->GetPseudoRoot())
+    {
+        if (articulationSet.find(parent.GetPrimPath()) != articulationSet.end())
+            return true;
+        parent = parent.GetParent();
+    }
+
+    return false;
+}
+
+using RigidBodyMap = std::map<pxr::SdfPath, RigidBodyDesc*>;
+
+bool IsDynamicBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, bool& physicsAPIFound)
+{
+    RigidBodyMap::const_iterator it = bodyMap.find(usdPrim.GetPrimPath());
+    if (it != bodyMap.end())
+    {
+        {
+            bool isAPISchemaEnabled = it->second->rigidBodyEnabled;
+
+            // Prim is dynamic body off PhysicsAPI is present and enabled
+            physicsAPIFound = true;
+            return isAPISchemaEnabled;
+        }
+    }
+
+    physicsAPIFound = false;
+    return false;
+}
+
+
+bool HasDynamicBodyParent(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, UsdPrim& bodyPrimPath)
+{
+    bool physicsAPIFound = false;    
+    UsdPrim parent = usdPrim;
+    while (parent != usdPrim.GetStage()->GetPseudoRoot())
+    {
+        if (IsDynamicBody(parent, bodyMap, physicsAPIFound))
+        {
+            bodyPrimPath = parent;
+            return true;
+        }
+
+        if (physicsAPIFound)
+        {
+            bodyPrimPath = parent;
+            return false;
+        }
+
+        parent = parent.GetParent();
+    }
+    return false;
+}
+
+template <typename DescType, typename UsdType> 
+void ProcessPhysicsPrims(const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc, 
+    std::function<bool(const UsdType& prim, DescType* desc)> processDescFn)
+{
+    if (!physicsPrims.empty())
+    {
+        physicsDesc.resize(physicsPrims.size());
+        for (size_t i = 0; i < physicsPrims.size(); i++)
+        {
+            const UsdType prim(physicsPrims[i]);
+            const bool ret = processDescFn(prim, &physicsDesc[i]);
+            if (!ret)
+            {
+                physicsDesc[i].isValid = false;
+            }
+        }
+    }
+}
+
+template <typename DescType> 
+void CallReportFn(PhysicsObjectType::Enum descType, const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc, 
+    UsdPhysicsReportFn reportFn, SdfPathVector& primPathsVector, void* userData)
+{
+    primPathsVector.resize(physicsPrims.size());
+    for (size_t i = 0; i < physicsPrims.size(); i++)
+    {
+        primPathsVector[i] = physicsPrims[i].GetPrimPath();
+    }
+    reportFn(descType, primPathsVector.size(), primPathsVector.data(), physicsDesc.data(), userData);
+}
+
+void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims, std::vector<RigidBodyDesc>& rigidBodyDescs, 
+    bool defaultSimulationOwner, std::unordered_set<SdfPath, SdfPath::Hash>& reportedBodies,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+    for (size_t i = rigidBodyDescs.size(); i--;)
+    {
+        bool ownerFound = false;
+        const RigidBodyDesc& desc = rigidBodyDescs[i];
+        if (desc.isValid)
+        {
+            if (desc.simulationOwners.empty() && defaultSimulationOwner)
+            {                
+                reportedBodies.insert(desc.primPath);
+                ownerFound = true;
+            }
+            else
+            {
+                for (const SdfPath& owner : desc.simulationOwners)
+                {
+                    if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+                    {
+                        reportedBodies.insert(desc.primPath);
+                        ownerFound = true;
+                        break;
+                    }
+                }
+            }
+        }
+        if (!ownerFound)
+        {
+            rigidBodyDescs[i] = rigidBodyDescs.back();
+            rigidBodyDescs.pop_back();
+            rigidBodyPrims[i] = rigidBodyPrims.back();
+            rigidBodyPrims.pop_back();
+        }
+    }    
+}
+
+// if collision belongs to a body that we care about include it
+// if collision does not belong to a body we care about its not included
+// if collision does not have a body set, we check its own simulationOwners
+template <typename DescType> 
+void CheckCollisionSimulationOwner(std::vector<UsdPrim>& collisionPrims, std::vector<DescType>& shapeDesc, 
+    bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+    for (size_t i = shapeDesc.size(); i--;)
+    {
+        bool ownerFound = false;
+        const ShapeDesc& desc = shapeDesc[i];
+        if (desc.isValid)
+        {
+            if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+            {        if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+        {
+            ownerFound = true;
+        }
+        else
+        {
+            if (desc.rigidBody == SdfPath())
+            {
+                if (desc.simulationOwners.empty() && defaultSimulationOwner)
+                {                
+                    ownerFound = true;
+                }
+                else
+                {
+                    for (const SdfPath& owner : desc.simulationOwners)
+                    {
+                        if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+                        {
+                            ownerFound = true;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+                ownerFound = true;
+            }
+            else
+            {
+                if (desc.rigidBody == SdfPath())
+                {
+                    if (desc.simulationOwners.empty() && defaultSimulationOwner)
+                    {                
+                        ownerFound = true;
+                    }
+                    else
+                    {
+                        for (const SdfPath& owner : desc.simulationOwners)
+                        {
+                            if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+                            {
+                                ownerFound = true;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!ownerFound)
+        {
+            shapeDesc[i] = shapeDesc.back();
+            shapeDesc.pop_back();
+            collisionPrims[i] = collisionPrims.back();
+            collisionPrims.pop_back();
+        }
+    }        
+}
+
+// Both bodies need to have simulation owners valid
+template <typename DescType> 
+void CheckJointSimulationOwner(std::vector<UsdPrim>& jointPrims, std::vector<DescType>& jointDesc, 
+    bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+    for (size_t i = jointDesc.size(); i--;)
+    {
+        const JointDesc& desc = jointDesc[i];
+
+        bool ownersValid = false;
+        if (desc.isValid)
+        {
+            if ((desc.body0 == SdfPath() || rigidBodiesSet.find(desc.body0) != rigidBodiesSet.end()) &&
+                (desc.body1 == SdfPath() || rigidBodiesSet.find(desc.body1) != rigidBodiesSet.end()))
+                {
+                    ownersValid = true;
+                }
+        }
+
+        if (!ownersValid)
+        {
+            jointDesc[i] = jointDesc.back();
+            jointDesc.pop_back();
+            jointPrims[i] = jointPrims.back();
+            jointPrims.pop_back();
+        }
+    }
+}
+
+// all bodies must have valid owner
+void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims, std::vector<ArticulationDesc>& articulationDescs, 
+    bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+    for (size_t i = articulationDescs.size(); i--;)
+    {
+        const ArticulationDesc& desc = articulationDescs[i];
+
+        bool ownersValid = true;
+        if (desc.isValid)
+        {
+            for (const SdfPath& body : desc.articulatedBodies)
+            {
+                if (body != SdfPath() && rigidBodiesSet.find(body) == rigidBodiesSet.end())
+                {
+                    ownersValid = false;
+                    break;
+                }
+            }
+        }
+
+        if (!ownersValid)
+        {
+            articulationDescs[i] = articulationDescs.back();
+            articulationDescs.pop_back();
+            articulationPrims[i] = articulationPrims.back();
+            articulationPrims.pop_back();
+        }
+    }   
+}
+
+SdfPath GetRigidBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap)
+{
+    UsdPrim bodyPrim = UsdPrim();
+    RigidBodyDesc* body = nullptr;
+    if (HasDynamicBodyParent(usdPrim, bodyMap, bodyPrim))
+    {
+       return bodyPrim.GetPrimPath();
+    }
+    else
+    {
+        // collision does not have a dynamic body parent, it is considered a static collision        
+        if (bodyPrim == UsdPrim())
+        {
+            return SdfPath();
+        }
+        else
+        {
+            return bodyPrim.GetPrimPath();
+        }
+    }
+}
+
+void GetCollisionShapeLocalTransfrom(UsdGeomXformCache& xfCache, const UsdPrim& collisionPrim, const UsdPrim& bodyPrim,
+                                            GfVec3f& localPosOut,
+                                            GfQuatf& localRotOut,
+                                            GfVec3f& localScaleOut)
+{
+    // compute the shape rel transform to a body and store it.
+    pxr::GfVec3f localPos(0.0f);
+    if (collisionPrim != bodyPrim)
+    {
+        bool resetXformStack;
+        const pxr::GfMatrix4d mat = xfCache.ComputeRelativeTransform(collisionPrim, bodyPrim, &resetXformStack);
+        GfTransform colLocalTransform(mat);
+
+        localPos = pxr::GfVec3f(colLocalTransform.GetTranslation());
+        localRotOut = pxr::GfQuatf(colLocalTransform.GetRotation().GetQuat());
+        localScaleOut = pxr::GfVec3f(colLocalTransform.GetScale());
+    }
+    else
+    {
+        const pxr::GfMatrix4d mat(1.0);
+
+        localRotOut = pxr::GfQuatf(1.0f);
+        localScaleOut = pxr::GfVec3f(1.0f);
+    }
+
+    // now apply the body scale to localPos
+    // physics does not support scales, so a rigid body scale has to be baked into the localPos
+    const pxr::GfTransform tr(xfCache.GetLocalToWorldTransform(bodyPrim));
+    const pxr::GfVec3d sc = tr.GetScale();
+
+    for (int i = 0; i < 3; i++)
+    {
+        localPos[i] *= (float)sc[i];
+    }
+
+    localPosOut = localPos;
+}
+
+void FinalizeCollision(UsdStageWeakPtr stage, UsdGeomXformCache& xfCache, const RigidBodyDesc* bodyDesc, ShapeDesc* shapeDesc)
+{
+    // get shape local pose
+    const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
+    GetCollisionShapeLocalTransfrom(xfCache, shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
+        shapeDesc->localPos, shapeDesc->localRot, shapeDesc->localScale);
+
+    if (bodyDesc)
+    {
+        shapeDesc->rigidBody = bodyDesc->primPath;
+    }
+}
+
+
+
+template <typename DescType> 
+void FinalizeCollisionDescs(UsdGeomXformCache& xfCache, const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc, 
+    RigidBodyMap& bodyMap, const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
+{
+    for (size_t i = 0; i < physicsDesc.size(); i++)
+    {
+        DescType& colDesc = physicsDesc[i];
+        if (colDesc.isValid)
+        {
+            const UsdPrim prim = physicsPrims[i];
+            // get the body
+            SdfPath bodyPath = GetRigidBody(prim, bodyMap);
+            // body was found, add collision to the body
+            RigidBodyDesc* bodyDesc = nullptr;
+            if (bodyPath != SdfPath())
+            {
+                RigidBodyMap::iterator bodyIt = bodyMap.find(bodyPath);
+                if (bodyIt != bodyMap.end())
+                {
+                    bodyDesc = bodyIt->second;
+                    bodyDesc->collisions.push_back(colDesc.primPath);
+                }
+            }
+
+            // check if collision belongs to collision groups
+            for (std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
+             it != collisionGroups.end(); ++it)
+            {
+                if (it->second.find(colDesc.primPath) != it->second.end())
+                {
+                    colDesc.collisionGroups.push_back(it->first);
+                }
+            }
+
+            // finalize the collision, fill up the local transform etc
+            FinalizeCollision(prim.GetStage(), xfCache, bodyDesc, &colDesc);
+        }
+    }
+}
+
+struct ArticulationLink
+{ 
+    SdfPathVector   childs;
+    SdfPath         rootJoint;
+    uint32_t        weight;
+    uint32_t        index;
+    bool            hasFixedJoint;
+    SdfPathVector   joints;
+};
+
+using ArticulationLinkMap = std::map<pxr::SdfPath, ArticulationLink>;
+using BodyJointMap = pxr::TfHashMap<pxr::SdfPath, std::vector<const JointDesc*>, pxr::SdfPath::Hash>;
+using JointMap = std::map<pxr::SdfPath, JointDesc*>;
+using ArticulationMap = std::map<pxr::SdfPath, ArticulationDesc*>;
+
+bool IsInLinkMap(const SdfPath& path, const std::vector<ArticulationLinkMap>& linkMaps)
+{
+    for (size_t i = 0; i < linkMaps.size(); i++)
+    {
+        ArticulationLinkMap::const_iterator it = linkMaps[i].find(path);
+        if (it != linkMaps[i].end())
+            return true;
+    }
+
+    return false;
+}
+
+void TraverseHierarchy(const pxr::UsdStageWeakPtr stage, const SdfPath& linkPath, ArticulationLinkMap& articulationLinkMap, const BodyJointMap& bodyJointMap, uint32_t& index, SdfPathVector& linkOrderVector)
+{
+    // check if we already parsed this link
+    ArticulationLinkMap::const_iterator artIt = articulationLinkMap.find(linkPath);
+    if (artIt != articulationLinkMap.end())
+        return;
+
+    linkOrderVector.push_back(linkPath);
+
+    BodyJointMap::const_iterator bjIt = bodyJointMap.find(linkPath);
+    if (bjIt != bodyJointMap.end())
+    {
+        ArticulationLink& link = articulationLinkMap[linkPath];
+        link.weight = 0;
+        link.index = index++;
+        link.hasFixedJoint = false;
+        const std::vector<const JointDesc*>& joints = bjIt->second;
+        for (size_t i = 0; i < joints.size(); i++)
+        {            
+            const JointDesc* desc = joints[i];
+            link.joints.push_back(desc->primPath);
+            if (desc->body0 == SdfPath() || (bodyJointMap.find(desc->body0) == bodyJointMap.end()) ||
+                desc->body1 == SdfPath() || (bodyJointMap.find(desc->body1) == bodyJointMap.end()))
+            {
+                if (desc->excludeFromArticulation)
+                {
+                    link.weight += 1000;
+                }
+                else
+                {
+                    link.weight += 100000;
+                    link.rootJoint = desc->primPath;
+                    link.hasFixedJoint = true;
+                }                
+                link.childs.push_back(SdfPath());                                
+            }
+            else
+            {
+                if (desc->excludeFromArticulation)
+                {
+                    link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
+                    link.weight += 1000;
+                }
+                else
+                {
+                    link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
+                    link.weight += 100;
+                    TraverseHierarchy(stage, link.childs.back(), articulationLinkMap, bodyJointMap, index, linkOrderVector);
+                }
+            }
+        }
+    }
+}
+
+void TraverseChilds(const ArticulationLink& link, const ArticulationLinkMap& map, uint32_t startIndex, uint32_t distance, int32_t* pathMatrix)
+{
+    const size_t mapSize = map.size();
+    const uint32_t currentIndex = link.index;
+    pathMatrix[startIndex + currentIndex * mapSize] = distance;
+
+    for (size_t i = 0; i < link.childs.size(); i++)
+    {
+        ArticulationLinkMap::const_iterator it = map.find(link.childs[i]);
+        if (it != map.end())
+        {
+            const uint32_t childIndex = it->second.index;
+            if (pathMatrix[startIndex + childIndex * mapSize] < 0)
+            {
+                TraverseChilds(it->second, map, startIndex, distance + 1, pathMatrix);
+            }
+        }        
+    }
+}
+
+pxr::SdfPath GetCenterOfGraph(const ArticulationLinkMap& map, const SdfPathVector& linkOrderVector)
+{
+    const size_t size = map.size();
+    int32_t* pathMatrix = new int32_t[size * size];
+    for (size_t i = 0; i < size; i ++)
+    {
+        for (size_t j = 0; j < size; j++)
+        {
+            pathMatrix [i + j * size] = -1;
+        }
+    }
+
+    for (ArticulationLinkMap::const_reference& ref : map)
+    {
+        const uint32_t startIndex = ref.second.index;
+        uint32_t distance = 0;
+        TraverseChilds(ref.second, map, startIndex, distance, pathMatrix);
+    }
+
+    int32_t shortestDistance = INT_MAX;
+    size_t numChilds = 0;
+    SdfPath primpath = SdfPath();
+    for (ArticulationLinkMap::const_reference& ref : map)
+    {
+        const uint32_t startIndex = ref.second.index;
+        int32_t longestPath = 0;
+        for (size_t i = 0; i < size; i++)
+        {
+            if (pathMatrix[startIndex + i * size] > longestPath)
+            {
+                longestPath = pathMatrix[startIndex + i * size];
+            }
+        }
+
+        // this needs to be deterministic, get the shortest path
+        // if there are more paths with same lenght, pick the one with more childs
+        // if there are more with same path and same amount of childs, pick the one with lowest hash
+        // The lowest hash is not right, this is wrong, it has to be the first link ordered by the traversal
+        if (longestPath < shortestDistance)
+        {
+            shortestDistance = longestPath;
+            numChilds = ref.second.childs.size();
+            primpath = ref.first;
+        }
+        else if (longestPath == shortestDistance)
+        {
+            if (numChilds < ref.second.childs.size())
+            {
+                numChilds = ref.second.childs.size();
+                primpath = ref.first;
+            }
+            else if (numChilds == ref.second.childs.size())
+            {
+                for (const SdfPath& orderPath : linkOrderVector)
+                {
+                    if (orderPath == primpath)
+                    {
+                        break;
+                    }
+                    else if (orderPath == ref.first)
+                    {
+                        primpath = ref.first;
+                    }
+                }
+            }
+        }
+    }
+
+    delete [] pathMatrix;
+
+    return primpath;
+}
+
+void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& articulationMap, const RigidBodyMap& rigidBodyMap, const JointMap& jointMap)
+{
+    BodyJointMap bodyJointMap;
+    if (!articulationMap.empty())
+    {
+        // construct the BodyJointMap
+        bodyJointMap.reserve(rigidBodyMap.size());
+        for (JointMap::const_reference& jointIt : jointMap)
+        {
+            const JointDesc* desc = jointIt.second;
+            if (desc->jointEnabled)
+            {
+                if (desc->body0 != SdfPath())
+                {
+                    RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body0);
+                    if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled && !fit->second->kinematicBody)
+                    {
+                        bodyJointMap[desc->body0].push_back(desc);
+                    }                    
+                }
+                if (desc->body1 != SdfPath())
+                {
+                    RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body1);
+                    if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled && !fit->second->kinematicBody)
+                    {
+                        bodyJointMap[desc->body1].push_back(desc);
+                    }
+                }
+            }
+        }
+    }
+
+    SdfPathVector articulationLinkOrderVector;
+
+    // first get user defined articulation roots
+    // then search for the best root in the articulation hierarchy
+    for (ArticulationMap::const_reference& it : articulationMap)
+    {
+        const SdfPath& articulationPath = it.first;
+        SdfPath articulationBaseLinkPath = articulationPath;
+
+        std::set<SdfPath> articulatedJoints;
+        std::set<SdfPath> articulatedBodies;
+
+        // check if its a floating articulation
+        {
+            RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(articulationPath);
+            if (bodyIt != rigidBodyMap.end())
+            {
+                if (!bodyIt->second->rigidBodyEnabled)
+                {
+                    TF_DIAGNOSTIC_WARNING(
+                        "ArticulationRootAPI definition on a static rigid body is not allowed, articulation root will be ignored. Prim: %s",
+                        articulationPath.GetText());
+                    continue;
+                }
+                if (bodyIt->second->kinematicBody)
+                {
+                    TF_DIAGNOSTIC_WARNING(
+                        "ArticulationRootAPI definition on a kinematic rigid body is not allowed, articulation root will be ignored. Prim: %s",
+                        articulationPath.GetText());
+                    continue;
+                }
+                it.second->rootPrims.push_back(bodyIt->first);
+            }
+            else
+            {
+                JointMap::const_iterator jointIt = jointMap.find(articulationPath);
+                if (jointIt != jointMap.end())
+                {
+                    const SdfPath& jointPath = jointIt->first;
+                    const JointDesc* jointDesc = jointIt->second;
+                    if (jointDesc->body0 == SdfPath() || jointDesc->body1 == SdfPath())
+                    {                        
+                        it.second->rootPrims.push_back(jointPath);
+                        articulationBaseLinkPath = jointDesc->body0 == SdfPath() ? jointDesc->body1 : jointDesc->body0;
+                    }
+                }
+            }
+        }
+
+        // search through the hierarchy for the best root        
+        const UsdPrim articulationPrim = stage->GetPrimAtPath(articulationBaseLinkPath);        
+        if (!articulationPrim)
+            continue;        
+        UsdPrimRange range(articulationPrim, UsdTraverseInstanceProxies());
+        std::vector<ArticulationLinkMap> articulationLinkMaps;
+        articulationLinkOrderVector.clear();
+
+        for (pxr::UsdPrimRange::const_iterator iter = range.begin(); iter != range.end(); ++iter)
+        {
+            const pxr::UsdPrim& prim = *iter;
+            if (!prim)
+                continue;
+            const SdfPath primPath = prim.GetPrimPath();            
+            if (IsInLinkMap(primPath, articulationLinkMaps))
+            {
+                iter.PruneChildren(); // Skip the subtree rooted at this prim
+                continue;
+            }
+
+            RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(primPath);
+            if (bodyIt != rigidBodyMap.end())
+            {
+                articulationLinkMaps.push_back(ArticulationLinkMap());
+                uint32_t index = 0;
+                TraverseHierarchy(stage, primPath, articulationLinkMaps.back(), bodyJointMap, index, articulationLinkOrderVector);
+            }
+        }
+
+        if (it.second->rootPrims.empty())
+        {
+            for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+            {
+                const ArticulationLinkMap& map = articulationLinkMaps[i];
+                SdfPath linkPath = SdfPath();
+                uint32_t largestWeight = 0;
+                bool hasFixedJoint = false;
+                for (ArticulationLinkMap::const_reference& linkIt : map)
+                {
+                    if (linkIt.second.hasFixedJoint)
+                    {
+                        hasFixedJoint = true;
+                    }
+                    if (linkIt.second.weight > largestWeight)
+                    {
+                        linkPath = (linkIt.second.rootJoint != SdfPath()) ? linkIt.second.rootJoint : linkIt.first;
+                        largestWeight = linkIt.second.weight;
+                    }
+                    else if (linkIt.second.weight == largestWeight)
+                    {
+                        const SdfPath optionalLinkPath = (linkIt.second.rootJoint != SdfPath()) ? linkIt.second.rootJoint : linkIt.first;
+                        for (const SdfPath& orderPath : articulationLinkOrderVector)
+                        {
+                            if (orderPath == linkPath)
+                            {
+                                break;
+                            }
+                            else if (orderPath == optionalLinkPath)
+                            {
+                                linkPath = optionalLinkPath;
+                            }
+                        }
+                    }
+
+                    for (size_t j = linkIt.second.joints.size(); j--;)
+                    {
+                        articulatedJoints.insert(linkIt.second.joints[j]);
+                    }
+                }
+
+                // for floating articulation lets find the body with the shortest paths (center of graph)
+                if (!hasFixedJoint)
+                {
+                    linkPath = GetCenterOfGraph(map, articulationLinkOrderVector);
+                }
+
+                if (linkPath != SdfPath())
+                {
+                    it.second->rootPrims.push_back(linkPath);
+                }
+            }
+        }
+        else
+        {
+            for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+            {
+                const ArticulationLinkMap& map = articulationLinkMaps[i];
+                SdfPath linkPath = SdfPath();
+                uint32_t largestWeight = 0;
+                bool hasFixedOrLoopJoint = false;
+                for (ArticulationLinkMap::const_reference& linkIt : map)
+                {
+                    for (size_t j = linkIt.second.joints.size(); j--;)
+                    {
+                        articulatedJoints.insert(linkIt.second.joints[j]);
+                    }
+                }
+            }
+        }
+        for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+        {
+            const ArticulationLinkMap& map = articulationLinkMaps[i];
+            for (ArticulationLinkMap::const_reference& linkIt : map)
+            {
+                articulatedBodies.insert(linkIt.second.childs.begin(), linkIt.second.childs.end());
+            }
+        }
+
+        if (it.second->rootPrims.empty())
+        {
+            it.second->isValid = false;
+        }
+
+        for (const SdfPath& p : articulatedJoints)
+        {
+            it.second->articulatedJoints.push_back(p);
+        }
+        for (const SdfPath& p : articulatedBodies)
+        {
+            it.second->articulatedBodies.push_back(p);
+        }
+    }
+    
+}
+
+
+
+bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
+        ParsePrimIteratorBase& primIterator,
+        UsdPhysicsReportFn reportFn,
+        void* userData,
+        const CustomUsdPhysicsTokens* customPhysicsTokens,
+        const std::vector<SdfPath>* simulationOwners)
+{
+    bool retVal = true;
+
+    if (!stage)
+    {
+        TF_RUNTIME_ERROR("Provided stage not valid.");
+        return false;
+    }
+
+    if (!reportFn)
+    {
+        TF_RUNTIME_ERROR("Provided report callback is not valid.");
+        return false;
+    }
+    
+    
+    std::vector<UsdPrim> scenePrims;
+    std::vector<UsdPrim> collisionGroupPrims;
+    std::vector<UsdPrim> materialPrims;
+    std::vector<UsdPrim> articulationPrims;
+    std::unordered_set<SdfPath, SdfPath::Hash> articulationPathsSet;
+    std::vector<UsdPrim> physicsD6JointPrims;
+    std::vector<UsdPrim> physicsRevoluteJointPrims;
+    std::vector<UsdPrim> physicsFixedJointPrims;
+    std::vector<UsdPrim> physicsPrismaticJointPrims;
+    std::vector<UsdPrim> physicsSphericalJointPrims;
+    std::vector<UsdPrim> physicsDistanceJointPrims;
+    std::vector<UsdPrim> physicsCustomJointPrims;
+    std::vector<UsdPrim> collisionPrims;
+    std::vector<UsdPrim> rigidBodyPrims;
+
+    // parse for scene first, get the descriptors, report all prims
+    // the descriptors are not complete yet
+    primIterator.reset();
+
+    static const TfToken gRigidBodyAPIToken("PhysicsRigidBodyAPI");
+    static const TfToken gCollisionAPIToken("PhysicsCollisionAPI");
+    static const TfToken gArticulationRootAPIToken("PhysicsArticulationRootAPI");
+    static const TfToken gMaterialAPIToken("PhysicsMaterialAPI");
+
+    bool defaultSimulationOwner = false;
+    std::unordered_set<SdfPath, SdfPath::Hash> simulationOwnersSet;
+    if (simulationOwners)
+    {
+        for (const SdfPath& p : *simulationOwners)
+        {
+            if (p == SdfPath())
+            {
+                defaultSimulationOwner = true;                
+            }
+            else
+            {
+                simulationOwnersSet.insert(p);
+            }
+        }
+    }
+
+    while (!primIterator.atEnd())
+    {
+        const pxr::UsdPrim& prim = *primIterator.getCurrent();
+        if (!prim)
+        {
+            primIterator.pruneChildren();
+            primIterator.next();
+            continue;
+        }
+
+        const SdfPath primPath = prim.GetPrimPath();
+        const UsdPrimTypeInfo& typeInfo = prim.GetPrimTypeInfo();
+        PhysicsObjectDesc* reportDesc = nullptr;
+
+        uint64_t apiFlags = 0;
+        const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
+        for (const TfToken& token : apis)
+        {
+            if (token == gArticulationRootAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eArticulationRootAPI;
+            }
+            if (token == gCollisionAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eCollisionAPI;
+            }
+            if (token == gRigidBodyAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eRigidBodyAPI;
+            }
+            if (!apiFlags && token == gMaterialAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eMaterialAPI;
+            }
+        }
+
+        if (typeInfo.GetSchemaType().IsA<UsdGeomPointInstancer>())
+        {
+            primIterator.pruneChildren(); // Skip the subtree for point instancers, those have to be traversed per prototype
+        }
+        else if (customPhysicsTokens && !customPhysicsTokens->instancerTokens.empty())
+        {
+            for (const TfToken& instToken : customPhysicsTokens->instancerTokens)
+            {
+                if (instToken == typeInfo.GetTypeName())
+                {
+                    primIterator.pruneChildren(); // Skip the subtree for custom instancers, those have to be traversed per prototype
+                    break;
+                }
+            }                
+        }
+
+        if (typeInfo.GetSchemaType().IsA<UsdPhysicsScene>())
+        {
+            scenePrims.push_back(prim);
+        }
+        else if (typeInfo.GetSchemaType().IsA<UsdPhysicsCollisionGroup>())
+        {
+            collisionGroupPrims.push_back(prim);
+        }
+        else if (apiFlags & SchemaAPIFlag::eMaterialAPI)
+        {
+            materialPrims.push_back(prim);
+        }
+        else if (typeInfo.GetSchemaType().IsA<UsdPhysicsJoint>())
+        {
+            if (typeInfo.GetSchemaType().IsA<UsdPhysicsFixedJoint>())
+            {
+                physicsFixedJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsRevoluteJoint>())
+            {
+                physicsRevoluteJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsPrismaticJoint>())
+            {
+                physicsPrismaticJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsSphericalJoint>())
+            {
+                physicsSphericalJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsDistanceJoint>())
+            {
+                physicsDistanceJointPrims.push_back(prim);
+            }
+            else
+            {
+                bool customJoint = false;
+                if (customPhysicsTokens)
+                {
+                    const TfToken& primType = typeInfo.GetTypeName();
+                    for (size_t i = 0; i < customPhysicsTokens->jointTokens.size(); i++)
+                    {
+                        if (primType == customPhysicsTokens->jointTokens[i])
+                        {
+                            customJoint = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (customJoint)
+                {
+                    physicsCustomJointPrims.push_back(prim);
+                }
+                else
+                {
+                    physicsD6JointPrims.push_back(prim);
+                }
+            }
+
+
+            // can be articulation definition
+            if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
+            {
+                articulationPrims.push_back(prim);
+                articulationPathsSet.insert(prim.GetPrimPath());
+            }
+        }
+        else
+        {
+            if (apiFlags & SchemaAPIFlag::eCollisionAPI)
+            {
+                collisionPrims.push_back(prim);
+            }
+            if (apiFlags & SchemaAPIFlag::eRigidBodyAPI)
+            {
+                rigidBodyPrims.push_back(prim);
+            }
+            if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
+            {
+                articulationPrims.push_back(prim);
+                articulationPathsSet.insert(prim.GetPrimPath());
+            }
+        }
+
+        primIterator.next();
+    }
+
+    // process parsing
+    // 
+    // Scenes
+    std::vector<SceneDesc> sceneDescs;
+
+    // is simulation owners provided, restrict scenes to just the one specified
+    if (simulationOwners)
+    {
+        for (size_t i = scenePrims.size(); i--;)
+        {
+            const SdfPath& primPath = scenePrims[i].GetPrimPath();
+            std::unordered_set<SdfPath, SdfPath::Hash>::const_iterator fit = simulationOwnersSet.find(primPath);
+            if (fit == simulationOwnersSet.end())
+            {
+                scenePrims[i] = scenePrims.back();
+                scenePrims.pop_back();
+            }            
+        }
+    }
+    ProcessPhysicsPrims<SceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs, ParseSceneDesc);
+
+    // Collision Groups
+    std::vector<CollisionGroupDesc> collisionGroupsDescs;
+    ProcessPhysicsPrims<CollisionGroupDesc, UsdPhysicsCollisionGroup>(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
+    // Run groups merging
+    std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
+    for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
+    {
+        const CollisionGroupDesc& desc = collisionGroupsDescs[i];
+
+        if (!desc.mergeGroupName.empty())
+        {
+            std::unordered_map<std::string, size_t>::const_iterator fit = mergeGroupNameToIndex.find(desc.mergeGroupName);
+            if (fit != mergeGroupNameToIndex.end())
+            {                
+                CollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
+                mergeDesc.mergedGroups.push_back(desc.primPath);
+                for (const SdfPath& sp : desc.filteredGroups)
+                {
+                    mergeDesc.filteredGroups.push_back(sp);
+                }
+
+                collisionGroupsDescs[i] = collisionGroupsDescs.back();
+                collisionGroupPrims[i] = collisionGroupPrims.back();
+                collisionGroupsDescs.pop_back();
+                collisionGroupPrims.pop_back();
+                i--;
+            }
+            else
+            {                
+                mergeGroupNameToIndex[desc.mergeGroupName] = i;
+                collisionGroupsDescs[i].mergedGroups.push_back(desc.primPath);
+            }
+        }
+    } 
+
+    // Populate the sets to check collisions, this needs to run in parallel!!!
+    std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets; 
+    for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
+    {
+        const UsdPrim groupPrim = collisionGroupPrims[i];
+        UsdStageWeakPtr stage = groupPrim.GetStage();
+        const CollisionGroupDesc& desc = collisionGroupsDescs[i];
+        std::unordered_set<SdfPath, SdfPath::Hash>& hashSet = collisionGroupSets[desc.primPath];
+
+        if (desc.mergedGroups.empty())
+        {
+            const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
+            if (cg)
+            {
+                const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
+                UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
+                const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+                for (const SdfPath& path : includedPaths)
+                {
+                    hashSet.insert(path);
+                }
+            }
+        }
+        else
+        {
+            for (const SdfPath& groupPath : desc.mergedGroups)
+            {
+                const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
+                if (cg)
+                {
+                    const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
+                    UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
+                    const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+                    for (const SdfPath& path : includedPaths)
+                    {
+                        hashSet.insert(path);
+                    }
+                }
+            }
+        }
+    }
+
+    // Rigid body physics material
+    std::vector<RigidBodyMaterialDesc> materialDescs;
+    ProcessPhysicsPrims<RigidBodyMaterialDesc, UsdPhysicsMaterialAPI>(materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
+
+    // Joints
+    std::vector<D6JointDesc> jointDescs;
+    ProcessPhysicsPrims<D6JointDesc, UsdPhysicsJoint>(physicsD6JointPrims, jointDescs, ParseD6JointDesc);
+
+    std::vector<RevoluteJointDesc> revoluteJointDescs;
+    ProcessPhysicsPrims<RevoluteJointDesc, UsdPhysicsRevoluteJoint>(physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
+
+    std::vector<PrismaticJointDesc> prismaticJointDescs;
+    ProcessPhysicsPrims<PrismaticJointDesc, UsdPhysicsPrismaticJoint>(physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
+
+    std::vector<SphericalJointDesc> sphericalJointDescs;
+    ProcessPhysicsPrims<SphericalJointDesc, UsdPhysicsSphericalJoint>(physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
+
+    std::vector<FixedJointDesc> fixedJointDescs;
+    ProcessPhysicsPrims<FixedJointDesc, UsdPhysicsFixedJoint>(physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
+
+    std::vector<DistanceJointDesc> distanceJointDescs;
+    ProcessPhysicsPrims<DistanceJointDesc, UsdPhysicsDistanceJoint>(physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
+
+    std::vector<CustomJointDesc> customJointDescs;
+    ProcessPhysicsPrims<CustomJointDesc, UsdPhysicsJoint>(physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
+
+    // A.B. contruct joint map revisit    
+    JointMap jointMap;
+    for (D6JointDesc& desc : jointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (RevoluteJointDesc& desc : revoluteJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (PrismaticJointDesc& desc : prismaticJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (SphericalJointDesc& desc : sphericalJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (FixedJointDesc& desc : fixedJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (DistanceJointDesc& desc : distanceJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (CustomJointDesc& desc : customJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+
+
+    // collisions
+    // first get the type
+    std::vector<PhysicsObjectType::Enum> collisionTypes;
+    collisionTypes.resize(collisionPrims.size());
+    std::vector<TfToken> customTokens;
+    for (size_t i = 0; i < collisionPrims.size(); i++)
+    {
+        if (customPhysicsTokens)
+        {
+            TfToken shapeToken;
+            const PhysicsObjectType::Enum shapeType = GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
+            collisionTypes[i] = shapeType;
+            if (shapeType == PhysicsObjectType::eCustomShape)
+            {
+                customTokens.push_back(shapeToken);
+            }
+        }
+        else
+        {
+            collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
+        }
+    }
+
+    std::vector<UsdPrim> sphereShapePrims;
+    std::vector<UsdPrim> cubeShapePrims;
+    std::vector<UsdPrim> cylinderShapePrims;
+    std::vector<UsdPrim> capsuleShapePrims;
+    std::vector<UsdPrim> coneShapePrims;
+    std::vector<UsdPrim> planeShapePrims;
+    std::vector<UsdPrim> meshShapePrims;
+    std::vector<UsdPrim> spherePointsShapePrims;
+    std::vector<UsdPrim> customShapePrims;
+    for (size_t i = 0; i < collisionTypes.size(); i++)
+    {
+        PhysicsObjectType::Enum type = collisionTypes[i];
+        switch (type)
+        {
+            case PhysicsObjectType::eSphereShape:
+            {
+                sphereShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eCubeShape:
+            {
+                cubeShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eCapsuleShape:
+            {
+                capsuleShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eCylinderShape:
+            {
+                cylinderShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eConeShape:
+            {
+                coneShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eMeshShape:
+            {
+                meshShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::ePlaneShape:
+            {
+                planeShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eCustomShape:
+            {
+                customShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eSpherePointsShape:
+            {
+                spherePointsShapePrims.push_back(collisionPrims[i]);
+            }
+            break;
+            case PhysicsObjectType::eUndefined:
+            default:            
+            {
+                TF_DIAGNOSTIC_WARNING("CollisionAPI applied to an unknown UsdGeomGPrim type, prim %s.",
+                    collisionPrims[i].GetPrimPath().GetString().c_str());
+            }
+            break;
+        }
+    }
+    std::vector<SphereShapeDesc> sphereShapeDescs;
+    ProcessPhysicsPrims<SphereShapeDesc, UsdPhysicsCollisionAPI>(sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
+
+    std::vector<CubeShapeDesc> cubeShapeDescs;
+    ProcessPhysicsPrims<CubeShapeDesc, UsdPhysicsCollisionAPI>(cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
+
+    std::vector<CylinderShapeDesc> cylinderShapeDescs;
+    ProcessPhysicsPrims<CylinderShapeDesc, UsdPhysicsCollisionAPI>(cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
+
+    std::vector<CapsuleShapeDesc> capsuleShapeDescs;
+    ProcessPhysicsPrims<CapsuleShapeDesc, UsdPhysicsCollisionAPI>(capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
+
+    std::vector<ConeShapeDesc> coneShapeDescs;
+    ProcessPhysicsPrims<ConeShapeDesc, UsdPhysicsCollisionAPI>(coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
+
+    std::vector<PlaneShapeDesc> planeShapeDescs;
+    ProcessPhysicsPrims<PlaneShapeDesc, UsdPhysicsCollisionAPI>(planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
+
+    std::vector<MeshShapeDesc> meshShapeDescs;
+    ProcessPhysicsPrims<MeshShapeDesc, UsdPhysicsCollisionAPI>(meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
+
+    std::vector<SpherePointsShapeDesc> spherePointsShapeDescs;
+    ProcessPhysicsPrims<SpherePointsShapeDesc, UsdPhysicsCollisionAPI>(spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
+
+    std::vector<CustomShapeDesc> customShapeDescs;
+    ProcessPhysicsPrims<CustomShapeDesc, UsdPhysicsCollisionAPI>(customShapePrims, customShapeDescs, ParseCustomShapeDesc);
+    if (customShapeDescs.size() == customTokens.size())
+    {
+        for (size_t i = 0; i < customShapeDescs.size(); i++)
+        {
+            customShapeDescs[i].customGeometryToken = customTokens[i];
+        }
+    }
+
+    // rigid bodies
+    std::vector<RigidBodyDesc> rigidBodyDescs;
+    ProcessPhysicsPrims<RigidBodyDesc, UsdPhysicsRigidBodyAPI>(rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
+    // Ensure if we have a hierarchical parent that has a dynamic parent,
+    // that we also have a reset xform stack, otherwise we should log an error.
+    // check for nested articulation roots, these are not supported
+    RigidBodyMap bodyMap;
+    for (size_t i = rigidBodyPrims.size(); i--;)
+    {
+        bodyMap[rigidBodyPrims[i].GetPrimPath()] = &rigidBodyDescs[i];
+    }
+
+    for (size_t i = rigidBodyPrims.size(); i--;)
+    {
+        const UsdPrim bodyPrim = rigidBodyPrims[i];
+        UsdPrim bodyParent = UsdPrim();
+        if (HasDynamicBodyParent(bodyPrim.GetParent(), bodyMap, bodyParent))
+        {
+            bool hasResetXformStack = false;
+            UsdPrim parent = bodyPrim;
+            while (parent != stage->GetPseudoRoot() && parent != bodyParent)
+            {
+                const UsdGeomXformable xform(parent);
+                if (xform && xform.GetResetXformStack())
+                {
+                    hasResetXformStack = true;
+                    break;
+                }
+                parent = parent.GetParent();
+            }
+            if (!hasResetXformStack)
+            {
+
+                TF_DIAGNOSTIC_WARNING("Rigid Body of (%s) missing xformstack reset when child of rigid body (%s) in hierarchy. "
+                    "Simulation of multiple RigidBodyAPI's in a hierarchy will cause unpredicted results. "
+                    "Please fix the hierarchy or use XformStack reset.",
+                    bodyPrim.GetPrimPath().GetText(),
+                    bodyParent.GetPrimPath().GetText());
+
+                rigidBodyPrims[i] = rigidBodyPrims.back();
+                rigidBodyPrims.pop_back();
+            }
+        }
+    }
+
+    // articulations
+    // check for nested articulation roots, these are not supported    
+    for (size_t i = articulationPrims.size(); i--;)
+    {
+        if (CheckNestedArticulationRoot(articulationPrims[i], articulationPathsSet))
+        {
+            TF_DIAGNOSTIC_WARNING("Nested ArticulationRootAPI not supported, API ignored, prim %s.",
+                    articulationPrims[i].GetPrimPath().GetString().c_str());
+            articulationPrims[i] = articulationPrims.back();
+            articulationPrims.pop_back();
+        }
+    }
+    std::vector<ArticulationDesc> articulationDescs;
+    ProcessPhysicsPrims<ArticulationDesc, UsdPhysicsArticulationRootAPI>(articulationPrims, articulationDescs, ParseArticulationDesc);
+
+    ArticulationMap articulationMap; // A.B. TODO probably not needed
+    for (size_t i = articulationPrims.size(); i--;)
+    {
+        articulationMap[articulationPrims[i].GetPrimPath()] = &articulationDescs[i];
+    }
+
+    // Finalize collisions
+    {
+        UsdGeomXformCache xfCache;
+
+        FinalizeCollisionDescs<SphereShapeDesc>(xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<CubeShapeDesc>(xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<CapsuleShapeDesc>(xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<CylinderShapeDesc>(xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<ConeShapeDesc>(xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<PlaneShapeDesc>(xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<MeshShapeDesc>(xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<SpherePointsShapeDesc>(xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<CustomShapeDesc>(xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
+    }
+
+    // Finalize articulations
+    {   
+        // A.B. walk through the finalize code refactor
+        FinalizeArticulations(stage, articulationMap, bodyMap, jointMap);
+    }
+
+    // if simulationOwners are in play lets shrink down the reported descriptors    
+    if (simulationOwners && !simulationOwners->empty())
+    {
+        std::unordered_set<SdfPath, SdfPath::Hash> reportedBodies;
+        // first check bodies
+        CheckRigidBodySimulationOwner(rigidBodyPrims, rigidBodyDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+        // check collisions
+        // if collision belongs to a body that we care about include it
+        // if collision does not belong to a body we care about its not included
+        // if collision does not have a body set, we check its own simulationOwners
+        CheckCollisionSimulationOwner(sphereShapePrims, sphereShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(cubeShapePrims, cubeShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(capsuleShapePrims, capsuleShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(cylinderShapePrims, cylinderShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(coneShapePrims, coneShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(planeShapePrims, planeShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(meshShapePrims, meshShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(spherePointsShapePrims, spherePointsShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(customShapePrims, customShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+        // Both bodies need to have simulation owners valid
+        CheckJointSimulationOwner(physicsFixedJointPrims, fixedJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsRevoluteJointPrims, revoluteJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsPrismaticJointPrims, prismaticJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsSphericalJointPrims, sphericalJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsDistanceJointPrims, distanceJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsD6JointPrims, jointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsCustomJointPrims, customJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+        // All bodies need to have simulation owners valid
+        CheckArticulationSimulationOwner(articulationPrims, articulationDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+    }
+
+    SdfPathVector primPathsVector;
+    // get the descriptors, finalize them and send them out in an order
+    // 1. send out the scenes
+    {
+        CallReportFn(PhysicsObjectType::eScene, scenePrims, sceneDescs, reportFn, primPathsVector, userData);
+    }
+
+    // 2. send out the CollisionGroups
+    {
+        CallReportFn(PhysicsObjectType::eCollisionGroup, collisionGroupPrims, collisionGroupsDescs, reportFn, primPathsVector, userData);
+    }
+
+    // 3. send out the materials
+    {
+        CallReportFn(PhysicsObjectType::eRigidBodyMaterial, materialPrims, materialDescs, reportFn, primPathsVector, userData);
+    }
+
+    // 4. finish out and send out shapes
+    {   
+        CallReportFn(PhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eCapsuleShape, capsuleShapePrims, capsuleShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eCylinderShape, cylinderShapePrims, cylinderShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eSpherePointsShape, spherePointsShapePrims, spherePointsShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs, reportFn, primPathsVector, userData);        
+    }
+
+    // 5. send out articulations
+    {
+        CallReportFn(PhysicsObjectType::eArticulation, articulationPrims, articulationDescs, reportFn, primPathsVector, userData);        
+    }
+
+    // 6. send out bodies
+    {
+        CallReportFn(PhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs, reportFn, primPathsVector, userData);                        
+    }
+
+    // 7. send out joints    
+    {
+        CallReportFn(PhysicsObjectType::eFixedJoint, physicsFixedJointPrims, fixedJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims, revoluteJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims, prismaticJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims, sphericalJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims, distanceJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(PhysicsObjectType::eCustomJoint, physicsCustomJointPrims, customJointDescs, reportFn, primPathsVector, userData);        
+    }
+
+    return retVal;
+}
+
+
+PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/usd/usdPhysics/parseUtils.h b/pxr/usd/usdPhysics/parseUtils.h
new file mode 100644
index 0000000000..a7b1ab3137
--- /dev/null
+++ b/pxr/usd/usdPhysics/parseUtils.h
@@ -0,0 +1,88 @@
+//
+// Copyright 2016 Pixar
+//
+// Licensed under the Apache License, Version 2.0 (the "Apache License")
+// with the following modification; you may not use this file except in
+// compliance with the Apache License and the following modification to it:
+// Section 6. Trademarks. is deleted and replaced with:
+//
+// 6. Trademarks. This License does not grant permission to use the trade
+//    names, trademarks, service marks, or product names of the Licensor
+//    and its affiliates, except as required to comply with Section 4(c) of
+//    the License and to reproduce the content of the NOTICE file.
+//
+// You may obtain a copy of the Apache License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the Apache License with the above modification is
+// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied. See the Apache License for the specific
+// language governing permissions and limitations under the Apache License.
+//
+#ifndef USDPHYSICS_PARSE_UTILS_H
+#define USDPHYSICS_PARSE_UTILS_H
+
+/// \file usdPhysics/parseUtils.h
+
+#include "pxr/pxr.h"
+#include "pxr/usd/usd/stage.h"
+#include "pxr/usd/usdGeom/xformCache.h"
+#include "pxr/usd/sdf/path.h"
+
+#include "pxr/usd/usdPhysics/api.h"
+#include "pxr/usd/usdPhysics/parseDesc.h"
+#include "pxr/usd/usdPhysics/parsePrimIterator.h"
+
+PXR_NAMESPACE_OPEN_SCOPE
+
+
+// -------------------------------------------------------------------------- //
+// PHYSICSPARSEUTILS                                                          //
+// -------------------------------------------------------------------------- //
+
+
+/// UsdPhysicsReportFn - report function that reports parsed data
+///
+/// \param[in] type     Object type
+/// \param[in] numDesc  Number of descriptors to be processed
+/// \param[in] primPaths    Array of prim paths that were parsed
+/// \param[in] objectDescs  Corresponding array of object descriptors of the reported type
+/// \param[in] userData User data provided to the parsing function
+using UsdPhysicsReportFn =
+    std::function<void(PhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
+        const PhysicsObjectDesc* objectDescs, void* userData)>;
+
+/// \struct CustomUsdPhysicsTokens
+///
+/// Token lists for custom physics objects
+///
+struct CustomUsdPhysicsTokens
+{
+    std::vector<TfToken> jointTokens;       ///< Custom joints to be reported by parsing
+    std::vector<TfToken> shapeTokens;       ///< Custom shapes to be reported by parsing
+    std::vector<TfToken> instancerTokens;   ///< Custom physics instancers to be skipped by parsing
+};
+
+/// Load USD physics from a given range
+///
+/// \param[in] stage      Stage to parse
+/// \param[in] range      USDRange to parse
+/// \param[in] reportFn   Report function that gets parsed USD physics data
+/// \param[in] userData   User data passed to report function
+/// \param[in] customPhysicsTokens Custom tokens to be reported by the parsing
+/// \param[in] simulationOwners List of simulation owners that should be parsed, adding SdfPath() 
+///                         indicates that objects without a simulation owner should be parsed too.
+/// \return True if load was successful
+USDPHYSICS_API bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
+        ParsePrimIteratorBase& range,
+        UsdPhysicsReportFn reportFn,
+        void* userData,
+        const CustomUsdPhysicsTokens* customPhysicsTokens = nullptr,
+        const std::vector<SdfPath>* simulationOwners = nullptr);
+
+
+PXR_NAMESPACE_CLOSE_SCOPE
+
+#endif
diff --git a/pxr/usd/usdPhysics/parsingUtils.dox b/pxr/usd/usdPhysics/parsingUtils.dox
new file mode 100644
index 0000000000..0e9679da15
--- /dev/null
+++ b/pxr/usd/usdPhysics/parsingUtils.dox
@@ -0,0 +1,412 @@
+/*!
+
+\page usdPhysics_page_front UsdPhysics : USD Physics Parsing Utils
+\if ( PIXAR_MFB_BUILD )
+\mainpage UsdPhysics : USD Physics Parsing Utils
+\endif
+
+<b>USD Physics Parsing Utils Overview.</b>
+
+\tableofcontents
+
+\section usdPhysics_parsing_purpose_and_scope Purpose and Scope
+
+When the UsdPhysics schema is applied to the stage, processing the stage UsdPrims
+and creating a consistent physics representation can be challenging, especially
+when dealing with different simulators. The UsdPhysics Parsing Utilities are
+designed to help achieve a consistent physics representation as defined in 
+the USD stage. The stage, or generally a set of ranges, is parsed, and the 
+function returns a callback or dictionary with parsed physics descriptors. 
+Additionally, it can leverage the concept of simulation owners to partition the 
+stage for multiple simulation engines.
+
+\section usdPhysics_parsing Specification
+
+The UsdPhysics schemas add physics capabilities to USD; however, deducing and 
+parsing the physics information can be non-trivial and may be misinterpreted. 
+This section aims to specify what data are returned by the parsing utilities 
+and what to expect in the parsed physics descriptors.
+
+\subsection usdPhysics_utils_params Physics Parsing Parameters
+
+The parsing utility function takes several input parameters that needs
+to be described:
+
+\li The stage to be parsed.
+\li Range of the UsdPrims to be parsed, note that the range is not a standard
+UsdPrimRange, but rather a custom physics range, that can be constructed either
+on a full stage or on a map of primitive hierarchies. It is important that the
+parsing reports full information of a completely new added prims, not just one
+subtree. This is important for articulation processing for example. Additionally
+this gives the option to define own traversal rules if needed.
+\li Report callback function that reports the descriptors back to the calling code.
+The report function returns an array of the same descriptors to be processed efficiently.
+Note that in python instead of a callback function all the descriptors are returned
+in a dictionary, where the key is the descriptor type and the value is a tuple of
+UsdPrim paths array and descriptors array.
+\li User data can be provided, these are then send to the callback function, the 
+user data are not passed in the python version.
+\li Optional custom physics tokens, there can be multiple custom tokens defined.
+The custom tokens can hold three arrays of tokens that define a custom behavior. 
+The custom geometry tokens specify if a certain geometry should be treated as a
+custom geometry that the calling code will handle. The custom joint tokens specify
+which joints are custom and the calling code needs to handle them. The custom
+point instancer tokens specify what point instancer hierarchies should be ignored
+additionally to standard point instancers. Note that point instancer hierarchies
+are skipped. It is expected that for a point instancer that one does parse individual
+prototypes.
+\li Optional simulation owners can be provided to restrict parsing to only 
+certain simulation owners. It is expected that simulation owners are PhysicsScene
+primitives. The parsing will then restrict parsing only to those scenes and
+objects that do have a simulation owner set to those scenes. If empty SdfPath 
+is provided, objects without a simulation owner are returned either. The behavior
+for simulation owners is described below for each type.
+
+\subsection usdPhysics_utils_determinism Physics Parsing Determinism
+
+The parsing should be deterministic; it's important that each subsequent run 
+reports the same information in the same order. This is especially crucial for 
+elements like articulation roots. In some cases, the parsing sacrifices performance 
+to achieve deterministic results.
+
+\subsection usdPhysics_object_descriptor Physics Object Descriptor
+
+The base physics object descriptor is never returned, all types are derived
+from this base class. This base class contains this physics information:
+
+\li Type of the physics descriptor, PhysicsObjectType::Enum defines all types available
+\li UsdPrim path that this descriptor was parsed from.
+\li IsValid boolean that specifies whether a returned described is valid or not.
+Note that the descriptors are processed in batches and if validation fails the
+descriptor is invalidated rather then removed from the array. 
+
+\subsection usdPhysics_scene_descriptor Physics Scene Descriptor
+
+For each UsdPhysics.Scene prim a PhysicsDesc is reported, this descriptor contains:
+
+\li Gravity direction, if there is no authored value or sentinel value provided
+a default direction is computed based on the stage upAxis.
+\li Gravity magnitude, if there is no authored value or sentinel value provided
+a default Earth gravity is computed based on the stage meters per unit value.
+
+\subsubsection usdPhysics_scene_descriptor_simulation_owner Physics Scene Simulation Owner Behavior
+
+If the parsing utility is provided with a list of allowed simulation owners, 
+the behavior changes. The returned PhysicsSceneDesc objects are restricted to 
+only those UsdPhysics.Scene prims whose paths match one of the provided simulation 
+owners. It is expected that the UsdPhysics.Scene prim path is the simulation owner 
+that defines where each body or collision belongs.
+
+\subsection usdPhysics_material_descriptor Physics RigidBody Material Descriptor
+
+For each prim with UsdPhysics.MaterialAPI a PhysicsRigidBodyMaterialDesc is reported, this descriptor contains:
+
+\li Static friction defined in USD.
+\li Dynamic friction defined in USD.
+\li Restitution defined in USD.
+\li Density defined in USD, note that density is expected to be specified in the stage units.
+
+\subsubsection usdPhysics_material_descriptor_simulation_owner Physics RigidBody Material Simulation Owner Behavior
+
+Since prims can be added/enabled during runtime, all physics materials are returned and not restricted by the
+simulation owners.
+
+\subsection usdPhysics_collision_group_descriptor Physics Collision Group Descriptor
+
+For each prim with UsdPhysics.CollisionGroup a possible PhysicsCollisionGroupDesc is created. In a subsequent pass
+the collision groups descriptors merge based on the mergeGroups attribute. The final list contains the merged 
+groups and contains this information:
+
+\li Inverted filtered groups boolean specifying whether the group does not (default true) collide with the provided
+list of filtered groups.
+\li Filtered groups list, list of groups that this group should not collide by default (can be inverted by boolean above).
+\li If group should be merged, the specified merge group name.
+\li Merged groups list, list of all groups paths that were merged together.
+
+\subsubsection usdPhysics_collision_group_descriptor_simulation_owner Physics Collision Group Simulation Owner Behavior
+
+Since prims can be added/enabled during runtime, all physics collision groups are returned and not restricted by the
+simulation owners.
+
+\subsection usdPhysics_rigid_body_descriptor Physics RigidBody Descriptor
+
+For each UsdGeom.Xformable prim with UsdPhysics.RigidBodyAPI, a physics rigid body
+descriptor is reported. Note that nesting rigid bodies is not allowed; 
+therefore, an error will be reported if attempted. To nest rigid bodies, it is 
+necessary to add resetXformOpStack on the rigid body. The reported descriptor 
+contains this information:
+
+\li List of collisions that belong to this rigid body.
+\li List of simulation owners for this rigid body, the behavior is described below.
+\li List of filtered collisions, the list contains all paths that the rigid body should not collide with. Note that this can be arbitrary
+path in the USD hierarchy. Its up to the implementation to check what objects are created under the hierarchy.
+\li World position of the rigid body.
+\li World orientation of the rigid body.
+\li World scale of the rigid body.
+\li Rigid body enabled boolean for fast toggle between a dynamic and static body.
+\li Kinematic body boolean, kinematic body is expected to be driven by transformation changes.
+\li Starts asleep boolean, specifies if a body should be awake or not when the sim starts.
+\li Initial angular velocity (note that the expected units are in degree and body local space).
+\li Initial linear velocity (note that the expected velocity is in body local space). 
+
+\subsubsection usdPhysics_rigid_body_descriptor_simulation_owner Physics RigidBody Simulation Owner Behavior
+
+The rigid body's simulation owners list is compared with the provided requested simulation owners list. If a match is found,
+the rigid body is reported; otherwise, the rigid body is skipped.
+
+\subsection usdPhysics_collision_descriptor Physics Shape Descriptor
+
+Physics shape descriptor is the base class for all specific shapes reported. In general for each prim with UsdPhysics.CollisionAPI
+a derived physics shape descriptor is returned. The base shape descriptor contains this shared information:
+
+\li Rigid body that the collision belongs to, if the rigid body path is not valid, its considered a static collision.
+\li Local position relative to the rigid body primitive, if static collision, the local position is a world position.
+\li Local orientation relative to the rigid body primitive, if static collision, the local orientation is a world orientation.
+\li Local scale relative to the rigid body primitive, if static collision, the local scale is a world position.
+\li List of used materials (path to a prim with material API). This list contains invalid SdfPath if no material is
+defined for the collision prim. Note that there can be multiple materials returned, this can happen in case when UsdGeom.Mesh
+primitive is parsed and it does have UsdGeom.Subset defined with different materials applied. The last material in this case is the
+material applied to the mesh prim (can be invalid path if no material applied).
+\li List of simulation owners for this collision, the behavior is described below.
+\li List of filtered collisions, the list contains all paths that the collision should not collide with. Note that this can be arbitrary
+path in the USD hierarchy. Its up to the implementation to check what objects are created under the hierarchy.
+\li List of collision groups this collision belongs to, note that only collision groups that are part
+of the current parsing range are checked for a scoped parse, this needs to be checked for already existing groups reported by full parse.
+\li Boolean to specify whether collision is enabled or disabled, this can be used to create objects in physics and then
+avoid runtime creation on the objects while toggling the USD attribute that enables/disables the collision.
+
+Note that many collision representations do not support non-uniform scale, behavior for each type is described below. 
+While non-uniform scale works for some representations scale of the orientation (skew) never works warnings should be reported.
+
+\subsection usdPhysics_sphere_collision_descriptor Physics Sphere Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Sphere primitive, then a physics sphere shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The sphere radius, note that the radius contains already scale so its the expected radius in world space. also
+since the sphere cant have non-uniform scale, if non-uniform scale is found a warning is reported. In case of a non-uniform
+scale the maximum of the scale per axis value is used to scale the UsdGeom.Sphere radius.
+
+\subsection usdPhysics_capsule_collision_descriptor Physics Capsule Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Capsule primitive, then a physics capsule shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The axis around which the capsule is represented.
+\li The capsule half height, measured from the center to the cylindrical top, where the hemispherical sphere based on radius is added.
+Note that the height contains already scale so its the expected height in world space. 
+\li The radius of the capsule, note that the radius contains already scale so its the expected radius in world space. 
+Note since the capsule cant have generic non-uniform scale, if non-uniform scale around radius is found a warning is reported. The scale
+along the provided axis does scale the height, while scale around the other two axis define the radius scale, the maximum of those is 
+used in case of a non-uniform scale.
+
+\subsection usdPhysics_cylinder_collision_descriptor Physics Cylinder Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Cylinder primitive, then a physics cylinder shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The axis around which the cylinder is represented.
+\li The cylinder half height, measured from the center to the cylindrical top.
+Note that the height contains already scale so its the expected height in world space. 
+\li The radius of the cylinder, note that the radius contains already scale so its the expected radius in world space. 
+Note since the cylinder cant have generic non-uniform scale, if non-uniform scale around radius is found a warning is reported. The scale
+along the provided axis does scale the height, while scale around the other two axis define the radius scale, the maximum of those is 
+used in case of a non-uniform scale.
+
+\subsection usdPhysics_cone_collision_descriptor Physics Cone Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Cone primitive, then a physics cone shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The axis around which the cone is represented.
+\li The cone half height, measured from the center to the cone top.
+Note that the height contains already scale so its the expected height in world space. 
+\li The radius of the cone, note that the radius contains already scale so its the expected radius in world space. 
+Note since the cone cant have generic non-uniform scale, if non-uniform scale around radius is found a warning is reported. The scale
+along the provided axis does scale the height, while scale around the other two axis define the radius scale, the maximum of those is 
+used in case of a non-uniform scale.
+
+\subsection usdPhysics_cube_collision_descriptor Physics Cube Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Cube primitive, then a physics cube shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The half extent of the cube including scale. Non-uniform scale in this case is supported as the cube size is multiplied
+by the world scale.
+
+\subsection usdPhysics_plane_collision_descriptor Physics Plane Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Plane primitive, then a physics plane shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The axis where the plane normal is pointing.
+
+\subsection usdPhysics_mesh_collision_descriptor Physics Mesh Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Mesh primitive, then a physics mesh shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The desired approximation for the mesh geometry.
+\li The mesh world scale, note that the points are not scaled, hence for meshes we need a separate scale information.
+\li Hint whether the mesh is double sided or not.
+
+\subsection usdPhysics_sphere_points_collision_descriptor Physics Sphere Points Shape Descriptor
+
+If physics collision API is applied to a UsdGeom.Points primitive, then a physics sphere points shape descriptor is reported.
+The descriptor contains this additional information:
+
+\li The list of sphere points to be created, each sphere point is defined by a center and radius in world coordinate. Note that non-uniform scale
+is not supported, the max per axis scale is applied.
+
+\subsection usdPhysics_custom_collision_descriptor Physics Custom Shape Descriptor
+
+Custom collisions can be defined on UsdPrims, if a custom shape token is provided to the parsing function then if the prim type
+or any of the prim applied APIs matches the custom shape token a custom shape descriptor is reported, these collisions are then 
+handled by the application. The custom shape descriptor contains:
+
+\li Custom geometry token that was provided to the parsing function, this identifies the custom geometry.
+
+\li The list of sphere points to be created, each sphere point is defined by a center and radius in world coordinate. Note that non-uniform scale
+is not supported, the max per axis scale is applied.
+
+\subsubsection usdPhysics_collision_descriptor_simulation_owner Physics Collision Simulation Owner Behavior
+
+Collisions can have their own list of simulation owners to which they can belong. 
+However, since they are associated with a rigid body, the behavior changes depending 
+on whether or not they belong to a rigid body. If a collision belongs to a rigid body 
+and one of the rigid body's simulation owners matches the requested simulation owners list, 
+then the collision is reported. If the rigid body's simulation owners do not match, 
+the collision is not reported. If a collision does not belong to a rigid body, 
+then the collision's simulation owners list is compared with the provided requested 
+simulation owners list, and if a match is found, the collision is reported; otherwise, 
+the collision is skipped.
+
+\subsection usdPhysics_joint_descriptor Physics Joint Descriptor
+
+Common base physics joint descriptor, this base class should not be instantiated. All joint types are derived
+from this base descriptor. For parsing, any UsdPhysics.Joint prim and its derived types a joint descriptor is
+reported. This descriptor contains:
+
+\li Path relationship defined in body0 rel, this path does not necessarily have to be the body path, its possible to 
+use some child prim as the relationship. Empty SdfPath means, the joint does have a world anchor, note that at least
+one dynamic body should be defined for body0 or body1.
+\li Path relationship defined in body1 rel, this path does not necessarily have to be the body path, its possible to 
+use some child prim as the relationship. Empty SdfPath means, the joint does have a world anchor, note that at least
+one dynamic body should be defined for body0 or body1.
+\li Path to body0, this does not have to be the path defined in the body0 rel, this is the path to the body that the joint
+is constraining. All poses defined in the descriptor are relative to the rigid body rather then the rel prim.
+\li Path to body1, this does not have to be the path defined in the body1 rel, this is the path to the body that the joint
+is constraining. All poses defined in the descriptor are relative to the rigid body rather then the rel prim.
+\li Local position against the body0 world frame.
+\li Local orientation against the body0 world frame.
+\li Local position against the body1 world frame.
+\li Local orientation against the body1 world frame.
+\li Boolean to quickly toggle the joint enabled/disable state.
+\li Boolean that defines whether collision between the constrained bodies is enabled or disabled.
+\li Boolean that can exclude joint from articulation, this is required in cases where articulation topology
+would create closed loops, those are in many cases not supported.
+\li Break force, when the joint breaks.
+\li Break torque when the joint breaks. 
+
+\subsection usdPhysics_fixed_joint_descriptor Physics Fixed Joint Descriptor
+
+For each UsdPhysics.FixedJoint a fixed joint descriptor is reported. The fixed joint does not have
+any additional parameters to be reported.
+
+\subsection usdPhysics_revolute_joint_descriptor Physics Revolute Joint Descriptor
+
+For each UsdPhysics.RevoluteJoint a revolute joint descriptor is reported. The revolute joint
+adds this information:
+
+\li The revolute joint axis.
+\li The revolute joint limit, it can be enabled or disabled. Additionally a pair of low high angle is 
+reported (note that the units are by default degree as per USD spec).
+\li The revolute joint drive, the drive that can be added to the revolute joint. Drive does have
+target position, target velocity, stiffness and damping. The expected drive formula looks like this -
+force = spring * (target position - position) + damping * (targetVelocity - velocity)
+
+\subsection usdPhysics_prismatic_joint_descriptor Physics Prismatic Joint Descriptor
+
+For each UsdPhysics.PrismaticJoint a prismatic joint descriptor is reported. The prismatic joint
+adds this information:
+
+\li The prismatic joint axis.
+\li The prismatic joint limit, it can be enabled or disabled. Additionally a pair of low high angle is 
+reported.
+\li The prismatic joint drive, the drive that can be added to the prismatic joint. Drive does have
+target position, target velocity, stiffness and damping. The expected drive formula looks like this -
+force = spring * (target position - position) + damping * (targetVelocity - velocity)
+
+\subsection usdPhysics_spherical_joint_descriptor Physics Spherical Joint Descriptor
+
+For each UsdPhysics.SphericalJoint a spherical joint descriptor is reported. The spherical joint
+adds this information:
+
+\li The spherical joint axis.
+\li The spherical joint limit, it can be enabled or disabled. Additionally a cone0 and cone1 angle is 
+reported (note that the units are by default degree as per USD spec). Note that in python the limit
+says always just lower/upper, the lower value is cone0 value and upper value is the cone1 value. 
+
+\subsection usdPhysics_distance_joint_descriptor Physics Distance Joint Descriptor
+
+For each UsdPhysics.DistanceJoint a distance joint descriptor is reported. The distance joint
+adds this information:
+
+\li Boolean stating whether the minimum limit is enabled as both limits can be enabled disabled independently.
+\li Boolean stating whether the maximum limit is enabled as both limits can be enabled disabled independently.
+\li The limit, for minimum and maximum definition. Note that in python the lower value defines the minimum, while
+the upper value defines the maximum. Both values are only valid if the bools above are true.
+
+\subsection usdPhysics_d6_joint_descriptor Physics D6 Joint Descriptor
+
+For each UsdPhysics.Joint a D6 joint descriptor is reported. The D6 joint is a generic joint that can be 
+setup per axis. The parsing reports these:
+
+\li List of limit pairs, where first is the DOF, while the second is the actual limit. Note that
+for the DOF, there can be three states, the limit is not set - free, limit is set lower is lower then upper
+then the limit is valid from lower to upper. If upper is lower then lower, then the DOF is considered locked.
+\li List of drive pairs, where first is the DOF, while the second is the drive.
+
+\subsection usdPhysics_custom_joint_descriptor Physics Custom Joint Descriptor
+
+For each derived UsdPhysics.Joint type that matches the custom joint token provided to the parsing
+custom joint descriptor is reported. This type does not have any additional information.
+
+\subsubsection usdPhysics_joint_descriptor_simulation_owner Physics Joint Simulation Owner Behavior
+
+Joints do not have own simulation owner, the simulation owner is decided based on the bodies the joint constrained.
+If both rigid bodies belong to the same simulation owner and the simulation owner is passed as the argument to
+parsing, the joint is returned.  
+
+\subsection usdPhysics_articulation_descriptor Physics Articulation Descriptor
+
+For each UsdPhysics.ArticulationRootAPI, an articulation descriptor is returned. 
+The articulation root API serves as a hint for the solver that the topology below 
+the articulation root should be solved as a reduced coordinate system. Note that 
+it is not possible to nest articulation root APIs within a hierarchy; doing so 
+will result in an error. The articulation descriptor contains this information:
+
+\li List of root paths is provided, with each path in this list indicating that 
+a topology starts from this root. There can be multiple topologies found under 
+one articulation root. Note that the root can be reported as either a rigid body 
+path, in which case the articulated topology is considered floating, or as a joint 
+path, in which case the articulated topology is considered fixed-based.
+\li List of filtered collisions for this articulation.
+\li List of joints that belong to this articulation.
+\li List of bodies that belong to this articulation
+
+It is expected that the articulation descriptor information is used to construct 
+a reduced coordinate topology, starting from the reported roots and using the 
+provided list of joints and bodies to construct the topology. Note that in the 
+case of closed loops, the joints are usually excluded from the articulation; 
+however, they are still reported in the list of joints.
+
+\subsubsection usdPhysics_articulation_descriptor_simulation_owner Physics Articulation Simulation Owner Behavior
+
+Articulations do not have their own simulation owner; the simulation owner is 
+determined based on the bodies that belong to the articulation. If all bodies 
+have the same simulation owner, then the articulation is reported and should be created. 
+If there is no alignment among the bodies regarding where they should be simulated, 
+the articulation is not reported.
+
+*/
diff --git a/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py b/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
new file mode 100644
index 0000000000..70472dce99
--- /dev/null
+++ b/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
@@ -0,0 +1,1284 @@
+#!/pxrpythonsubst
+#
+# Copyright 2021 Pixar
+#
+# Licensed under the Apache License, Version 2.0 (the "Apache License")
+# with the following modification; you may not use this file except in
+# compliance with the Apache License and the following modification to it:
+# Section 6. Trademarks. is deleted and replaced with:
+#
+# 6. Trademarks. This License does not grant permission to use the trade
+#    names, trademarks, service marks, or product names of the Licensor
+#    and its affiliates, except as required to comply with Section 4(c) of
+#    the License and to reproduce the content of the NOTICE file.
+#
+# You may obtain a copy of the Apache License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the Apache License with the above modification is
+# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the Apache License for the specific
+# language governing permissions and limitations under the Apache License.
+
+import os, unittest
+from pxr import Usd, UsdPhysics, Gf, UsdGeom, Sdf, UsdShade
+
+
+toleranceEpsilon = 0.01
+
+
+class TestUsdPhysicsParsing(unittest.TestCase):
+
+    def test_scene_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)        
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        
+        for key, value in ret_dict.items():
+            if key == UsdPhysics.PhysicsObjectType.Scene:                
+                scene_found = True
+                paths, scene_descs = value
+                for path, scene_desc in zip(paths, scene_descs):
+                    self.assertTrue(path == scene.GetPrim().GetPrimPath())
+                    self.assertTrue(Gf.IsClose(scene_desc.gravityDirection, Gf.Vec3f(0, -1, 0), toleranceEpsilon))
+                    self.assertAlmostEqual(scene_desc.gravityMagnitude, 981.0, delta=toleranceEpsilon)
+
+        self.assertTrue(scene_found)
+
+    def test_collision_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        shape_prim = None
+        shapes = {
+            "sphere" : {"type" : UsdGeom.Sphere, "radius" : 30},
+            "capsule" : {"type" : UsdGeom.Capsule, "radius" : 30, "height" : 10, "axis" : UsdGeom.Tokens.y},
+            "cone" : {"type" : UsdGeom.Cone, "radius" : 30, "height" : 10, "axis" : UsdGeom.Tokens.z},
+            "cylinder" : {"type" : UsdGeom.Cylinder, "radius" : 30, "height" : 10, "axis" : UsdGeom.Tokens.y},
+            "plane" : {"type" : UsdGeom.Plane, "axis" : UsdGeom.Tokens.z},
+            "mesh" : {"type" : UsdGeom.Mesh},
+            "points" : {"type" : UsdGeom.Points},
+        }
+
+        for key, params in shapes.items():
+            if shape_prim is not None:
+                stage.RemovePrim(shape_prim.GetPrimPath())
+            shape = params["type"].Define(stage, "/Sphere")
+            shape_prim = shape.GetPrim()
+            
+            if (key == "sphere"):
+                shape.GetRadiusAttr().Set(params["radius"])
+            elif (key == "capsule") or (key == "cone") or (key == "cylinder"):
+                shape.GetRadiusAttr().Set(params["radius"])
+                shape.GetHeightAttr().Set(params["height"])
+                shape.GetAxisAttr().Set(params["axis"])
+            elif (key == "plane"):
+                shape.GetAxisAttr().Set(params["axis"])
+            elif (key == "mesh"):
+                meshColAPI = UsdPhysics.MeshCollisionAPI.Apply(shape.GetPrim())
+                meshColAPI.GetApproximationAttr().Set(UsdPhysics.Tokens.convexHull)
+            elif (key == "points"):
+                shape.GetWidthsAttr().Set([5.0, 10.0])
+                shape.GetPointsAttr().Set([Gf.Vec3f(1.0), Gf.Vec3f(2.0)])
+
+            position = Gf.Vec3f(100.0, 20.0, 10.0)
+            rotate_xyz = Gf.Vec3f(0.0, 0.0, 45.0)
+            scale = Gf.Vec3f(3.0, 3.0, 3.0)
+
+            shape.AddTranslateOp().Set(position)
+            shape.AddRotateXYZOp().Set(rotate_xyz)
+            shape.AddScaleOp().Set(scale)
+
+            UsdPhysics.CollisionAPI.Apply(shape_prim)
+
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+            scene_found = False
+            num_shape_found = 0
+
+            def compare_shape_params(desc):
+                self.assertTrue(prim_path == shape_prim.GetPrimPath())
+                self.assertTrue(desc.rigidBody == Sdf.Path())
+                self.assertTrue(desc.collisionEnabled is True)
+                self.assertTrue(len(desc.materials) == 1)
+                self.assertTrue(desc.materials[0] == Sdf.Path())
+                self.assertTrue(len(desc.simulationOwners) == 0)
+                self.assertTrue(len(desc.filteredCollisions) == 0)
+
+                # transformation
+                self.assertTrue(Gf.IsClose(position, desc.localPos, toleranceEpsilon))
+                r = Gf.Rotation(desc.localRot)
+                eulerAngles = r.Decompose(Gf.Vec3d.XAxis(), Gf.Vec3d.YAxis(), Gf.Vec3d.ZAxis())
+                self.assertTrue(Gf.IsClose(Gf.Vec3f(eulerAngles), rotate_xyz, toleranceEpsilon))
+                self.assertTrue(Gf.IsClose(scale, desc.localScale, toleranceEpsilon))
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.SphereShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # sphere shape
+                        self.assertEqual(desc.radius, params["radius"] * scale[0])
+
+                        num_shape_found = num_shape_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.CapsuleShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # capsule shape
+                        self.assertEqual(desc.radius, params["radius"] * scale[0])
+                        self.assertEqual(desc.halfHeight, params["height"] * 0.5 * scale[0])
+                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Y)
+
+                        num_shape_found = num_shape_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.ConeShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # cone shape
+                        self.assertEqual(desc.radius, params["radius"] * scale[0])
+                        self.assertEqual(desc.halfHeight, params["height"] * 0.5 * scale[0])
+                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Z)
+
+                        num_shape_found = num_shape_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.CylinderShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # cylinder shape
+                        self.assertEqual(desc.radius, params["radius"] * scale[0])
+                        self.assertEqual(desc.halfHeight, params["height"] * 0.5 * scale[0])
+                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Y)
+
+                        num_shape_found = num_shape_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.PlaneShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # plane shape
+                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Z)
+
+                        num_shape_found = num_shape_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.MeshShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # mesh shape
+                        self.assertTrue(desc.approximation == UsdPhysics.Tokens.convexHull)
+                        self.assertTrue(desc.doubleSided is not True)
+                        self.assertTrue(Gf.IsClose(scale, desc.meshScale, toleranceEpsilon))
+
+                        num_shape_found = num_shape_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.SpherePointsShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common shape
+                        compare_shape_params(desc)
+
+                        # sphere points shape
+                        self.assertTrue(len(desc.spherePoints) == 2)
+                        self.assertTrue(desc.spherePoints[0].center == Gf.Vec3f(1.0))
+                        self.assertTrue(desc.spherePoints[1].center == Gf.Vec3f(2.0))
+                        self.assertTrue(desc.spherePoints[0].radius == 7.5)     # scale * width * 0.5
+                        self.assertTrue(desc.spherePoints[1].radius == 15.0)    # scale * width * 0.5
+
+                        num_shape_found = num_shape_found + 1
+
+            self.assertTrue(scene_found)
+            self.assertTrue(num_shape_found == 1)
+
+    def test_rigidbody_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)            
+
+        rigidbody = UsdGeom.Xform.Define(stage, "/rigidBody")
+        rboAPI = UsdPhysics.RigidBodyAPI.Apply(rigidbody.GetPrim())
+        position = Gf.Vec3f(100.0, 20.0, 10.0)
+        rotate_xyz = Gf.Vec3f(0.0, 0.0, 45.0)
+        scale = Gf.Vec3f(3.0, 3.0, 3.0)
+
+        rigidbody.AddTranslateOp().Set(position)
+        rigidbody.AddRotateXYZOp().Set(rotate_xyz)
+        rigidbody.AddScaleOp().Set(scale)
+
+        velocity = Gf.Vec3f(20.0, 10.0, 5.0)
+        angular_vel = Gf.Vec3f(10.0, 1.0, 2.0)
+        rboAPI.GetVelocityAttr().Set(velocity)
+        rboAPI.GetAngularVelocityAttr().Set(angular_vel)
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        rigidbody_found = False
+        
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                for prim_path, desc in zip(prim_paths, descs):
+                    scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                for prim_path, desc in zip(prim_paths, descs):
+                    rigidbody_found = True
+                    self.assertTrue(prim_path == rigidbody.GetPrim().GetPrimPath())
+                    self.assertTrue(len(desc.collisions) == 0)
+                    self.assertTrue(len(desc.filteredCollisions) == 0)
+                    self.assertTrue(len(desc.simulationOwners) == 0)
+
+                    # transformation
+                    self.assertTrue(Gf.IsClose(position, desc.position, toleranceEpsilon))
+                    r = Gf.Rotation(desc.rotation)
+                    eulerAngles = r.Decompose(Gf.Vec3d.XAxis(), Gf.Vec3d.YAxis(), Gf.Vec3d.ZAxis())
+                    self.assertTrue(Gf.IsClose(Gf.Vec3f(eulerAngles), rotate_xyz, toleranceEpsilon))
+                    self.assertTrue(Gf.IsClose(scale, desc.scale, toleranceEpsilon))
+
+                    self.assertTrue(desc.rigidBodyEnabled is True)
+                    self.assertTrue(desc.kinematicBody is not True)
+                    self.assertTrue(desc.startsAsleep is not True)
+                    
+                    self.assertTrue(Gf.IsClose(velocity, desc.linearVelocity, toleranceEpsilon))
+                    self.assertTrue(Gf.IsClose(angular_vel, desc.angularVelocity, toleranceEpsilon))
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigidbody_found)
+
+    def test_rigidbody_collision_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)            
+
+        rigidbody = UsdGeom.Xform.Define(stage, "/rigidBody")
+        UsdPhysics.RigidBodyAPI.Apply(rigidbody.GetPrim())
+        rb_position = Gf.Vec3f(100.0, 0.0, 0.0)
+        rb_rotate_xyz = Gf.Vec3f(0.0, 0.0, 0.0)
+        rb_scale = Gf.Vec3f(3.0, 3.0, 3.0)
+
+        rigidbody.AddTranslateOp().Set(rb_position)
+        rigidbody.AddRotateXYZOp().Set(rb_rotate_xyz)
+        rigidbody.AddScaleOp().Set(rb_scale)
+
+        cube = UsdGeom.Cube.Define(stage, "/rigidBody/cube")
+        UsdPhysics.CollisionAPI.Apply(cube.GetPrim())        
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        rigidbody_found = False
+        cube_found = False
+        
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                for prim_path, desc in zip(prim_paths, descs):
+                    scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                for prim_path, desc in zip(prim_paths, descs):
+                    rigidbody_found = True
+                    self.assertTrue(prim_path == rigidbody.GetPrim().GetPrimPath())
+                    self.assertTrue(len(desc.collisions) == 1)
+                    self.assertTrue(desc.collisions[0] == cube.GetPrim().GetPrimPath())
+
+                    # transformation
+                    self.assertTrue(Gf.IsClose(rb_position, desc.position, toleranceEpsilon))
+                    r = Gf.Rotation(desc.rotation)
+                    eulerAngles = r.Decompose(Gf.Vec3d.XAxis(), Gf.Vec3d.YAxis(), Gf.Vec3d.ZAxis())
+                    self.assertTrue(Gf.IsClose(Gf.Vec3f(eulerAngles), rb_rotate_xyz, toleranceEpsilon))
+                    self.assertTrue(Gf.IsClose(rb_scale, desc.scale, toleranceEpsilon))
+            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+                for prim_path, desc in zip(prim_paths, descs):
+                    cube_found = True
+                    self.assertTrue(prim_path == cube.GetPrim().GetPrimPath())
+                    self.assertTrue(desc.rigidBody == rigidbody.GetPrim().GetPrimPath())
+
+                    # transformation
+                    self.assertTrue(Gf.IsClose(Gf.Vec3f(0.0), desc.localPos, toleranceEpsilon))
+                    r = Gf.Rotation(desc.localRot)
+                    eulerAngles = r.Decompose(Gf.Vec3d.XAxis(), Gf.Vec3d.YAxis(), Gf.Vec3d.ZAxis())
+                    self.assertTrue(Gf.IsClose(Gf.Vec3f(eulerAngles), Gf.Vec3f(0.0), toleranceEpsilon))
+                    self.assertTrue(Gf.IsClose(Gf.Vec3f(1.0), desc.localScale, toleranceEpsilon))
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigidbody_found)
+        self.assertTrue(cube_found)
+
+    def test_filtering_pairs_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)            
+
+        rigidbody_0 = UsdGeom.Xform.Define(stage, "/rigidBody0")
+        UsdPhysics.RigidBodyAPI.Apply(rigidbody_0.GetPrim())
+
+        cube_0 = UsdGeom.Cube.Define(stage, "/rigidBody0/cube")
+        UsdPhysics.CollisionAPI.Apply(cube_0.GetPrim())
+
+        rigidbody_1 = UsdGeom.Xform.Define(stage, "/rigidBody1")
+        UsdPhysics.RigidBodyAPI.Apply(rigidbody_1.GetPrim())
+        rb_filter = UsdPhysics.FilteredPairsAPI.Apply(rigidbody_1.GetPrim())
+        rb_filter.GetFilteredPairsRel().AddTarget(rigidbody_0.GetPrim().GetPrimPath())
+
+        cube_1 = UsdGeom.Cube.Define(stage, "/rigidBody1/cube")
+        UsdPhysics.CollisionAPI.Apply(cube_1.GetPrim())
+        col_filter = UsdPhysics.FilteredPairsAPI.Apply(cube_1.GetPrim())
+        col_filter.GetFilteredPairsRel().AddTarget(cube_0.GetPrim().GetPrimPath())
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        rigidbody_count = 0
+        cube_count = 0
+        
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                for prim_path, desc in zip(prim_paths, descs):
+                    scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                for prim_path, desc in zip(prim_paths, descs):
+                    rigidbody_count = rigidbody_count + 1
+                    if prim_path == rigidbody_1.GetPrim().GetPrimPath():
+                        self.assertTrue(len(desc.filteredCollisions) == 1)
+                        self.assertTrue(desc.filteredCollisions[0] == rigidbody_0.GetPrim().GetPrimPath())
+            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+                for prim_path, desc in zip(prim_paths, descs):
+                    cube_count = cube_count + 1
+                    if prim_path == cube_1.GetPrim().GetPrimPath():
+                        self.assertTrue(len(desc.filteredCollisions) == 1)
+                        self.assertTrue(desc.filteredCollisions[0] == cube_0.GetPrim().GetPrimPath())
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigidbody_count == 2)
+        self.assertTrue(cube_count == 2)
+
+    # materials
+    def test_collision_material_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)            
+
+        cube = UsdGeom.Cube.Define(stage, "/cube")
+        UsdPhysics.CollisionAPI.Apply(cube.GetPrim())
+
+        # single material
+        materialPrim = UsdShade.Material.Define(stage, "/physicsMaterial")
+        UsdPhysics.MaterialAPI.Apply(materialPrim.GetPrim())
+        bindingAPI = UsdShade.MaterialBindingAPI.Apply(cube.GetPrim())
+        bindingAPI.Bind(materialPrim, UsdShade.Tokens.weakerThanDescendants, "physics")
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        cube_found = False
+        material_found = False
+        
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                for prim_path, desc in zip(prim_paths, descs):
+                    scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+                for prim_path, desc in zip(prim_paths, descs):
+                    cube_found = True
+                    self.assertTrue(len(desc.materials) == 1)
+                    desc.materials[0] = materialPrim.GetPrim().GetPrimPath()
+            elif key == UsdPhysics.PhysicsObjectType.RigidBodyMaterial:
+                for prim_path, desc in zip(prim_paths, descs):
+                    material_found = True
+                    self.assertTrue(prim_path == materialPrim.GetPrim().GetPrimPath())
+                    self.assertEqual(desc.staticFriction, 0)
+                    self.assertEqual(desc.dynamicFriction, 0)
+                    self.assertEqual(desc.restitution, 0)
+                    self.assertEqual(desc.density, 0)
+
+        self.assertTrue(scene_found)
+        self.assertTrue(cube_found)
+        self.assertTrue(material_found)
+
+    def test_collision_multi_material_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)            
+
+        mesh = UsdGeom.Mesh.Define(stage, "/mesh")
+        UsdPhysics.CollisionAPI.Apply(mesh.GetPrim())
+        meshColAPI = UsdPhysics.MeshCollisionAPI.Apply(mesh.GetPrim())
+        meshColAPI.GetApproximationAttr().Set(UsdPhysics.Tokens.none)
+
+        # materials        
+        materialPrim0 = UsdShade.Material.Define(stage, "/physicsMaterial0")
+        UsdPhysics.MaterialAPI.Apply(materialPrim0.GetPrim())
+        materialPrim1 = UsdShade.Material.Define(stage, "/physicsMaterial1")
+        UsdPhysics.MaterialAPI.Apply(materialPrim1.GetPrim())
+
+        materials = [materialPrim0, materialPrim1]
+
+        # Fill in VtArrays
+        points = []
+        normals = []
+        indices = []
+        vertexCounts = []
+
+        stripSize = 100.0
+        halfSize = 500.0 
+
+        for i in range(2):
+            subset = UsdGeom.Subset.Define(stage, "/mesh/subset" + str(i))
+            subset.CreateElementTypeAttr().Set("face")
+            subset_indices = [i]
+
+            bindingAPI = UsdShade.MaterialBindingAPI.Apply(subset.GetPrim())
+            bindingAPI.Bind(materials[i] , UsdShade.Tokens.weakerThanDescendants, "physics")
+            # rel = subset.GetPrim().CreateRelationship("material:binding:physics", False)
+            # rel.SetTargets([materials[i].GetPrim().GetPrimPath()])
+
+            points.append(Gf.Vec3f(-stripSize / 2.0 + stripSize * i, -halfSize, 0.0))
+            points.append(Gf.Vec3f(-stripSize / 2.0 + stripSize * (i + 1), -halfSize, 0.0))
+            points.append(Gf.Vec3f(-stripSize / 2.0 + stripSize * (i + 1), halfSize, 0.0))
+            points.append(Gf.Vec3f(-stripSize / 2.0 + stripSize * i, halfSize, 0.0))
+            
+            for j in range(4):
+                normals.append(Gf.Vec3f(0, 0, 1))
+                indices.append(j + i * 4)                
+
+            subset.CreateIndicesAttr().Set(subset_indices)
+            vertexCounts.append(4)
+
+        mesh.CreateFaceVertexCountsAttr().Set(vertexCounts)
+        mesh.CreateFaceVertexIndicesAttr().Set(indices)
+        mesh.CreatePointsAttr().Set(points)
+        mesh.CreateDoubleSidedAttr().Set(False)
+        mesh.CreateNormalsAttr().Set(normals)
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        mesh_found = False
+        num_materials = 0
+        
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                for prim_path, desc in zip(prim_paths, descs):
+                    scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.MeshShape:
+                for prim_path, desc in zip(prim_paths, descs):
+                    mesh_found = True
+                    self.assertTrue(len(desc.materials) == 3)   # three materials, the last material is the one applied eventually to the collision itself                                        
+                    self.assertTrue(desc.materials[0] == materialPrim0.GetPrim().GetPrimPath())
+                    self.assertTrue(desc.materials[1] == materialPrim1.GetPrim().GetPrimPath())
+                    self.assertTrue(desc.materials[2] == Sdf.Path())
+            elif key == UsdPhysics.PhysicsObjectType.RigidBodyMaterial:
+                for prim_path, desc in zip(prim_paths, descs):
+                    num_materials = num_materials + 1
+
+        self.assertTrue(scene_found)
+        self.assertTrue(mesh_found)
+        self.assertTrue(num_materials == 2)
+
+    # joints
+    def test_joint_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        rigid_body_0 = UsdGeom.Xform.Define(stage, "/rigidBody0")
+        UsdPhysics.RigidBodyAPI.Apply(rigid_body_0.GetPrim())
+        rigid_body_1 = UsdGeom.Xform.Define(stage, "/rigidBody1")
+        UsdPhysics.RigidBodyAPI.Apply(rigid_body_1.GetPrim())
+
+        joint_prim = None
+        joints = {
+            "fixed" : {"type" : UsdPhysics.FixedJoint},
+            "revolute0" : {"type" : UsdPhysics.RevoluteJoint, "axis" : UsdGeom.Tokens.y, "limit" : True, "drive" : True},
+            "revolute1" : {"type" : UsdPhysics.RevoluteJoint, "axis" : UsdGeom.Tokens.y, "limit" : False, "drive" : False},
+            "prismatic0" : {"type" : UsdPhysics.PrismaticJoint, "axis" : UsdGeom.Tokens.z, "limit" : True, "drive" : True},
+            "prismatic1" : {"type" : UsdPhysics.PrismaticJoint, "axis" : UsdGeom.Tokens.z, "limit" : False, "drive" : False},
+            "spherical" : {"type" : UsdPhysics.SphericalJoint, "axis" : UsdGeom.Tokens.z},
+            "distance" : {"type" : UsdPhysics.DistanceJoint},
+            "d6" : {"type" : UsdPhysics.Joint},
+        }
+
+        for key, params in joints.items():
+            if joint_prim is not None:
+                stage.RemovePrim(joint_prim.GetPrimPath())
+            joint = params["type"].Define(stage, "/joint")
+            joint_prim = joint.GetPrim()
+
+            # common part
+            joint.GetBody0Rel().AddTarget(rigid_body_0.GetPrim().GetPrimPath())
+            joint.GetBody1Rel().AddTarget(rigid_body_1.GetPrim().GetPrimPath())
+
+            joint.GetBreakForceAttr().Set(500)
+            joint.GetBreakTorqueAttr().Set(1500)
+
+            joint.GetLocalPos0Attr().Set(Gf.Vec3f(1.0))
+            joint.GetLocalPos1Attr().Set(Gf.Vec3f(-1.0))
+
+            if (key == "revolute0") or (key == "revolute1"):
+                joint.GetAxisAttr().Set(params["axis"])
+                if (params["limit"]):
+                    joint.GetLowerLimitAttr().Set(0)
+                    joint.GetUpperLimitAttr().Set(90)
+                if (params["drive"]):
+                    drive = UsdPhysics.DriveAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.angular)
+                    drive.GetTargetPositionAttr().Set(10)
+                    drive.GetTargetVelocityAttr().Set(20)
+                    drive.GetStiffnessAttr().Set(30)
+                    drive.GetDampingAttr().Set(40)
+            elif (key == "prismatic0") or (key == "prismatic1"):
+                joint.GetAxisAttr().Set(params["axis"])
+                if (params["limit"]):
+                    joint.GetLowerLimitAttr().Set(10)
+                    joint.GetUpperLimitAttr().Set(80)
+                if (params["drive"]):
+                    drive = UsdPhysics.DriveAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.linear)
+                    drive.GetTargetPositionAttr().Set(10)
+                    drive.GetTargetVelocityAttr().Set(20)
+                    drive.GetStiffnessAttr().Set(30)
+                    drive.GetDampingAttr().Set(40)
+            elif (key == "spherical"):
+                joint.GetAxisAttr().Set(params["axis"])
+                joint.CreateConeAngle0LimitAttr().Set(20)
+                joint.CreateConeAngle1LimitAttr().Set(30)
+            elif (key == "distance"):
+                joint.GetMinDistanceAttr().Set(0)
+                joint.GetMaxDistanceAttr().Set(10)
+            elif (key == "d6"):
+                x_trans_lim = UsdPhysics.LimitAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.transX)
+                x_trans_lim.CreateLowAttr().Set(-10)
+                x_trans_lim.CreateHighAttr().Set(10)
+                y_trans_lim = UsdPhysics.LimitAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.transY)
+                y_trans_lim.CreateLowAttr().Set(-20)
+                y_trans_lim.CreateHighAttr().Set(20)
+
+                x_rot_lim = UsdPhysics.LimitAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.rotX)
+                x_rot_lim.CreateLowAttr().Set(-30)
+                x_rot_lim.CreateHighAttr().Set(30)
+                y_rot_lim = UsdPhysics.LimitAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.rotY)
+                y_rot_lim.CreateLowAttr().Set(30)
+                y_rot_lim.CreateHighAttr().Set(-30)
+
+                drive = UsdPhysics.DriveAPI.Apply(joint.GetPrim(), UsdPhysics.Tokens.rotX)
+                drive.GetTargetPositionAttr().Set(10)
+                drive.GetTargetVelocityAttr().Set(20)
+                drive.GetStiffnessAttr().Set(30)
+                drive.GetDampingAttr().Set(40)
+
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+            scene_found = False
+            num_joints_found = 0
+
+            def compare_joint_params(desc):
+                self.assertTrue(prim_path == joint_prim.GetPrimPath())
+
+                self.assertTrue(desc.rel0 == rigid_body_0.GetPrim().GetPrimPath())
+                self.assertTrue(desc.body0 == rigid_body_0.GetPrim().GetPrimPath())
+                self.assertTrue(desc.rel1 == rigid_body_1.GetPrim().GetPrimPath())
+                self.assertTrue(desc.body1 == rigid_body_1.GetPrim().GetPrimPath())
+
+                self.assertTrue(Gf.IsClose(desc.localPose0Position, Gf.Vec3f(1.0), toleranceEpsilon))
+                self.assertTrue(Gf.IsClose(desc.localPose1Position, Gf.Vec3f(-1.0), toleranceEpsilon))
+
+                self.assertTrue(desc.jointEnabled is True)
+                self.assertTrue(desc.collisionEnabled is False)
+                self.assertTrue(desc.excludeFromArticulation is False)
+
+                self.assertEqual(desc.breakForce, 500)
+                self.assertEqual(desc.breakTorque, 1500)
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.FixedJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common joint
+                        compare_joint_params(desc)
+
+                        num_joints_found = num_joints_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.RevoluteJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common joint
+                        compare_joint_params(desc)
+
+                        # revolute joint part
+                        self.assertTrue(desc.axis == UsdPhysics.PhysicsAxis.Y)
+
+                        # limit
+                        if (params["limit"]):
+                            self.assertTrue(desc.limit.enabled is True)
+                            self.assertEqual(desc.limit.lower, 0)
+                            self.assertEqual(desc.limit.upper, 90)
+                        else:
+                            self.assertTrue(desc.limit.enabled is False)
+
+                        # drive
+                        if (params["drive"]):
+                            self.assertTrue(desc.drive.enabled is True)
+                            self.assertEqual(desc.drive.targetPosition, 10)
+                            self.assertEqual(desc.drive.targetVelocity, 20)
+                            self.assertEqual(desc.drive.stiffness, 30)
+                            self.assertEqual(desc.drive.damping, 40)
+                        else:
+                            self.assertTrue(desc.drive.enabled is False)
+
+                        num_joints_found = num_joints_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.PrismaticJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common joint
+                        compare_joint_params(desc)
+
+                        # prismatic joint part
+                        self.assertTrue(desc.axis == UsdPhysics.PhysicsAxis.Z)
+
+                        # limit
+                        if (params["limit"]):                        
+                            self.assertTrue(desc.limit.enabled is True)
+                            self.assertEqual(desc.limit.lower, 10)
+                            self.assertEqual(desc.limit.upper, 80)
+                        else:
+                            self.assertTrue(desc.limit.enabled is False)
+
+                        # drive
+                        if (params["drive"]):
+                            self.assertTrue(desc.drive.enabled is True)
+                            self.assertEqual(desc.drive.targetPosition, 10)
+                            self.assertEqual(desc.drive.targetVelocity, 20)
+                            self.assertEqual(desc.drive.stiffness, 30)
+                            self.assertEqual(desc.drive.damping, 40)
+                        else:
+                            self.assertTrue(desc.drive.enabled is False)
+
+                        num_joints_found = num_joints_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.D6Joint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common joint
+                        compare_joint_params(desc)
+
+                        # d6 joint part
+                        self.assertTrue(len(desc.jointLimits) == 4)
+                        self.assertTrue(len(desc.jointDrives) == 1)
+
+                        # drive for rotX
+                        xDrivePair = desc.jointDrives[0]
+                        self.assertTrue(xDrivePair.first == UsdPhysics.PhysicsJointDOF.RotX)
+                        xDrive = xDrivePair.second
+                        self.assertTrue(xDrive.enabled is True)
+                        self.assertEqual(xDrive.targetPosition, 10)
+                        self.assertEqual(xDrive.targetVelocity, 20)
+                        self.assertEqual(xDrive.stiffness, 30)
+                        self.assertEqual(xDrive.damping, 40)
+
+                        # limits
+                        for d6_limit in desc.jointLimits:
+                            limit_dof = d6_limit.first
+                            limit = d6_limit.second
+                            if limit_dof == UsdPhysics.PhysicsJointDOF.TransX:
+                                self.assertTrue(limit.enabled is True)
+                                self.assertEqual(limit.lower, -10)
+                                self.assertEqual(limit.upper, 10)
+                            elif limit_dof == UsdPhysics.PhysicsJointDOF.TransY:
+                                self.assertTrue(limit.enabled is True)
+                                self.assertEqual(limit.lower, -20)
+                                self.assertEqual(limit.upper, 20)
+                            elif limit_dof == UsdPhysics.PhysicsJointDOF.RotX:
+                                self.assertTrue(limit.enabled is True)
+                                self.assertEqual(limit.lower, -30)
+                                self.assertEqual(limit.upper, 30)
+                            elif limit_dof == UsdPhysics.PhysicsJointDOF.RotY:
+                                self.assertTrue(limit.enabled is True)
+                                self.assertEqual(limit.lower, 30)       # lower higher then upper means DOF is locked
+                                self.assertEqual(limit.upper, -30)
+
+                        num_joints_found = num_joints_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.SphericalJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common joint
+                        compare_joint_params(desc)
+
+                        # spherical joint part
+                        self.assertTrue(desc.axis == UsdPhysics.PhysicsAxis.Z)
+                        self.assertTrue(desc.limit.enabled is True)
+                        self.assertEqual(desc.limit.lower, 20)  # lower maps to cone0 angle
+                        self.assertEqual(desc.limit.upper, 30)  # upper maps to cone1 angle
+
+                        num_joints_found = num_joints_found + 1
+                elif key == UsdPhysics.PhysicsObjectType.DistanceJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        # common joint
+                        compare_joint_params(desc)
+
+                        # distance joint part
+                        self.assertTrue(desc.minEnabled is True)  # limit can be per min/max, limit.enabled not used
+                        self.assertTrue(desc.maxEnabled is True)
+                        self.assertEqual(desc.limit.lower, 0)  # lower maps to min
+                        self.assertEqual(desc.limit.upper, 10)  # upper maps to max
+
+                        num_joints_found = num_joints_found + 1
+
+            self.assertTrue(scene_found)
+            self.assertTrue(num_joints_found == 1)
+
+    # articulations
+    def test_articulation_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        # top level xform
+        top_xform = UsdGeom.Xform.Define(stage, "/xform")
+
+        rigid_body_0 = UsdGeom.Xform.Define(stage, "/xform/rigidBody0")
+        UsdPhysics.RigidBodyAPI.Apply(rigid_body_0.GetPrim())
+        rigid_body_1 = UsdGeom.Xform.Define(stage, "/xform/rigidBody1")
+        UsdPhysics.RigidBodyAPI.Apply(rigid_body_1.GetPrim())
+        rigid_body_2 = UsdGeom.Xform.Define(stage, "/xform/rigidBody2")
+        UsdPhysics.RigidBodyAPI.Apply(rigid_body_2.GetPrim())
+
+        joint_0 = UsdPhysics.RevoluteJoint.Define(stage, "/xform/revoluteJoint0")
+        joint_0.GetBody0Rel().AddTarget(rigid_body_0.GetPrim().GetPrimPath())
+        joint_0.GetBody1Rel().AddTarget(rigid_body_1.GetPrim().GetPrimPath())
+
+        joint_1 = UsdPhysics.RevoluteJoint.Define(stage, "/xform/revoluteJoint1")
+        joint_1.GetBody0Rel().AddTarget(rigid_body_1.GetPrim().GetPrimPath())
+        joint_1.GetBody1Rel().AddTarget(rigid_body_2.GetPrim().GetPrimPath())
+
+        articulation_api_prim = None
+        fixed_joint = None
+        articulations = ["floating", "auto", "fixed", "auto_fixed"]
+
+        for type in articulations:
+            if articulation_api_prim is not None:
+                articulation_api_prim.RemoveAPI(UsdPhysics.ArticulationRootAPI)
+                articulation_api_prim = None
+
+            if type == "fixed":
+                fixed_joint = UsdPhysics.FixedJoint.Define(stage, "/xform/fixedJoint")
+                fixed_joint.GetBody1Rel().AddTarget(rigid_body_0.GetPrim().GetPrimPath())
+                UsdPhysics.ArticulationRootAPI.Apply(fixed_joint.GetPrim())
+                articulation_api_prim = fixed_joint.GetPrim()
+            elif type == "floating":
+                UsdPhysics.ArticulationRootAPI.Apply(rigid_body_1.GetPrim())
+                articulation_api_prim = rigid_body_1.GetPrim()
+            elif type == "auto" or type == "auto_fixed":
+                UsdPhysics.ArticulationRootAPI.Apply(top_xform.GetPrim())
+                articulation_api_prim = top_xform.GetPrim()
+
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+            scene_found = False
+            articulation_found = False
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.Articulation:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        articulation_found = True
+
+                        self.assertTrue(len(desc.rootPrims) == 1)
+
+                        if type == "floating" or type == "auto":
+                            self.assertTrue(len(desc.articulatedJoints) == 2)
+                            self.assertTrue(len(desc.articulatedBodies) == 3)
+                            
+                            self.assertTrue(desc.rootPrims[0] == rigid_body_1.GetPrim().GetPrimPath())
+                        else:
+                            self.assertTrue(len(desc.articulatedJoints) == 3)
+                            self.assertTrue(len(desc.articulatedBodies) == 4)   # SdfPath returned for the static body
+
+                            self.assertTrue(desc.rootPrims[0] == fixed_joint.GetPrim().GetPrimPath())
+
+            self.assertTrue(scene_found)
+            self.assertTrue(articulation_found)
+
+    def test_collision_groups_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        num_collision_groups = 10
+
+        collision_groups = []
+        for i in range(num_collision_groups):
+            collision_group = UsdPhysics.CollisionGroup.Define(stage, "/collision_group" + str(i))
+            collision_group.GetInvertFilteredGroupsAttr().Set(False)
+            collision_groups.append(collision_group)
+            if i == 0:
+                collision_group.GetFilteredGroupsRel().AddTarget("/collision_group" + str(num_collision_groups - 1))
+            else:
+                collision_group.GetFilteredGroupsRel().AddTarget("/collision_group" + str(i - 1))
+                if i % 3 == 0:
+                    collision_group.GetMergeGroupNameAttr().Set("three")
+                if i % 4 == 0:
+                    collision_group.GetMergeGroupNameAttr().Set("four")
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        num_reported_collision_groups = 0
+
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.CollisionGroup:
+                for prim_path, desc in zip(prim_paths, descs):
+                    if desc.mergeGroupName == "three":
+                        self.assertTrue(prim_path == collision_groups[3].GetPrim().GetPrimPath())
+                        self.assertTrue(len(desc.mergedGroups) == 3)
+                        self.assertTrue(len(desc.filteredGroups) == 3)                        
+                        self.assertTrue(desc.filteredGroups[0] == "/collision_group2")
+                        self.assertTrue(desc.filteredGroups[1] == "/collision_group5")
+                        self.assertTrue(desc.filteredGroups[2] == "/collision_group8")
+                    elif desc.mergeGroupName == "four":
+                        self.assertTrue(prim_path == collision_groups[4].GetPrim().GetPrimPath())
+                        self.assertTrue(len(desc.mergedGroups) == 2)
+                        self.assertTrue(len(desc.filteredGroups) == 2)                        
+                        self.assertTrue(desc.filteredGroups[0] == "/collision_group3")
+                        self.assertTrue(desc.filteredGroups[1] == "/collision_group7")
+                    else:
+                        self.assertTrue(not desc.mergeGroupName)
+                        self.assertTrue(len(desc.mergedGroups) == 0)
+                        self.assertTrue(len(desc.filteredGroups) == 1)
+
+                    self.assertTrue(desc.invertFilteredGroups is False)
+                    num_reported_collision_groups = num_reported_collision_groups + 1
+
+        self.assertTrue(scene_found)
+        self.assertTrue(num_reported_collision_groups == 7)
+
+    def test_collision_groups_collider_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        collision_group_0 = UsdPhysics.CollisionGroup.Define(stage, "/collision_group_0")
+        collision_group_1 = UsdPhysics.CollisionGroup.Define(stage, "/collision_group_1")
+
+        cube = UsdGeom.Cube.Define(stage, "/cube")
+        UsdPhysics.CollisionAPI.Apply(cube.GetPrim())
+
+        collision_group_0.GetCollidersCollectionAPI().GetIncludesRel().AddTarget(cube.GetPrim().GetPrimPath())
+        collision_group_1.GetCollidersCollectionAPI().GetIncludesRel().AddTarget(cube.GetPrim().GetPrimPath())
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())))
+
+        scene_found = False
+        num_reported_collision_groups = 0
+        shape_reported = False
+
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.CollisionGroup:
+                for prim_path, desc in zip(prim_paths, descs):
+                    num_reported_collision_groups = num_reported_collision_groups + 1
+            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+                for prim_path, desc in zip(prim_paths, descs):
+                    self.assertTrue(len(desc.collisionGroups) == 2)
+                    self.assertTrue(desc.collisionGroups[0] == collision_group_0.GetPrim().GetPrimPath())
+                    self.assertTrue(desc.collisionGroups[1] == collision_group_1.GetPrim().GetPrimPath())
+                    shape_reported = True
+
+        self.assertTrue(scene_found)
+        self.assertTrue(num_reported_collision_groups == 2)
+        self.assertTrue(shape_reported)
+
+    # custom tokens
+    def test_custom_geometry_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        UsdGeom.Cube.Define(stage, "/cube")
+
+        layer = stage.GetEditTarget().GetLayer()
+        primSpec = Sdf.CreatePrimInLayer(layer, "/cube")
+        listOp = Sdf.TokenListOp()
+        listOp.prependedItems = ["MyCustomGeometryAPI", "PhysicsCollisionAPI"]
+        primSpec.SetInfo(Usd.Tokens.apiSchemas, listOp)
+
+        custom_tokens = UsdPhysics.CustomUsdPhysicsTokens()
+        custom_tokens.shapeTokens.append("MyCustomGeometryAPI")
+
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens)
+
+        scene_found = False
+        custom_geometry_found = False
+
+        for key, value in ret_dict.items():
+            prim_paths, descs = value
+            if key == UsdPhysics.PhysicsObjectType.Scene:
+                scene_found = True
+            elif key == UsdPhysics.PhysicsObjectType.CustomShape:
+                for prim_path, desc in zip(prim_paths, descs):
+                    custom_geometry_found = True
+
+        self.assertTrue(scene_found)
+        self.assertTrue(custom_geometry_found)
+
+    # simulation owner tests
+    def test_rigid_body_simulation_owner_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        cube = UsdGeom.Cube.Define(stage, "/cube")
+        rbo_api = UsdPhysics.RigidBodyAPI.Apply(cube.GetPrim())
+
+        custom_tokens = UsdPhysics.CustomUsdPhysicsTokens()
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+
+        def check_ret_dict():
+            scene_found = False
+            rigid_body_found = False
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        rigid_body_found = True
+
+            return scene_found, rigid_body_found
+
+        scene_found, rigid_body_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(not rigid_body_found)
+
+        simulation_owners = [Sdf.Path()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found = check_ret_dict()
+
+        self.assertTrue(not scene_found)
+        self.assertTrue(rigid_body_found)
+
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        rbo_api.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigid_body_found)
+
+    def test_collision_simulation_owner_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        xform = UsdGeom.Xform.Define(stage, "/xform")
+        rbo_api = UsdPhysics.RigidBodyAPI.Apply(xform.GetPrim())
+
+        cube = UsdGeom.Cube.Define(stage, "/xform/cube")
+        collision_api = UsdPhysics.CollisionAPI.Apply(cube.GetPrim())
+
+        custom_tokens = UsdPhysics.CustomUsdPhysicsTokens()
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+
+        def check_ret_dict():
+            scene_found = False
+            rigid_body_found = False
+            collision_found = False
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        rigid_body_found = True
+                elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        collision_found = True
+
+            return scene_found, rigid_body_found, collision_found
+
+        scene_found, rigid_body_found, collision_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(not rigid_body_found)
+        self.assertTrue(not collision_found)
+
+        simulation_owners = [Sdf.Path()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, collision_found = check_ret_dict()
+
+        self.assertTrue(not scene_found)
+        self.assertTrue(rigid_body_found)
+        self.assertTrue(collision_found)
+
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        rbo_api.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, collision_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigid_body_found)
+        self.assertTrue(collision_found)
+
+        xform.GetPrim().RemoveAPI(UsdPhysics.RigidBodyAPI)
+        simulation_owners = [Sdf.Path()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, collision_found = check_ret_dict()
+
+        self.assertTrue(not scene_found)
+        self.assertTrue(not rigid_body_found)
+        self.assertTrue(collision_found)
+
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, collision_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(not rigid_body_found)
+        self.assertTrue(not collision_found)
+
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        collision_api.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, collision_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(not rigid_body_found)
+        self.assertTrue(collision_found)
+
+    def test_joint_simulation_owner_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        xform_0 = UsdGeom.Xform.Define(stage, "/xform0")
+        rbo_api_0 = UsdPhysics.RigidBodyAPI.Apply(xform_0.GetPrim())
+
+        xform_1 = UsdGeom.Xform.Define(stage, "/xform1")
+        rbo_api_1 = UsdPhysics.RigidBodyAPI.Apply(xform_1.GetPrim())
+
+        fixed_joint = UsdPhysics.FixedJoint.Define(stage, "/fixedJoint")
+
+        def check_ret_dict():
+            scene_found = False
+            rigid_body_found = False
+            joint_found = False
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        rigid_body_found = True
+                elif key == UsdPhysics.PhysicsObjectType.FixedJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        joint_found = True
+
+            return scene_found, rigid_body_found, joint_found
+
+        test_cases = ["body0", "body1", "both"]
+        for tc in test_cases:
+            rbo_api_0.GetSimulationOwnerRel().ClearTargets(False)
+            rbo_api_1.GetSimulationOwnerRel().ClearTargets(False)
+
+            if tc == "body0":
+                fixed_joint.GetBody0Rel().AddTarget(xform_0.GetPrim().GetPrimPath())
+            elif tc == "body1":
+                fixed_joint.GetBody1Rel().AddTarget(xform_1.GetPrim().GetPrimPath())
+            elif tc == "both":
+                fixed_joint.GetBody0Rel().AddTarget(xform_0.GetPrim().GetPrimPath())
+                fixed_joint.GetBody1Rel().AddTarget(xform_1.GetPrim().GetPrimPath())
+
+            custom_tokens = UsdPhysics.CustomUsdPhysicsTokens()
+            simulation_owners = [scene.GetPrim().GetPrimPath()]
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+
+            scene_found, rigid_body_found, joint_found = check_ret_dict()
+
+            self.assertTrue(scene_found)
+            self.assertTrue(not rigid_body_found)
+            self.assertTrue(not joint_found)
+
+            simulation_owners = [Sdf.Path()]
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+            scene_found, rigid_body_found, joint_found = check_ret_dict()
+
+            self.assertTrue(not scene_found)
+            self.assertTrue(rigid_body_found)
+            self.assertTrue(joint_found)
+
+            rbo_api_0.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+            rbo_api_1.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+            simulation_owners = [scene.GetPrim().GetPrimPath()]
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+            scene_found, rigid_body_found, joint_found = check_ret_dict()
+
+            self.assertTrue(scene_found)
+            self.assertTrue(rigid_body_found)
+            self.assertTrue(joint_found)
+
+            rbo_api_0.GetSimulationOwnerRel().ClearTargets(False)            
+            rbo_api_1.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+            simulation_owners = [scene.GetPrim().GetPrimPath()]
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+            scene_found, rigid_body_found, joint_found = check_ret_dict()
+
+            self.assertTrue(scene_found)
+            self.assertTrue(rigid_body_found)
+            self.assertTrue(not joint_found)
+
+            rbo_api_0.GetSimulationOwnerRel().ClearTargets(False)            
+            rbo_api_1.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+            simulation_owners = [Sdf.Path(), scene.GetPrim().GetPrimPath()]
+            ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+            scene_found, rigid_body_found, joint_found = check_ret_dict()
+
+            self.assertTrue(scene_found)
+            self.assertTrue(rigid_body_found)
+            self.assertTrue(joint_found)
+
+    def test_articulation_simulation_owner_parse(self):
+        stage = Usd.Stage.CreateInMemory()
+        self.assertTrue(stage)
+
+        scene = UsdPhysics.Scene.Define(stage, '/physicsScene')
+        self.assertTrue(scene)
+
+        xform = UsdGeom.Xform.Define(stage, "/xform")
+        UsdPhysics.ArticulationRootAPI.Apply(xform.GetPrim())
+
+        cube_0 = UsdGeom.Cube.Define(stage, "/xform/cube0")
+        rigid_body_api_0 = UsdPhysics.RigidBodyAPI.Apply(cube_0.GetPrim())
+
+        cube_1 = UsdGeom.Cube.Define(stage, "/xform/cube1")
+        rigid_body_api_1 = UsdPhysics.RigidBodyAPI.Apply(cube_1.GetPrim())
+
+        cube_2 = UsdGeom.Cube.Define(stage, "/xform/cube2")
+        rigid_body_api_2 = UsdPhysics.RigidBodyAPI.Apply(cube_2.GetPrim())
+
+        revolute_joint_0 = UsdPhysics.RevoluteJoint.Define(stage, "/xform/revoluteJoint0")
+        revolute_joint_0.GetBody0Rel().AddTarget(cube_0.GetPrim().GetPrimPath())
+        revolute_joint_0.GetBody1Rel().AddTarget(cube_1.GetPrim().GetPrimPath())
+
+        revolute_joint_1 = UsdPhysics.RevoluteJoint.Define(stage, "/xform/revoluteJoint1")
+        revolute_joint_1.GetBody0Rel().AddTarget(cube_1.GetPrim().GetPrimPath())
+        revolute_joint_1.GetBody1Rel().AddTarget(cube_2.GetPrim().GetPrimPath())
+
+        custom_tokens = UsdPhysics.CustomUsdPhysicsTokens()
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+
+        def check_ret_dict():
+            scene_found = False
+            rigid_body_found = False
+            articulation_found = False
+            joint_found = False
+
+            for key, value in ret_dict.items():
+                prim_paths, descs = value
+                if key == UsdPhysics.PhysicsObjectType.Scene:
+                    scene_found = True
+                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        rigid_body_found = True
+                elif key == UsdPhysics.PhysicsObjectType.RevoluteJoint:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        joint_found = True
+                elif key == UsdPhysics.PhysicsObjectType.Articulation:
+                    for prim_path, desc in zip(prim_paths, descs):
+                        articulation_found = True
+
+            return scene_found, rigid_body_found, joint_found, articulation_found
+
+        scene_found, rigid_body_found, joint_found, articulation_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(not rigid_body_found)
+        self.assertTrue(not joint_found)
+        self.assertTrue(not articulation_found)
+
+        simulation_owners = [Sdf.Path()]
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, joint_found, articulation_found = check_ret_dict()
+
+        self.assertTrue(not scene_found)
+        self.assertTrue(rigid_body_found)
+        self.assertTrue(joint_found)
+        self.assertTrue(articulation_found)
+
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        rigid_body_api_0.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        rigid_body_api_1.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, joint_found, articulation_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigid_body_found)
+        self.assertTrue(joint_found)
+        self.assertTrue(not articulation_found)
+
+        simulation_owners = [scene.GetPrim().GetPrimPath()]
+        rigid_body_api_0.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        rigid_body_api_1.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        rigid_body_api_2.GetSimulationOwnerRel().AddTarget(scene.GetPrim().GetPrimPath())
+        ret_dict = UsdPhysics.LoadUsdPhysicsFromRange(stage, UsdPhysics.ParsePrimIteratorRange(Usd.PrimRange(stage.GetPseudoRoot())), custom_tokens, simulation_owners)
+        scene_found, rigid_body_found, joint_found, articulation_found = check_ret_dict()
+
+        self.assertTrue(scene_found)
+        self.assertTrue(rigid_body_found)
+        self.assertTrue(joint_found)
+        self.assertTrue(articulation_found)
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/pxr/usd/usdPhysics/wrapParseUtils.cpp b/pxr/usd/usdPhysics/wrapParseUtils.cpp
new file mode 100644
index 0000000000..9cdedd0833
--- /dev/null
+++ b/pxr/usd/usdPhysics/wrapParseUtils.cpp
@@ -0,0 +1,1178 @@
+//
+// Copyright 2016 Pixar
+//
+// Licensed under the Apache License, Version 2.0 (the "Apache License")
+// with the following modification; you may not use this file except in
+// compliance with the Apache License and the following modification to it:
+// Section 6. Trademarks. is deleted and replaced with:
+//
+// 6. Trademarks. This License does not grant permission to use the trade
+//    names, trademarks, service marks, or product names of the Licensor
+//    and its affiliates, except as required to comply with Section 4(c) of
+//    the License and to reproduce the content of the NOTICE file.
+//
+// You may obtain a copy of the Apache License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the Apache License with the above modification is
+// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied. See the Apache License for the specific
+// language governing permissions and limitations under the Apache License.
+//
+#include "pxr/pxr.h"
+
+#include "parseUtils.h"
+#include "parseDesc.h"
+
+#include "pxr/usd/usd/stage.h"
+#include "pxr/usd/usd/primRange.h"
+
+#include "pxr/usd/usd/pyConversions.h"
+#include "pxr/base/tf/pyContainerConversions.h"
+#include "pxr/base/tf/pyResultConversions.h"
+#include "pxr/base/tf/pyUtils.h"
+#include "pxr/base/tf/wrapTypeHelpers.h"
+
+#include "pxr/usd/usd/pyConversions.h"
+
+#include "pxr/external/boost/python/suite/indexing/vector_indexing_suite.hpp"
+
+#include "pxr/external/boost/python.hpp"
+#include "pxr/external/boost/python/class.hpp"
+#include "pxr/external/boost/python/def.hpp"
+#include "pxr/external/boost/python/enum.hpp"
+#include "pxr/external/boost/python/object.hpp"
+#include "pxr/external/boost/python/str.hpp"
+
+template <typename T>
+void registerVectorConverter(const char* name)
+{
+    pxr_boost::python::class_<std::vector<T>>(name).def(vector_indexing_suite<std::vector<T>>());
+}
+
+PXR_NAMESPACE_USING_DIRECTIVE
+
+using namespace pxr_boost::python;
+
+
+// Wrapper class
+class ParsePrimIteratorBaseWrap : public ParsePrimIteratorBase, public pxr_boost::python::wrapper<ParsePrimIteratorBase> {
+public:
+    void reset() {
+        this->get_override("reset")();
+    }
+
+    bool atEnd() const {
+        return this->get_override("atEnd")();
+    }
+
+    UsdPrimRange::const_iterator getCurrent() {
+        return this->get_override("getCurrent")();
+    }
+
+    void next() {
+        this->get_override("next")();
+    }
+
+    void pruneChildren() {
+        this->get_override("pruneChildren")();
+    }
+};
+
+class MarshalCallback
+{
+public:    
+
+    SdfPathVector                   scenePrimPaths;
+    std::vector<SceneDesc>          sceneDescs;
+
+    SdfPathVector                   rigidBodyPrimPaths;
+    std::vector<RigidBodyDesc>      rigidBodyDescs;
+
+    SdfPathVector                   sphereShapePrimPaths;
+    std::vector<SphereShapeDesc>    sphereShapeDescs;
+
+    SdfPathVector                   cubeShapePrimPaths;
+    std::vector<CubeShapeDesc>    cubeShapeDescs;
+
+    SdfPathVector                   capsuleShapePrimPaths;
+    std::vector<CapsuleShapeDesc>    capsuleShapeDescs;
+
+    SdfPathVector                   cylinderShapePrimPaths;
+    std::vector<CylinderShapeDesc>    cylinderShapeDescs;
+
+    SdfPathVector            coneShapePrimPaths;
+    std::vector<ConeShapeDesc>    coneShapeDescs;
+
+    SdfPathVector            meshShapePrimPaths;
+    std::vector<MeshShapeDesc>    meshShapeDescs;
+
+    SdfPathVector            planeShapePrimPaths;
+    std::vector<PlaneShapeDesc>    planeShapeDescs;
+
+    SdfPathVector            customShapePrimPaths;
+    std::vector<CustomShapeDesc>    customShapeDescs;
+
+    SdfPathVector            spherePointShapePrimPaths;
+    std::vector<SpherePointsShapeDesc>    spherePointsShapeDescs;
+
+    SdfPathVector            fixedJointPrimPaths;
+    std::vector<FixedJointDesc>    fixedJointDescs;
+
+    SdfPathVector            revoluteJointPrimPaths;
+    std::vector<RevoluteJointDesc>    revoluteJointDescs;
+
+    SdfPathVector            prismaticJointPrimPaths;
+    std::vector<PrismaticJointDesc>    prismaticJointDescs;
+
+    SdfPathVector            sphericalJointPrimPaths;
+    std::vector<SphericalJointDesc>    sphericalJointDescs;
+
+    SdfPathVector            distanceJointPrimPaths;
+    std::vector<DistanceJointDesc>    distanceJointDescs;
+
+    SdfPathVector            d6JointPrimPaths;
+    std::vector<D6JointDesc>    d6JointDescs;
+
+    SdfPathVector            customJointPrimPaths;
+    std::vector<CustomJointDesc>    customJointDescs;
+
+    SdfPathVector            rigidBodyMaterialPrimPaths;
+    std::vector<RigidBodyMaterialDesc>    rigidBodyMaterialDescs;
+
+    SdfPathVector            articulationPrimPaths;
+    std::vector<ArticulationDesc>    articulationDescs;
+
+    SdfPathVector            collisionGroupPrimPaths;
+    std::vector<CollisionGroupDesc>    collisionGroupDescs;
+
+    void clear()
+    {
+        scenePrimPaths.clear();
+        sceneDescs.clear();
+
+        rigidBodyPrimPaths.clear();
+        rigidBodyDescs.clear();
+
+        sphereShapePrimPaths.clear();
+        sphereShapeDescs.clear();
+
+        cubeShapePrimPaths.clear();
+        cubeShapeDescs.clear();
+
+        capsuleShapePrimPaths.clear();
+        capsuleShapeDescs.clear();
+
+        cylinderShapePrimPaths.clear();
+        cylinderShapeDescs.clear();
+
+        coneShapePrimPaths.clear();
+        coneShapeDescs.clear();
+
+        meshShapePrimPaths.clear();
+        meshShapeDescs.clear();
+
+        planeShapePrimPaths.clear();
+        planeShapeDescs.clear();
+
+        customShapePrimPaths.clear();
+        customShapeDescs.clear();
+
+        spherePointShapePrimPaths.clear();
+        spherePointsShapeDescs.clear();
+
+        fixedJointPrimPaths.clear();
+        fixedJointDescs.clear();
+
+        revoluteJointPrimPaths.clear();
+        revoluteJointDescs.clear();
+
+        prismaticJointPrimPaths.clear();
+        prismaticJointDescs.clear();
+
+        sphericalJointPrimPaths.clear();
+        sphericalJointDescs.clear();
+
+        distanceJointPrimPaths.clear();
+        distanceJointDescs.clear();
+
+        d6JointPrimPaths.clear();
+        d6JointDescs.clear();
+
+        customJointPrimPaths.clear();
+        customJointDescs.clear();
+
+        rigidBodyMaterialPrimPaths.clear();
+        rigidBodyMaterialDescs.clear();
+
+        articulationPrimPaths.clear();
+        articulationDescs.clear();
+
+        collisionGroupPrimPaths.clear();
+        collisionGroupDescs.clear();
+    }
+
+} gMarshalCallback;
+
+template <typename DescType>
+void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsDest, const PhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
+{
+    primsDest.resize(numDesc);
+    objectDescsDest.resize(numDesc);
+
+    if (numDesc)
+    {
+        const DescType* sourceDesc = reinterpret_cast<const DescType*>(objectDescsSource);
+
+        for (size_t i = 0; i < numDesc; i++)
+        {
+            primsDest[i] = primsSource[i];
+            objectDescsDest[i] = sourceDesc[i];
+        }
+    }
+}
+
+void ReportPhysicsObjectsFn(PhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
+    const PhysicsObjectDesc* objectDescs, void* userData)
+{
+    MarshalCallback* cb = (MarshalCallback*)userData;
+        
+    switch (type)
+    {
+        case PhysicsObjectType::eScene:
+        {       
+            copyDescs(numDesc, primPaths, cb->scenePrimPaths, objectDescs, cb->sceneDescs);
+        }        
+        break;
+        case PhysicsObjectType::eRigidBody:
+        {       
+            copyDescs(numDesc, primPaths, cb->rigidBodyPrimPaths, objectDescs, cb->rigidBodyDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eSphereShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->sphereShapePrimPaths, objectDescs, cb->sphereShapeDescs);
+        }  
+        break;      
+        case PhysicsObjectType::eCubeShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->cubeShapePrimPaths, objectDescs, cb->cubeShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eCapsuleShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->capsuleShapePrimPaths, objectDescs, cb->capsuleShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eCylinderShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->cylinderShapePrimPaths, objectDescs, cb->cylinderShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eConeShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->coneShapePrimPaths, objectDescs, cb->coneShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eMeshShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->meshShapePrimPaths, objectDescs, cb->meshShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::ePlaneShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->planeShapePrimPaths, objectDescs, cb->planeShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eCustomShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->customShapePrimPaths, objectDescs, cb->customShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eSpherePointsShape:
+        {       
+            copyDescs(numDesc, primPaths, cb->spherePointShapePrimPaths, objectDescs, cb->spherePointsShapeDescs);
+        }        
+        break;        
+        case PhysicsObjectType::eFixedJoint:
+        {       
+            copyDescs(numDesc, primPaths, cb->fixedJointPrimPaths, objectDescs, cb->fixedJointDescs);
+        }        
+        break;
+        case PhysicsObjectType::eRevoluteJoint:
+        {       
+            copyDescs(numDesc, primPaths, cb->revoluteJointPrimPaths, objectDescs, cb->revoluteJointDescs);
+        }     
+        break;   
+        case PhysicsObjectType::ePrismaticJoint:
+        {       
+            copyDescs(numDesc, primPaths, cb->prismaticJointPrimPaths, objectDescs, cb->prismaticJointDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eSphericalJoint:
+        {       
+            copyDescs(numDesc, primPaths, cb->sphericalJointPrimPaths, objectDescs, cb->sphericalJointDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eDistanceJoint:
+        {       
+            copyDescs(numDesc, primPaths, cb->distanceJointPrimPaths, objectDescs, cb->distanceJointDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eD6Joint:
+        {       
+            copyDescs(numDesc, primPaths, cb->d6JointPrimPaths, objectDescs, cb->d6JointDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eCustomJoint:
+        {       
+            copyDescs(numDesc, primPaths, cb->customJointPrimPaths, objectDescs, cb->customJointDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eRigidBodyMaterial:
+        {       
+            copyDescs(numDesc, primPaths, cb->rigidBodyMaterialPrimPaths, objectDescs, cb->rigidBodyMaterialDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eArticulation:
+        {       
+            copyDescs(numDesc, primPaths, cb->articulationPrimPaths, objectDescs, cb->articulationDescs);
+        }     
+        break;   
+        case PhysicsObjectType::eCollisionGroup:
+        {       
+            copyDescs(numDesc, primPaths, cb->collisionGroupPrimPaths, objectDescs, cb->collisionGroupDescs);
+        }     
+        break;   
+    }
+}
+
+struct _CustomUsdPhysicsTokens
+{
+    _CustomUsdPhysicsTokens()
+    {
+
+    }
+
+    pxr_boost::python::list jointTokens;       ///< Custom joints to be reported by parsing
+    pxr_boost::python::list shapeTokens;       ///< Custom shapes to be reported by parsing
+    pxr_boost::python::list instancerTokens;   ///< Custom physics instancers to be skipped by parsing
+};
+
+std::string getString(const pxr_boost::python::object& po)
+{
+    if (pxr_boost::python::extract<std::string>(po).check()) {
+        std::string str = pxr_boost::python::extract<std::string>(po);
+        return str;
+    }
+    else 
+    {
+        // Handle non-string items, e.g. convert to string
+        std::string str = pxr_boost::python::extract<std::string>(pxr_boost::python::str(po));
+        return str;
+    }
+}
+
+pxr_boost::python::dict _LoadUsdPhysicsFromRange(UsdStageWeakPtr stage, ParsePrimIteratorBase& range, const _CustomUsdPhysicsTokens& customTokens, const std::vector<SdfPath>& simulationOwners)
+{   
+    CustomUsdPhysicsTokens parsingCustomTokens;
+    bool customTokensValid = false;
+    const size_t jointTokesSize = len(customTokens.jointTokens);
+    const size_t shapeTokesSize = len(customTokens.shapeTokens);
+    const size_t instancerTokesSize = len(customTokens.instancerTokens);
+    if (jointTokesSize || shapeTokesSize || instancerTokesSize)
+    {
+        for (size_t i = 0; i < jointTokesSize; i++)
+        {
+            parsingCustomTokens.jointTokens.push_back(TfToken(getString(customTokens.jointTokens[i])));
+        }
+        for (size_t i = 0; i < shapeTokesSize; i++)
+        {
+            parsingCustomTokens.shapeTokens.push_back(TfToken(getString(customTokens.shapeTokens[i])));
+        }
+        for (size_t i = 0; i < instancerTokesSize; i++)
+        {
+            parsingCustomTokens.instancerTokens.push_back(TfToken(getString(customTokens.instancerTokens[i])));
+        }
+        customTokensValid = true;
+    }
+
+    gMarshalCallback.clear();
+    const bool ret_val = LoadUsdPhysicsFromRange(stage, range, ReportPhysicsObjectsFn, &gMarshalCallback, 
+        customTokensValid ? &parsingCustomTokens : nullptr,
+        !simulationOwners.empty() ? &simulationOwners : nullptr);
+    pxr_boost::python::dict retDict;
+    if (ret_val)
+    {
+        if (!gMarshalCallback.sceneDescs.empty())
+        {
+            retDict[PhysicsObjectType::eScene] = pxr_boost::python::make_tuple(gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
+        }
+        if (!gMarshalCallback.rigidBodyDescs.empty())
+        {
+            retDict[PhysicsObjectType::eRigidBody] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
+        }
+        if (!gMarshalCallback.sphereShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eSphereShape] = pxr_boost::python::make_tuple(gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
+        }
+        if (!gMarshalCallback.cubeShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eCubeShape] = pxr_boost::python::make_tuple(gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
+        }
+        if (!gMarshalCallback.capsuleShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eCapsuleShape] = pxr_boost::python::make_tuple(gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
+        }
+        if (!gMarshalCallback.cylinderShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eCylinderShape] = pxr_boost::python::make_tuple(gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
+        }
+        if (!gMarshalCallback.coneShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eConeShape] = pxr_boost::python::make_tuple(gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
+        }
+        if (!gMarshalCallback.meshShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eMeshShape] = pxr_boost::python::make_tuple(gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
+        }
+        if (!gMarshalCallback.planeShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::ePlaneShape] = pxr_boost::python::make_tuple(gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
+        }
+        if (!gMarshalCallback.customShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eCustomShape] = pxr_boost::python::make_tuple(gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
+        }
+        if (!gMarshalCallback.spherePointsShapeDescs.empty())
+        {
+            retDict[PhysicsObjectType::eSpherePointsShape] = pxr_boost::python::make_tuple(gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
+        }
+        if (!gMarshalCallback.fixedJointDescs.empty())
+        {
+            retDict[PhysicsObjectType::eFixedJoint] = pxr_boost::python::make_tuple(gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
+        }
+        if (!gMarshalCallback.revoluteJointDescs.empty())
+        {
+            retDict[PhysicsObjectType::eRevoluteJoint] = pxr_boost::python::make_tuple(gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
+        }
+        if (!gMarshalCallback.prismaticJointDescs.empty())
+        {
+            retDict[PhysicsObjectType::ePrismaticJoint] = pxr_boost::python::make_tuple(gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
+        }
+        if (!gMarshalCallback.sphericalJointDescs.empty())
+        {
+            retDict[PhysicsObjectType::eSphericalJoint] = pxr_boost::python::make_tuple(gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
+        }
+        if (!gMarshalCallback.distanceJointDescs.empty())
+        {
+            retDict[PhysicsObjectType::eDistanceJoint] = pxr_boost::python::make_tuple(gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
+        }
+        if (!gMarshalCallback.d6JointDescs.empty())
+        {
+            retDict[PhysicsObjectType::eD6Joint] = pxr_boost::python::make_tuple(gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
+        }
+        if (!gMarshalCallback.customJointDescs.empty())
+        {
+            retDict[PhysicsObjectType::eCustomJoint] = pxr_boost::python::make_tuple(gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
+        }
+        if (!gMarshalCallback.rigidBodyMaterialDescs.empty())
+        {
+            retDict[PhysicsObjectType::eRigidBodyMaterial] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
+        }
+        if (!gMarshalCallback.articulationDescs.empty())
+        {
+            retDict[PhysicsObjectType::eArticulation] = pxr_boost::python::make_tuple(gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
+        }
+        if (!gMarshalCallback.collisionGroupDescs.empty())
+        {
+            retDict[PhysicsObjectType::eCollisionGroup] = pxr_boost::python::make_tuple(gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
+        }
+    }    
+    return retDict;
+}
+
+static std::string
+_CustomUsdPhysicsTokens_Repr(const CustomUsdPhysicsTokens& self)
+{
+    return TfStringPrintf("%sCustomUsdPhysicsTokens(jointTokens=%s, shapeTokens=%s, instancerTokens=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.jointTokens).c_str(),
+        TfPyRepr(self.shapeTokens).c_str(),
+        TfPyRepr(self.instancerTokens).c_str());
+}
+
+static std::string
+_PhysicsObjectDesc_Repr(const PhysicsObjectDesc& self)
+{
+    return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.type).c_str(),
+        TfPyRepr(self.primPath).c_str(),
+        TfPyRepr(self.isValid).c_str());
+}
+
+static std::string
+_SceneDesc_Repr(const SceneDesc& self)
+{
+    return TfStringPrintf("%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.gravityDirection).c_str(),
+        TfPyRepr(self.gravityMagnitude).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_CollisionGroupDesc_Repr(const CollisionGroupDesc& self)
+{
+    return TfStringPrintf("%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.invertFilteredGroups).c_str(),
+        TfPyRepr(self.mergeGroupName).c_str(),
+        TfPyRepr(self.mergedGroups).c_str(),
+        TfPyRepr(self.filteredGroups).c_str(),        
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_RigidBodyMaterialDesc_Repr(const RigidBodyMaterialDesc& self)
+{
+    return TfStringPrintf("%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.staticFriction).c_str(),
+        TfPyRepr(self.dynamicFriction).c_str(),
+        TfPyRepr(self.restitution).c_str(),
+        TfPyRepr(self.density).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_ShapeDesc_Repr(const ShapeDesc& self)
+{
+    return TfStringPrintf("%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.rigidBody).c_str(),
+        TfPyRepr(self.localPos).c_str(),
+        TfPyRepr(self.localRot).c_str(),
+        TfPyRepr(self.localScale).c_str(),
+        TfPyRepr(self.materials).c_str(),
+        TfPyRepr(self.simulationOwners).c_str(),
+        TfPyRepr(self.filteredCollisions).c_str(),
+        TfPyRepr(self.collisionGroups).c_str(),
+        TfPyRepr(self.collisionEnabled).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_SphereShapeDesc_Repr(const SphereShapeDesc& self)
+{
+    return TfStringPrintf("%sSphereShapeDesc(radius=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.radius).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_CapsuleShapeDesc_Repr(const CapsuleShapeDesc& self)
+{
+    return TfStringPrintf("%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.radius).c_str(),
+        TfPyRepr(self.halfHeight).c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_CylinderShapeDesc_Repr(const CylinderShapeDesc& self)
+{
+    return TfStringPrintf("%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.radius).c_str(),
+        TfPyRepr(self.halfHeight).c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_ConeShapeDesc_Repr(const ConeShapeDesc& self)
+{
+    return TfStringPrintf("%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.radius).c_str(),
+        TfPyRepr(self.halfHeight).c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_PlaneShapeDesc_Repr(const PlaneShapeDesc& self)
+{
+    return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_CustomShapeDesc_Repr(const CustomShapeDesc& self)
+{
+    return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.customGeometryToken).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_CubeShapeDesc_Repr(const CubeShapeDesc& self)
+{
+    return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.halfExtents).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_MeshShapeDesc_Repr(const MeshShapeDesc& self)
+{
+    return TfStringPrintf("%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.approximation).c_str(),
+        TfPyRepr(self.meshScale).c_str(),
+        TfPyRepr(self.doubleSided).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_SpherePoint_Repr(const SpherePoint& self)
+{
+    return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.center).c_str(),
+        TfPyRepr(self.radius).c_str());
+}
+
+static std::string
+_SpherePointsShapeDesc_Repr(const SpherePointsShapeDesc& self)
+{
+    return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.spherePoints).c_str(),
+        _ShapeDesc_Repr(self).c_str());
+}
+
+static std::string
+_RigidBodyDesc_Repr(const RigidBodyDesc& self)
+{
+    return TfStringPrintf("%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, simulationOwners=%s, position=%s, rotation=%s, scale=%s, rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, linearVelocity=%s, angularVelocity=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.collisions).c_str(),
+        TfPyRepr(self.filteredCollisions).c_str(),
+        TfPyRepr(self.simulationOwners).c_str(),
+        TfPyRepr(self.position).c_str(),
+        TfPyRepr(self.rotation).c_str(),
+        TfPyRepr(self.scale).c_str(),
+        TfPyRepr(self.rigidBodyEnabled).c_str(),
+        TfPyRepr(self.kinematicBody).c_str(),
+        TfPyRepr(self.startsAsleep).c_str(),
+        TfPyRepr(self.linearVelocity).c_str(),
+        TfPyRepr(self.angularVelocity).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_JointLimit_Repr(const JointLimit& self)
+{
+    return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.enabled).c_str(),
+        TfPyRepr(self.lower).c_str(),
+        TfPyRepr(self.upper).c_str());
+}
+
+static std::string
+_JointDrive_Repr(const JointDrive& self)
+{
+    return TfStringPrintf("%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.enabled).c_str(),
+        TfPyRepr(self.targetPosition).c_str(),
+        TfPyRepr(self.targetVelocity).c_str(),
+        TfPyRepr(self.forceLimit).c_str(),
+        TfPyRepr(self.stiffness).c_str(),
+        TfPyRepr(self.damping).c_str(),
+        TfPyRepr(self.acceleration).c_str());
+}
+
+static std::string
+_ArticulationDesc_Repr(const ArticulationDesc& self)
+{
+    return TfStringPrintf("%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, articulatedJoints=%s, articulatedBodies=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.rootPrims).c_str(),
+        TfPyRepr(self.filteredCollisions).c_str(),
+        TfPyRepr(self.articulatedJoints).c_str(),
+        TfPyRepr(self.articulatedBodies).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_JointDesc_Repr(const JointDesc& self)
+{
+    return TfStringPrintf("%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, localPose0Position=%s, localPose0Orientation=%s, localPose1Position=%s, localPose1Orientation=%s, jointEnabled=%s, breakForce=%s, breakTorque=%s, excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.rel0).c_str(),
+        TfPyRepr(self.rel1).c_str(),
+        TfPyRepr(self.body0).c_str(),
+        TfPyRepr(self.body1).c_str(),
+        TfPyRepr(self.localPose0Position).c_str(),
+        TfPyRepr(self.localPose0Orientation).c_str(),
+        TfPyRepr(self.localPose1Position).c_str(),
+        TfPyRepr(self.localPose1Orientation).c_str(),
+        TfPyRepr(self.jointEnabled).c_str(),
+        TfPyRepr(self.breakForce).c_str(),
+        TfPyRepr(self.breakTorque).c_str(),
+        TfPyRepr(self.excludeFromArticulation).c_str(),
+        TfPyRepr(self.collisionEnabled).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
+}
+
+static std::string
+_JointLimitDOFPair_Repr(const std::pair<PhysicsJointDOF::Enum, JointLimit>& self)
+{
+    return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.first).c_str(),
+        TfPyRepr(self.second).c_str());
+}
+
+static std::string
+_JointDriveDOFPair_Repr(const std::pair<PhysicsJointDOF::Enum, JointDrive>& self)
+{
+    return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.first).c_str(),
+        TfPyRepr(self.second).c_str());
+}
+
+static std::string
+_D6JointDesc_Repr(const D6JointDesc& self)
+{
+    return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.jointLimits).c_str(),
+        TfPyRepr(self.jointDrives).c_str(),
+        _JointDesc_Repr(self).c_str());
+}
+
+static std::string
+_PrismaticJointDesc_Repr(const PrismaticJointDesc& self)
+{
+    return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.axis).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        TfPyRepr(self.drive).c_str(),
+        _JointDesc_Repr(self).c_str());
+}
+
+static std::string
+_SphericalJointDesc_Repr(const SphericalJointDesc& self)
+{
+    return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.axis).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        _JointDesc_Repr(self).c_str());
+}
+
+static std::string
+_RevoluteJointDesc_Repr(const RevoluteJointDesc& self)
+{
+    return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.axis).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        TfPyRepr(self.drive).c_str(),
+        _JointDesc_Repr(self).c_str());
+}
+
+static std::string
+_DistanceJointDesc_Repr(const DistanceJointDesc& self)
+{
+    return TfStringPrintf("%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
+        TF_PY_REPR_PREFIX,
+        TfPyRepr(self.minEnabled).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        TfPyRepr(self.maxEnabled).c_str(),
+        _JointDesc_Repr(self).c_str());
+}
+
+void wrapParseUtils()
+{
+    pxr_boost::python::enum_<PhysicsObjectType::Enum>("PhysicsObjectType")
+    .value("Undefined", PhysicsObjectType::eUndefined)
+    .value("Scene", PhysicsObjectType::eScene)
+    .value("RigidBody", PhysicsObjectType::eRigidBody)
+    .value("SphereShape", PhysicsObjectType::eSphereShape)
+    .value("CubeShape", PhysicsObjectType::eCubeShape)
+    .value("CapsuleShape", PhysicsObjectType::eCapsuleShape)
+    .value("CylinderShape", PhysicsObjectType::eCylinderShape)
+    .value("ConeShape", PhysicsObjectType::eConeShape)
+    .value("MeshShape", PhysicsObjectType::eMeshShape)
+    .value("PlaneShape", PhysicsObjectType::ePlaneShape)
+    .value("CustomShape", PhysicsObjectType::eCustomShape)
+    .value("SpherePointsShape", PhysicsObjectType::eSpherePointsShape)
+    .value("FixedJoint", PhysicsObjectType::eFixedJoint)
+    .value("RevoluteJoint", PhysicsObjectType::eRevoluteJoint)
+    .value("PrismaticJoint", PhysicsObjectType::ePrismaticJoint)
+    .value("SphericalJoint", PhysicsObjectType::eSphericalJoint)
+    .value("DistanceJoint", PhysicsObjectType::eDistanceJoint)
+    .value("D6Joint", PhysicsObjectType::eD6Joint)
+    .value("CustomJoint", PhysicsObjectType::eCustomJoint)
+    .value("RigidBodyMaterial", PhysicsObjectType::eRigidBodyMaterial)
+    .value("Articulation", PhysicsObjectType::eArticulation)
+    .value("CollisionGroup", PhysicsObjectType::eCollisionGroup)
+    ;
+
+    pxr_boost::python::enum_<PhysicsAxis::Enum>("PhysicsAxis")
+    .value("X", PhysicsAxis::eX)
+    .value("Y", PhysicsAxis::eY)
+    .value("Z", PhysicsAxis::eZ)
+    ;
+
+    pxr_boost::python::enum_<PhysicsJointDOF::Enum>("PhysicsJointDOF")
+    .value("Distance", PhysicsJointDOF::eDistance)
+    .value("TransX", PhysicsJointDOF::eTransX)
+    .value("TransY", PhysicsJointDOF::eTransY)
+    .value("TransZ", PhysicsJointDOF::eTransZ)
+    .value("RotX", PhysicsJointDOF::eRotX)
+    .value("RotY", PhysicsJointDOF::eRotY)
+    .value("RotZ", PhysicsJointDOF::eRotZ)
+    ;
+    
+    pxr_boost::python::class_<_CustomUsdPhysicsTokens>
+        cupt("CustomUsdPhysicsTokens");
+    cupt
+        .def_readwrite("jointTokens", &_CustomUsdPhysicsTokens::jointTokens)
+        .def_readwrite("shapeTokens", &_CustomUsdPhysicsTokens::shapeTokens)
+        .def_readwrite("instancerTokens", &_CustomUsdPhysicsTokens::instancerTokens)
+        .def("__repr__", _CustomUsdPhysicsTokens_Repr);
+
+    pxr_boost::python::class_<PhysicsObjectDesc>
+        podcls("PhysicsObjectDesc", pxr_boost::python::no_init);
+    podcls
+        .def_readonly("type", &PhysicsObjectDesc::type)
+        .def_readonly("primPath", &PhysicsObjectDesc::primPath)
+        .def_readonly("isValid", &PhysicsObjectDesc::isValid)
+        .def("__repr__", _PhysicsObjectDesc_Repr);
+
+    pxr_boost::python::class_<SceneDesc, bases<PhysicsObjectDesc>>
+        sdcls("SceneDesc", pxr_boost::python::no_init);
+    sdcls
+        .def_readonly("gravityDirection", &SceneDesc::gravityDirection)        
+        .def_readonly("gravityMagnitude", &SceneDesc::gravityMagnitude)
+        .def("__repr__", _SceneDesc_Repr);
+
+    pxr_boost::python::class_<CollisionGroupDesc, bases<PhysicsObjectDesc>>
+        cgcls("CollisionGroupDesc", pxr_boost::python::no_init);
+    cgcls
+        .def_readonly("invertFilteredGroups", &CollisionGroupDesc::invertFilteredGroups)
+        .add_property("mergedGroups", make_function(&CollisionGroupDesc::getMergedGroups,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredGroups", make_function(&CollisionGroupDesc::getFilteredGroups,
+            return_value_policy<TfPySequenceToList>()))
+        .def_readonly("mergeGroupName", &CollisionGroupDesc::mergeGroupName)
+        .def("__repr__", _CollisionGroupDesc_Repr);
+
+    pxr_boost::python::class_<RigidBodyMaterialDesc, bases<PhysicsObjectDesc>>
+        rbmcls("RigidBodyMaterialDesc", pxr_boost::python::no_init);
+    rbmcls
+        .def_readonly("staticFriction", &RigidBodyMaterialDesc::staticFriction)
+        .def_readonly("dynamicFriction", &RigidBodyMaterialDesc::dynamicFriction)
+        .def_readonly("restitution", &RigidBodyMaterialDesc::restitution)
+        .def_readonly("density", &RigidBodyMaterialDesc::density)
+        .def("__repr__", _RigidBodyMaterialDesc_Repr);
+
+    pxr_boost::python::class_<ShapeDesc, bases<PhysicsObjectDesc>>
+        shdcls("ShapeDesc", pxr_boost::python::no_init);
+    shdcls
+        .def_readonly("rigidBody", &ShapeDesc::rigidBody)
+        .def_readonly("localPos", &ShapeDesc::localPos)
+        .def_readonly("localRot", &ShapeDesc::localRot)
+        .def_readonly("localScale", &ShapeDesc::localScale)
+        .add_property("materials", make_function(&ShapeDesc::getMaterials,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("simulationOwners", make_function(&ShapeDesc::getSimulationOwners,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredCollisions", make_function(&ShapeDesc::getFilteredCollisions,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("collisionGroups", make_function(&ShapeDesc::getCollisionGroups,
+            return_value_policy<TfPySequenceToList>()))
+        .def_readonly("collisionEnabled", &ShapeDesc::collisionEnabled)
+        .def("__repr__", _ShapeDesc_Repr);
+
+    pxr_boost::python::class_<SphereShapeDesc, bases<ShapeDesc>>
+        ssdcls("SphereShapeDesc", pxr_boost::python::no_init);
+    ssdcls
+        .def_readonly("radius", &SphereShapeDesc::radius)
+        .def("__repr__", _SphereShapeDesc_Repr);
+
+    pxr_boost::python::class_<CapsuleShapeDesc, bases<ShapeDesc>>
+        csdcls("CapsuleShapeDesc", pxr_boost::python::no_init);
+    csdcls
+        .def_readonly("radius", &CapsuleShapeDesc::radius)
+        .def_readonly("halfHeight", &CapsuleShapeDesc::halfHeight)
+        .def_readonly("axis", &CapsuleShapeDesc::axis)
+        .def("__repr__", _CapsuleShapeDesc_Repr);
+
+    pxr_boost::python::class_<CylinderShapeDesc, bases<ShapeDesc>>
+        cysdcls("CylinderShapeDesc", pxr_boost::python::no_init);
+    cysdcls
+        .def_readonly("radius", &CylinderShapeDesc::radius)
+        .def_readonly("halfHeight", &CylinderShapeDesc::halfHeight)
+        .def_readonly("axis", &CylinderShapeDesc::axis)
+        .def("__repr__", _CylinderShapeDesc_Repr);
+
+    pxr_boost::python::class_<ConeShapeDesc, bases<ShapeDesc>>
+        cosdcls("ConeShapeDesc", pxr_boost::python::no_init);
+    cosdcls
+        .def_readonly("radius", &ConeShapeDesc::radius)
+        .def_readonly("halfHeight", &ConeShapeDesc::halfHeight)
+        .def_readonly("axis", &ConeShapeDesc::axis)
+        .def("__repr__", _ConeShapeDesc_Repr);
+
+    pxr_boost::python::class_<PlaneShapeDesc, bases<ShapeDesc>>
+        pscls("PlaneShapeDesc", pxr_boost::python::no_init);
+    pscls
+        .def_readonly("axis", &PlaneShapeDesc::axis)
+        .def("__repr__", _PlaneShapeDesc_Repr);
+
+    pxr_boost::python::class_<CustomShapeDesc, bases<ShapeDesc>>
+        cuscls("CustomShapeDesc", pxr_boost::python::no_init);
+    cuscls
+        .def_readonly("customGeometryToken", &CustomShapeDesc::customGeometryToken)
+        .def("__repr__", _CustomShapeDesc_Repr);
+
+    pxr_boost::python::class_<CubeShapeDesc, bases<ShapeDesc>>
+        cubescls("CubeShapeDesc", pxr_boost::python::no_init);
+    cubescls
+        .def_readonly("halfExtents", &CubeShapeDesc::halfExtents)
+        .def("__repr__", _CubeShapeDesc_Repr);
+
+    pxr_boost::python::class_<MeshShapeDesc, bases<ShapeDesc>>
+        mscls("MeshShapeDesc", pxr_boost::python::no_init);
+    mscls
+        .add_property("approximation", &MeshShapeDesc::GetApproximation)
+        .def_readonly("meshScale", &MeshShapeDesc::meshScale)
+        .def_readonly("doubleSided", &MeshShapeDesc::doubleSided)
+        .def("__repr__", _MeshShapeDesc_Repr);
+
+    pxr_boost::python::class_<SpherePoint>
+        sppb("SpherePoint", pxr_boost::python::no_init);
+    sppb
+        .def_readonly("center", &SpherePoint::center)
+        .def_readonly("radius", &SpherePoint::radius)
+        .def("__repr__", _SpherePoint_Repr);
+
+    pxr_boost::python::class_<SpherePointsShapeDesc, bases<ShapeDesc>>
+        spmscls("SpherePointsShapeDesc", pxr_boost::python::no_init);
+    spmscls
+        .add_property("spherePoints", &SpherePointsShapeDesc::spherePoints)
+        .def("__repr__", _SpherePointsShapeDesc_Repr);
+
+    pxr_boost::python::class_<RigidBodyDesc, bases<PhysicsObjectDesc>>
+        rbcls("RigidBodyDesc", pxr_boost::python::no_init);
+    rbcls
+        .add_property("collisions", make_function(&RigidBodyDesc::getCollisions,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredCollisions", make_function(&RigidBodyDesc::getFilteredCollisions,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("simulationOwners", make_function(&RigidBodyDesc::getSimulationOwners,
+            return_value_policy<TfPySequenceToList>()))
+        .def_readonly("position", &RigidBodyDesc::position)
+        .def_readonly("rotation", &RigidBodyDesc::rotation)
+        .def_readonly("scale", &RigidBodyDesc::scale)
+        .def_readonly("rigidBodyEnabled", &RigidBodyDesc::rigidBodyEnabled)
+        .def_readonly("kinematicBody", &RigidBodyDesc::kinematicBody)
+        .def_readonly("startsAsleep", &RigidBodyDesc::startsAsleep)
+        .def_readonly("linearVelocity", &RigidBodyDesc::linearVelocity)
+        .def_readonly("angularVelocity", &RigidBodyDesc::angularVelocity)
+        .def("__repr__", _RigidBodyDesc_Repr);
+
+    pxr_boost::python::class_<JointLimit>
+        jlcls("JointLimit", pxr_boost::python::no_init);
+    jlcls
+        .def_readonly("enabled", &JointLimit::enabled)
+        .def_readonly("lower", &JointLimit::lower)
+        .def_readonly("upper", &JointLimit::upper)
+        .def("__repr__", _JointLimit_Repr);
+
+    pxr_boost::python::class_<JointDrive>
+        jdcls("JointDrive", pxr_boost::python::no_init);
+    jdcls
+        .def_readonly("enabled", &JointDrive::enabled)
+        .def_readonly("targetPosition", &JointDrive::targetPosition)
+        .def_readonly("targetVelocity", &JointDrive::targetVelocity)
+        .def_readonly("forceLimit", &JointDrive::forceLimit)
+        .def_readonly("stiffness", &JointDrive::stiffness)
+        .def_readonly("damping", &JointDrive::damping)
+        .def_readonly("acceleration", &JointDrive::acceleration)
+        .def("__repr__", _JointDrive_Repr);
+
+    pxr_boost::python::class_<ArticulationDesc, bases<PhysicsObjectDesc>>
+        adcls("ArticulationDesc", pxr_boost::python::no_init);
+    adcls
+        .add_property("rootPrims", make_function(&ArticulationDesc::GetRootPrims,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredCollisions", make_function(&ArticulationDesc::GetFilteredCollisions,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("articulatedJoints", make_function(&ArticulationDesc::GetArticulatedJoints,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("articulatedBodies", make_function(&ArticulationDesc::GetArticulatedBodies,
+            return_value_policy<TfPySequenceToList>()))
+        .def("__repr__", _ArticulationDesc_Repr);
+
+    pxr_boost::python::class_<JointDesc, bases<PhysicsObjectDesc>>
+        jdscls("JointDesc", pxr_boost::python::no_init);
+    jdscls
+        .def_readonly("rel0", &JointDesc::rel0)
+        .def_readonly("rel1", &JointDesc::rel1)
+        .def_readonly("body0", &JointDesc::body0)
+        .def_readonly("body1", &JointDesc::body1)
+        .def_readonly("localPose0Position", &JointDesc::localPose0Position)
+        .def_readonly("localPose0Orientation", &JointDesc::localPose0Orientation)
+        .def_readonly("localPose1Position", &JointDesc::localPose1Position)
+        .def_readonly("localPose1Orientation", &JointDesc::localPose1Orientation)
+        .def_readonly("jointEnabled", &JointDesc::jointEnabled)
+        .def_readonly("breakForce", &JointDesc::breakForce)
+        .def_readonly("breakTorque", &JointDesc::breakTorque)
+        .def_readonly("excludeFromArticulation", &JointDesc::excludeFromArticulation)
+        .def_readonly("collisionEnabled", &JointDesc::collisionEnabled)
+        .def("__repr__", _JointDesc_Repr);
+
+    pxr_boost::python::class_<CustomJointDesc, bases<JointDesc>>
+        cjdscls("CustomJointDesc", pxr_boost::python::no_init);
+
+    pxr_boost::python::class_<FixedJointDesc, bases<JointDesc>>
+        fjdscls("FixedJointDesc", pxr_boost::python::no_init);
+
+    class_<std::pair<PhysicsJointDOF::Enum, JointLimit> >("JointLimitDOFPair")
+        .def_readwrite("first", &std::pair<PhysicsJointDOF::Enum, JointLimit>::first)
+        .def_readwrite("second", &std::pair<PhysicsJointDOF::Enum, JointLimit>::second)
+        .def("__repr__", _JointLimitDOFPair_Repr);
+
+    class_<std::pair<PhysicsJointDOF::Enum, JointDrive> >("JointDriveDOFPair")
+        .def_readwrite("first", &std::pair<PhysicsJointDOF::Enum, JointDrive>::first)
+        .def_readwrite("second", &std::pair<PhysicsJointDOF::Enum, JointDrive>::second)
+        .def("__repr__", _JointDriveDOFPair_Repr);
+
+    pxr_boost::python::class_<D6JointDesc, bases<JointDesc>>
+        d6jdscls("D6JointDesc", pxr_boost::python::no_init);
+    d6jdscls
+        .def_readonly("jointLimits", &D6JointDesc::jointLimits)
+        .def_readonly("jointDrives", &D6JointDesc::jointDrives)
+        .def("__repr__", _D6JointDesc_Repr);
+
+    pxr_boost::python::class_<PrismaticJointDesc, bases<JointDesc>>
+        pjdscls("PrismaticJointDesc", pxr_boost::python::no_init);
+    pjdscls
+        .def_readonly("axis", &PrismaticJointDesc::axis)
+        .def_readonly("limit", &PrismaticJointDesc::limit)
+        .def_readonly("drive", &PrismaticJointDesc::drive)
+        .def("__repr__", _PrismaticJointDesc_Repr);
+
+    pxr_boost::python::class_<SphericalJointDesc, bases<JointDesc>>
+        sjdscls("SphericalJointDesc", pxr_boost::python::no_init);
+    sjdscls
+        .def_readonly("axis", &SphericalJointDesc::axis)
+        .def_readonly("limit", &SphericalJointDesc::limit)
+        .def("__repr__", _SphericalJointDesc_Repr);
+
+    pxr_boost::python::class_<RevoluteJointDesc, bases<JointDesc>>
+        rjdscls("RevoluteJointDesc", pxr_boost::python::no_init);
+    rjdscls
+        .def_readonly("axis", &RevoluteJointDesc::axis)
+        .def_readonly("limit", &RevoluteJointDesc::limit)
+        .def_readonly("drive", &RevoluteJointDesc::drive)
+        .def("__repr__", _RevoluteJointDesc_Repr);
+
+    pxr_boost::python::class_<DistanceJointDesc, bases<JointDesc>>
+        djdscls("DistanceJointDesc", pxr_boost::python::no_init);
+    djdscls
+        .def_readonly("minEnabled", &DistanceJointDesc::minEnabled)
+        .def_readonly("limit", &DistanceJointDesc::limit)
+        .def_readonly("maxEnabled", &DistanceJointDesc::maxEnabled)
+        .def("__repr__", _DistanceJointDesc_Repr);
+
+    registerVectorConverter<UsdCollectionMembershipQuery>("PhysicsCollectionMembershipQueryVector");
+
+    registerVectorConverter<std::pair<PhysicsJointDOF::Enum, JointLimit>>("PhysicsJointLimitDOFVector");
+
+    registerVectorConverter<std::pair<PhysicsJointDOF::Enum, JointDrive>>("PhysicsJointDriveDOFVector");
+
+    registerVectorConverter<SpherePoint>("PhysicsSpherePointVector");
+
+    registerVectorConverter<SceneDesc>("SceneDescVector");
+
+    registerVectorConverter<RigidBodyDesc>("RigidBodyDescVector");
+
+    registerVectorConverter<SphereShapeDesc>("SphereShapeDescVector");
+
+    registerVectorConverter<CapsuleShapeDesc>("CapsuleShapeDescVector");
+
+    registerVectorConverter<CylinderShapeDesc>("CylinderShapeDescVector");
+
+    registerVectorConverter<ConeShapeDesc>("ConeShapeDescVector");
+
+    registerVectorConverter<CubeShapeDesc>("CubeShapeDescVector");
+
+    registerVectorConverter<MeshShapeDesc>("MeshShapeDescVector");
+
+    registerVectorConverter<PlaneShapeDesc>("PlaneShapeDescVector");
+
+    registerVectorConverter<CustomShapeDesc>("CustomShapeDescVector");
+
+    registerVectorConverter<SpherePointsShapeDesc>("SpherePointsShapeDescVector");
+
+    registerVectorConverter<JointDesc>("JointDescVector");
+
+    registerVectorConverter<FixedJointDesc>("FixedJointDescVector");
+
+    registerVectorConverter<DistanceJointDesc>("DistanceJointDescVector");
+
+    registerVectorConverter<RevoluteJointDesc>("RevoluteJointDescVector");
+
+    registerVectorConverter<PrismaticJointDesc>("PrismaticJointDescVector");
+
+    registerVectorConverter<SphericalJointDesc>("SphericalJointDescVector");
+
+    registerVectorConverter<D6JointDesc>("D6JointDescVector");
+
+    registerVectorConverter<CustomJointDesc>("CustomJointDescVector");
+
+    registerVectorConverter<RigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
+
+    registerVectorConverter<ArticulationDesc>("ArticulationDescVector");
+
+    registerVectorConverter<CollisionGroupDesc>("CollisionGroupDescVector");
+
+    pxr_boost::python::class_<ParsePrimIteratorBaseWrap, noncopyable>
+        vparseitclsvv("ParsePrimIteratorBaseWrap", no_init);
+      vparseitclsvv.def(init<>());
+
+    pxr_boost::python::class_<ParsePrimIteratorRange, bases<ParsePrimIteratorBase>>
+        parseitcls("ParsePrimIteratorRange", no_init);
+    parseitcls
+        .def(init<UsdPrimRange>(arg("primRange")));        
+
+    pxr_boost::python::class_<ExcludeListPrimIteratorRange, bases<ParsePrimIteratorBase>>
+        parseitExccls("ExcludeListPrimIteratorRange", no_init);
+    parseitExccls
+        .def(init<UsdPrimRange,SdfPathVector>());
+
+    def("LoadUsdPhysicsFromRange", _LoadUsdPhysicsFromRange, 
+            (args("stage"), args("range"), args("customTokens") = _CustomUsdPhysicsTokens(), args("simulationOwners") = std::vector<SdfPath>()));
+}

From 31fb92ffbd90c1c026eaaf452ad357d0fe234505 Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Sun, 6 Oct 2024 09:32:30 +0200
Subject: [PATCH 2/8] linux compilation fix

---
 pxr/usd/usdPhysics/wrapParseUtils.cpp | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/pxr/usd/usdPhysics/wrapParseUtils.cpp b/pxr/usd/usdPhysics/wrapParseUtils.cpp
index 9cdedd0833..441a25f7d7 100644
--- a/pxr/usd/usdPhysics/wrapParseUtils.cpp
+++ b/pxr/usd/usdPhysics/wrapParseUtils.cpp
@@ -46,14 +46,15 @@
 #include "pxr/external/boost/python/object.hpp"
 #include "pxr/external/boost/python/str.hpp"
 
+
+PXR_NAMESPACE_USING_DIRECTIVE
+
 template <typename T>
 void registerVectorConverter(const char* name)
 {
-    pxr_boost::python::class_<std::vector<T>>(name).def(vector_indexing_suite<std::vector<T>>());
+    pxr_boost::python::class_<std::vector<T>>(name).def(pxr_boost::python::vector_indexing_suite<std::vector<T>>());
 }
 
-PXR_NAMESPACE_USING_DIRECTIVE
-
 using namespace pxr_boost::python;
 
 

From 4bdca6686e35e3b357ad9bbc32d22f57dd925a57 Mon Sep 17 00:00:00 2001
From: oborovicka <olda.borovicka@gmail.com>
Date: Sat, 5 Oct 2024 16:22:47 +0200
Subject: [PATCH 3/8] Desc renames

---
 pxr/usd/usdPhysics/parseDesc.h                | 304 +++++-----
 pxr/usd/usdPhysics/parseUtils.cpp             | 432 +++++++-------
 pxr/usd/usdPhysics/parseUtils.h               |   4 +-
 .../testenv/testUsdPhysicsParsing.py          | 126 ++--
 pxr/usd/usdPhysics/wrapParseUtils.cpp         | 558 +++++++++---------
 5 files changed, 712 insertions(+), 712 deletions(-)

diff --git a/pxr/usd/usdPhysics/parseDesc.h b/pxr/usd/usdPhysics/parseDesc.h
index 12897fb9d8..22b6bb3a16 100644
--- a/pxr/usd/usdPhysics/parseDesc.h
+++ b/pxr/usd/usdPhysics/parseDesc.h
@@ -42,11 +42,11 @@ PXR_NAMESPACE_OPEN_SCOPE
 /// Sentinel value for flt max compare
 const float physicsSentinelLimit = 0.5e38f;
 
-/// \struct PhysicsObjectType
+/// \struct UsdPhysicsObjectType
 ///
 /// Physics object type structure for type enumeration
 ///
-struct PhysicsObjectType
+struct UsdPhysicsObjectType
 {
     enum Enum
     {
@@ -84,11 +84,11 @@ struct PhysicsObjectType
     };
 };
 
-/// \struct PhysicsAxis
+/// \struct UsdPhysicsAxis
 ///
 /// Physics axis structure for type enumeration
 ///
-struct PhysicsAxis
+struct UsdPhysicsAxis
 {
     enum Enum
     {
@@ -98,11 +98,11 @@ struct PhysicsAxis
     };
 };
 
-/// \struct PhysicsJointDOF
+/// \struct UsdPhysicsJointDOF
 ///
 /// Physics joint degree of freedom structure for type enumeration
 ///
-struct PhysicsJointDOF
+struct UsdPhysicsJointDOF
 {
     enum Enum
     {
@@ -116,37 +116,37 @@ struct PhysicsJointDOF
     };
 };
 
-/// \struct PhysicsObjectDesc
+/// \struct UsdPhysicsObjectDesc
 ///
 /// Base physics object descriptor
 ///
-struct PhysicsObjectDesc
+struct UsdPhysicsObjectDesc
 {
-    PhysicsObjectDesc() : type(PhysicsObjectType::eUndefined), isValid(true)
+    UsdPhysicsObjectDesc() : type(UsdPhysicsObjectType::eUndefined), isValid(true)
     {
     }
 
-    virtual ~PhysicsObjectDesc()
+    virtual ~UsdPhysicsObjectDesc()
     {
     }
 
-    PhysicsObjectType::Enum type;   ///< Descriptor type
+    UsdPhysicsObjectType::Enum type;   ///< Descriptor type
     SdfPath primPath;                ///< SdfPath for the prim from which the descriptor was parsed
     bool isValid;                   ///< Validity of a descriptor, the parsing may succeed, but the descriptor might be not valid
 };
 
-/// \struct RigidBodyMaterialDesc
+/// \struct UsdPhysicsRigidBodyMaterialDesc
 ///
 /// Rigid body material descriptor
 ///
-struct RigidBodyMaterialDesc : PhysicsObjectDesc
+struct UsdPhysicsRigidBodyMaterialDesc : UsdPhysicsObjectDesc
 {
-    RigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f), restitution(0.0f), density(-1.0f)
+    UsdPhysicsRigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f), restitution(0.0f), density(-1.0f)
     {
-        type = PhysicsObjectType::eRigidBodyMaterial;
+        type = UsdPhysicsObjectType::eRigidBodyMaterial;
     }
 
-    bool operator == (const RigidBodyMaterialDesc&) const
+    bool operator == (const UsdPhysicsRigidBodyMaterialDesc&) const
     {
         return false;
     }
@@ -158,18 +158,18 @@ struct RigidBodyMaterialDesc : PhysicsObjectDesc
     float density;              ///< Density
 };
 
-/// \struct SceneDesc
+/// \struct UsdPhysicsSceneDesc
 ///
 /// Scene descriptor
 ///
-struct SceneDesc : PhysicsObjectDesc
+struct UsdPhysicsSceneDesc : UsdPhysicsObjectDesc
 {
-    SceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
+    UsdPhysicsSceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
     {
-        type = PhysicsObjectType::eScene;
+        type = UsdPhysicsObjectType::eScene;
     }
 
-    bool operator == (const SceneDesc&) const
+    bool operator == (const UsdPhysicsSceneDesc&) const
     {
         return false;
     }
@@ -178,18 +178,18 @@ struct SceneDesc : PhysicsObjectDesc
     float gravityMagnitude;     ///< Gravity magnitude, -inf means Earth gravity adjusted by metersPerUnit will be returned
 };
 
-/// \struct CollisionGroupDesc
+/// \struct UsdPhysicsCollisionGroupDesc
 ///
 /// Collision group descriptor
 ///
-struct CollisionGroupDesc : PhysicsObjectDesc
+struct UsdPhysicsCollisionGroupDesc : UsdPhysicsObjectDesc
 {
-    CollisionGroupDesc()
+    UsdPhysicsCollisionGroupDesc()
     {
-        type = PhysicsObjectType::eCollisionGroup;
+        type = UsdPhysicsObjectType::eCollisionGroup;
     }
 
-    bool operator == (const CollisionGroupDesc&) const
+    bool operator == (const UsdPhysicsCollisionGroupDesc&) const
     {
         return false;
     }
@@ -210,7 +210,7 @@ struct CollisionGroupDesc : PhysicsObjectDesc
     SdfPathVector mergedGroups;                     ///< List of merged collision groups
 };
 
-/// \struct ShapeDesc
+/// \struct UsdPhysicsShapeDesc
 ///
 /// Shape descriptor, base class should not be reported
 ///
@@ -218,9 +218,9 @@ struct CollisionGroupDesc : PhysicsObjectDesc
 /// the collision shape sizes already contain the scale.
 /// The exception are mesh collisions which do have geometry scale reported.
 ///
-struct ShapeDesc : PhysicsObjectDesc
+struct UsdPhysicsShapeDesc : UsdPhysicsObjectDesc
 {
-    ShapeDesc()
+    UsdPhysicsShapeDesc()
         : localPos(0.0f, 0.0f, 0.0f),
           localRot(1.0f, 0.0f, 0.0f, 0.0f),
           localScale(1.0f, 1.0f, 1.0f),
@@ -260,18 +260,18 @@ struct ShapeDesc : PhysicsObjectDesc
     bool collisionEnabled;                  ///< Collision enabled/disabled bool
 };
 
-/// \struct SphereShapeDesc
+/// \struct UsdPhysicsSphereShapeDesc
 ///
 /// Sphere shape collision descriptor
 ///
-struct SphereShapeDesc : ShapeDesc
+struct UsdPhysicsSphereShapeDesc : UsdPhysicsShapeDesc
 {
-    SphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
+    UsdPhysicsSphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
     {
-        type = PhysicsObjectType::eSphereShape;
+        type = UsdPhysicsObjectType::eSphereShape;
     }
 
-    bool operator == (const SphereShapeDesc&) const
+    bool operator == (const UsdPhysicsSphereShapeDesc&) const
     {
         return false;
     }
@@ -279,63 +279,63 @@ struct SphereShapeDesc : ShapeDesc
     float radius;               ///< Sphere radius
 };
 
-/// \struct CapsuleShapeDesc
+/// \struct UsdPhysicsCapsuleShapeDesc
 ///
 /// Capsule shape collision descriptor
 ///
-struct CapsuleShapeDesc : ShapeDesc
+struct UsdPhysicsCapsuleShapeDesc : UsdPhysicsShapeDesc
 {
-    CapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, PhysicsAxis::Enum cap_axis = PhysicsAxis::eX)
+    UsdPhysicsCapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
         : radius(inRadius), halfHeight(half_height), axis(cap_axis)
     {
-        type = PhysicsObjectType::eCapsuleShape;
+        type = UsdPhysicsObjectType::eCapsuleShape;
     }
 
-    bool operator == (const CapsuleShapeDesc&) const
+    bool operator == (const UsdPhysicsCapsuleShapeDesc&) const
     {
         return false;
     }
 
     float radius;               ///< Capsule radius
     float halfHeight;           ///< Capsule half height
-    PhysicsAxis::Enum axis;     ///< Capsule axis
+    UsdPhysicsAxis::Enum axis;     ///< Capsule axis
 };
 
-/// \struct CylinderShapeDesc
+/// \struct UsdPhysicsCylinderShapeDesc
 ///
 /// Cylinder shape collision descriptor
 ///
-struct CylinderShapeDesc : ShapeDesc
+struct UsdPhysicsCylinderShapeDesc : UsdPhysicsShapeDesc
 {
-    CylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, PhysicsAxis::Enum cap_axis = PhysicsAxis::eX)
+    UsdPhysicsCylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
         : radius(inRadius), halfHeight(half_height), axis(cap_axis)
     {
-        type = PhysicsObjectType::eCylinderShape;
+        type = UsdPhysicsObjectType::eCylinderShape;
     }
 
-    bool operator == (const CylinderShapeDesc&) const
+    bool operator == (const UsdPhysicsCylinderShapeDesc&) const
     {
         return false;
     }
 
     float radius;               ///< Cylinder radius
     float halfHeight;           ///< Cylinder half height
-    PhysicsAxis::Enum axis;     ///< Cylinder axis
+    UsdPhysicsAxis::Enum axis;     ///< Cylinder axis
 };
 
-/// \struct ConeShapeDesc
+/// \struct UsdPhysicsConeShapeDesc
 ///
 /// Cone shape collision descriptor
 ///
-struct ConeShapeDesc : ShapeDesc
+struct UsdPhysicsConeShapeDesc : UsdPhysicsShapeDesc
 {
-    ConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, PhysicsAxis::Enum cap_axis = PhysicsAxis::eX)
+    UsdPhysicsConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
         : radius(inRadius), halfHeight(half_height), axis(cap_axis)
     {
-        type = PhysicsObjectType::eConeShape;
+        type = UsdPhysicsObjectType::eConeShape;
     }
 
-    bool operator == (const ConeShapeDesc&) const
+    bool operator == (const UsdPhysicsConeShapeDesc&) const
     {
         return false;
     }
@@ -343,41 +343,41 @@ struct ConeShapeDesc : ShapeDesc
 
     float radius;               ///< Cone radius
     float halfHeight;           ///< Cone half height
-    PhysicsAxis::Enum axis;     ///< Cone axis
+    UsdPhysicsAxis::Enum axis;     ///< Cone axis
 };
 
-/// \struct PlaneShapeDesc
+/// \struct UsdPhysicsPlaneShapeDesc
 ///
 /// Plane shape collision descriptor
 ///
-struct PlaneShapeDesc : ShapeDesc
+struct UsdPhysicsPlaneShapeDesc : UsdPhysicsShapeDesc
 {
-    PlaneShapeDesc(PhysicsAxis::Enum up_axis = PhysicsAxis::eX)
+    UsdPhysicsPlaneShapeDesc(UsdPhysicsAxis::Enum up_axis = UsdPhysicsAxis::eX)
         : axis(up_axis)
     {
-        type = PhysicsObjectType::ePlaneShape;
+        type = UsdPhysicsObjectType::ePlaneShape;
     }
-    bool operator == (const PlaneShapeDesc&) const
+    bool operator == (const UsdPhysicsPlaneShapeDesc&) const
     {
         return false;
     }
 
 
-    PhysicsAxis::Enum axis;     ///< Plane axis
+    UsdPhysicsAxis::Enum axis;     ///< Plane axis
 };
 
 
-/// \struct CustomShapeDesc
+/// \struct UsdPhysicsCustomShapeDesc
 ///
 /// Custom shape collision descriptor
 ///
-struct CustomShapeDesc : ShapeDesc
+struct UsdPhysicsCustomShapeDesc : UsdPhysicsShapeDesc
 {
-    CustomShapeDesc()
+    UsdPhysicsCustomShapeDesc()
     {
-        type = PhysicsObjectType::eCustomShape;
+        type = UsdPhysicsObjectType::eCustomShape;
     }
-    bool operator == (const CustomShapeDesc&) const
+    bool operator == (const UsdPhysicsCustomShapeDesc&) const
     {
         return false;
     }
@@ -386,17 +386,17 @@ struct CustomShapeDesc : ShapeDesc
     TfToken customGeometryToken;    ///< Custom geometry token for this collision
 };
 
-/// \struct CubeShapeDesc
+/// \struct UsdPhysicsCubeShapeDesc
 ///
 /// Cube shape collision descriptor
 ///
-struct CubeShapeDesc : ShapeDesc
+struct UsdPhysicsCubeShapeDesc : UsdPhysicsShapeDesc
 {
-    CubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f)) : halfExtents(inHalfExtents)
+    UsdPhysicsCubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f)) : halfExtents(inHalfExtents)
     {
-        type = PhysicsObjectType::eCubeShape;
+        type = UsdPhysicsObjectType::eCubeShape;
     }
-    bool operator == (const CubeShapeDesc&) const
+    bool operator == (const UsdPhysicsCubeShapeDesc&) const
     {
         return false;
     }
@@ -404,23 +404,23 @@ struct CubeShapeDesc : ShapeDesc
     GfVec3f halfExtents;        ///< Half extents of the cube
 };
 
-/// \struct MeshShapeDesc
+/// \struct UsdPhysicsMeshShapeDesc
 ///
 /// Mesh shape collision descriptor
 ///
-struct MeshShapeDesc : ShapeDesc
+struct UsdPhysicsMeshShapeDesc : UsdPhysicsShapeDesc
 {
-    MeshShapeDesc() : meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
+    UsdPhysicsMeshShapeDesc() : meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
     {
-        type = PhysicsObjectType::eMeshShape;
+        type = UsdPhysicsObjectType::eMeshShape;
     }
-    bool operator == (const MeshShapeDesc&) const
+    bool operator == (const UsdPhysicsMeshShapeDesc&) const
     {
         return false;
     }
 
 
-    ~MeshShapeDesc()
+    ~UsdPhysicsMeshShapeDesc()
     {
     }
 
@@ -434,14 +434,14 @@ struct MeshShapeDesc : ShapeDesc
     bool doubleSided;           ///< Bool to define whether mesh is double sided or not
 };
 
-/// \struct SpherePoint
+/// \struct UsdPhysicsSpherePoint
 ///
 /// This struct represents a single sphere-point
 /// which is a position and a radius
 ///
-struct SpherePoint
+struct UsdPhysicsSpherePoint
 {
-    bool operator == (const SpherePoint&) const
+    bool operator == (const UsdPhysicsSpherePoint&) const
     {
         return false;
     }
@@ -450,39 +450,39 @@ struct SpherePoint
     float radius;
 };
 
-/// \struct SpherePointsShapeDesc
+/// \struct UsdPhysicsSpherePointsShapeDesc
 ///
 /// This struct represents a collection of
 /// sphere points. Basically just an array of
 /// spheres which has been populated from a
 /// UsdGeomPoints primitive
 ///
-struct SpherePointsShapeDesc : ShapeDesc
+struct UsdPhysicsSpherePointsShapeDesc : UsdPhysicsShapeDesc
 {
-    SpherePointsShapeDesc(void)
+    UsdPhysicsSpherePointsShapeDesc(void)
     {
-        type = PhysicsObjectType::eSpherePointsShape;
+        type = UsdPhysicsObjectType::eSpherePointsShape;
     }
-    bool operator == (const SpherePointsShapeDesc&) const
+    bool operator == (const UsdPhysicsSpherePointsShapeDesc&) const
     {
         return false;
     }
 
 
-    ~SpherePointsShapeDesc(void)
+    ~UsdPhysicsSpherePointsShapeDesc(void)
     {
     }
 
-    std::vector<SpherePoint> spherePoints;  ///< Lit of sphere points
+    std::vector<UsdPhysicsSpherePoint> spherePoints;  ///< Lit of sphere points
 };
 
-/// \struct RigidBodyDesc
+/// \struct UsdPhysicsRigidBodyDesc
 ///
 /// Rigid body descriptor
 ///
-struct RigidBodyDesc : PhysicsObjectDesc
+struct UsdPhysicsRigidBodyDesc : UsdPhysicsObjectDesc
 {
-    RigidBodyDesc()
+    UsdPhysicsRigidBodyDesc()
         : position(0.0f, 0.0f, 0.0f),
           rotation(1.0f, 0.0f, 0.0f, 0.0f),
           scale(1.0f, 1.0f, 1.0f),
@@ -492,9 +492,9 @@ struct RigidBodyDesc : PhysicsObjectDesc
           linearVelocity(0.0f, 0.0f, 0.0f),
           angularVelocity(0.0f, 0.0f, 0.0f)
     {
-        type = PhysicsObjectType::eRigidBody;
+        type = UsdPhysicsObjectType::eRigidBody;
     }
-    bool operator == (const RigidBodyDesc&) const
+    bool operator == (const UsdPhysicsRigidBodyDesc&) const
     {
         return false;
     }
@@ -528,17 +528,17 @@ struct RigidBodyDesc : PhysicsObjectDesc
     GfVec3f angularVelocity;                ///< Rigid body initial angular velocity
 };
 
-/// \struct JointLimit
+/// \struct UsdPhysicsJointLimit
 ///
 /// Joint limit descriptor
 ///
-struct JointLimit
+struct UsdPhysicsJointLimit
 {
-    JointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
+    UsdPhysicsJointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
     {
     }
 
-    bool operator == (const JointLimit&) const
+    bool operator == (const UsdPhysicsJointLimit&) const
     {
         return false;
     }
@@ -559,15 +559,15 @@ struct JointLimit
     };
 };
 
-/// \struct JointDrive
+/// \struct UsdPhysicsJointDrive
 ///
 /// Joint drive descriptor
 /// The expected drive formula:
 /// force = spring * (target position - position) + damping * (targetVelocity - velocity)
 ///
-struct JointDrive
+struct UsdPhysicsJointDrive
 {
-    JointDrive()
+    UsdPhysicsJointDrive()
         : enabled(false),
           targetPosition(0.0f),
           targetVelocity(0.0f),
@@ -578,7 +578,7 @@ struct JointDrive
     {
     }
 
-    bool operator == (const JointDrive&) const
+    bool operator == (const UsdPhysicsJointDrive&) const
     {
         return false;
     }
@@ -593,17 +593,17 @@ struct JointDrive
 };
 
 
-/// \struct ArticulationDesc
+/// \struct UsdPhysicsArticulationDesc
 ///
 /// Articulation description
 ///
-struct ArticulationDesc : PhysicsObjectDesc
+struct UsdPhysicsArticulationDesc : UsdPhysicsObjectDesc
 {
-    ArticulationDesc()
+    UsdPhysicsArticulationDesc()
     {
-        type = PhysicsObjectType::eArticulation;
+        type = UsdPhysicsObjectType::eArticulation;
     }
-    bool operator == (const ArticulationDesc&) const
+    bool operator == (const UsdPhysicsArticulationDesc&) const
     {
         return false;
     }
@@ -634,16 +634,16 @@ struct ArticulationDesc : PhysicsObjectDesc
     SdfPathVector articulatedBodies;    ///< List of bodies that can be part of this articulation
 };
 
-using JointLimits = std::vector<std::pair<PhysicsJointDOF::Enum, JointLimit>>;
-using JointDrives = std::vector<std::pair<PhysicsJointDOF::Enum, JointDrive>>;
+using JointLimits = std::vector<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>;
+using JointDrives = std::vector<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>>;
 
-/// \struct JointDesc
+/// \struct UsdPhysicsJointDesc
 ///
 /// Base UsdPhysics joint descriptor
 ///
-struct JointDesc : public PhysicsObjectDesc
+struct UsdPhysicsJointDesc : public UsdPhysicsObjectDesc
 {
-    JointDesc()
+    UsdPhysicsJointDesc()
         : localPose0Position(0.0f, 0.0f, 0.0f),
           localPose0Orientation(1.0f, 0.0f, 0.0f, 0.0f),
           localPose1Position(0.0f, 0.0f, 0.0f),
@@ -655,7 +655,7 @@ struct JointDesc : public PhysicsObjectDesc
     {
     }
 
-    bool operator == (const JointDesc&) const
+    bool operator == (const UsdPhysicsJointDesc&) const
     {
         return false;
     }
@@ -675,50 +675,50 @@ struct JointDesc : public PhysicsObjectDesc
     bool collisionEnabled;          ///< Defines if collision is enabled or disabled between the jointed bodies
 };
 
-/// \struct CustomJointDesc
+/// \struct UsdPhysicsCustomJointDesc
 ///
 /// Custom joint descriptor
 ///
-struct CustomJointDesc : public JointDesc
+struct UsdPhysicsCustomJointDesc : public UsdPhysicsJointDesc
 {
-    CustomJointDesc()
+    UsdPhysicsCustomJointDesc()
     {
-        type = PhysicsObjectType::eCustomJoint;
+        type = UsdPhysicsObjectType::eCustomJoint;
     }
-    bool operator == (const CustomJointDesc&) const
+    bool operator == (const UsdPhysicsCustomJointDesc&) const
     {
         return false;
     }
 
 };
 
-/// \struct FixedJointDesc
+/// \struct UsdPhysicsFixedJointDesc
 ///
 /// Fixed joint descriptor
 ///
-struct FixedJointDesc : public JointDesc
+struct UsdPhysicsFixedJointDesc : public UsdPhysicsJointDesc
 {
-    FixedJointDesc()
+    UsdPhysicsFixedJointDesc()
     {
-        type = PhysicsObjectType::eFixedJoint;
+        type = UsdPhysicsObjectType::eFixedJoint;
     }
-    bool operator == (const FixedJointDesc&) const
+    bool operator == (const UsdPhysicsFixedJointDesc&) const
     {
         return false;
     }
 };
 
-/// \struct D6JointDesc
+/// \struct UsdPhysicsD6JointDesc
 ///
 /// Generic D6 joint descriptor
 ///
-struct D6JointDesc : public JointDesc
+struct UsdPhysicsD6JointDesc : public UsdPhysicsJointDesc
 {
-    D6JointDesc()
+    UsdPhysicsD6JointDesc()
     {
-        type = PhysicsObjectType::eD6Joint;
+        type = UsdPhysicsObjectType::eD6Joint;
     }
-    bool operator == (const D6JointDesc&) const
+    bool operator == (const UsdPhysicsD6JointDesc&) const
     {
         return false;
     }
@@ -727,83 +727,83 @@ struct D6JointDesc : public JointDesc
     JointDrives jointDrives;    ///< List of joint drives
 };
 
-/// \struct PrismaticJointDesc
+/// \struct UsdPhysicsPrismaticJointDesc
 ///
 /// Prismatic joint descriptor
 ///
-struct PrismaticJointDesc : public JointDesc
+struct UsdPhysicsPrismaticJointDesc : public UsdPhysicsJointDesc
 {
-    PrismaticJointDesc() : axis(PhysicsAxis::eX)
+    UsdPhysicsPrismaticJointDesc() : axis(UsdPhysicsAxis::eX)
     {
-        type = PhysicsObjectType::ePrismaticJoint;
+        type = UsdPhysicsObjectType::ePrismaticJoint;
     }
-    bool operator == (const PrismaticJointDesc&) const
+    bool operator == (const UsdPhysicsPrismaticJointDesc&) const
     {
         return false;
     }
 
 
-    PhysicsAxis::Enum axis; ///< The joints axis
-    JointLimit limit;       ///< Joint linear limit
-    JointDrive drive;       ///< Joint linear drive
+    UsdPhysicsAxis::Enum axis; ///< The joints axis
+    UsdPhysicsJointLimit limit;       ///< Joint linear limit
+    UsdPhysicsJointDrive drive;       ///< Joint linear drive
 };
 
-/// \struct SphericalJointDesc
+/// \struct UsdPhysicsSphericalJointDesc
 ///
 /// Spherical joint descriptor
 ///
-struct SphericalJointDesc : public JointDesc
+struct UsdPhysicsSphericalJointDesc : public UsdPhysicsJointDesc
 {
-    SphericalJointDesc() : axis(PhysicsAxis::eX)
+    UsdPhysicsSphericalJointDesc() : axis(UsdPhysicsAxis::eX)
     {
-        type = PhysicsObjectType::eSphericalJoint;
+        type = UsdPhysicsObjectType::eSphericalJoint;
     }
-    bool operator == (const SphericalJointDesc&) const
+    bool operator == (const UsdPhysicsSphericalJointDesc&) const
     {
         return false;
     }
 
-    PhysicsAxis::Enum axis; ///< The joints axis
-    JointLimit limit;       ///< The joint spherical limit
+    UsdPhysicsAxis::Enum axis; ///< The joints axis
+    UsdPhysicsJointLimit limit;       ///< The joint spherical limit
 };
 
-/// \struct RevoluteJointDesc
+/// \struct UsdPhysicsRevoluteJointDesc
 ///
 /// Revolute joint descriptor
 ///
-struct RevoluteJointDesc : public JointDesc
+struct UsdPhysicsRevoluteJointDesc : public UsdPhysicsJointDesc
 {
-    RevoluteJointDesc() : axis(PhysicsAxis::eX)
+    UsdPhysicsRevoluteJointDesc() : axis(UsdPhysicsAxis::eX)
     {
-        type = PhysicsObjectType::eRevoluteJoint;
+        type = UsdPhysicsObjectType::eRevoluteJoint;
     }
-    bool operator == (const RevoluteJointDesc&) const
+    bool operator == (const UsdPhysicsRevoluteJointDesc&) const
     {
         return false;
     }
 
-    PhysicsAxis::Enum axis; ///< The joints axis
-    JointLimit limit;       ///< The angular limit
-    JointDrive drive;       ///< The angular drive
+    UsdPhysicsAxis::Enum axis; ///< The joints axis
+    UsdPhysicsJointLimit limit;       ///< The angular limit
+    UsdPhysicsJointDrive drive;       ///< The angular drive
 };
 
-/// \struct DistanceJointDesc
+/// \struct UsdPhysicsDistanceJointDesc
 ///
 /// Distance joint descriptor
 ///
-struct DistanceJointDesc : public JointDesc
+struct UsdPhysicsDistanceJointDesc : public UsdPhysicsJointDesc
 {
-    DistanceJointDesc() : minEnabled(false), maxEnabled(false)
+    UsdPhysicsDistanceJointDesc() : minEnabled(false), maxEnabled(false)
     {
-        type = PhysicsObjectType::eDistanceJoint;
+        type = UsdPhysicsObjectType::eDistanceJoint;
     }
-    bool operator == (const DistanceJointDesc&) const
+    bool operator == (const UsdPhysicsDistanceJointDesc&) const
     {
         return false;
     }
     bool minEnabled;    ///< Defines if minimum limit is enabled
     bool maxEnabled;    ///< Defines if maximum limit is enabled
-    JointLimit limit;   ///< The distance limit
+    UsdPhysicsJointLimit limit;   ///< The distance limit
 };
 
 
diff --git a/pxr/usd/usdPhysics/parseUtils.cpp b/pxr/usd/usdPhysics/parseUtils.cpp
index 8fa2ec2b5c..6a57cc8c17 100644
--- a/pxr/usd/usdPhysics/parseUtils.cpp
+++ b/pxr/usd/usdPhysics/parseUtils.cpp
@@ -76,7 +76,7 @@ void ParseFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filtere
     }
 }
 
-bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI, ArticulationDesc* articulationDesc)
+bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI, UsdPhysicsArticulationDesc* articulationDesc)
 {
     if (articulationDesc && articulationAPI)
     {       
@@ -86,16 +86,16 @@ bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI,
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or ArticulationDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or UsdPhysicsArticulationDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-PhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
+UsdPhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
 {
-    PhysicsObjectType::Enum retVal = PhysicsObjectType::eUndefined;
+    UsdPhysicsObjectType::Enum retVal = UsdPhysicsObjectType::eUndefined;
 
     // custom shape handling
     bool customShape = false;
@@ -110,19 +110,19 @@ PhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<
             {
                 if (apis[j] == (*customTokens)[i])
                 {
-                    retVal = PhysicsObjectType::eCustomShape;
+                    retVal = UsdPhysicsObjectType::eCustomShape;
                     if (customeGeometryToken)
                         *customeGeometryToken = apis[j];
                     break;
                 }
             }
-            if(retVal == PhysicsObjectType::eCustomShape)
+            if(retVal == UsdPhysicsObjectType::eCustomShape)
             {
                 break;
             }
             if (primType == (*customTokens)[i])
             {
-                    retVal = PhysicsObjectType::eCustomShape;
+                    retVal = UsdPhysicsObjectType::eCustomShape;
                     if (customeGeometryToken)
                         *customeGeometryToken = primType;                
                 break;
@@ -130,7 +130,7 @@ PhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<
         }
     }
 
-    if (retVal == PhysicsObjectType::eCustomShape)
+    if (retVal == UsdPhysicsObjectType::eCustomShape)
         return retVal;
 
     // geomgprim that belongs to that collision
@@ -138,38 +138,38 @@ PhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<
     {
         // If the primitive is a UsdGeomPoints *and* it has a widths attribute
         // corresponding to the positions attribute, then we treat it as an
-        // array of spheres corresponding to the 'SpherePointsShapeDesc'
+        // array of spheres corresponding to the 'UsdPhysicsSpherePointsShapeDesc'
         if (prim.IsA<UsdGeomMesh>())
         {
-            retVal = PhysicsObjectType::eMeshShape;
+            retVal = UsdPhysicsObjectType::eMeshShape;
         }
         else if (prim.IsA<UsdGeomCube>())
         {
-            retVal = PhysicsObjectType::eCubeShape;
+            retVal = UsdPhysicsObjectType::eCubeShape;
         }
         else if (prim.IsA<UsdGeomSphere>())
         {
-            retVal = PhysicsObjectType::eSphereShape;
+            retVal = UsdPhysicsObjectType::eSphereShape;
         }
         else if (prim.IsA<UsdGeomCapsule>())
         {
-            retVal = PhysicsObjectType::eCapsuleShape;
+            retVal = UsdPhysicsObjectType::eCapsuleShape;
         }
         else if (prim.IsA<UsdGeomCylinder>())
         {
-            retVal = PhysicsObjectType::eCylinderShape;
+            retVal = UsdPhysicsObjectType::eCylinderShape;
         }
         else if (prim.IsA<UsdGeomCone>())
         {
-            retVal = PhysicsObjectType::eConeShape;
+            retVal = UsdPhysicsObjectType::eConeShape;
         }
         else if (prim.IsA<UsdGeomPlane>())
         {
-            retVal = PhysicsObjectType::ePlaneShape;
+            retVal = UsdPhysicsObjectType::ePlaneShape;
         }
         else if (prim.IsA<UsdGeomPoints>())
         {
-            retVal = PhysicsObjectType::eSpherePointsShape;
+            retVal = UsdPhysicsObjectType::eSpherePointsShape;
         }
     }
     
@@ -226,7 +226,7 @@ static void ParseColFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVecto
     }
 }
 
-void FinalizeDesc(const UsdPhysicsCollisionAPI& colAPI, ShapeDesc& desc)
+void FinalizeDesc(const UsdPhysicsCollisionAPI& colAPI, UsdPhysicsShapeDesc& desc)
 {
     // set the collider material as last
     // set SdfPath() anyway, this would indicate default material should be used, this is required for trimesh subset materials
@@ -255,7 +255,7 @@ void FinalizeDesc(const UsdPhysicsCollisionAPI& colAPI, ShapeDesc& desc)
 }
 
 
-bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, SphereShapeDesc* sphereShapeDesc)
+bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsSphereShapeDesc* sphereShapeDesc)
 {
     if (sphereShapeDesc && collisionAPI)
     {       
@@ -297,13 +297,13 @@ bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, SphereShap
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or SphereShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsSphereShapeDesc is not valid.");
         return false;
     }
     return true;
 }
 
-bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CubeShapeDesc* cubeShapeDesc)
+bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCubeShapeDesc* cubeShapeDesc)
 {
     if (cubeShapeDesc && collisionAPI)
     {       
@@ -344,14 +344,14 @@ bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CubeShapeDes
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CubeShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCubeShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CylinderShapeDesc* cylinderShapeDesc)
+bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCylinderShapeDesc* cylinderShapeDesc)
 {
     if (cylinderShapeDesc && collisionAPI)
     {       
@@ -363,7 +363,7 @@ bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, Cylinder
 
             float radius = 1.0f;
             float halfHeight = 1.0f;
-            PhysicsAxis::Enum axis = PhysicsAxis::eX;
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
             // Get shape parameters
             {
@@ -379,9 +379,9 @@ bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, Cylinder
                 {
                     shape.GetAxisAttr().Get(&capAxis);
                     if (capAxis == UsdPhysicsTokens.Get()->y)
-                        axis = PhysicsAxis::eY;
+                        axis = UsdPhysicsAxis::eY;
                     else if (capAxis == UsdPhysicsTokens.Get()->z)
-                        axis = PhysicsAxis::eZ;
+                        axis = UsdPhysicsAxis::eZ;
                 }
             }
 
@@ -389,12 +389,12 @@ bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, Cylinder
                 // scale the radius and height based on the given axis token
                 const pxr::GfVec3d sc = tr.GetScale();
                 CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                if (axis == PhysicsAxis::eX)
+                if (axis == UsdPhysicsAxis::eX)
                 {
                     halfHeight *= float(sc[0]);
                     radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
                 }
-                else if (axis == PhysicsAxis::eY)
+                else if (axis == UsdPhysicsAxis::eY)
                 {
                     halfHeight *= float(sc[1]);
                     radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
@@ -420,14 +420,14 @@ bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, Cylinder
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CylinderShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCylinderShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CapsuleShapeDesc* capsuleShapeDesc)
+bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCapsuleShapeDesc* capsuleShapeDesc)
 {
     if (capsuleShapeDesc && collisionAPI)
     {       
@@ -439,7 +439,7 @@ bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CapsuleSh
 
             float radius = 1.0f;
             float halfHeight = 1.0f;
-            PhysicsAxis::Enum axis = PhysicsAxis::eX;
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
             // Get shape parameters
             {
@@ -455,9 +455,9 @@ bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CapsuleSh
                 {
                     shape.GetAxisAttr().Get(&capAxis);
                     if (capAxis == UsdPhysicsTokens.Get()->y)
-                        axis = PhysicsAxis::eY;
+                        axis = UsdPhysicsAxis::eY;
                     else if (capAxis == UsdPhysicsTokens.Get()->z)
-                        axis = PhysicsAxis::eZ;
+                        axis = UsdPhysicsAxis::eZ;
                 }
             }
 
@@ -465,12 +465,12 @@ bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CapsuleSh
                 // scale the radius and height based on the given axis token
                 const pxr::GfVec3d sc = tr.GetScale();
                 CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                if (axis == PhysicsAxis::eX)
+                if (axis == UsdPhysicsAxis::eX)
                 {
                     halfHeight *= float(sc[0]);
                     radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
                 }
-                else if (axis == PhysicsAxis::eY)
+                else if (axis == UsdPhysicsAxis::eY)
                 {
                     halfHeight *= float(sc[1]);
                     radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
@@ -496,14 +496,14 @@ bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CapsuleSh
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CapsuleShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCapsuleShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, ConeShapeDesc* coneShapeDesc)
+bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsConeShapeDesc* coneShapeDesc)
 {
     if (coneShapeDesc && collisionAPI)
     {       
@@ -515,7 +515,7 @@ bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, ConeShapeDes
 
             float radius = 1.0f;
             float halfHeight = 1.0f;
-            PhysicsAxis::Enum axis = PhysicsAxis::eX;
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
             // Get shape parameters
             {
@@ -531,9 +531,9 @@ bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, ConeShapeDes
                 {
                     shape.GetAxisAttr().Get(&capAxis);
                     if (capAxis == UsdPhysicsTokens.Get()->y)
-                        axis = PhysicsAxis::eY;
+                        axis = UsdPhysicsAxis::eY;
                     else if (capAxis == UsdPhysicsTokens.Get()->z)
-                        axis = PhysicsAxis::eZ;
+                        axis = UsdPhysicsAxis::eZ;
                 }
             }
 
@@ -541,12 +541,12 @@ bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, ConeShapeDes
                 // scale the radius and height based on the given axis token
                 const pxr::GfVec3d sc = tr.GetScale();
                 CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                if (axis == PhysicsAxis::eX)
+                if (axis == UsdPhysicsAxis::eX)
                 {
                     halfHeight *= float(sc[0]);
                     radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
                 }
-                else if (axis == PhysicsAxis::eY)
+                else if (axis == UsdPhysicsAxis::eY)
                 {
                     halfHeight *= float(sc[1]);
                     radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
@@ -572,14 +572,14 @@ bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, ConeShapeDes
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or ConeShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsConeShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, MeshShapeDesc* meshShapeDesc)
+bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsMeshShapeDesc* meshShapeDesc)
 {
     if (meshShapeDesc && collisionAPI)
     {       
@@ -632,14 +632,14 @@ bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, MeshShapeDes
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or MeshShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsMeshShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, PlaneShapeDesc* planeShapeDesc)
+bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsPlaneShapeDesc* planeShapeDesc)
 {
     if (planeShapeDesc && collisionAPI)
     {       
@@ -647,17 +647,17 @@ bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, PlaneShapeD
         const UsdGeomPlane shape(usdPrim);
         if (shape)
         {
-            PhysicsAxis::Enum axis = PhysicsAxis::eX;     
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;     
 
             TfToken tfAxis;            
             shape.GetAxisAttr().Get(&tfAxis);
             if (tfAxis == UsdPhysicsTokens.Get()->y)
             {
-                axis = PhysicsAxis::eY;
+                axis = UsdPhysicsAxis::eY;
             }
             else if (tfAxis == UsdPhysicsTokens.Get()->z)
             {
-                axis = PhysicsAxis::eZ;
+                axis = UsdPhysicsAxis::eZ;
             }
 
             planeShapeDesc->axis = axis;            
@@ -673,14 +673,14 @@ bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, PlaneShapeD
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or PlaneShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsPlaneShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, SpherePointsShapeDesc* spherePointsShapeDesc)
+bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsSpherePointsShapeDesc* spherePointsShapeDesc)
 {
     if (spherePointsShapeDesc && collisionAPI)
     {       
@@ -740,14 +740,14 @@ bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, Sphe
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or SpherePointsShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsSpherePointsShapeDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CustomShapeDesc* customShapeDesc)
+bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCustomShapeDesc* customShapeDesc)
 {
     if (customShapeDesc && collisionAPI)
     {       
@@ -758,7 +758,7 @@ bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CustomShap
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or CustomShapeDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCustomShapeDesc is not valid.");
         return false;
 
     }
@@ -766,7 +766,7 @@ bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, CustomShap
 }
 
 
-bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup, CollisionGroupDesc* collisionGroupDesc)
+bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup, UsdPhysicsCollisionGroupDesc* collisionGroupDesc)
 {
     if (collisionGroup && collisionGroupDesc)
     {        
@@ -783,7 +783,7 @@ bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup, Col
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionGroup or CollisionGroupDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionGroup or UsdPhysicsCollisionGroupDesc is not valid.");
         return false;
     }
 
@@ -895,7 +895,7 @@ SdfPath GetLocalPose(UsdStageWeakPtr stage, const SdfPath& relPath, GfVec3f& t,
     return body ? body.GetPrimPath() : SdfPath();
 }
 
-void FinalizeJoint(const UsdPhysicsJoint& jointPrim, JointDesc* jointDesc)
+void FinalizeJoint(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
 {
     // joint bodies anchor point local transforms    
     GfVec3f t0(0.f);
@@ -929,7 +929,7 @@ void FinalizeJoint(const UsdPhysicsJoint& jointPrim, JointDesc* jointDesc)
     jointDesc->localPose1Orientation = q1;
 }
 
-bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, JointDesc* jointDesc)
+bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
 {
     const UsdPrim prim = jointPrim.GetPrim();
 
@@ -956,7 +956,7 @@ bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, JointDesc* jointDesc
     return true;
 }
 
-bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint, DistanceJointDesc* distanceJointDesc)
+bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint, UsdPhysicsDistanceJointDesc* distanceJointDesc)
 {
     if (distanceJointDesc && distanceJoint)
     {
@@ -984,14 +984,14 @@ bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint, Distan
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsDistanceJoint or DistanceJointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsDistanceJoint or UsdPhysicsDistanceJointDesc is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseDrive(const UsdPhysicsDriveAPI& drive, JointDrive* jointDrive)
+bool ParseDrive(const UsdPhysicsDriveAPI& drive, UsdPhysicsJointDrive* jointDrive)
 {
     if (drive && jointDrive)
     {
@@ -1010,14 +1010,14 @@ bool ParseDrive(const UsdPhysicsDriveAPI& drive, JointDrive* jointDrive)
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsDriveAPI or JointDrive is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsDriveAPI or UsdPhysicsJointDrive is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint, FixedJointDesc* fixedJointDesc)
+bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint, UsdPhysicsFixedJointDesc* fixedJointDesc)
 {
     if (fixedJointDesc && fixedJoint)
     {
@@ -1029,14 +1029,14 @@ bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint, FixedJointDesc*
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsFixedJoint or FixedJointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsFixedJoint or UsdPhysicsFixedJointDesc is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseLimit(const UsdPhysicsLimitAPI& limit, JointLimit* jointLimit)
+bool ParseLimit(const UsdPhysicsLimitAPI& limit, UsdPhysicsJointLimit* jointLimit)
 {
     if (limit && jointLimit)
     {
@@ -1048,14 +1048,14 @@ bool ParseLimit(const UsdPhysicsLimitAPI& limit, JointLimit* jointLimit)
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsLimitAPI or JointLimit is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsLimitAPI or UsdPhysicsJointLimit is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, D6JointDesc* jointDesc)
+bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsD6JointDesc* jointDesc)
 {    
     if (jointDesc && jointPrim)
     {
@@ -1066,11 +1066,11 @@ bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, D6JointDesc* jointDesc)
         }
 
         // D6 joint        
-        const std::array<std::pair<PhysicsJointDOF::Enum, TfToken>, 7> axisVector = {
-            std::make_pair(PhysicsJointDOF::eDistance, UsdPhysicsTokens->distance), std::make_pair(PhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
-            std::make_pair(PhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),     std::make_pair(PhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
-            std::make_pair(PhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),         std::make_pair(PhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
-            std::make_pair(PhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
+        const std::array<std::pair<UsdPhysicsJointDOF::Enum, TfToken>, 7> axisVector = {
+            std::make_pair(UsdPhysicsJointDOF::eDistance, UsdPhysicsTokens->distance), std::make_pair(UsdPhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
+            std::make_pair(UsdPhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),     std::make_pair(UsdPhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
+            std::make_pair(UsdPhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),         std::make_pair(UsdPhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
+            std::make_pair(UsdPhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
         };
 
         for (size_t i = 0; i < axisVector.size(); i++)
@@ -1080,7 +1080,7 @@ bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, D6JointDesc* jointDesc)
             const UsdPhysicsLimitAPI limitAPI = UsdPhysicsLimitAPI::Get(jointPrim.GetPrim(), axisToken);
             if (limitAPI)
             {
-                JointLimit limit;
+                UsdPhysicsJointLimit limit;
                 if (ParseLimit(limitAPI, &limit))
                 {
                     jointDesc->jointLimits.push_back(std::make_pair(axisVector[i].first, limit));
@@ -1090,7 +1090,7 @@ bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, D6JointDesc* jointDesc)
             const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(jointPrim.GetPrim(), axisToken);
             if (driveAPI)
             {
-                JointDrive drive;
+                UsdPhysicsJointDrive drive;
                 if (ParseDrive(driveAPI, &drive))
                 {
                     jointDesc->jointDrives.push_back(std::make_pair(axisVector[i].first, drive));
@@ -1100,14 +1100,14 @@ bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, D6JointDesc* jointDesc)
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or JointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim, CustomJointDesc* customJointDesc)
+bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsCustomJointDesc* customJointDesc)
 {
     if (customJointDesc && jointPrim)
     {
@@ -1119,14 +1119,14 @@ bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim, CustomJointDesc* cus
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or JointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial, RigidBodyMaterialDesc* rbMaterialDesc)
+bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial, UsdPhysicsRigidBodyMaterialDesc* rbMaterialDesc)
 {
     if (rbMaterialDesc && usdMaterial)
     {       
@@ -1141,14 +1141,14 @@ bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial, RigidB
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsMaterialAPI or RigidBodyMaterialDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsMaterialAPI or UsdPhysicsRigidBodyMaterialDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseLinearDrive(JointDrive* dst, const UsdPrim& usdPrim)
+bool ParseLinearDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
 {
     dst->enabled = false;
     const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->linear);
@@ -1161,7 +1161,7 @@ bool ParseLinearDrive(JointDrive* dst, const UsdPrim& usdPrim)
 }
 
 
-bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, PrismaticJointDesc* prismaticJointDesc)
+bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, UsdPhysicsPrismaticJointDesc* prismaticJointDesc)
 {
     if (prismaticJointDesc && prismaticJoint)
     {
@@ -1171,14 +1171,14 @@ bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, Pri
             return false;
         }
 
-        PhysicsAxis::Enum jointAxis = PhysicsAxis::eX;
+        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
         TfToken axis = UsdPhysicsTokens->x;            
         prismaticJoint.GetAxisAttr().Get(&axis);
 
         if (axis == UsdPhysicsTokens->y)
-            jointAxis = PhysicsAxis::eY;
+            jointAxis = UsdPhysicsAxis::eY;
         else if (axis == UsdPhysicsTokens->z)
-            jointAxis = PhysicsAxis::eZ;
+            jointAxis = UsdPhysicsAxis::eZ;
         prismaticJointDesc->axis = jointAxis;
 
         prismaticJointDesc->limit.enabled = false;
@@ -1197,14 +1197,14 @@ bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, Pri
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsPrismaticJoint or PrismaticJointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsPrismaticJoint or UsdPhysicsPrismaticJointDesc is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseAngularDrive(JointDrive* dst, const UsdPrim& usdPrim)
+bool ParseAngularDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
 {
     dst->enabled = false;
     const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->angular);
@@ -1217,7 +1217,7 @@ bool ParseAngularDrive(JointDrive* dst, const UsdPrim& usdPrim)
 }
 
 
-bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, RevoluteJointDesc* revoluteJointDesc)
+bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, UsdPhysicsRevoluteJointDesc* revoluteJointDesc)
 {
     if (revoluteJointDesc && revoluteJoint)
     {
@@ -1227,14 +1227,14 @@ bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, Revolu
             return false;
         }
 
-        PhysicsAxis::Enum jointAxis = PhysicsAxis::eX;
+        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
         TfToken axis = UsdPhysicsTokens->x;
         revoluteJoint.GetAxisAttr().Get(&axis);
 
         if (axis == UsdPhysicsTokens->y)
-            jointAxis = PhysicsAxis::eY;
+            jointAxis = UsdPhysicsAxis::eY;
         else if (axis == UsdPhysicsTokens->z)
-            jointAxis = PhysicsAxis::eZ;
+            jointAxis = UsdPhysicsAxis::eZ;
         revoluteJointDesc->axis = jointAxis;
 
         revoluteJointDesc->limit.enabled = false;
@@ -1255,7 +1255,7 @@ bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, Revolu
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or JointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
         return false;
     }
 
@@ -1297,7 +1297,7 @@ inline bool ScaleIsUniform(T scaleX, T scaleY, T scaleZ, T eps = T(1.0e-5))
 }
 
 
-void GetRigidBodyTransformation(const UsdPrim& bodyPrim, RigidBodyDesc& desc)
+void GetRigidBodyTransformation(const UsdPrim& bodyPrim, UsdPhysicsRigidBodyDesc& desc)
 {
     const GfMatrix4d mat = UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
     const GfTransform tr(mat);
@@ -1315,7 +1315,7 @@ void GetRigidBodyTransformation(const UsdPrim& bodyPrim, RigidBodyDesc& desc)
     desc.scale = GfVec3f(sc);
 }
 
-bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI, RigidBodyDesc* rigidBodyDesc)
+bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI, UsdPhysicsRigidBodyDesc* rigidBodyDesc)
 {
     if (rigidBodyDesc && rigidBodyAPI)
     {       
@@ -1380,14 +1380,14 @@ bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI, RigidBodyDes
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsRigidBodyAPI or RigidBodyDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsRigidBodyAPI or UsdPhysicsRigidBodyDesc is not valid.");
         return false;
 
     }
     return true;
 }
 
-bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint, SphericalJointDesc* sphericalJointDesc)
+bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint, UsdPhysicsSphericalJointDesc* sphericalJointDesc)
 {
     if (sphericalJointDesc && sphericalJoint)
     {
@@ -1397,14 +1397,14 @@ bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint, Sph
             return false;
         }
 
-        PhysicsAxis::Enum jointAxis = PhysicsAxis::eX;
+        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
         TfToken axis = UsdPhysicsTokens->x;
         sphericalJoint.GetAxisAttr().Get(&axis);
 
         if (axis == UsdPhysicsTokens->y)
-            jointAxis = PhysicsAxis::eY;
+            jointAxis = UsdPhysicsAxis::eY;
         else if (axis == UsdPhysicsTokens->z)
-            jointAxis = PhysicsAxis::eZ;
+            jointAxis = UsdPhysicsAxis::eZ;
         sphericalJointDesc->axis = jointAxis;
 
         sphericalJointDesc->limit.enabled = false;
@@ -1419,14 +1419,14 @@ bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint, Sph
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsSphericalJoint or SphericalJointDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsSphericalJoint or UsdPhysicsSphericalJointDesc is not valid.");
         return false;
     }
 
     return true;
 }
 
-bool ParseSceneDesc(const UsdPhysicsScene& scene, SceneDesc* sceneDesc)
+bool ParseSceneDesc(const UsdPhysicsScene& scene, UsdPhysicsSceneDesc* sceneDesc)
 {
     if (sceneDesc && scene)
     {
@@ -1463,7 +1463,7 @@ bool ParseSceneDesc(const UsdPhysicsScene& scene, SceneDesc* sceneDesc)
     }
     else
     {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsScene or SceneDesc is not valid.");
+        TF_RUNTIME_ERROR("Provided UsdPhysicsScene or UsdPhysicsSceneDesc is not valid.");
         return false;
     }
     return true;
@@ -1493,7 +1493,7 @@ bool CheckNestedArticulationRoot(const pxr::UsdPrim& usdPrim, const std::unorder
     return false;
 }
 
-using RigidBodyMap = std::map<pxr::SdfPath, RigidBodyDesc*>;
+using RigidBodyMap = std::map<pxr::SdfPath, UsdPhysicsRigidBodyDesc*>;
 
 bool IsDynamicBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, bool& physicsAPIFound)
 {
@@ -1557,7 +1557,7 @@ void ProcessPhysicsPrims(const std::vector<UsdPrim>& physicsPrims, std::vector<D
 }
 
 template <typename DescType> 
-void CallReportFn(PhysicsObjectType::Enum descType, const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc, 
+void CallReportFn(UsdPhysicsObjectType::Enum descType, const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc, 
     UsdPhysicsReportFn reportFn, SdfPathVector& primPathsVector, void* userData)
 {
     primPathsVector.resize(physicsPrims.size());
@@ -1568,14 +1568,14 @@ void CallReportFn(PhysicsObjectType::Enum descType, const std::vector<UsdPrim>&
     reportFn(descType, primPathsVector.size(), primPathsVector.data(), physicsDesc.data(), userData);
 }
 
-void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims, std::vector<RigidBodyDesc>& rigidBodyDescs, 
+void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims, std::vector<UsdPhysicsRigidBodyDesc>& rigidBodyDescs, 
     bool defaultSimulationOwner, std::unordered_set<SdfPath, SdfPath::Hash>& reportedBodies,
     const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
     for (size_t i = rigidBodyDescs.size(); i--;)
     {
         bool ownerFound = false;
-        const RigidBodyDesc& desc = rigidBodyDescs[i];
+        const UsdPhysicsRigidBodyDesc& desc = rigidBodyDescs[i];
         if (desc.isValid)
         {
             if (desc.simulationOwners.empty() && defaultSimulationOwner)
@@ -1617,7 +1617,7 @@ void CheckCollisionSimulationOwner(std::vector<UsdPrim>& collisionPrims, std::ve
     for (size_t i = shapeDesc.size(); i--;)
     {
         bool ownerFound = false;
-        const ShapeDesc& desc = shapeDesc[i];
+        const UsdPhysicsShapeDesc& desc = shapeDesc[i];
         if (desc.isValid)
         {
             if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
@@ -1690,7 +1690,7 @@ void CheckJointSimulationOwner(std::vector<UsdPrim>& jointPrims, std::vector<Des
 {
     for (size_t i = jointDesc.size(); i--;)
     {
-        const JointDesc& desc = jointDesc[i];
+        const UsdPhysicsJointDesc& desc = jointDesc[i];
 
         bool ownersValid = false;
         if (desc.isValid)
@@ -1713,13 +1713,13 @@ void CheckJointSimulationOwner(std::vector<UsdPrim>& jointPrims, std::vector<Des
 }
 
 // all bodies must have valid owner
-void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims, std::vector<ArticulationDesc>& articulationDescs, 
+void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims, std::vector<UsdPhysicsArticulationDesc>& articulationDescs, 
     bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
     const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
     for (size_t i = articulationDescs.size(); i--;)
     {
-        const ArticulationDesc& desc = articulationDescs[i];
+        const UsdPhysicsArticulationDesc& desc = articulationDescs[i];
 
         bool ownersValid = true;
         if (desc.isValid)
@@ -1747,7 +1747,7 @@ void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims, s
 SdfPath GetRigidBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap)
 {
     UsdPrim bodyPrim = UsdPrim();
-    RigidBodyDesc* body = nullptr;
+    UsdPhysicsRigidBodyDesc* body = nullptr;
     if (HasDynamicBodyParent(usdPrim, bodyMap, bodyPrim))
     {
        return bodyPrim.GetPrimPath();
@@ -1804,7 +1804,7 @@ void GetCollisionShapeLocalTransfrom(UsdGeomXformCache& xfCache, const UsdPrim&
     localPosOut = localPos;
 }
 
-void FinalizeCollision(UsdStageWeakPtr stage, UsdGeomXformCache& xfCache, const RigidBodyDesc* bodyDesc, ShapeDesc* shapeDesc)
+void FinalizeCollision(UsdStageWeakPtr stage, UsdGeomXformCache& xfCache, const UsdPhysicsRigidBodyDesc* bodyDesc, UsdPhysicsShapeDesc* shapeDesc)
 {
     // get shape local pose
     const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
@@ -1832,7 +1832,7 @@ void FinalizeCollisionDescs(UsdGeomXformCache& xfCache, const std::vector<UsdPri
             // get the body
             SdfPath bodyPath = GetRigidBody(prim, bodyMap);
             // body was found, add collision to the body
-            RigidBodyDesc* bodyDesc = nullptr;
+            UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
             if (bodyPath != SdfPath())
             {
                 RigidBodyMap::iterator bodyIt = bodyMap.find(bodyPath);
@@ -1870,9 +1870,9 @@ struct ArticulationLink
 };
 
 using ArticulationLinkMap = std::map<pxr::SdfPath, ArticulationLink>;
-using BodyJointMap = pxr::TfHashMap<pxr::SdfPath, std::vector<const JointDesc*>, pxr::SdfPath::Hash>;
-using JointMap = std::map<pxr::SdfPath, JointDesc*>;
-using ArticulationMap = std::map<pxr::SdfPath, ArticulationDesc*>;
+using BodyJointMap = pxr::TfHashMap<pxr::SdfPath, std::vector<const UsdPhysicsJointDesc*>, pxr::SdfPath::Hash>;
+using JointMap = std::map<pxr::SdfPath, UsdPhysicsJointDesc*>;
+using ArticulationMap = std::map<pxr::SdfPath, UsdPhysicsArticulationDesc*>;
 
 bool IsInLinkMap(const SdfPath& path, const std::vector<ArticulationLinkMap>& linkMaps)
 {
@@ -1902,10 +1902,10 @@ void TraverseHierarchy(const pxr::UsdStageWeakPtr stage, const SdfPath& linkPath
         link.weight = 0;
         link.index = index++;
         link.hasFixedJoint = false;
-        const std::vector<const JointDesc*>& joints = bjIt->second;
+        const std::vector<const UsdPhysicsJointDesc*>& joints = bjIt->second;
         for (size_t i = 0; i < joints.size(); i++)
         {            
-            const JointDesc* desc = joints[i];
+            const UsdPhysicsJointDesc* desc = joints[i];
             link.joints.push_back(desc->primPath);
             if (desc->body0 == SdfPath() || (bodyJointMap.find(desc->body0) == bodyJointMap.end()) ||
                 desc->body1 == SdfPath() || (bodyJointMap.find(desc->body1) == bodyJointMap.end()))
@@ -2042,7 +2042,7 @@ void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& ar
         bodyJointMap.reserve(rigidBodyMap.size());
         for (JointMap::const_reference& jointIt : jointMap)
         {
-            const JointDesc* desc = jointIt.second;
+            const UsdPhysicsJointDesc* desc = jointIt.second;
             if (desc->jointEnabled)
             {
                 if (desc->body0 != SdfPath())
@@ -2104,7 +2104,7 @@ void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& ar
                 if (jointIt != jointMap.end())
                 {
                     const SdfPath& jointPath = jointIt->first;
-                    const JointDesc* jointDesc = jointIt->second;
+                    const UsdPhysicsJointDesc* jointDesc = jointIt->second;
                     if (jointDesc->body0 == SdfPath() || jointDesc->body1 == SdfPath())
                     {                        
                         it.second->rootPrims.push_back(jointPath);
@@ -2316,7 +2316,7 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
 
         const SdfPath primPath = prim.GetPrimPath();
         const UsdPrimTypeInfo& typeInfo = prim.GetPrimTypeInfo();
-        PhysicsObjectDesc* reportDesc = nullptr;
+        UsdPhysicsObjectDesc* reportDesc = nullptr;
 
         uint64_t apiFlags = 0;
         const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
@@ -2447,7 +2447,7 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     // process parsing
     // 
     // Scenes
-    std::vector<SceneDesc> sceneDescs;
+    std::vector<UsdPhysicsSceneDesc> sceneDescs;
 
     // is simulation owners provided, restrict scenes to just the one specified
     if (simulationOwners)
@@ -2463,23 +2463,23 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
             }            
         }
     }
-    ProcessPhysicsPrims<SceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs, ParseSceneDesc);
+    ProcessPhysicsPrims<UsdPhysicsSceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs, ParseSceneDesc);
 
     // Collision Groups
-    std::vector<CollisionGroupDesc> collisionGroupsDescs;
-    ProcessPhysicsPrims<CollisionGroupDesc, UsdPhysicsCollisionGroup>(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
+    std::vector<UsdPhysicsCollisionGroupDesc> collisionGroupsDescs;
+    ProcessPhysicsPrims<UsdPhysicsCollisionGroupDesc, UsdPhysicsCollisionGroup>(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
     // Run groups merging
     std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
     for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
     {
-        const CollisionGroupDesc& desc = collisionGroupsDescs[i];
+        const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
 
         if (!desc.mergeGroupName.empty())
         {
             std::unordered_map<std::string, size_t>::const_iterator fit = mergeGroupNameToIndex.find(desc.mergeGroupName);
             if (fit != mergeGroupNameToIndex.end())
             {                
-                CollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
+                UsdPhysicsCollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
                 mergeDesc.mergedGroups.push_back(desc.primPath);
                 for (const SdfPath& sp : desc.filteredGroups)
                 {
@@ -2506,7 +2506,7 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     {
         const UsdPrim groupPrim = collisionGroupPrims[i];
         UsdStageWeakPtr stage = groupPrim.GetStage();
-        const CollisionGroupDesc& desc = collisionGroupsDescs[i];
+        const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
         std::unordered_set<SdfPath, SdfPath::Hash>& hashSet = collisionGroupSets[desc.primPath];
 
         if (desc.mergedGroups.empty())
@@ -2543,58 +2543,58 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     }
 
     // Rigid body physics material
-    std::vector<RigidBodyMaterialDesc> materialDescs;
-    ProcessPhysicsPrims<RigidBodyMaterialDesc, UsdPhysicsMaterialAPI>(materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
+    std::vector<UsdPhysicsRigidBodyMaterialDesc> materialDescs;
+    ProcessPhysicsPrims<UsdPhysicsRigidBodyMaterialDesc, UsdPhysicsMaterialAPI>(materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
 
     // Joints
-    std::vector<D6JointDesc> jointDescs;
-    ProcessPhysicsPrims<D6JointDesc, UsdPhysicsJoint>(physicsD6JointPrims, jointDescs, ParseD6JointDesc);
+    std::vector<UsdPhysicsD6JointDesc> jointDescs;
+    ProcessPhysicsPrims<UsdPhysicsD6JointDesc, UsdPhysicsJoint>(physicsD6JointPrims, jointDescs, ParseD6JointDesc);
 
-    std::vector<RevoluteJointDesc> revoluteJointDescs;
-    ProcessPhysicsPrims<RevoluteJointDesc, UsdPhysicsRevoluteJoint>(physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
+    std::vector<UsdPhysicsRevoluteJointDesc> revoluteJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsRevoluteJointDesc, UsdPhysicsRevoluteJoint>(physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
 
-    std::vector<PrismaticJointDesc> prismaticJointDescs;
-    ProcessPhysicsPrims<PrismaticJointDesc, UsdPhysicsPrismaticJoint>(physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
+    std::vector<UsdPhysicsPrismaticJointDesc> prismaticJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsPrismaticJointDesc, UsdPhysicsPrismaticJoint>(physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
 
-    std::vector<SphericalJointDesc> sphericalJointDescs;
-    ProcessPhysicsPrims<SphericalJointDesc, UsdPhysicsSphericalJoint>(physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
+    std::vector<UsdPhysicsSphericalJointDesc> sphericalJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsSphericalJointDesc, UsdPhysicsSphericalJoint>(physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
 
-    std::vector<FixedJointDesc> fixedJointDescs;
-    ProcessPhysicsPrims<FixedJointDesc, UsdPhysicsFixedJoint>(physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
+    std::vector<UsdPhysicsFixedJointDesc> fixedJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsFixedJointDesc, UsdPhysicsFixedJoint>(physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
 
-    std::vector<DistanceJointDesc> distanceJointDescs;
-    ProcessPhysicsPrims<DistanceJointDesc, UsdPhysicsDistanceJoint>(physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
+    std::vector<UsdPhysicsDistanceJointDesc> distanceJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsDistanceJointDesc, UsdPhysicsDistanceJoint>(physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
 
-    std::vector<CustomJointDesc> customJointDescs;
-    ProcessPhysicsPrims<CustomJointDesc, UsdPhysicsJoint>(physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
+    std::vector<UsdPhysicsCustomJointDesc> customJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsCustomJointDesc, UsdPhysicsJoint>(physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
 
     // A.B. contruct joint map revisit    
     JointMap jointMap;
-    for (D6JointDesc& desc : jointDescs)
+    for (UsdPhysicsD6JointDesc& desc : jointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
-    for (RevoluteJointDesc& desc : revoluteJointDescs)
+    for (UsdPhysicsRevoluteJointDesc& desc : revoluteJointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
-    for (PrismaticJointDesc& desc : prismaticJointDescs)
+    for (UsdPhysicsPrismaticJointDesc& desc : prismaticJointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
-    for (SphericalJointDesc& desc : sphericalJointDescs)
+    for (UsdPhysicsSphericalJointDesc& desc : sphericalJointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
-    for (FixedJointDesc& desc : fixedJointDescs)
+    for (UsdPhysicsFixedJointDesc& desc : fixedJointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
-    for (DistanceJointDesc& desc : distanceJointDescs)
+    for (UsdPhysicsDistanceJointDesc& desc : distanceJointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
-    for (CustomJointDesc& desc : customJointDescs)
+    for (UsdPhysicsCustomJointDesc& desc : customJointDescs)
     {
         jointMap[desc.primPath] = &desc;
     }
@@ -2602,7 +2602,7 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
 
     // collisions
     // first get the type
-    std::vector<PhysicsObjectType::Enum> collisionTypes;
+    std::vector<UsdPhysicsObjectType::Enum> collisionTypes;
     collisionTypes.resize(collisionPrims.size());
     std::vector<TfToken> customTokens;
     for (size_t i = 0; i < collisionPrims.size(); i++)
@@ -2610,9 +2610,9 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
         if (customPhysicsTokens)
         {
             TfToken shapeToken;
-            const PhysicsObjectType::Enum shapeType = GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
+            const UsdPhysicsObjectType::Enum shapeType = GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
             collisionTypes[i] = shapeType;
-            if (shapeType == PhysicsObjectType::eCustomShape)
+            if (shapeType == UsdPhysicsObjectType::eCustomShape)
             {
                 customTokens.push_back(shapeToken);
             }
@@ -2634,55 +2634,55 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     std::vector<UsdPrim> customShapePrims;
     for (size_t i = 0; i < collisionTypes.size(); i++)
     {
-        PhysicsObjectType::Enum type = collisionTypes[i];
+        UsdPhysicsObjectType::Enum type = collisionTypes[i];
         switch (type)
         {
-            case PhysicsObjectType::eSphereShape:
+            case UsdPhysicsObjectType::eSphereShape:
             {
                 sphereShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eCubeShape:
+            case UsdPhysicsObjectType::eCubeShape:
             {
                 cubeShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eCapsuleShape:
+            case UsdPhysicsObjectType::eCapsuleShape:
             {
                 capsuleShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eCylinderShape:
+            case UsdPhysicsObjectType::eCylinderShape:
             {
                 cylinderShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eConeShape:
+            case UsdPhysicsObjectType::eConeShape:
             {
                 coneShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eMeshShape:
+            case UsdPhysicsObjectType::eMeshShape:
             {
                 meshShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::ePlaneShape:
+            case UsdPhysicsObjectType::ePlaneShape:
             {
                 planeShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eCustomShape:
+            case UsdPhysicsObjectType::eCustomShape:
             {
                 customShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eSpherePointsShape:
+            case UsdPhysicsObjectType::eSpherePointsShape:
             {
                 spherePointsShapePrims.push_back(collisionPrims[i]);
             }
             break;
-            case PhysicsObjectType::eUndefined:
+            case UsdPhysicsObjectType::eUndefined:
             default:            
             {
                 TF_DIAGNOSTIC_WARNING("CollisionAPI applied to an unknown UsdGeomGPrim type, prim %s.",
@@ -2691,32 +2691,32 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
             break;
         }
     }
-    std::vector<SphereShapeDesc> sphereShapeDescs;
-    ProcessPhysicsPrims<SphereShapeDesc, UsdPhysicsCollisionAPI>(sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
+    std::vector<UsdPhysicsSphereShapeDesc> sphereShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsSphereShapeDesc, UsdPhysicsCollisionAPI>(sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
 
-    std::vector<CubeShapeDesc> cubeShapeDescs;
-    ProcessPhysicsPrims<CubeShapeDesc, UsdPhysicsCollisionAPI>(cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
+    std::vector<UsdPhysicsCubeShapeDesc> cubeShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCubeShapeDesc, UsdPhysicsCollisionAPI>(cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
 
-    std::vector<CylinderShapeDesc> cylinderShapeDescs;
-    ProcessPhysicsPrims<CylinderShapeDesc, UsdPhysicsCollisionAPI>(cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
+    std::vector<UsdPhysicsCylinderShapeDesc> cylinderShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCylinderShapeDesc, UsdPhysicsCollisionAPI>(cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
 
-    std::vector<CapsuleShapeDesc> capsuleShapeDescs;
-    ProcessPhysicsPrims<CapsuleShapeDesc, UsdPhysicsCollisionAPI>(capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
+    std::vector<UsdPhysicsCapsuleShapeDesc> capsuleShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCapsuleShapeDesc, UsdPhysicsCollisionAPI>(capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
 
-    std::vector<ConeShapeDesc> coneShapeDescs;
-    ProcessPhysicsPrims<ConeShapeDesc, UsdPhysicsCollisionAPI>(coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
+    std::vector<UsdPhysicsConeShapeDesc> coneShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsConeShapeDesc, UsdPhysicsCollisionAPI>(coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
 
-    std::vector<PlaneShapeDesc> planeShapeDescs;
-    ProcessPhysicsPrims<PlaneShapeDesc, UsdPhysicsCollisionAPI>(planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
+    std::vector<UsdPhysicsPlaneShapeDesc> planeShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsPlaneShapeDesc, UsdPhysicsCollisionAPI>(planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
 
-    std::vector<MeshShapeDesc> meshShapeDescs;
-    ProcessPhysicsPrims<MeshShapeDesc, UsdPhysicsCollisionAPI>(meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
+    std::vector<UsdPhysicsMeshShapeDesc> meshShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsMeshShapeDesc, UsdPhysicsCollisionAPI>(meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
 
-    std::vector<SpherePointsShapeDesc> spherePointsShapeDescs;
-    ProcessPhysicsPrims<SpherePointsShapeDesc, UsdPhysicsCollisionAPI>(spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
+    std::vector<UsdPhysicsSpherePointsShapeDesc> spherePointsShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsSpherePointsShapeDesc, UsdPhysicsCollisionAPI>(spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
 
-    std::vector<CustomShapeDesc> customShapeDescs;
-    ProcessPhysicsPrims<CustomShapeDesc, UsdPhysicsCollisionAPI>(customShapePrims, customShapeDescs, ParseCustomShapeDesc);
+    std::vector<UsdPhysicsCustomShapeDesc> customShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCustomShapeDesc, UsdPhysicsCollisionAPI>(customShapePrims, customShapeDescs, ParseCustomShapeDesc);
     if (customShapeDescs.size() == customTokens.size())
     {
         for (size_t i = 0; i < customShapeDescs.size(); i++)
@@ -2726,8 +2726,8 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     }
 
     // rigid bodies
-    std::vector<RigidBodyDesc> rigidBodyDescs;
-    ProcessPhysicsPrims<RigidBodyDesc, UsdPhysicsRigidBodyAPI>(rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
+    std::vector<UsdPhysicsRigidBodyDesc> rigidBodyDescs;
+    ProcessPhysicsPrims<UsdPhysicsRigidBodyDesc, UsdPhysicsRigidBodyAPI>(rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
     // Ensure if we have a hierarchical parent that has a dynamic parent,
     // that we also have a reset xform stack, otherwise we should log an error.
     // check for nested articulation roots, these are not supported
@@ -2782,8 +2782,8 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
             articulationPrims.pop_back();
         }
     }
-    std::vector<ArticulationDesc> articulationDescs;
-    ProcessPhysicsPrims<ArticulationDesc, UsdPhysicsArticulationRootAPI>(articulationPrims, articulationDescs, ParseArticulationDesc);
+    std::vector<UsdPhysicsArticulationDesc> articulationDescs;
+    ProcessPhysicsPrims<UsdPhysicsArticulationDesc, UsdPhysicsArticulationRootAPI>(articulationPrims, articulationDescs, ParseArticulationDesc);
 
     ArticulationMap articulationMap; // A.B. TODO probably not needed
     for (size_t i = articulationPrims.size(); i--;)
@@ -2795,15 +2795,15 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     {
         UsdGeomXformCache xfCache;
 
-        FinalizeCollisionDescs<SphereShapeDesc>(xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<CubeShapeDesc>(xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<CapsuleShapeDesc>(xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<CylinderShapeDesc>(xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<ConeShapeDesc>(xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<PlaneShapeDesc>(xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<MeshShapeDesc>(xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<SpherePointsShapeDesc>(xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<CustomShapeDesc>(xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsSphereShapeDesc>(xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCubeShapeDesc>(xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCapsuleShapeDesc>(xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCylinderShapeDesc>(xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsConeShapeDesc>(xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsPlaneShapeDesc>(xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsMeshShapeDesc>(xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsSpherePointsShapeDesc>(xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCustomShapeDesc>(xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
     }
 
     // Finalize articulations
@@ -2850,51 +2850,51 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     // get the descriptors, finalize them and send them out in an order
     // 1. send out the scenes
     {
-        CallReportFn(PhysicsObjectType::eScene, scenePrims, sceneDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eScene, scenePrims, sceneDescs, reportFn, primPathsVector, userData);
     }
 
     // 2. send out the CollisionGroups
     {
-        CallReportFn(PhysicsObjectType::eCollisionGroup, collisionGroupPrims, collisionGroupsDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eCollisionGroup, collisionGroupPrims, collisionGroupsDescs, reportFn, primPathsVector, userData);
     }
 
     // 3. send out the materials
     {
-        CallReportFn(PhysicsObjectType::eRigidBodyMaterial, materialPrims, materialDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eRigidBodyMaterial, materialPrims, materialDescs, reportFn, primPathsVector, userData);
     }
 
     // 4. finish out and send out shapes
     {   
-        CallReportFn(PhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eCapsuleShape, capsuleShapePrims, capsuleShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eCylinderShape, cylinderShapePrims, cylinderShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eSpherePointsShape, spherePointsShapePrims, spherePointsShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eCapsuleShape, capsuleShapePrims, capsuleShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eCylinderShape, cylinderShapePrims, cylinderShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eSpherePointsShape, spherePointsShapePrims, spherePointsShapeDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs, reportFn, primPathsVector, userData);        
     }
 
     // 5. send out articulations
     {
-        CallReportFn(PhysicsObjectType::eArticulation, articulationPrims, articulationDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eArticulation, articulationPrims, articulationDescs, reportFn, primPathsVector, userData);        
     }
 
     // 6. send out bodies
     {
-        CallReportFn(PhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs, reportFn, primPathsVector, userData);                        
+        CallReportFn(UsdPhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs, reportFn, primPathsVector, userData);                        
     }
 
     // 7. send out joints    
     {
-        CallReportFn(PhysicsObjectType::eFixedJoint, physicsFixedJointPrims, fixedJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims, revoluteJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims, prismaticJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims, sphericalJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims, distanceJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(PhysicsObjectType::eCustomJoint, physicsCustomJointPrims, customJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eFixedJoint, physicsFixedJointPrims, fixedJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims, revoluteJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims, prismaticJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims, sphericalJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims, distanceJointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs, reportFn, primPathsVector, userData);        
+        CallReportFn(UsdPhysicsObjectType::eCustomJoint, physicsCustomJointPrims, customJointDescs, reportFn, primPathsVector, userData);        
     }
 
     return retVal;
diff --git a/pxr/usd/usdPhysics/parseUtils.h b/pxr/usd/usdPhysics/parseUtils.h
index a7b1ab3137..9f3cedb26d 100644
--- a/pxr/usd/usdPhysics/parseUtils.h
+++ b/pxr/usd/usdPhysics/parseUtils.h
@@ -51,8 +51,8 @@ PXR_NAMESPACE_OPEN_SCOPE
 /// \param[in] objectDescs  Corresponding array of object descriptors of the reported type
 /// \param[in] userData User data provided to the parsing function
 using UsdPhysicsReportFn =
-    std::function<void(PhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
-        const PhysicsObjectDesc* objectDescs, void* userData)>;
+    std::function<void(UsdPhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
+        const UsdPhysicsObjectDesc* objectDescs, void* userData)>;
 
 /// \struct CustomUsdPhysicsTokens
 ///
diff --git a/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py b/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
index 70472dce99..4af98e3ca3 100644
--- a/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
+++ b/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
@@ -43,7 +43,7 @@ def test_scene_parse(self):
         scene_found = False
         
         for key, value in ret_dict.items():
-            if key == UsdPhysics.PhysicsObjectType.Scene:                
+            if key == UsdPhysics.ObjectType.Scene:                
                 scene_found = True
                 paths, scene_descs = value
                 for path, scene_desc in zip(paths, scene_descs):
@@ -125,9 +125,9 @@ def compare_shape_params(desc):
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.SphereShape:
+                elif key == UsdPhysics.ObjectType.SphereShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
@@ -136,7 +136,7 @@ def compare_shape_params(desc):
                         self.assertEqual(desc.radius, params["radius"] * scale[0])
 
                         num_shape_found = num_shape_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.CapsuleShape:
+                elif key == UsdPhysics.ObjectType.CapsuleShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
@@ -144,10 +144,10 @@ def compare_shape_params(desc):
                         # capsule shape
                         self.assertEqual(desc.radius, params["radius"] * scale[0])
                         self.assertEqual(desc.halfHeight, params["height"] * 0.5 * scale[0])
-                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Y)
+                        self.assertEqual(desc.axis, UsdPhysics.Axis.Y)
 
                         num_shape_found = num_shape_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.ConeShape:
+                elif key == UsdPhysics.ObjectType.ConeShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
@@ -155,10 +155,10 @@ def compare_shape_params(desc):
                         # cone shape
                         self.assertEqual(desc.radius, params["radius"] * scale[0])
                         self.assertEqual(desc.halfHeight, params["height"] * 0.5 * scale[0])
-                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Z)
+                        self.assertEqual(desc.axis, UsdPhysics.Axis.Z)
 
                         num_shape_found = num_shape_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.CylinderShape:
+                elif key == UsdPhysics.ObjectType.CylinderShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
@@ -166,19 +166,19 @@ def compare_shape_params(desc):
                         # cylinder shape
                         self.assertEqual(desc.radius, params["radius"] * scale[0])
                         self.assertEqual(desc.halfHeight, params["height"] * 0.5 * scale[0])
-                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Y)
+                        self.assertEqual(desc.axis, UsdPhysics.Axis.Y)
 
                         num_shape_found = num_shape_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.PlaneShape:
+                elif key == UsdPhysics.ObjectType.PlaneShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
 
                         # plane shape
-                        self.assertEqual(desc.axis, UsdPhysics.PhysicsAxis.Z)
+                        self.assertEqual(desc.axis, UsdPhysics.Axis.Z)
 
                         num_shape_found = num_shape_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.MeshShape:
+                elif key == UsdPhysics.ObjectType.MeshShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
@@ -189,7 +189,7 @@ def compare_shape_params(desc):
                         self.assertTrue(Gf.IsClose(scale, desc.meshScale, toleranceEpsilon))
 
                         num_shape_found = num_shape_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.SpherePointsShape:
+                elif key == UsdPhysics.ObjectType.SpherePointsShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common shape
                         compare_shape_params(desc)
@@ -235,10 +235,10 @@ def test_rigidbody_parse(self):
         
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 for prim_path, desc in zip(prim_paths, descs):
                     scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+            elif key == UsdPhysics.ObjectType.RigidBody:
                 for prim_path, desc in zip(prim_paths, descs):
                     rigidbody_found = True
                     self.assertTrue(prim_path == rigidbody.GetPrim().GetPrimPath())
@@ -291,10 +291,10 @@ def test_rigidbody_collision_parse(self):
         
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 for prim_path, desc in zip(prim_paths, descs):
                     scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+            elif key == UsdPhysics.ObjectType.RigidBody:
                 for prim_path, desc in zip(prim_paths, descs):
                     rigidbody_found = True
                     self.assertTrue(prim_path == rigidbody.GetPrim().GetPrimPath())
@@ -307,7 +307,7 @@ def test_rigidbody_collision_parse(self):
                     eulerAngles = r.Decompose(Gf.Vec3d.XAxis(), Gf.Vec3d.YAxis(), Gf.Vec3d.ZAxis())
                     self.assertTrue(Gf.IsClose(Gf.Vec3f(eulerAngles), rb_rotate_xyz, toleranceEpsilon))
                     self.assertTrue(Gf.IsClose(rb_scale, desc.scale, toleranceEpsilon))
-            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+            elif key == UsdPhysics.ObjectType.CubeShape:
                 for prim_path, desc in zip(prim_paths, descs):
                     cube_found = True
                     self.assertTrue(prim_path == cube.GetPrim().GetPrimPath())
@@ -355,16 +355,16 @@ def test_filtering_pairs_parse(self):
         
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 for prim_path, desc in zip(prim_paths, descs):
                     scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+            elif key == UsdPhysics.ObjectType.RigidBody:
                 for prim_path, desc in zip(prim_paths, descs):
                     rigidbody_count = rigidbody_count + 1
                     if prim_path == rigidbody_1.GetPrim().GetPrimPath():
                         self.assertTrue(len(desc.filteredCollisions) == 1)
                         self.assertTrue(desc.filteredCollisions[0] == rigidbody_0.GetPrim().GetPrimPath())
-            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+            elif key == UsdPhysics.ObjectType.CubeShape:
                 for prim_path, desc in zip(prim_paths, descs):
                     cube_count = cube_count + 1
                     if prim_path == cube_1.GetPrim().GetPrimPath():
@@ -400,15 +400,15 @@ def test_collision_material_parse(self):
         
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 for prim_path, desc in zip(prim_paths, descs):
                     scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+            elif key == UsdPhysics.ObjectType.CubeShape:
                 for prim_path, desc in zip(prim_paths, descs):
                     cube_found = True
                     self.assertTrue(len(desc.materials) == 1)
                     desc.materials[0] = materialPrim.GetPrim().GetPrimPath()
-            elif key == UsdPhysics.PhysicsObjectType.RigidBodyMaterial:
+            elif key == UsdPhysics.ObjectType.RigidBodyMaterial:
                 for prim_path, desc in zip(prim_paths, descs):
                     material_found = True
                     self.assertTrue(prim_path == materialPrim.GetPrim().GetPrimPath())
@@ -486,17 +486,17 @@ def test_collision_multi_material_parse(self):
         
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 for prim_path, desc in zip(prim_paths, descs):
                     scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.MeshShape:
+            elif key == UsdPhysics.ObjectType.MeshShape:
                 for prim_path, desc in zip(prim_paths, descs):
                     mesh_found = True
                     self.assertTrue(len(desc.materials) == 3)   # three materials, the last material is the one applied eventually to the collision itself                                        
                     self.assertTrue(desc.materials[0] == materialPrim0.GetPrim().GetPrimPath())
                     self.assertTrue(desc.materials[1] == materialPrim1.GetPrim().GetPrimPath())
                     self.assertTrue(desc.materials[2] == Sdf.Path())
-            elif key == UsdPhysics.PhysicsObjectType.RigidBodyMaterial:
+            elif key == UsdPhysics.ObjectType.RigidBodyMaterial:
                 for prim_path, desc in zip(prim_paths, descs):
                     num_materials = num_materials + 1
 
@@ -620,21 +620,21 @@ def compare_joint_params(desc):
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.FixedJoint:
+                elif key == UsdPhysics.ObjectType.FixedJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common joint
                         compare_joint_params(desc)
 
                         num_joints_found = num_joints_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.RevoluteJoint:
+                elif key == UsdPhysics.ObjectType.RevoluteJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common joint
                         compare_joint_params(desc)
 
                         # revolute joint part
-                        self.assertTrue(desc.axis == UsdPhysics.PhysicsAxis.Y)
+                        self.assertTrue(desc.axis == UsdPhysics.Axis.Y)
 
                         # limit
                         if (params["limit"]):
@@ -655,13 +655,13 @@ def compare_joint_params(desc):
                             self.assertTrue(desc.drive.enabled is False)
 
                         num_joints_found = num_joints_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.PrismaticJoint:
+                elif key == UsdPhysics.ObjectType.PrismaticJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common joint
                         compare_joint_params(desc)
 
                         # prismatic joint part
-                        self.assertTrue(desc.axis == UsdPhysics.PhysicsAxis.Z)
+                        self.assertTrue(desc.axis == UsdPhysics.Axis.Z)
 
                         # limit
                         if (params["limit"]):                        
@@ -682,7 +682,7 @@ def compare_joint_params(desc):
                             self.assertTrue(desc.drive.enabled is False)
 
                         num_joints_found = num_joints_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.D6Joint:
+                elif key == UsdPhysics.ObjectType.D6Joint:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common joint
                         compare_joint_params(desc)
@@ -693,7 +693,7 @@ def compare_joint_params(desc):
 
                         # drive for rotX
                         xDrivePair = desc.jointDrives[0]
-                        self.assertTrue(xDrivePair.first == UsdPhysics.PhysicsJointDOF.RotX)
+                        self.assertTrue(xDrivePair.first == UsdPhysics.JointDOF.RotX)
                         xDrive = xDrivePair.second
                         self.assertTrue(xDrive.enabled is True)
                         self.assertEqual(xDrive.targetPosition, 10)
@@ -705,37 +705,37 @@ def compare_joint_params(desc):
                         for d6_limit in desc.jointLimits:
                             limit_dof = d6_limit.first
                             limit = d6_limit.second
-                            if limit_dof == UsdPhysics.PhysicsJointDOF.TransX:
+                            if limit_dof == UsdPhysics.JointDOF.TransX:
                                 self.assertTrue(limit.enabled is True)
                                 self.assertEqual(limit.lower, -10)
                                 self.assertEqual(limit.upper, 10)
-                            elif limit_dof == UsdPhysics.PhysicsJointDOF.TransY:
+                            elif limit_dof == UsdPhysics.JointDOF.TransY:
                                 self.assertTrue(limit.enabled is True)
                                 self.assertEqual(limit.lower, -20)
                                 self.assertEqual(limit.upper, 20)
-                            elif limit_dof == UsdPhysics.PhysicsJointDOF.RotX:
+                            elif limit_dof == UsdPhysics.JointDOF.RotX:
                                 self.assertTrue(limit.enabled is True)
                                 self.assertEqual(limit.lower, -30)
                                 self.assertEqual(limit.upper, 30)
-                            elif limit_dof == UsdPhysics.PhysicsJointDOF.RotY:
+                            elif limit_dof == UsdPhysics.JointDOF.RotY:
                                 self.assertTrue(limit.enabled is True)
                                 self.assertEqual(limit.lower, 30)       # lower higher then upper means DOF is locked
                                 self.assertEqual(limit.upper, -30)
 
                         num_joints_found = num_joints_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.SphericalJoint:
+                elif key == UsdPhysics.ObjectType.SphericalJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common joint
                         compare_joint_params(desc)
 
                         # spherical joint part
-                        self.assertTrue(desc.axis == UsdPhysics.PhysicsAxis.Z)
+                        self.assertTrue(desc.axis == UsdPhysics.Axis.Z)
                         self.assertTrue(desc.limit.enabled is True)
                         self.assertEqual(desc.limit.lower, 20)  # lower maps to cone0 angle
                         self.assertEqual(desc.limit.upper, 30)  # upper maps to cone1 angle
 
                         num_joints_found = num_joints_found + 1
-                elif key == UsdPhysics.PhysicsObjectType.DistanceJoint:
+                elif key == UsdPhysics.ObjectType.DistanceJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         # common joint
                         compare_joint_params(desc)
@@ -805,9 +805,9 @@ def test_articulation_parse(self):
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.Articulation:
+                elif key == UsdPhysics.ObjectType.Articulation:
                     for prim_path, desc in zip(prim_paths, descs):
                         articulation_found = True
 
@@ -857,9 +857,9 @@ def test_collision_groups_parse(self):
 
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.CollisionGroup:
+            elif key == UsdPhysics.ObjectType.CollisionGroup:
                 for prim_path, desc in zip(prim_paths, descs):
                     if desc.mergeGroupName == "three":
                         self.assertTrue(prim_path == collision_groups[3].GetPrim().GetPrimPath())
@@ -909,12 +909,12 @@ def test_collision_groups_collider_parse(self):
 
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.CollisionGroup:
+            elif key == UsdPhysics.ObjectType.CollisionGroup:
                 for prim_path, desc in zip(prim_paths, descs):
                     num_reported_collision_groups = num_reported_collision_groups + 1
-            elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+            elif key == UsdPhysics.ObjectType.CubeShape:
                 for prim_path, desc in zip(prim_paths, descs):
                     self.assertTrue(len(desc.collisionGroups) == 2)
                     self.assertTrue(desc.collisionGroups[0] == collision_group_0.GetPrim().GetPrimPath())
@@ -951,9 +951,9 @@ def test_custom_geometry_parse(self):
 
         for key, value in ret_dict.items():
             prim_paths, descs = value
-            if key == UsdPhysics.PhysicsObjectType.Scene:
+            if key == UsdPhysics.ObjectType.Scene:
                 scene_found = True
-            elif key == UsdPhysics.PhysicsObjectType.CustomShape:
+            elif key == UsdPhysics.ObjectType.CustomShape:
                 for prim_path, desc in zip(prim_paths, descs):
                     custom_geometry_found = True
 
@@ -981,9 +981,9 @@ def check_ret_dict():
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                elif key == UsdPhysics.ObjectType.RigidBody:
                     for prim_path, desc in zip(prim_paths, descs):
                         rigid_body_found = True
 
@@ -1033,12 +1033,12 @@ def check_ret_dict():
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                elif key == UsdPhysics.ObjectType.RigidBody:
                     for prim_path, desc in zip(prim_paths, descs):
                         rigid_body_found = True
-                elif key == UsdPhysics.PhysicsObjectType.CubeShape:
+                elif key == UsdPhysics.ObjectType.CubeShape:
                     for prim_path, desc in zip(prim_paths, descs):
                         collision_found = True
 
@@ -1115,12 +1115,12 @@ def check_ret_dict():
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                elif key == UsdPhysics.ObjectType.RigidBody:
                     for prim_path, desc in zip(prim_paths, descs):
                         rigid_body_found = True
-                elif key == UsdPhysics.PhysicsObjectType.FixedJoint:
+                elif key == UsdPhysics.ObjectType.FixedJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         joint_found = True
 
@@ -1226,15 +1226,15 @@ def check_ret_dict():
 
             for key, value in ret_dict.items():
                 prim_paths, descs = value
-                if key == UsdPhysics.PhysicsObjectType.Scene:
+                if key == UsdPhysics.ObjectType.Scene:
                     scene_found = True
-                elif key == UsdPhysics.PhysicsObjectType.RigidBody:
+                elif key == UsdPhysics.ObjectType.RigidBody:
                     for prim_path, desc in zip(prim_paths, descs):
                         rigid_body_found = True
-                elif key == UsdPhysics.PhysicsObjectType.RevoluteJoint:
+                elif key == UsdPhysics.ObjectType.RevoluteJoint:
                     for prim_path, desc in zip(prim_paths, descs):
                         joint_found = True
-                elif key == UsdPhysics.PhysicsObjectType.Articulation:
+                elif key == UsdPhysics.ObjectType.Articulation:
                     for prim_path, desc in zip(prim_paths, descs):
                         articulation_found = True
 
diff --git a/pxr/usd/usdPhysics/wrapParseUtils.cpp b/pxr/usd/usdPhysics/wrapParseUtils.cpp
index 441a25f7d7..2bda6b875d 100644
--- a/pxr/usd/usdPhysics/wrapParseUtils.cpp
+++ b/pxr/usd/usdPhysics/wrapParseUtils.cpp
@@ -87,67 +87,67 @@ class MarshalCallback
 public:    
 
     SdfPathVector                   scenePrimPaths;
-    std::vector<SceneDesc>          sceneDescs;
+    std::vector<UsdPhysicsSceneDesc>          sceneDescs;
 
     SdfPathVector                   rigidBodyPrimPaths;
-    std::vector<RigidBodyDesc>      rigidBodyDescs;
+    std::vector<UsdPhysicsRigidBodyDesc>      rigidBodyDescs;
 
     SdfPathVector                   sphereShapePrimPaths;
-    std::vector<SphereShapeDesc>    sphereShapeDescs;
+    std::vector<UsdPhysicsSphereShapeDesc>    sphereShapeDescs;
 
     SdfPathVector                   cubeShapePrimPaths;
-    std::vector<CubeShapeDesc>    cubeShapeDescs;
+    std::vector<UsdPhysicsCubeShapeDesc>    cubeShapeDescs;
 
     SdfPathVector                   capsuleShapePrimPaths;
-    std::vector<CapsuleShapeDesc>    capsuleShapeDescs;
+    std::vector<UsdPhysicsCapsuleShapeDesc>    capsuleShapeDescs;
 
     SdfPathVector                   cylinderShapePrimPaths;
-    std::vector<CylinderShapeDesc>    cylinderShapeDescs;
+    std::vector<UsdPhysicsCylinderShapeDesc>    cylinderShapeDescs;
 
     SdfPathVector            coneShapePrimPaths;
-    std::vector<ConeShapeDesc>    coneShapeDescs;
+    std::vector<UsdPhysicsConeShapeDesc>    coneShapeDescs;
 
     SdfPathVector            meshShapePrimPaths;
-    std::vector<MeshShapeDesc>    meshShapeDescs;
+    std::vector<UsdPhysicsMeshShapeDesc>    meshShapeDescs;
 
     SdfPathVector            planeShapePrimPaths;
-    std::vector<PlaneShapeDesc>    planeShapeDescs;
+    std::vector<UsdPhysicsPlaneShapeDesc>    planeShapeDescs;
 
     SdfPathVector            customShapePrimPaths;
-    std::vector<CustomShapeDesc>    customShapeDescs;
+    std::vector<UsdPhysicsCustomShapeDesc>    customShapeDescs;
 
     SdfPathVector            spherePointShapePrimPaths;
-    std::vector<SpherePointsShapeDesc>    spherePointsShapeDescs;
+    std::vector<UsdPhysicsSpherePointsShapeDesc>    spherePointsShapeDescs;
 
     SdfPathVector            fixedJointPrimPaths;
-    std::vector<FixedJointDesc>    fixedJointDescs;
+    std::vector<UsdPhysicsFixedJointDesc>    fixedJointDescs;
 
     SdfPathVector            revoluteJointPrimPaths;
-    std::vector<RevoluteJointDesc>    revoluteJointDescs;
+    std::vector<UsdPhysicsRevoluteJointDesc>    revoluteJointDescs;
 
     SdfPathVector            prismaticJointPrimPaths;
-    std::vector<PrismaticJointDesc>    prismaticJointDescs;
+    std::vector<UsdPhysicsPrismaticJointDesc>    prismaticJointDescs;
 
     SdfPathVector            sphericalJointPrimPaths;
-    std::vector<SphericalJointDesc>    sphericalJointDescs;
+    std::vector<UsdPhysicsSphericalJointDesc>    sphericalJointDescs;
 
     SdfPathVector            distanceJointPrimPaths;
-    std::vector<DistanceJointDesc>    distanceJointDescs;
+    std::vector<UsdPhysicsDistanceJointDesc>    distanceJointDescs;
 
     SdfPathVector            d6JointPrimPaths;
-    std::vector<D6JointDesc>    d6JointDescs;
+    std::vector<UsdPhysicsD6JointDesc>    d6JointDescs;
 
     SdfPathVector            customJointPrimPaths;
-    std::vector<CustomJointDesc>    customJointDescs;
+    std::vector<UsdPhysicsCustomJointDesc>    customJointDescs;
 
     SdfPathVector            rigidBodyMaterialPrimPaths;
-    std::vector<RigidBodyMaterialDesc>    rigidBodyMaterialDescs;
+    std::vector<UsdPhysicsRigidBodyMaterialDesc>    rigidBodyMaterialDescs;
 
     SdfPathVector            articulationPrimPaths;
-    std::vector<ArticulationDesc>    articulationDescs;
+    std::vector<UsdPhysicsArticulationDesc>    articulationDescs;
 
     SdfPathVector            collisionGroupPrimPaths;
-    std::vector<CollisionGroupDesc>    collisionGroupDescs;
+    std::vector<UsdPhysicsCollisionGroupDesc>    collisionGroupDescs;
 
     void clear()
     {
@@ -218,7 +218,7 @@ class MarshalCallback
 } gMarshalCallback;
 
 template <typename DescType>
-void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsDest, const PhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
+void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsDest, const UsdPhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
 {
     primsDest.resize(numDesc);
     objectDescsDest.resize(numDesc);
@@ -235,114 +235,114 @@ void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsD
     }
 }
 
-void ReportPhysicsObjectsFn(PhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
-    const PhysicsObjectDesc* objectDescs, void* userData)
+void ReportPhysicsObjectsFn(UsdPhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
+    const UsdPhysicsObjectDesc* objectDescs, void* userData)
 {
     MarshalCallback* cb = (MarshalCallback*)userData;
         
     switch (type)
     {
-        case PhysicsObjectType::eScene:
+        case UsdPhysicsObjectType::eScene:
         {       
             copyDescs(numDesc, primPaths, cb->scenePrimPaths, objectDescs, cb->sceneDescs);
         }        
         break;
-        case PhysicsObjectType::eRigidBody:
+        case UsdPhysicsObjectType::eRigidBody:
         {       
             copyDescs(numDesc, primPaths, cb->rigidBodyPrimPaths, objectDescs, cb->rigidBodyDescs);
         }        
         break;        
-        case PhysicsObjectType::eSphereShape:
+        case UsdPhysicsObjectType::eSphereShape:
         {       
             copyDescs(numDesc, primPaths, cb->sphereShapePrimPaths, objectDescs, cb->sphereShapeDescs);
         }  
         break;      
-        case PhysicsObjectType::eCubeShape:
+        case UsdPhysicsObjectType::eCubeShape:
         {       
             copyDescs(numDesc, primPaths, cb->cubeShapePrimPaths, objectDescs, cb->cubeShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eCapsuleShape:
+        case UsdPhysicsObjectType::eCapsuleShape:
         {       
             copyDescs(numDesc, primPaths, cb->capsuleShapePrimPaths, objectDescs, cb->capsuleShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eCylinderShape:
+        case UsdPhysicsObjectType::eCylinderShape:
         {       
             copyDescs(numDesc, primPaths, cb->cylinderShapePrimPaths, objectDescs, cb->cylinderShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eConeShape:
+        case UsdPhysicsObjectType::eConeShape:
         {       
             copyDescs(numDesc, primPaths, cb->coneShapePrimPaths, objectDescs, cb->coneShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eMeshShape:
+        case UsdPhysicsObjectType::eMeshShape:
         {       
             copyDescs(numDesc, primPaths, cb->meshShapePrimPaths, objectDescs, cb->meshShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::ePlaneShape:
+        case UsdPhysicsObjectType::ePlaneShape:
         {       
             copyDescs(numDesc, primPaths, cb->planeShapePrimPaths, objectDescs, cb->planeShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eCustomShape:
+        case UsdPhysicsObjectType::eCustomShape:
         {       
             copyDescs(numDesc, primPaths, cb->customShapePrimPaths, objectDescs, cb->customShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eSpherePointsShape:
+        case UsdPhysicsObjectType::eSpherePointsShape:
         {       
             copyDescs(numDesc, primPaths, cb->spherePointShapePrimPaths, objectDescs, cb->spherePointsShapeDescs);
         }        
         break;        
-        case PhysicsObjectType::eFixedJoint:
+        case UsdPhysicsObjectType::eFixedJoint:
         {       
             copyDescs(numDesc, primPaths, cb->fixedJointPrimPaths, objectDescs, cb->fixedJointDescs);
         }        
         break;
-        case PhysicsObjectType::eRevoluteJoint:
+        case UsdPhysicsObjectType::eRevoluteJoint:
         {       
             copyDescs(numDesc, primPaths, cb->revoluteJointPrimPaths, objectDescs, cb->revoluteJointDescs);
         }     
         break;   
-        case PhysicsObjectType::ePrismaticJoint:
+        case UsdPhysicsObjectType::ePrismaticJoint:
         {       
             copyDescs(numDesc, primPaths, cb->prismaticJointPrimPaths, objectDescs, cb->prismaticJointDescs);
         }     
         break;   
-        case PhysicsObjectType::eSphericalJoint:
+        case UsdPhysicsObjectType::eSphericalJoint:
         {       
             copyDescs(numDesc, primPaths, cb->sphericalJointPrimPaths, objectDescs, cb->sphericalJointDescs);
         }     
         break;   
-        case PhysicsObjectType::eDistanceJoint:
+        case UsdPhysicsObjectType::eDistanceJoint:
         {       
             copyDescs(numDesc, primPaths, cb->distanceJointPrimPaths, objectDescs, cb->distanceJointDescs);
         }     
         break;   
-        case PhysicsObjectType::eD6Joint:
+        case UsdPhysicsObjectType::eD6Joint:
         {       
             copyDescs(numDesc, primPaths, cb->d6JointPrimPaths, objectDescs, cb->d6JointDescs);
         }     
         break;   
-        case PhysicsObjectType::eCustomJoint:
+        case UsdPhysicsObjectType::eCustomJoint:
         {       
             copyDescs(numDesc, primPaths, cb->customJointPrimPaths, objectDescs, cb->customJointDescs);
         }     
         break;   
-        case PhysicsObjectType::eRigidBodyMaterial:
+        case UsdPhysicsObjectType::eRigidBodyMaterial:
         {       
             copyDescs(numDesc, primPaths, cb->rigidBodyMaterialPrimPaths, objectDescs, cb->rigidBodyMaterialDescs);
         }     
         break;   
-        case PhysicsObjectType::eArticulation:
+        case UsdPhysicsObjectType::eArticulation:
         {       
             copyDescs(numDesc, primPaths, cb->articulationPrimPaths, objectDescs, cb->articulationDescs);
         }     
         break;   
-        case PhysicsObjectType::eCollisionGroup:
+        case UsdPhysicsObjectType::eCollisionGroup:
         {       
             copyDescs(numDesc, primPaths, cb->collisionGroupPrimPaths, objectDescs, cb->collisionGroupDescs);
         }     
@@ -409,87 +409,87 @@ pxr_boost::python::dict _LoadUsdPhysicsFromRange(UsdStageWeakPtr stage, ParsePri
     {
         if (!gMarshalCallback.sceneDescs.empty())
         {
-            retDict[PhysicsObjectType::eScene] = pxr_boost::python::make_tuple(gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
+            retDict[UsdPhysicsObjectType::eScene] = pxr_boost::python::make_tuple(gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
         }
         if (!gMarshalCallback.rigidBodyDescs.empty())
         {
-            retDict[PhysicsObjectType::eRigidBody] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
+            retDict[UsdPhysicsObjectType::eRigidBody] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
         }
         if (!gMarshalCallback.sphereShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eSphereShape] = pxr_boost::python::make_tuple(gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
+            retDict[UsdPhysicsObjectType::eSphereShape] = pxr_boost::python::make_tuple(gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
         }
         if (!gMarshalCallback.cubeShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eCubeShape] = pxr_boost::python::make_tuple(gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
+            retDict[UsdPhysicsObjectType::eCubeShape] = pxr_boost::python::make_tuple(gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
         }
         if (!gMarshalCallback.capsuleShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eCapsuleShape] = pxr_boost::python::make_tuple(gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
+            retDict[UsdPhysicsObjectType::eCapsuleShape] = pxr_boost::python::make_tuple(gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
         }
         if (!gMarshalCallback.cylinderShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eCylinderShape] = pxr_boost::python::make_tuple(gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
+            retDict[UsdPhysicsObjectType::eCylinderShape] = pxr_boost::python::make_tuple(gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
         }
         if (!gMarshalCallback.coneShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eConeShape] = pxr_boost::python::make_tuple(gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
+            retDict[UsdPhysicsObjectType::eConeShape] = pxr_boost::python::make_tuple(gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
         }
         if (!gMarshalCallback.meshShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eMeshShape] = pxr_boost::python::make_tuple(gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
+            retDict[UsdPhysicsObjectType::eMeshShape] = pxr_boost::python::make_tuple(gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
         }
         if (!gMarshalCallback.planeShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::ePlaneShape] = pxr_boost::python::make_tuple(gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
+            retDict[UsdPhysicsObjectType::ePlaneShape] = pxr_boost::python::make_tuple(gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
         }
         if (!gMarshalCallback.customShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eCustomShape] = pxr_boost::python::make_tuple(gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
+            retDict[UsdPhysicsObjectType::eCustomShape] = pxr_boost::python::make_tuple(gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
         }
         if (!gMarshalCallback.spherePointsShapeDescs.empty())
         {
-            retDict[PhysicsObjectType::eSpherePointsShape] = pxr_boost::python::make_tuple(gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
+            retDict[UsdPhysicsObjectType::eSpherePointsShape] = pxr_boost::python::make_tuple(gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
         }
         if (!gMarshalCallback.fixedJointDescs.empty())
         {
-            retDict[PhysicsObjectType::eFixedJoint] = pxr_boost::python::make_tuple(gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
+            retDict[UsdPhysicsObjectType::eFixedJoint] = pxr_boost::python::make_tuple(gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
         }
         if (!gMarshalCallback.revoluteJointDescs.empty())
         {
-            retDict[PhysicsObjectType::eRevoluteJoint] = pxr_boost::python::make_tuple(gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
+            retDict[UsdPhysicsObjectType::eRevoluteJoint] = pxr_boost::python::make_tuple(gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
         }
         if (!gMarshalCallback.prismaticJointDescs.empty())
         {
-            retDict[PhysicsObjectType::ePrismaticJoint] = pxr_boost::python::make_tuple(gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
+            retDict[UsdPhysicsObjectType::ePrismaticJoint] = pxr_boost::python::make_tuple(gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
         }
         if (!gMarshalCallback.sphericalJointDescs.empty())
         {
-            retDict[PhysicsObjectType::eSphericalJoint] = pxr_boost::python::make_tuple(gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
+            retDict[UsdPhysicsObjectType::eSphericalJoint] = pxr_boost::python::make_tuple(gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
         }
         if (!gMarshalCallback.distanceJointDescs.empty())
         {
-            retDict[PhysicsObjectType::eDistanceJoint] = pxr_boost::python::make_tuple(gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
+            retDict[UsdPhysicsObjectType::eDistanceJoint] = pxr_boost::python::make_tuple(gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
         }
         if (!gMarshalCallback.d6JointDescs.empty())
         {
-            retDict[PhysicsObjectType::eD6Joint] = pxr_boost::python::make_tuple(gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
+            retDict[UsdPhysicsObjectType::eD6Joint] = pxr_boost::python::make_tuple(gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
         }
         if (!gMarshalCallback.customJointDescs.empty())
         {
-            retDict[PhysicsObjectType::eCustomJoint] = pxr_boost::python::make_tuple(gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
+            retDict[UsdPhysicsObjectType::eCustomJoint] = pxr_boost::python::make_tuple(gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
         }
         if (!gMarshalCallback.rigidBodyMaterialDescs.empty())
         {
-            retDict[PhysicsObjectType::eRigidBodyMaterial] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
+            retDict[UsdPhysicsObjectType::eRigidBodyMaterial] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
         }
         if (!gMarshalCallback.articulationDescs.empty())
         {
-            retDict[PhysicsObjectType::eArticulation] = pxr_boost::python::make_tuple(gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
+            retDict[UsdPhysicsObjectType::eArticulation] = pxr_boost::python::make_tuple(gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
         }
         if (!gMarshalCallback.collisionGroupDescs.empty())
         {
-            retDict[PhysicsObjectType::eCollisionGroup] = pxr_boost::python::make_tuple(gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
+            retDict[UsdPhysicsObjectType::eCollisionGroup] = pxr_boost::python::make_tuple(gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
         }
     }    
     return retDict;
@@ -506,7 +506,7 @@ _CustomUsdPhysicsTokens_Repr(const CustomUsdPhysicsTokens& self)
 }
 
 static std::string
-_PhysicsObjectDesc_Repr(const PhysicsObjectDesc& self)
+_PhysicsObjectDesc_Repr(const UsdPhysicsObjectDesc& self)
 {
     return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
         TF_PY_REPR_PREFIX,
@@ -516,7 +516,7 @@ _PhysicsObjectDesc_Repr(const PhysicsObjectDesc& self)
 }
 
 static std::string
-_SceneDesc_Repr(const SceneDesc& self)
+_SceneDesc_Repr(const UsdPhysicsSceneDesc& self)
 {
     return TfStringPrintf("%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -526,7 +526,7 @@ _SceneDesc_Repr(const SceneDesc& self)
 }
 
 static std::string
-_CollisionGroupDesc_Repr(const CollisionGroupDesc& self)
+_CollisionGroupDesc_Repr(const UsdPhysicsCollisionGroupDesc& self)
 {
     return TfStringPrintf("%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -538,7 +538,7 @@ _CollisionGroupDesc_Repr(const CollisionGroupDesc& self)
 }
 
 static std::string
-_RigidBodyMaterialDesc_Repr(const RigidBodyMaterialDesc& self)
+_RigidBodyMaterialDesc_Repr(const UsdPhysicsRigidBodyMaterialDesc& self)
 {
     return TfStringPrintf("%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -550,7 +550,7 @@ _RigidBodyMaterialDesc_Repr(const RigidBodyMaterialDesc& self)
 }
 
 static std::string
-_ShapeDesc_Repr(const ShapeDesc& self)
+_ShapeDesc_Repr(const UsdPhysicsShapeDesc& self)
 {
     return TfStringPrintf("%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -567,7 +567,7 @@ _ShapeDesc_Repr(const ShapeDesc& self)
 }
 
 static std::string
-_SphereShapeDesc_Repr(const SphereShapeDesc& self)
+_SphereShapeDesc_Repr(const UsdPhysicsSphereShapeDesc& self)
 {
     return TfStringPrintf("%sSphereShapeDesc(radius=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -576,7 +576,7 @@ _SphereShapeDesc_Repr(const SphereShapeDesc& self)
 }
 
 static std::string
-_CapsuleShapeDesc_Repr(const CapsuleShapeDesc& self)
+_CapsuleShapeDesc_Repr(const UsdPhysicsCapsuleShapeDesc& self)
 {
     return TfStringPrintf("%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -587,7 +587,7 @@ _CapsuleShapeDesc_Repr(const CapsuleShapeDesc& self)
 }
 
 static std::string
-_CylinderShapeDesc_Repr(const CylinderShapeDesc& self)
+_CylinderShapeDesc_Repr(const UsdPhysicsCylinderShapeDesc& self)
 {
     return TfStringPrintf("%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -598,7 +598,7 @@ _CylinderShapeDesc_Repr(const CylinderShapeDesc& self)
 }
 
 static std::string
-_ConeShapeDesc_Repr(const ConeShapeDesc& self)
+_ConeShapeDesc_Repr(const UsdPhysicsConeShapeDesc& self)
 {
     return TfStringPrintf("%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -609,7 +609,7 @@ _ConeShapeDesc_Repr(const ConeShapeDesc& self)
 }
 
 static std::string
-_PlaneShapeDesc_Repr(const PlaneShapeDesc& self)
+_PlaneShapeDesc_Repr(const UsdPhysicsPlaneShapeDesc& self)
 {
     return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -618,7 +618,7 @@ _PlaneShapeDesc_Repr(const PlaneShapeDesc& self)
 }
 
 static std::string
-_CustomShapeDesc_Repr(const CustomShapeDesc& self)
+_CustomShapeDesc_Repr(const UsdPhysicsCustomShapeDesc& self)
 {
     return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -627,7 +627,7 @@ _CustomShapeDesc_Repr(const CustomShapeDesc& self)
 }
 
 static std::string
-_CubeShapeDesc_Repr(const CubeShapeDesc& self)
+_CubeShapeDesc_Repr(const UsdPhysicsCubeShapeDesc& self)
 {
     return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -636,7 +636,7 @@ _CubeShapeDesc_Repr(const CubeShapeDesc& self)
 }
 
 static std::string
-_MeshShapeDesc_Repr(const MeshShapeDesc& self)
+_MeshShapeDesc_Repr(const UsdPhysicsMeshShapeDesc& self)
 {
     return TfStringPrintf("%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -647,7 +647,7 @@ _MeshShapeDesc_Repr(const MeshShapeDesc& self)
 }
 
 static std::string
-_SpherePoint_Repr(const SpherePoint& self)
+_SpherePoint_Repr(const UsdPhysicsSpherePoint& self)
 {
     return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
         TF_PY_REPR_PREFIX,
@@ -656,7 +656,7 @@ _SpherePoint_Repr(const SpherePoint& self)
 }
 
 static std::string
-_SpherePointsShapeDesc_Repr(const SpherePointsShapeDesc& self)
+_SpherePointsShapeDesc_Repr(const UsdPhysicsSpherePointsShapeDesc& self)
 {
     return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -665,7 +665,7 @@ _SpherePointsShapeDesc_Repr(const SpherePointsShapeDesc& self)
 }
 
 static std::string
-_RigidBodyDesc_Repr(const RigidBodyDesc& self)
+_RigidBodyDesc_Repr(const UsdPhysicsRigidBodyDesc& self)
 {
     return TfStringPrintf("%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, simulationOwners=%s, position=%s, rotation=%s, scale=%s, rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, linearVelocity=%s, angularVelocity=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -684,7 +684,7 @@ _RigidBodyDesc_Repr(const RigidBodyDesc& self)
 }
 
 static std::string
-_JointLimit_Repr(const JointLimit& self)
+_JointLimit_Repr(const UsdPhysicsJointLimit& self)
 {
     return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
         TF_PY_REPR_PREFIX,
@@ -694,7 +694,7 @@ _JointLimit_Repr(const JointLimit& self)
 }
 
 static std::string
-_JointDrive_Repr(const JointDrive& self)
+_JointDrive_Repr(const UsdPhysicsJointDrive& self)
 {
     return TfStringPrintf("%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
         TF_PY_REPR_PREFIX,
@@ -708,7 +708,7 @@ _JointDrive_Repr(const JointDrive& self)
 }
 
 static std::string
-_ArticulationDesc_Repr(const ArticulationDesc& self)
+_ArticulationDesc_Repr(const UsdPhysicsArticulationDesc& self)
 {
     return TfStringPrintf("%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, articulatedJoints=%s, articulatedBodies=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -720,7 +720,7 @@ _ArticulationDesc_Repr(const ArticulationDesc& self)
 }
 
 static std::string
-_JointDesc_Repr(const JointDesc& self)
+_JointDesc_Repr(const UsdPhysicsJointDesc& self)
 {
     return TfStringPrintf("%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, localPose0Position=%s, localPose0Orientation=%s, localPose1Position=%s, localPose1Orientation=%s, jointEnabled=%s, breakForce=%s, breakTorque=%s, excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -741,7 +741,7 @@ _JointDesc_Repr(const JointDesc& self)
 }
 
 static std::string
-_JointLimitDOFPair_Repr(const std::pair<PhysicsJointDOF::Enum, JointLimit>& self)
+_JointLimitDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>& self)
 {
     return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
         TF_PY_REPR_PREFIX,
@@ -750,7 +750,7 @@ _JointLimitDOFPair_Repr(const std::pair<PhysicsJointDOF::Enum, JointLimit>& self
 }
 
 static std::string
-_JointDriveDOFPair_Repr(const std::pair<PhysicsJointDOF::Enum, JointDrive>& self)
+_JointDriveDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>& self)
 {
     return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
         TF_PY_REPR_PREFIX,
@@ -759,7 +759,7 @@ _JointDriveDOFPair_Repr(const std::pair<PhysicsJointDOF::Enum, JointDrive>& self
 }
 
 static std::string
-_D6JointDesc_Repr(const D6JointDesc& self)
+_D6JointDesc_Repr(const UsdPhysicsD6JointDesc& self)
 {
     return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -769,7 +769,7 @@ _D6JointDesc_Repr(const D6JointDesc& self)
 }
 
 static std::string
-_PrismaticJointDesc_Repr(const PrismaticJointDesc& self)
+_PrismaticJointDesc_Repr(const UsdPhysicsPrismaticJointDesc& self)
 {
     return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -780,7 +780,7 @@ _PrismaticJointDesc_Repr(const PrismaticJointDesc& self)
 }
 
 static std::string
-_SphericalJointDesc_Repr(const SphericalJointDesc& self)
+_SphericalJointDesc_Repr(const UsdPhysicsSphericalJointDesc& self)
 {
     return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -790,7 +790,7 @@ _SphericalJointDesc_Repr(const SphericalJointDesc& self)
 }
 
 static std::string
-_RevoluteJointDesc_Repr(const RevoluteJointDesc& self)
+_RevoluteJointDesc_Repr(const UsdPhysicsRevoluteJointDesc& self)
 {
     return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -801,7 +801,7 @@ _RevoluteJointDesc_Repr(const RevoluteJointDesc& self)
 }
 
 static std::string
-_DistanceJointDesc_Repr(const DistanceJointDesc& self)
+_DistanceJointDesc_Repr(const UsdPhysicsDistanceJointDesc& self)
 {
     return TfStringPrintf("%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
         TF_PY_REPR_PREFIX,
@@ -813,45 +813,45 @@ _DistanceJointDesc_Repr(const DistanceJointDesc& self)
 
 void wrapParseUtils()
 {
-    pxr_boost::python::enum_<PhysicsObjectType::Enum>("PhysicsObjectType")
-    .value("Undefined", PhysicsObjectType::eUndefined)
-    .value("Scene", PhysicsObjectType::eScene)
-    .value("RigidBody", PhysicsObjectType::eRigidBody)
-    .value("SphereShape", PhysicsObjectType::eSphereShape)
-    .value("CubeShape", PhysicsObjectType::eCubeShape)
-    .value("CapsuleShape", PhysicsObjectType::eCapsuleShape)
-    .value("CylinderShape", PhysicsObjectType::eCylinderShape)
-    .value("ConeShape", PhysicsObjectType::eConeShape)
-    .value("MeshShape", PhysicsObjectType::eMeshShape)
-    .value("PlaneShape", PhysicsObjectType::ePlaneShape)
-    .value("CustomShape", PhysicsObjectType::eCustomShape)
-    .value("SpherePointsShape", PhysicsObjectType::eSpherePointsShape)
-    .value("FixedJoint", PhysicsObjectType::eFixedJoint)
-    .value("RevoluteJoint", PhysicsObjectType::eRevoluteJoint)
-    .value("PrismaticJoint", PhysicsObjectType::ePrismaticJoint)
-    .value("SphericalJoint", PhysicsObjectType::eSphericalJoint)
-    .value("DistanceJoint", PhysicsObjectType::eDistanceJoint)
-    .value("D6Joint", PhysicsObjectType::eD6Joint)
-    .value("CustomJoint", PhysicsObjectType::eCustomJoint)
-    .value("RigidBodyMaterial", PhysicsObjectType::eRigidBodyMaterial)
-    .value("Articulation", PhysicsObjectType::eArticulation)
-    .value("CollisionGroup", PhysicsObjectType::eCollisionGroup)
+    pxr_boost::python::enum_<UsdPhysicsObjectType::Enum>("ObjectType")
+    .value("Undefined", UsdPhysicsObjectType::eUndefined)
+    .value("Scene", UsdPhysicsObjectType::eScene)
+    .value("RigidBody", UsdPhysicsObjectType::eRigidBody)
+    .value("SphereShape", UsdPhysicsObjectType::eSphereShape)
+    .value("CubeShape", UsdPhysicsObjectType::eCubeShape)
+    .value("CapsuleShape", UsdPhysicsObjectType::eCapsuleShape)
+    .value("CylinderShape", UsdPhysicsObjectType::eCylinderShape)
+    .value("ConeShape", UsdPhysicsObjectType::eConeShape)
+    .value("MeshShape", UsdPhysicsObjectType::eMeshShape)
+    .value("PlaneShape", UsdPhysicsObjectType::ePlaneShape)
+    .value("CustomShape", UsdPhysicsObjectType::eCustomShape)
+    .value("SpherePointsShape", UsdPhysicsObjectType::eSpherePointsShape)
+    .value("FixedJoint", UsdPhysicsObjectType::eFixedJoint)
+    .value("RevoluteJoint", UsdPhysicsObjectType::eRevoluteJoint)
+    .value("PrismaticJoint", UsdPhysicsObjectType::ePrismaticJoint)
+    .value("SphericalJoint", UsdPhysicsObjectType::eSphericalJoint)
+    .value("DistanceJoint", UsdPhysicsObjectType::eDistanceJoint)
+    .value("D6Joint", UsdPhysicsObjectType::eD6Joint)
+    .value("CustomJoint", UsdPhysicsObjectType::eCustomJoint)
+    .value("RigidBodyMaterial", UsdPhysicsObjectType::eRigidBodyMaterial)
+    .value("Articulation", UsdPhysicsObjectType::eArticulation)
+    .value("CollisionGroup", UsdPhysicsObjectType::eCollisionGroup)
     ;
 
-    pxr_boost::python::enum_<PhysicsAxis::Enum>("PhysicsAxis")
-    .value("X", PhysicsAxis::eX)
-    .value("Y", PhysicsAxis::eY)
-    .value("Z", PhysicsAxis::eZ)
+    pxr_boost::python::enum_<UsdPhysicsAxis::Enum>("Axis")
+    .value("X", UsdPhysicsAxis::eX)
+    .value("Y", UsdPhysicsAxis::eY)
+    .value("Z", UsdPhysicsAxis::eZ)
     ;
 
-    pxr_boost::python::enum_<PhysicsJointDOF::Enum>("PhysicsJointDOF")
-    .value("Distance", PhysicsJointDOF::eDistance)
-    .value("TransX", PhysicsJointDOF::eTransX)
-    .value("TransY", PhysicsJointDOF::eTransY)
-    .value("TransZ", PhysicsJointDOF::eTransZ)
-    .value("RotX", PhysicsJointDOF::eRotX)
-    .value("RotY", PhysicsJointDOF::eRotY)
-    .value("RotZ", PhysicsJointDOF::eRotZ)
+    pxr_boost::python::enum_<UsdPhysicsJointDOF::Enum>("JointDOF")
+    .value("Distance", UsdPhysicsJointDOF::eDistance)
+    .value("TransX", UsdPhysicsJointDOF::eTransX)
+    .value("TransY", UsdPhysicsJointDOF::eTransY)
+    .value("TransZ", UsdPhysicsJointDOF::eTransZ)
+    .value("RotX", UsdPhysicsJointDOF::eRotX)
+    .value("RotY", UsdPhysicsJointDOF::eRotY)
+    .value("RotZ", UsdPhysicsJointDOF::eRotZ)
     ;
     
     pxr_boost::python::class_<_CustomUsdPhysicsTokens>
@@ -862,303 +862,303 @@ void wrapParseUtils()
         .def_readwrite("instancerTokens", &_CustomUsdPhysicsTokens::instancerTokens)
         .def("__repr__", _CustomUsdPhysicsTokens_Repr);
 
-    pxr_boost::python::class_<PhysicsObjectDesc>
-        podcls("PhysicsObjectDesc", pxr_boost::python::no_init);
+    pxr_boost::python::class_<UsdPhysicsObjectDesc>
+        podcls("ObjectDesc", pxr_boost::python::no_init);
     podcls
-        .def_readonly("type", &PhysicsObjectDesc::type)
-        .def_readonly("primPath", &PhysicsObjectDesc::primPath)
-        .def_readonly("isValid", &PhysicsObjectDesc::isValid)
+        .def_readonly("type", &UsdPhysicsObjectDesc::type)
+        .def_readonly("primPath", &UsdPhysicsObjectDesc::primPath)
+        .def_readonly("isValid", &UsdPhysicsObjectDesc::isValid)
         .def("__repr__", _PhysicsObjectDesc_Repr);
 
-    pxr_boost::python::class_<SceneDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsSceneDesc, bases<UsdPhysicsObjectDesc>>
         sdcls("SceneDesc", pxr_boost::python::no_init);
     sdcls
-        .def_readonly("gravityDirection", &SceneDesc::gravityDirection)        
-        .def_readonly("gravityMagnitude", &SceneDesc::gravityMagnitude)
+        .def_readonly("gravityDirection", &UsdPhysicsSceneDesc::gravityDirection)        
+        .def_readonly("gravityMagnitude", &UsdPhysicsSceneDesc::gravityMagnitude)
         .def("__repr__", _SceneDesc_Repr);
 
-    pxr_boost::python::class_<CollisionGroupDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsCollisionGroupDesc, bases<UsdPhysicsObjectDesc>>
         cgcls("CollisionGroupDesc", pxr_boost::python::no_init);
     cgcls
-        .def_readonly("invertFilteredGroups", &CollisionGroupDesc::invertFilteredGroups)
-        .add_property("mergedGroups", make_function(&CollisionGroupDesc::getMergedGroups,
+        .def_readonly("invertFilteredGroups", &UsdPhysicsCollisionGroupDesc::invertFilteredGroups)
+        .add_property("mergedGroups", make_function(&UsdPhysicsCollisionGroupDesc::getMergedGroups,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredGroups", make_function(&CollisionGroupDesc::getFilteredGroups,
+        .add_property("filteredGroups", make_function(&UsdPhysicsCollisionGroupDesc::getFilteredGroups,
             return_value_policy<TfPySequenceToList>()))
-        .def_readonly("mergeGroupName", &CollisionGroupDesc::mergeGroupName)
+        .def_readonly("mergeGroupName", &UsdPhysicsCollisionGroupDesc::mergeGroupName)
         .def("__repr__", _CollisionGroupDesc_Repr);
 
-    pxr_boost::python::class_<RigidBodyMaterialDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsRigidBodyMaterialDesc, bases<UsdPhysicsObjectDesc>>
         rbmcls("RigidBodyMaterialDesc", pxr_boost::python::no_init);
     rbmcls
-        .def_readonly("staticFriction", &RigidBodyMaterialDesc::staticFriction)
-        .def_readonly("dynamicFriction", &RigidBodyMaterialDesc::dynamicFriction)
-        .def_readonly("restitution", &RigidBodyMaterialDesc::restitution)
-        .def_readonly("density", &RigidBodyMaterialDesc::density)
+        .def_readonly("staticFriction", &UsdPhysicsRigidBodyMaterialDesc::staticFriction)
+        .def_readonly("dynamicFriction", &UsdPhysicsRigidBodyMaterialDesc::dynamicFriction)
+        .def_readonly("restitution", &UsdPhysicsRigidBodyMaterialDesc::restitution)
+        .def_readonly("density", &UsdPhysicsRigidBodyMaterialDesc::density)
         .def("__repr__", _RigidBodyMaterialDesc_Repr);
 
-    pxr_boost::python::class_<ShapeDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsShapeDesc, bases<UsdPhysicsObjectDesc>>
         shdcls("ShapeDesc", pxr_boost::python::no_init);
     shdcls
-        .def_readonly("rigidBody", &ShapeDesc::rigidBody)
-        .def_readonly("localPos", &ShapeDesc::localPos)
-        .def_readonly("localRot", &ShapeDesc::localRot)
-        .def_readonly("localScale", &ShapeDesc::localScale)
-        .add_property("materials", make_function(&ShapeDesc::getMaterials,
+        .def_readonly("rigidBody", &UsdPhysicsShapeDesc::rigidBody)
+        .def_readonly("localPos", &UsdPhysicsShapeDesc::localPos)
+        .def_readonly("localRot", &UsdPhysicsShapeDesc::localRot)
+        .def_readonly("localScale", &UsdPhysicsShapeDesc::localScale)
+        .add_property("materials", make_function(&UsdPhysicsShapeDesc::getMaterials,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("simulationOwners", make_function(&ShapeDesc::getSimulationOwners,
+        .add_property("simulationOwners", make_function(&UsdPhysicsShapeDesc::getSimulationOwners,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredCollisions", make_function(&ShapeDesc::getFilteredCollisions,
+        .add_property("filteredCollisions", make_function(&UsdPhysicsShapeDesc::getFilteredCollisions,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("collisionGroups", make_function(&ShapeDesc::getCollisionGroups,
+        .add_property("collisionGroups", make_function(&UsdPhysicsShapeDesc::getCollisionGroups,
             return_value_policy<TfPySequenceToList>()))
-        .def_readonly("collisionEnabled", &ShapeDesc::collisionEnabled)
+        .def_readonly("collisionEnabled", &UsdPhysicsShapeDesc::collisionEnabled)
         .def("__repr__", _ShapeDesc_Repr);
 
-    pxr_boost::python::class_<SphereShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsSphereShapeDesc, bases<UsdPhysicsShapeDesc>>
         ssdcls("SphereShapeDesc", pxr_boost::python::no_init);
     ssdcls
-        .def_readonly("radius", &SphereShapeDesc::radius)
+        .def_readonly("radius", &UsdPhysicsSphereShapeDesc::radius)
         .def("__repr__", _SphereShapeDesc_Repr);
 
-    pxr_boost::python::class_<CapsuleShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsCapsuleShapeDesc, bases<UsdPhysicsShapeDesc>>
         csdcls("CapsuleShapeDesc", pxr_boost::python::no_init);
     csdcls
-        .def_readonly("radius", &CapsuleShapeDesc::radius)
-        .def_readonly("halfHeight", &CapsuleShapeDesc::halfHeight)
-        .def_readonly("axis", &CapsuleShapeDesc::axis)
+        .def_readonly("radius", &UsdPhysicsCapsuleShapeDesc::radius)
+        .def_readonly("halfHeight", &UsdPhysicsCapsuleShapeDesc::halfHeight)
+        .def_readonly("axis", &UsdPhysicsCapsuleShapeDesc::axis)
         .def("__repr__", _CapsuleShapeDesc_Repr);
 
-    pxr_boost::python::class_<CylinderShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsCylinderShapeDesc, bases<UsdPhysicsShapeDesc>>
         cysdcls("CylinderShapeDesc", pxr_boost::python::no_init);
     cysdcls
-        .def_readonly("radius", &CylinderShapeDesc::radius)
-        .def_readonly("halfHeight", &CylinderShapeDesc::halfHeight)
-        .def_readonly("axis", &CylinderShapeDesc::axis)
+        .def_readonly("radius", &UsdPhysicsCylinderShapeDesc::radius)
+        .def_readonly("halfHeight", &UsdPhysicsCylinderShapeDesc::halfHeight)
+        .def_readonly("axis", &UsdPhysicsCylinderShapeDesc::axis)
         .def("__repr__", _CylinderShapeDesc_Repr);
 
-    pxr_boost::python::class_<ConeShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsConeShapeDesc, bases<UsdPhysicsShapeDesc>>
         cosdcls("ConeShapeDesc", pxr_boost::python::no_init);
     cosdcls
-        .def_readonly("radius", &ConeShapeDesc::radius)
-        .def_readonly("halfHeight", &ConeShapeDesc::halfHeight)
-        .def_readonly("axis", &ConeShapeDesc::axis)
+        .def_readonly("radius", &UsdPhysicsConeShapeDesc::radius)
+        .def_readonly("halfHeight", &UsdPhysicsConeShapeDesc::halfHeight)
+        .def_readonly("axis", &UsdPhysicsConeShapeDesc::axis)
         .def("__repr__", _ConeShapeDesc_Repr);
 
-    pxr_boost::python::class_<PlaneShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsPlaneShapeDesc, bases<UsdPhysicsShapeDesc>>
         pscls("PlaneShapeDesc", pxr_boost::python::no_init);
     pscls
-        .def_readonly("axis", &PlaneShapeDesc::axis)
+        .def_readonly("axis", &UsdPhysicsPlaneShapeDesc::axis)
         .def("__repr__", _PlaneShapeDesc_Repr);
 
-    pxr_boost::python::class_<CustomShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsCustomShapeDesc, bases<UsdPhysicsShapeDesc>>
         cuscls("CustomShapeDesc", pxr_boost::python::no_init);
     cuscls
-        .def_readonly("customGeometryToken", &CustomShapeDesc::customGeometryToken)
+        .def_readonly("customGeometryToken", &UsdPhysicsCustomShapeDesc::customGeometryToken)
         .def("__repr__", _CustomShapeDesc_Repr);
 
-    pxr_boost::python::class_<CubeShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsCubeShapeDesc, bases<UsdPhysicsShapeDesc>>
         cubescls("CubeShapeDesc", pxr_boost::python::no_init);
     cubescls
-        .def_readonly("halfExtents", &CubeShapeDesc::halfExtents)
+        .def_readonly("halfExtents", &UsdPhysicsCubeShapeDesc::halfExtents)
         .def("__repr__", _CubeShapeDesc_Repr);
 
-    pxr_boost::python::class_<MeshShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsMeshShapeDesc, bases<UsdPhysicsShapeDesc>>
         mscls("MeshShapeDesc", pxr_boost::python::no_init);
     mscls
-        .add_property("approximation", &MeshShapeDesc::GetApproximation)
-        .def_readonly("meshScale", &MeshShapeDesc::meshScale)
-        .def_readonly("doubleSided", &MeshShapeDesc::doubleSided)
+        .add_property("approximation", &UsdPhysicsMeshShapeDesc::GetApproximation)
+        .def_readonly("meshScale", &UsdPhysicsMeshShapeDesc::meshScale)
+        .def_readonly("doubleSided", &UsdPhysicsMeshShapeDesc::doubleSided)
         .def("__repr__", _MeshShapeDesc_Repr);
 
-    pxr_boost::python::class_<SpherePoint>
+    pxr_boost::python::class_<UsdPhysicsSpherePoint>
         sppb("SpherePoint", pxr_boost::python::no_init);
     sppb
-        .def_readonly("center", &SpherePoint::center)
-        .def_readonly("radius", &SpherePoint::radius)
+        .def_readonly("center", &UsdPhysicsSpherePoint::center)
+        .def_readonly("radius", &UsdPhysicsSpherePoint::radius)
         .def("__repr__", _SpherePoint_Repr);
 
-    pxr_boost::python::class_<SpherePointsShapeDesc, bases<ShapeDesc>>
+    pxr_boost::python::class_<UsdPhysicsSpherePointsShapeDesc, bases<UsdPhysicsShapeDesc>>
         spmscls("SpherePointsShapeDesc", pxr_boost::python::no_init);
     spmscls
-        .add_property("spherePoints", &SpherePointsShapeDesc::spherePoints)
+        .add_property("spherePoints", &UsdPhysicsSpherePointsShapeDesc::spherePoints)
         .def("__repr__", _SpherePointsShapeDesc_Repr);
 
-    pxr_boost::python::class_<RigidBodyDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsRigidBodyDesc, bases<UsdPhysicsObjectDesc>>
         rbcls("RigidBodyDesc", pxr_boost::python::no_init);
     rbcls
-        .add_property("collisions", make_function(&RigidBodyDesc::getCollisions,
+        .add_property("collisions", make_function(&UsdPhysicsRigidBodyDesc::getCollisions,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredCollisions", make_function(&RigidBodyDesc::getFilteredCollisions,
+        .add_property("filteredCollisions", make_function(&UsdPhysicsRigidBodyDesc::getFilteredCollisions,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("simulationOwners", make_function(&RigidBodyDesc::getSimulationOwners,
+        .add_property("simulationOwners", make_function(&UsdPhysicsRigidBodyDesc::getSimulationOwners,
             return_value_policy<TfPySequenceToList>()))
-        .def_readonly("position", &RigidBodyDesc::position)
-        .def_readonly("rotation", &RigidBodyDesc::rotation)
-        .def_readonly("scale", &RigidBodyDesc::scale)
-        .def_readonly("rigidBodyEnabled", &RigidBodyDesc::rigidBodyEnabled)
-        .def_readonly("kinematicBody", &RigidBodyDesc::kinematicBody)
-        .def_readonly("startsAsleep", &RigidBodyDesc::startsAsleep)
-        .def_readonly("linearVelocity", &RigidBodyDesc::linearVelocity)
-        .def_readonly("angularVelocity", &RigidBodyDesc::angularVelocity)
+        .def_readonly("position", &UsdPhysicsRigidBodyDesc::position)
+        .def_readonly("rotation", &UsdPhysicsRigidBodyDesc::rotation)
+        .def_readonly("scale", &UsdPhysicsRigidBodyDesc::scale)
+        .def_readonly("rigidBodyEnabled", &UsdPhysicsRigidBodyDesc::rigidBodyEnabled)
+        .def_readonly("kinematicBody", &UsdPhysicsRigidBodyDesc::kinematicBody)
+        .def_readonly("startsAsleep", &UsdPhysicsRigidBodyDesc::startsAsleep)
+        .def_readonly("linearVelocity", &UsdPhysicsRigidBodyDesc::linearVelocity)
+        .def_readonly("angularVelocity", &UsdPhysicsRigidBodyDesc::angularVelocity)
         .def("__repr__", _RigidBodyDesc_Repr);
 
-    pxr_boost::python::class_<JointLimit>
+    pxr_boost::python::class_<UsdPhysicsJointLimit>
         jlcls("JointLimit", pxr_boost::python::no_init);
     jlcls
-        .def_readonly("enabled", &JointLimit::enabled)
-        .def_readonly("lower", &JointLimit::lower)
-        .def_readonly("upper", &JointLimit::upper)
+        .def_readonly("enabled", &UsdPhysicsJointLimit::enabled)
+        .def_readonly("lower", &UsdPhysicsJointLimit::lower)
+        .def_readonly("upper", &UsdPhysicsJointLimit::upper)
         .def("__repr__", _JointLimit_Repr);
 
-    pxr_boost::python::class_<JointDrive>
+    pxr_boost::python::class_<UsdPhysicsJointDrive>
         jdcls("JointDrive", pxr_boost::python::no_init);
     jdcls
-        .def_readonly("enabled", &JointDrive::enabled)
-        .def_readonly("targetPosition", &JointDrive::targetPosition)
-        .def_readonly("targetVelocity", &JointDrive::targetVelocity)
-        .def_readonly("forceLimit", &JointDrive::forceLimit)
-        .def_readonly("stiffness", &JointDrive::stiffness)
-        .def_readonly("damping", &JointDrive::damping)
-        .def_readonly("acceleration", &JointDrive::acceleration)
+        .def_readonly("enabled", &UsdPhysicsJointDrive::enabled)
+        .def_readonly("targetPosition", &UsdPhysicsJointDrive::targetPosition)
+        .def_readonly("targetVelocity", &UsdPhysicsJointDrive::targetVelocity)
+        .def_readonly("forceLimit", &UsdPhysicsJointDrive::forceLimit)
+        .def_readonly("stiffness", &UsdPhysicsJointDrive::stiffness)
+        .def_readonly("damping", &UsdPhysicsJointDrive::damping)
+        .def_readonly("acceleration", &UsdPhysicsJointDrive::acceleration)
         .def("__repr__", _JointDrive_Repr);
 
-    pxr_boost::python::class_<ArticulationDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsArticulationDesc, bases<UsdPhysicsObjectDesc>>
         adcls("ArticulationDesc", pxr_boost::python::no_init);
     adcls
-        .add_property("rootPrims", make_function(&ArticulationDesc::GetRootPrims,
+        .add_property("rootPrims", make_function(&UsdPhysicsArticulationDesc::GetRootPrims,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredCollisions", make_function(&ArticulationDesc::GetFilteredCollisions,
+        .add_property("filteredCollisions", make_function(&UsdPhysicsArticulationDesc::GetFilteredCollisions,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("articulatedJoints", make_function(&ArticulationDesc::GetArticulatedJoints,
+        .add_property("articulatedJoints", make_function(&UsdPhysicsArticulationDesc::GetArticulatedJoints,
             return_value_policy<TfPySequenceToList>()))
-        .add_property("articulatedBodies", make_function(&ArticulationDesc::GetArticulatedBodies,
+        .add_property("articulatedBodies", make_function(&UsdPhysicsArticulationDesc::GetArticulatedBodies,
             return_value_policy<TfPySequenceToList>()))
         .def("__repr__", _ArticulationDesc_Repr);
 
-    pxr_boost::python::class_<JointDesc, bases<PhysicsObjectDesc>>
+    pxr_boost::python::class_<UsdPhysicsJointDesc, bases<UsdPhysicsObjectDesc>>
         jdscls("JointDesc", pxr_boost::python::no_init);
     jdscls
-        .def_readonly("rel0", &JointDesc::rel0)
-        .def_readonly("rel1", &JointDesc::rel1)
-        .def_readonly("body0", &JointDesc::body0)
-        .def_readonly("body1", &JointDesc::body1)
-        .def_readonly("localPose0Position", &JointDesc::localPose0Position)
-        .def_readonly("localPose0Orientation", &JointDesc::localPose0Orientation)
-        .def_readonly("localPose1Position", &JointDesc::localPose1Position)
-        .def_readonly("localPose1Orientation", &JointDesc::localPose1Orientation)
-        .def_readonly("jointEnabled", &JointDesc::jointEnabled)
-        .def_readonly("breakForce", &JointDesc::breakForce)
-        .def_readonly("breakTorque", &JointDesc::breakTorque)
-        .def_readonly("excludeFromArticulation", &JointDesc::excludeFromArticulation)
-        .def_readonly("collisionEnabled", &JointDesc::collisionEnabled)
+        .def_readonly("rel0", &UsdPhysicsJointDesc::rel0)
+        .def_readonly("rel1", &UsdPhysicsJointDesc::rel1)
+        .def_readonly("body0", &UsdPhysicsJointDesc::body0)
+        .def_readonly("body1", &UsdPhysicsJointDesc::body1)
+        .def_readonly("localPose0Position", &UsdPhysicsJointDesc::localPose0Position)
+        .def_readonly("localPose0Orientation", &UsdPhysicsJointDesc::localPose0Orientation)
+        .def_readonly("localPose1Position", &UsdPhysicsJointDesc::localPose1Position)
+        .def_readonly("localPose1Orientation", &UsdPhysicsJointDesc::localPose1Orientation)
+        .def_readonly("jointEnabled", &UsdPhysicsJointDesc::jointEnabled)
+        .def_readonly("breakForce", &UsdPhysicsJointDesc::breakForce)
+        .def_readonly("breakTorque", &UsdPhysicsJointDesc::breakTorque)
+        .def_readonly("excludeFromArticulation", &UsdPhysicsJointDesc::excludeFromArticulation)
+        .def_readonly("collisionEnabled", &UsdPhysicsJointDesc::collisionEnabled)
         .def("__repr__", _JointDesc_Repr);
 
-    pxr_boost::python::class_<CustomJointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsCustomJointDesc, bases<UsdPhysicsJointDesc>>
         cjdscls("CustomJointDesc", pxr_boost::python::no_init);
 
-    pxr_boost::python::class_<FixedJointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsFixedJointDesc, bases<UsdPhysicsJointDesc>>
         fjdscls("FixedJointDesc", pxr_boost::python::no_init);
 
-    class_<std::pair<PhysicsJointDOF::Enum, JointLimit> >("JointLimitDOFPair")
-        .def_readwrite("first", &std::pair<PhysicsJointDOF::Enum, JointLimit>::first)
-        .def_readwrite("second", &std::pair<PhysicsJointDOF::Enum, JointLimit>::second)
+    class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit> >("JointLimitDOFPair")
+        .def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::first)
+        .def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::second)
         .def("__repr__", _JointLimitDOFPair_Repr);
 
-    class_<std::pair<PhysicsJointDOF::Enum, JointDrive> >("JointDriveDOFPair")
-        .def_readwrite("first", &std::pair<PhysicsJointDOF::Enum, JointDrive>::first)
-        .def_readwrite("second", &std::pair<PhysicsJointDOF::Enum, JointDrive>::second)
+    class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive> >("JointDriveDOFPair")
+        .def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::first)
+        .def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::second)
         .def("__repr__", _JointDriveDOFPair_Repr);
 
-    pxr_boost::python::class_<D6JointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsD6JointDesc, bases<UsdPhysicsJointDesc>>
         d6jdscls("D6JointDesc", pxr_boost::python::no_init);
     d6jdscls
-        .def_readonly("jointLimits", &D6JointDesc::jointLimits)
-        .def_readonly("jointDrives", &D6JointDesc::jointDrives)
+        .def_readonly("jointLimits", &UsdPhysicsD6JointDesc::jointLimits)
+        .def_readonly("jointDrives", &UsdPhysicsD6JointDesc::jointDrives)
         .def("__repr__", _D6JointDesc_Repr);
 
-    pxr_boost::python::class_<PrismaticJointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsPrismaticJointDesc, bases<UsdPhysicsJointDesc>>
         pjdscls("PrismaticJointDesc", pxr_boost::python::no_init);
     pjdscls
-        .def_readonly("axis", &PrismaticJointDesc::axis)
-        .def_readonly("limit", &PrismaticJointDesc::limit)
-        .def_readonly("drive", &PrismaticJointDesc::drive)
+        .def_readonly("axis", &UsdPhysicsPrismaticJointDesc::axis)
+        .def_readonly("limit", &UsdPhysicsPrismaticJointDesc::limit)
+        .def_readonly("drive", &UsdPhysicsPrismaticJointDesc::drive)
         .def("__repr__", _PrismaticJointDesc_Repr);
 
-    pxr_boost::python::class_<SphericalJointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsSphericalJointDesc, bases<UsdPhysicsJointDesc>>
         sjdscls("SphericalJointDesc", pxr_boost::python::no_init);
     sjdscls
-        .def_readonly("axis", &SphericalJointDesc::axis)
-        .def_readonly("limit", &SphericalJointDesc::limit)
+        .def_readonly("axis", &UsdPhysicsSphericalJointDesc::axis)
+        .def_readonly("limit", &UsdPhysicsSphericalJointDesc::limit)
         .def("__repr__", _SphericalJointDesc_Repr);
 
-    pxr_boost::python::class_<RevoluteJointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsRevoluteJointDesc, bases<UsdPhysicsJointDesc>>
         rjdscls("RevoluteJointDesc", pxr_boost::python::no_init);
     rjdscls
-        .def_readonly("axis", &RevoluteJointDesc::axis)
-        .def_readonly("limit", &RevoluteJointDesc::limit)
-        .def_readonly("drive", &RevoluteJointDesc::drive)
+        .def_readonly("axis", &UsdPhysicsRevoluteJointDesc::axis)
+        .def_readonly("limit", &UsdPhysicsRevoluteJointDesc::limit)
+        .def_readonly("drive", &UsdPhysicsRevoluteJointDesc::drive)
         .def("__repr__", _RevoluteJointDesc_Repr);
 
-    pxr_boost::python::class_<DistanceJointDesc, bases<JointDesc>>
+    pxr_boost::python::class_<UsdPhysicsDistanceJointDesc, bases<UsdPhysicsJointDesc>>
         djdscls("DistanceJointDesc", pxr_boost::python::no_init);
     djdscls
-        .def_readonly("minEnabled", &DistanceJointDesc::minEnabled)
-        .def_readonly("limit", &DistanceJointDesc::limit)
-        .def_readonly("maxEnabled", &DistanceJointDesc::maxEnabled)
+        .def_readonly("minEnabled", &UsdPhysicsDistanceJointDesc::minEnabled)
+        .def_readonly("limit", &UsdPhysicsDistanceJointDesc::limit)
+        .def_readonly("maxEnabled", &UsdPhysicsDistanceJointDesc::maxEnabled)
         .def("__repr__", _DistanceJointDesc_Repr);
 
     registerVectorConverter<UsdCollectionMembershipQuery>("PhysicsCollectionMembershipQueryVector");
 
-    registerVectorConverter<std::pair<PhysicsJointDOF::Enum, JointLimit>>("PhysicsJointLimitDOFVector");
+    registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>("PhysicsJointLimitDOFVector");
 
-    registerVectorConverter<std::pair<PhysicsJointDOF::Enum, JointDrive>>("PhysicsJointDriveDOFVector");
+    registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>>("PhysicsJointDriveDOFVector");
 
-    registerVectorConverter<SpherePoint>("PhysicsSpherePointVector");
+    registerVectorConverter<UsdPhysicsSpherePoint>("PhysicsSpherePointVector");
 
-    registerVectorConverter<SceneDesc>("SceneDescVector");
+    registerVectorConverter<UsdPhysicsSceneDesc>("SceneDescVector");
 
-    registerVectorConverter<RigidBodyDesc>("RigidBodyDescVector");
+    registerVectorConverter<UsdPhysicsRigidBodyDesc>("RigidBodyDescVector");
 
-    registerVectorConverter<SphereShapeDesc>("SphereShapeDescVector");
+    registerVectorConverter<UsdPhysicsSphereShapeDesc>("SphereShapeDescVector");
 
-    registerVectorConverter<CapsuleShapeDesc>("CapsuleShapeDescVector");
+    registerVectorConverter<UsdPhysicsCapsuleShapeDesc>("CapsuleShapeDescVector");
 
-    registerVectorConverter<CylinderShapeDesc>("CylinderShapeDescVector");
+    registerVectorConverter<UsdPhysicsCylinderShapeDesc>("CylinderShapeDescVector");
 
-    registerVectorConverter<ConeShapeDesc>("ConeShapeDescVector");
+    registerVectorConverter<UsdPhysicsConeShapeDesc>("ConeShapeDescVector");
 
-    registerVectorConverter<CubeShapeDesc>("CubeShapeDescVector");
+    registerVectorConverter<UsdPhysicsCubeShapeDesc>("CubeShapeDescVector");
 
-    registerVectorConverter<MeshShapeDesc>("MeshShapeDescVector");
+    registerVectorConverter<UsdPhysicsMeshShapeDesc>("MeshShapeDescVector");
 
-    registerVectorConverter<PlaneShapeDesc>("PlaneShapeDescVector");
+    registerVectorConverter<UsdPhysicsPlaneShapeDesc>("PlaneShapeDescVector");
 
-    registerVectorConverter<CustomShapeDesc>("CustomShapeDescVector");
+    registerVectorConverter<UsdPhysicsCustomShapeDesc>("CustomShapeDescVector");
 
-    registerVectorConverter<SpherePointsShapeDesc>("SpherePointsShapeDescVector");
+    registerVectorConverter<UsdPhysicsSpherePointsShapeDesc>("SpherePointsShapeDescVector");
 
-    registerVectorConverter<JointDesc>("JointDescVector");
+    registerVectorConverter<UsdPhysicsJointDesc>("JointDescVector");
 
-    registerVectorConverter<FixedJointDesc>("FixedJointDescVector");
+    registerVectorConverter<UsdPhysicsFixedJointDesc>("FixedJointDescVector");
 
-    registerVectorConverter<DistanceJointDesc>("DistanceJointDescVector");
+    registerVectorConverter<UsdPhysicsDistanceJointDesc>("DistanceJointDescVector");
 
-    registerVectorConverter<RevoluteJointDesc>("RevoluteJointDescVector");
+    registerVectorConverter<UsdPhysicsRevoluteJointDesc>("RevoluteJointDescVector");
 
-    registerVectorConverter<PrismaticJointDesc>("PrismaticJointDescVector");
+    registerVectorConverter<UsdPhysicsPrismaticJointDesc>("PrismaticJointDescVector");
 
-    registerVectorConverter<SphericalJointDesc>("SphericalJointDescVector");
+    registerVectorConverter<UsdPhysicsSphericalJointDesc>("SphericalJointDescVector");
 
-    registerVectorConverter<D6JointDesc>("D6JointDescVector");
+    registerVectorConverter<UsdPhysicsD6JointDesc>("D6JointDescVector");
 
-    registerVectorConverter<CustomJointDesc>("CustomJointDescVector");
+    registerVectorConverter<UsdPhysicsCustomJointDesc>("CustomJointDescVector");
 
-    registerVectorConverter<RigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
+    registerVectorConverter<UsdPhysicsRigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
 
-    registerVectorConverter<ArticulationDesc>("ArticulationDescVector");
+    registerVectorConverter<UsdPhysicsArticulationDesc>("ArticulationDescVector");
 
-    registerVectorConverter<CollisionGroupDesc>("CollisionGroupDescVector");
+    registerVectorConverter<UsdPhysicsCollisionGroupDesc>("CollisionGroupDescVector");
 
     pxr_boost::python::class_<ParsePrimIteratorBaseWrap, noncopyable>
         vparseitclsvv("ParsePrimIteratorBaseWrap", no_init);

From abab76d60155610ae9160f0350a87f9ae78ec5b7 Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Sun, 6 Oct 2024 09:54:36 +0200
Subject: [PATCH 4/8] constant rename

---
 pxr/usd/usdPhysics/parseDesc.h    |  2 +-
 pxr/usd/usdPhysics/parseUtils.cpp | 10 +++++-----
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/pxr/usd/usdPhysics/parseDesc.h b/pxr/usd/usdPhysics/parseDesc.h
index 22b6bb3a16..7d40bee77e 100644
--- a/pxr/usd/usdPhysics/parseDesc.h
+++ b/pxr/usd/usdPhysics/parseDesc.h
@@ -40,7 +40,7 @@ PXR_NAMESPACE_OPEN_SCOPE
 // -------------------------------------------------------------------------- //
 
 /// Sentinel value for flt max compare
-const float physicsSentinelLimit = 0.5e38f;
+const float usdPhysicsSentinelLimit = 0.5e38f;
 
 /// \struct UsdPhysicsObjectType
 ///
diff --git a/pxr/usd/usdPhysics/parseUtils.cpp b/pxr/usd/usdPhysics/parseUtils.cpp
index 6a57cc8c17..e54539ebf4 100644
--- a/pxr/usd/usdPhysics/parseUtils.cpp
+++ b/pxr/usd/usdPhysics/parseUtils.cpp
@@ -1042,8 +1042,8 @@ bool ParseLimit(const UsdPhysicsLimitAPI& limit, UsdPhysicsJointLimit* jointLimi
     {
         limit.GetLowAttr().Get(&jointLimit->lower);
         limit.GetHighAttr().Get(&jointLimit->upper);
-        if ((isfinite(jointLimit->lower) && jointLimit->lower > -physicsSentinelLimit) ||
-            (isfinite(jointLimit->upper) && jointLimit->upper < physicsSentinelLimit))
+        if ((isfinite(jointLimit->lower) && jointLimit->lower > -usdPhysicsSentinelLimit) ||
+            (isfinite(jointLimit->upper) && jointLimit->upper < usdPhysicsSentinelLimit))
                 jointLimit->enabled = true;
     }
     else
@@ -1184,8 +1184,8 @@ bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, Usd
         prismaticJointDesc->limit.enabled = false;
         prismaticJoint.GetLowerLimitAttr().Get(&prismaticJointDesc->limit.lower);
         prismaticJoint.GetUpperLimitAttr().Get(&prismaticJointDesc->limit.upper);
-        if ((isfinite(prismaticJointDesc->limit.lower) && (prismaticJointDesc->limit.lower > -physicsSentinelLimit)) || 
-            (isfinite(prismaticJointDesc->limit.upper) && (prismaticJointDesc->limit.upper < physicsSentinelLimit)))
+        if ((isfinite(prismaticJointDesc->limit.lower) && (prismaticJointDesc->limit.lower > -usdPhysicsSentinelLimit)) || 
+            (isfinite(prismaticJointDesc->limit.upper) && (prismaticJointDesc->limit.upper < usdPhysicsSentinelLimit)))
         {
             prismaticJointDesc->limit.enabled = true;
         }
@@ -1243,7 +1243,7 @@ bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, UsdPhy
         revoluteJoint.GetLowerLimitAttr().Get(&revoluteJointDesc->limit.lower);
         revoluteJoint.GetUpperLimitAttr().Get(&revoluteJointDesc->limit.upper);
         if (isfinite(revoluteJointDesc->limit.lower) && isfinite(revoluteJointDesc->limit.upper)
-            && revoluteJointDesc->limit.lower > -physicsSentinelLimit && revoluteJointDesc->limit.upper < physicsSentinelLimit)
+            && revoluteJointDesc->limit.lower > -usdPhysicsSentinelLimit && revoluteJointDesc->limit.upper < usdPhysicsSentinelLimit)
         {
             revoluteJointDesc->limit.enabled = true;
         }

From b246e86b59ae06041c8080c12352fde877f2dbfc Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Tue, 8 Oct 2024 08:31:27 +0200
Subject: [PATCH 5/8] Macos compilation fix

---
 pxr/usd/usdPhysics/wrapParseUtils.cpp | 56 +++++++++++++--------------
 1 file changed, 28 insertions(+), 28 deletions(-)

diff --git a/pxr/usd/usdPhysics/wrapParseUtils.cpp b/pxr/usd/usdPhysics/wrapParseUtils.cpp
index 2bda6b875d..24accad196 100644
--- a/pxr/usd/usdPhysics/wrapParseUtils.cpp
+++ b/pxr/usd/usdPhysics/wrapParseUtils.cpp
@@ -499,7 +499,7 @@ static std::string
 _CustomUsdPhysicsTokens_Repr(const CustomUsdPhysicsTokens& self)
 {
     return TfStringPrintf("%sCustomUsdPhysicsTokens(jointTokens=%s, shapeTokens=%s, instancerTokens=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.jointTokens).c_str(),
         TfPyRepr(self.shapeTokens).c_str(),
         TfPyRepr(self.instancerTokens).c_str());
@@ -509,7 +509,7 @@ static std::string
 _PhysicsObjectDesc_Repr(const UsdPhysicsObjectDesc& self)
 {
     return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.type).c_str(),
         TfPyRepr(self.primPath).c_str(),
         TfPyRepr(self.isValid).c_str());
@@ -519,7 +519,7 @@ static std::string
 _SceneDesc_Repr(const UsdPhysicsSceneDesc& self)
 {
     return TfStringPrintf("%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.gravityDirection).c_str(),
         TfPyRepr(self.gravityMagnitude).c_str(),
         _PhysicsObjectDesc_Repr(self).c_str());
@@ -529,7 +529,7 @@ static std::string
 _CollisionGroupDesc_Repr(const UsdPhysicsCollisionGroupDesc& self)
 {
     return TfStringPrintf("%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.invertFilteredGroups).c_str(),
         TfPyRepr(self.mergeGroupName).c_str(),
         TfPyRepr(self.mergedGroups).c_str(),
@@ -541,7 +541,7 @@ static std::string
 _RigidBodyMaterialDesc_Repr(const UsdPhysicsRigidBodyMaterialDesc& self)
 {
     return TfStringPrintf("%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.staticFriction).c_str(),
         TfPyRepr(self.dynamicFriction).c_str(),
         TfPyRepr(self.restitution).c_str(),
@@ -553,7 +553,7 @@ static std::string
 _ShapeDesc_Repr(const UsdPhysicsShapeDesc& self)
 {
     return TfStringPrintf("%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.rigidBody).c_str(),
         TfPyRepr(self.localPos).c_str(),
         TfPyRepr(self.localRot).c_str(),
@@ -570,7 +570,7 @@ static std::string
 _SphereShapeDesc_Repr(const UsdPhysicsSphereShapeDesc& self)
 {
     return TfStringPrintf("%sSphereShapeDesc(radius=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.radius).c_str(),
         _ShapeDesc_Repr(self).c_str());
 }
@@ -579,7 +579,7 @@ static std::string
 _CapsuleShapeDesc_Repr(const UsdPhysicsCapsuleShapeDesc& self)
 {
     return TfStringPrintf("%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.radius).c_str(),
         TfPyRepr(self.halfHeight).c_str(),
         TfPyRepr(self.axis).c_str(),
@@ -590,7 +590,7 @@ static std::string
 _CylinderShapeDesc_Repr(const UsdPhysicsCylinderShapeDesc& self)
 {
     return TfStringPrintf("%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.radius).c_str(),
         TfPyRepr(self.halfHeight).c_str(),
         TfPyRepr(self.axis).c_str(),
@@ -601,7 +601,7 @@ static std::string
 _ConeShapeDesc_Repr(const UsdPhysicsConeShapeDesc& self)
 {
     return TfStringPrintf("%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.radius).c_str(),
         TfPyRepr(self.halfHeight).c_str(),
         TfPyRepr(self.axis).c_str(),
@@ -612,7 +612,7 @@ static std::string
 _PlaneShapeDesc_Repr(const UsdPhysicsPlaneShapeDesc& self)
 {
     return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.axis).c_str(),
         _ShapeDesc_Repr(self).c_str());
 }
@@ -621,7 +621,7 @@ static std::string
 _CustomShapeDesc_Repr(const UsdPhysicsCustomShapeDesc& self)
 {
     return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.customGeometryToken).c_str(),
         _ShapeDesc_Repr(self).c_str());
 }
@@ -630,7 +630,7 @@ static std::string
 _CubeShapeDesc_Repr(const UsdPhysicsCubeShapeDesc& self)
 {
     return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.halfExtents).c_str(),
         _ShapeDesc_Repr(self).c_str());
 }
@@ -639,7 +639,7 @@ static std::string
 _MeshShapeDesc_Repr(const UsdPhysicsMeshShapeDesc& self)
 {
     return TfStringPrintf("%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.approximation).c_str(),
         TfPyRepr(self.meshScale).c_str(),
         TfPyRepr(self.doubleSided).c_str(),
@@ -650,7 +650,7 @@ static std::string
 _SpherePoint_Repr(const UsdPhysicsSpherePoint& self)
 {
     return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.center).c_str(),
         TfPyRepr(self.radius).c_str());
 }
@@ -659,7 +659,7 @@ static std::string
 _SpherePointsShapeDesc_Repr(const UsdPhysicsSpherePointsShapeDesc& self)
 {
     return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.spherePoints).c_str(),
         _ShapeDesc_Repr(self).c_str());
 }
@@ -668,7 +668,7 @@ static std::string
 _RigidBodyDesc_Repr(const UsdPhysicsRigidBodyDesc& self)
 {
     return TfStringPrintf("%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, simulationOwners=%s, position=%s, rotation=%s, scale=%s, rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, linearVelocity=%s, angularVelocity=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.collisions).c_str(),
         TfPyRepr(self.filteredCollisions).c_str(),
         TfPyRepr(self.simulationOwners).c_str(),
@@ -687,7 +687,7 @@ static std::string
 _JointLimit_Repr(const UsdPhysicsJointLimit& self)
 {
     return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.enabled).c_str(),
         TfPyRepr(self.lower).c_str(),
         TfPyRepr(self.upper).c_str());
@@ -697,7 +697,7 @@ static std::string
 _JointDrive_Repr(const UsdPhysicsJointDrive& self)
 {
     return TfStringPrintf("%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.enabled).c_str(),
         TfPyRepr(self.targetPosition).c_str(),
         TfPyRepr(self.targetVelocity).c_str(),
@@ -711,7 +711,7 @@ static std::string
 _ArticulationDesc_Repr(const UsdPhysicsArticulationDesc& self)
 {
     return TfStringPrintf("%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, articulatedJoints=%s, articulatedBodies=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.rootPrims).c_str(),
         TfPyRepr(self.filteredCollisions).c_str(),
         TfPyRepr(self.articulatedJoints).c_str(),
@@ -723,7 +723,7 @@ static std::string
 _JointDesc_Repr(const UsdPhysicsJointDesc& self)
 {
     return TfStringPrintf("%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, localPose0Position=%s, localPose0Orientation=%s, localPose1Position=%s, localPose1Orientation=%s, jointEnabled=%s, breakForce=%s, breakTorque=%s, excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.rel0).c_str(),
         TfPyRepr(self.rel1).c_str(),
         TfPyRepr(self.body0).c_str(),
@@ -744,7 +744,7 @@ static std::string
 _JointLimitDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>& self)
 {
     return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.first).c_str(),
         TfPyRepr(self.second).c_str());
 }
@@ -753,7 +753,7 @@ static std::string
 _JointDriveDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>& self)
 {
     return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.first).c_str(),
         TfPyRepr(self.second).c_str());
 }
@@ -762,7 +762,7 @@ static std::string
 _D6JointDesc_Repr(const UsdPhysicsD6JointDesc& self)
 {
     return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.jointLimits).c_str(),
         TfPyRepr(self.jointDrives).c_str(),
         _JointDesc_Repr(self).c_str());
@@ -772,7 +772,7 @@ static std::string
 _PrismaticJointDesc_Repr(const UsdPhysicsPrismaticJointDesc& self)
 {
     return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.axis).c_str(),
         TfPyRepr(self.limit).c_str(),
         TfPyRepr(self.drive).c_str(),
@@ -783,7 +783,7 @@ static std::string
 _SphericalJointDesc_Repr(const UsdPhysicsSphericalJointDesc& self)
 {
     return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.axis).c_str(),
         TfPyRepr(self.limit).c_str(),
         _JointDesc_Repr(self).c_str());
@@ -793,7 +793,7 @@ static std::string
 _RevoluteJointDesc_Repr(const UsdPhysicsRevoluteJointDesc& self)
 {
     return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.axis).c_str(),
         TfPyRepr(self.limit).c_str(),
         TfPyRepr(self.drive).c_str(),
@@ -804,7 +804,7 @@ static std::string
 _DistanceJointDesc_Repr(const UsdPhysicsDistanceJointDesc& self)
 {
     return TfStringPrintf("%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
-        TF_PY_REPR_PREFIX,
+        TF_PY_REPR_PREFIX.c_str(),
         TfPyRepr(self.minEnabled).c_str(),
         TfPyRepr(self.limit).c_str(),
         TfPyRepr(self.maxEnabled).c_str(),

From 0f865c709405e7be7c8d9adc1667bd4aa495cfe4 Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Sun, 27 Oct 2024 17:56:48 +0100
Subject: [PATCH 6/8] paralellism

---
 pxr/usd/usdPhysics/parseUtils.cpp | 366 +++++++++++++++++-------------
 1 file changed, 203 insertions(+), 163 deletions(-)

diff --git a/pxr/usd/usdPhysics/parseUtils.cpp b/pxr/usd/usdPhysics/parseUtils.cpp
index e54539ebf4..f941fa210f 100644
--- a/pxr/usd/usdPhysics/parseUtils.cpp
+++ b/pxr/usd/usdPhysics/parseUtils.cpp
@@ -65,6 +65,10 @@
 
 #include "pxr/usd/usdGeom/pointInstancer.h"
 
+#include "pxr/base/work/dispatcher.h"
+#include "pxr/base/work/loops.h"
+
+
 PXR_NAMESPACE_OPEN_SCOPE
 
 void ParseFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
@@ -1537,22 +1541,31 @@ bool HasDynamicBodyParent(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, U
     return false;
 }
 
+
 template <typename DescType, typename UsdType> 
 void ProcessPhysicsPrims(const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc, 
     std::function<bool(const UsdType& prim, DescType* desc)> processDescFn)
 {
     if (!physicsPrims.empty())
     {
-        physicsDesc.resize(physicsPrims.size());
-        for (size_t i = 0; i < physicsPrims.size(); i++)
+        const size_t numPrims = physicsPrims.size();
+        physicsDesc.resize(numPrims);
+
+        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
         {
-            const UsdType prim(physicsPrims[i]);
-            const bool ret = processDescFn(prim, &physicsDesc[i]);
-            if (!ret)
+            for (size_t i = beginIdx; i < endIdx; i++)
             {
-                physicsDesc[i].isValid = false;
+                const UsdType prim(physicsPrims[i]);
+                const bool ret = processDescFn(prim, &physicsDesc[i]);
+                if (!ret)
+                {
+                    physicsDesc[i].isValid = false;
+                }
             }
-        }
+        };
+
+        const size_t numPrimPerBatch = 10;
+        WorkParallelForN(numPrims, workLambda, numPrimPerBatch);
     }
 }
 
@@ -1614,72 +1627,73 @@ void CheckCollisionSimulationOwner(std::vector<UsdPrim>& collisionPrims, std::ve
     bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
     const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
-    for (size_t i = shapeDesc.size(); i--;)
-    {
-        bool ownerFound = false;
-        const UsdPhysicsShapeDesc& desc = shapeDesc[i];
-        if (desc.isValid)
-        {
-            if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
-            {        if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
-        {
-            ownerFound = true;
-        }
-        else
-        {
-            if (desc.rigidBody == SdfPath())
-            {
-                if (desc.simulationOwners.empty() && defaultSimulationOwner)
-                {                
-                    ownerFound = true;
-                }
-                else
-                {
-                    for (const SdfPath& owner : desc.simulationOwners)
-                    {
-                        if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-                        {
-                            ownerFound = true;
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-
-                ownerFound = true;
-            }
-            else
-            {
-                if (desc.rigidBody == SdfPath())
-                {
-                    if (desc.simulationOwners.empty() && defaultSimulationOwner)
-                    {                
-                        ownerFound = true;
-                    }
-                    else
-                    {
-                        for (const SdfPath& owner : desc.simulationOwners)
-                        {
-                            if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-                            {
-                                ownerFound = true;
-                                break;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        if (!ownerFound)
-        {
-            shapeDesc[i] = shapeDesc.back();
-            shapeDesc.pop_back();
-            collisionPrims[i] = collisionPrims.back();
-            collisionPrims.pop_back();
-        }
-    }        
+	for (size_t i = shapeDesc.size(); i--;)
+	{
+		bool ownerFound = false;
+		const UsdPhysicsShapeDesc& desc = shapeDesc[i];
+		if (desc.isValid)
+		{
+			if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+			{
+				if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+				{
+					ownerFound = true;
+				}
+				else
+				{
+					if (desc.rigidBody == SdfPath())
+					{
+						if (desc.simulationOwners.empty() && defaultSimulationOwner)
+						{
+							ownerFound = true;
+						}
+						else
+						{
+							for (const SdfPath& owner : desc.simulationOwners)
+							{
+								if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+								{
+									ownerFound = true;
+									break;
+								}
+							}
+						}
+					}
+				}
+
+				ownerFound = true;
+			}
+			else
+			{
+				if (desc.rigidBody == SdfPath())
+				{
+					if (desc.simulationOwners.empty() && defaultSimulationOwner)
+					{
+						ownerFound = true;
+					}
+					else
+					{
+						for (const SdfPath& owner : desc.simulationOwners)
+						{
+							if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+							{
+								ownerFound = true;
+								break;
+							}
+						}
+					}
+				}
+			}
+		}
+
+		if (!ownerFound)
+		{
+			shapeDesc[i] = shapeDesc.back();
+			shapeDesc.pop_back();
+			collisionPrims[i] = collisionPrims.back();
+			collisionPrims.pop_back();
+		}
+	}
 }
 
 // Both bodies need to have simulation owners valid
@@ -1766,17 +1780,21 @@ SdfPath GetRigidBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap)
     }
 }
 
-void GetCollisionShapeLocalTransfrom(UsdGeomXformCache& xfCache, const UsdPrim& collisionPrim, const UsdPrim& bodyPrim,
-                                            GfVec3f& localPosOut,
-                                            GfQuatf& localRotOut,
-                                            GfVec3f& localScaleOut)
+void GetCollisionShapeLocalTransfrom(const UsdPrim& collisionPrim, const UsdPrim& bodyPrim,
+    GfVec3f& localPosOut,
+    GfQuatf& localRotOut,
+    GfVec3f& localScaleOut)
 {
+    // body transform
+    const GfMatrix4d bodyLocalToWorldMatrix = UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+
     // compute the shape rel transform to a body and store it.
     pxr::GfVec3f localPos(0.0f);
     if (collisionPrim != bodyPrim)
     {
-        bool resetXformStack;
-        const pxr::GfMatrix4d mat = xfCache.ComputeRelativeTransform(collisionPrim, bodyPrim, &resetXformStack);
+        const GfMatrix4d collisionLocalToWorldMatrix = UsdGeomXformable(collisionPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+        
+        const pxr::GfMatrix4d mat = collisionLocalToWorldMatrix * bodyLocalToWorldMatrix.GetInverse();
         GfTransform colLocalTransform(mat);
 
         localPos = pxr::GfVec3f(colLocalTransform.GetTranslation());
@@ -1793,7 +1811,7 @@ void GetCollisionShapeLocalTransfrom(UsdGeomXformCache& xfCache, const UsdPrim&
 
     // now apply the body scale to localPos
     // physics does not support scales, so a rigid body scale has to be baked into the localPos
-    const pxr::GfTransform tr(xfCache.GetLocalToWorldTransform(bodyPrim));
+    const pxr::GfTransform tr(bodyLocalToWorldMatrix);
     const pxr::GfVec3d sc = tr.GetScale();
 
     for (int i = 0; i < 3; i++)
@@ -1804,11 +1822,11 @@ void GetCollisionShapeLocalTransfrom(UsdGeomXformCache& xfCache, const UsdPrim&
     localPosOut = localPos;
 }
 
-void FinalizeCollision(UsdStageWeakPtr stage, UsdGeomXformCache& xfCache, const UsdPhysicsRigidBodyDesc* bodyDesc, UsdPhysicsShapeDesc* shapeDesc)
+void FinalizeCollision(UsdStageWeakPtr stage, const UsdPhysicsRigidBodyDesc* bodyDesc, UsdPhysicsShapeDesc* shapeDesc)
 {
     // get shape local pose
     const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
-    GetCollisionShapeLocalTransfrom(xfCache, shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
+    GetCollisionShapeLocalTransfrom(shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
         shapeDesc->localPos, shapeDesc->localRot, shapeDesc->localScale);
 
     if (bodyDesc)
@@ -1817,46 +1835,50 @@ void FinalizeCollision(UsdStageWeakPtr stage, UsdGeomXformCache& xfCache, const
     }
 }
 
-
-
 template <typename DescType> 
 void FinalizeCollisionDescs(UsdGeomXformCache& xfCache, const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc, 
-    RigidBodyMap& bodyMap, const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
+    const RigidBodyMap& bodyMap, const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
 {
-    for (size_t i = 0; i < physicsDesc.size(); i++)
+    const auto workLambda = [physicsPrims, &physicsDesc, bodyMap, collisionGroups](const size_t beginIdx, const size_t endIdx)
     {
-        DescType& colDesc = physicsDesc[i];
-        if (colDesc.isValid)
+        for (size_t i = beginIdx; i < endIdx; i++)        
         {
-            const UsdPrim prim = physicsPrims[i];
-            // get the body
-            SdfPath bodyPath = GetRigidBody(prim, bodyMap);
-            // body was found, add collision to the body
-            UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
-            if (bodyPath != SdfPath())
+            DescType& colDesc = physicsDesc[i];
+            if (colDesc.isValid)
             {
-                RigidBodyMap::iterator bodyIt = bodyMap.find(bodyPath);
-                if (bodyIt != bodyMap.end())
+                const UsdPrim prim = physicsPrims[i];
+                // get the body
+                SdfPath bodyPath = GetRigidBody(prim, bodyMap);
+                // body was found, add collision to the body
+                UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
+                if (bodyPath != SdfPath())
                 {
-                    bodyDesc = bodyIt->second;
-                    bodyDesc->collisions.push_back(colDesc.primPath);
+                    RigidBodyMap::const_iterator bodyIt = bodyMap.find(bodyPath);
+                    if (bodyIt != bodyMap.end())
+                    {
+                        bodyDesc = bodyIt->second;
+                        bodyDesc->collisions.push_back(colDesc.primPath);
+                    }
                 }
-            }
 
-            // check if collision belongs to collision groups
-            for (std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
-             it != collisionGroups.end(); ++it)
-            {
-                if (it->second.find(colDesc.primPath) != it->second.end())
+                // check if collision belongs to collision groups
+                for (std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
+                    it != collisionGroups.end(); ++it)
                 {
-                    colDesc.collisionGroups.push_back(it->first);
+                    if (it->second.find(colDesc.primPath) != it->second.end())
+                    {
+                        colDesc.collisionGroups.push_back(it->first);
+                    }
                 }
-            }
 
-            // finalize the collision, fill up the local transform etc
-            FinalizeCollision(prim.GetStage(), xfCache, bodyDesc, &colDesc);
+                // finalize the collision, fill up the local transform etc
+                FinalizeCollision(prim.GetStage(), bodyDesc, &colDesc);
+            }
         }
-    }
+    };
+
+    const size_t numPrimPerBatch = 10;
+    WorkParallelForN(physicsPrims.size(), workLambda, numPrimPerBatch);
 }
 
 struct ArticulationLink
@@ -2063,14 +2085,14 @@ void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& ar
                 }
             }
         }
-    }
-
-    SdfPathVector articulationLinkOrderVector;
+    }    
 
     // first get user defined articulation roots
     // then search for the best root in the articulation hierarchy
-    for (ArticulationMap::const_reference& it : articulationMap)
-    {
+    const auto workLambda = [rigidBodyMap, jointMap, stage, bodyJointMap](ArticulationMap::const_reference& it)    
+    {        
+        SdfPathVector articulationLinkOrderVector;
+
         const SdfPath& articulationPath = it.first;
         SdfPath articulationBaseLinkPath = articulationPath;
 
@@ -2087,14 +2109,14 @@ void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& ar
                     TF_DIAGNOSTIC_WARNING(
                         "ArticulationRootAPI definition on a static rigid body is not allowed, articulation root will be ignored. Prim: %s",
                         articulationPath.GetText());
-                    continue;
+                    return;
                 }
                 if (bodyIt->second->kinematicBody)
                 {
                     TF_DIAGNOSTIC_WARNING(
                         "ArticulationRootAPI definition on a kinematic rigid body is not allowed, articulation root will be ignored. Prim: %s",
                         articulationPath.GetText());
-                    continue;
+                    return;
                 }
                 it.second->rootPrims.push_back(bodyIt->first);
             }
@@ -2117,7 +2139,7 @@ void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& ar
         // search through the hierarchy for the best root        
         const UsdPrim articulationPrim = stage->GetPrimAtPath(articulationBaseLinkPath);        
         if (!articulationPrim)
-            continue;        
+            return;
         UsdPrimRange range(articulationPrim, UsdTraverseInstanceProxies());
         std::vector<ArticulationLinkMap> articulationLinkMaps;
         articulationLinkOrderVector.clear();
@@ -2235,12 +2257,11 @@ void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& ar
         {
             it.second->articulatedBodies.push_back(p);
         }
-    }
+    };
     
+    WorkParallelForEach(articulationMap.begin(), articulationMap.end(), workLambda);    
 }
 
-
-
 bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
         ParsePrimIteratorBase& primIterator,
         UsdPhysicsReportFn reportFn,
@@ -2469,11 +2490,14 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     std::vector<UsdPhysicsCollisionGroupDesc> collisionGroupsDescs;
     ProcessPhysicsPrims<UsdPhysicsCollisionGroupDesc, UsdPhysicsCollisionGroup>(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
     // Run groups merging
+    std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets;
     std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
     for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
     {
         const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
 
+        collisionGroupSets[desc.primPath];
+
         if (!desc.mergeGroupName.empty())
         {
             std::unordered_map<std::string, size_t>::const_iterator fit = mergeGroupNameToIndex.find(desc.mergeGroupName);
@@ -2500,46 +2524,54 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
         }
     } 
 
-    // Populate the sets to check collisions, this needs to run in parallel!!!
-    std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets; 
-    for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
+    // Populate the sets to check collisions
     {
-        const UsdPrim groupPrim = collisionGroupPrims[i];
-        UsdStageWeakPtr stage = groupPrim.GetStage();
-        const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
-        std::unordered_set<SdfPath, SdfPath::Hash>& hashSet = collisionGroupSets[desc.primPath];
-
-        if (desc.mergedGroups.empty())
+        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
         {
-            const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
-            if (cg)
+            for (size_t i = beginIdx; i < endIdx; i++)
             {
-                const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
-                UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
-                const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
-                for (const SdfPath& path : includedPaths)
+                const UsdPrim groupPrim = collisionGroupPrims[i];
+                UsdStageWeakPtr stage = groupPrim.GetStage();
+                const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
+
+                std::unordered_set<SdfPath, SdfPath::Hash>& hashSet = collisionGroupSets[desc.primPath];
+
+                if (desc.mergedGroups.empty())
                 {
-                    hashSet.insert(path);
+                    const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
+                    if (cg)
+                    {
+                        const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
+                        UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
+                        const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+                        for (const SdfPath& path : includedPaths)
+                        {
+                            hashSet.insert(path);
+                        }
+                    }
                 }
-            }
-        }
-        else
-        {
-            for (const SdfPath& groupPath : desc.mergedGroups)
-            {
-                const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
-                if (cg)
+                else
                 {
-                    const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
-                    UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
-                    const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
-                    for (const SdfPath& path : includedPaths)
+                    for (const SdfPath& groupPath : desc.mergedGroups)
                     {
-                        hashSet.insert(path);
+                        const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
+                        if (cg)
+                        {
+                            const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
+                            UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
+                            const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+                            for (const SdfPath& path : includedPaths)
+                            {
+                                hashSet.insert(path);
+                            }
+                        }
                     }
                 }
             }
-        }
+        };
+
+        const size_t numPrimPerBatch = 10;
+        WorkParallelForN(collisionGroupsDescs.size(), workLambda, numPrimPerBatch);
     }
 
     // Rigid body physics material
@@ -2605,22 +2637,30 @@ bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
     std::vector<UsdPhysicsObjectType::Enum> collisionTypes;
     collisionTypes.resize(collisionPrims.size());
     std::vector<TfToken> customTokens;
-    for (size_t i = 0; i < collisionPrims.size(); i++)
-    {
-        if (customPhysicsTokens)
+    {       
+        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
         {
-            TfToken shapeToken;
-            const UsdPhysicsObjectType::Enum shapeType = GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
-            collisionTypes[i] = shapeType;
-            if (shapeType == UsdPhysicsObjectType::eCustomShape)
+            for (size_t i = beginIdx; i < endIdx; i++)
             {
-                customTokens.push_back(shapeToken);
+                if (customPhysicsTokens)
+                {
+                    TfToken shapeToken;
+                    const UsdPhysicsObjectType::Enum shapeType = GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
+                    collisionTypes[i] = shapeType;
+                    if (shapeType == UsdPhysicsObjectType::eCustomShape)
+                    {
+                        customTokens.push_back(shapeToken);
+                    }
+                }
+                else
+                {
+                    collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
+                }
             }
-        }
-        else
-        {
-            collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
-        }
+        };
+        
+        const size_t numPrimPerBatch = 10;
+        WorkParallelForN(collisionPrims.size(), workLambda, numPrimPerBatch);
     }
 
     std::vector<UsdPrim> sphereShapePrims;

From 17abf775cefcdab34dc1d89e7ff84363aa25f0e0 Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Wed, 30 Oct 2024 13:04:59 +0100
Subject: [PATCH 7/8] updated based on review

---
 pxr/usd/usdPhysics/CMakeLists.txt             |    2 +-
 pxr/usd/usdPhysics/module.cpp                 |    2 +-
 pxr/usd/usdPhysics/parseDesc.h                | 1038 +--
 pxr/usd/usdPhysics/parsePrimIterator.h        |  390 +-
 pxr/usd/usdPhysics/parseUtils.cpp             | 5644 +++++++++--------
 pxr/usd/usdPhysics/parseUtils.h               |   50 +-
 .../testenv/testUsdPhysicsParsing.py          |   23 +-
 pxr/usd/usdPhysics/wrapParseUtils.cpp         | 1881 +++---
 8 files changed, 4634 insertions(+), 4396 deletions(-)

diff --git a/pxr/usd/usdPhysics/CMakeLists.txt b/pxr/usd/usdPhysics/CMakeLists.txt
index 74f38456fc..930546aff3 100644
--- a/pxr/usd/usdPhysics/CMakeLists.txt
+++ b/pxr/usd/usdPhysics/CMakeLists.txt
@@ -77,7 +77,7 @@ pxr_register_test(testUsdPhysicsCollisionGroupAPI
     EXPECTED_RETURN_CODE 0
 )
 
-pxr_register_test(testUsdPhysicsCollisitestUsdPhysicsParsingonGroupAPI
+pxr_register_test(testUsdPhysicsParsing
     PYTHON
     COMMAND "${CMAKE_INSTALL_PREFIX}/tests/testUsdPhysicsParsing"
     EXPECTED_RETURN_CODE 0
diff --git a/pxr/usd/usdPhysics/module.cpp b/pxr/usd/usdPhysics/module.cpp
index d176c3aff4..ec03de1e70 100644
--- a/pxr/usd/usdPhysics/module.cpp
+++ b/pxr/usd/usdPhysics/module.cpp
@@ -19,7 +19,7 @@ PXR_NAMESPACE_USING_DIRECTIVE
 TF_WRAP_MODULE
 {
 	TF_WRAP(Metrics);
-    TF_WRAP(ParseUtils);
+	TF_WRAP(ParseUtils);
 
     // Generated Schema classes.  Do not remove or edit the following line.
     #include "generatedSchema.module.h"
diff --git a/pxr/usd/usdPhysics/parseDesc.h b/pxr/usd/usdPhysics/parseDesc.h
index 7d40bee77e..ef53b8139e 100644
--- a/pxr/usd/usdPhysics/parseDesc.h
+++ b/pxr/usd/usdPhysics/parseDesc.h
@@ -1,25 +1,8 @@
 //
-// Copyright 2016 Pixar
+// Copyright 2024 Pixar
 //
-// Licensed under the Apache License, Version 2.0 (the "Apache License")
-// with the following modification; you may not use this file except in
-// compliance with the Apache License and the following modification to it:
-// Section 6. Trademarks. is deleted and replaced with:
-//
-// 6. Trademarks. This License does not grant permission to use the trade
-//    names, trademarks, service marks, or product names of the Licensor
-//    and its affiliates, except as required to comply with Section 4(c) of
-//    the License and to reproduce the content of the NOTICE file.
-//
-// You may obtain a copy of the Apache License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the Apache License with the above modification is
-// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, either express or implied. See the Apache License for the specific
-// language governing permissions and limitations under the Apache License.
+// Licensed under the terms set forth in the LICENSE.txt file available at
+// https://openusd.org/license.
 //
 #ifndef USDPHYSICS_PARSE_DESC_H
 #define USDPHYSICS_PARSE_DESC_H
@@ -48,40 +31,40 @@ const float usdPhysicsSentinelLimit = 0.5e38f;
 ///
 struct UsdPhysicsObjectType
 {
-    enum Enum
-    {
-        eUndefined,
+	enum Enum
+	{
+		eUndefined,
 
-        eScene,
+		eScene,
 
-        eRigidBody,
+		eRigidBody,
 
-        eSphereShape,
-        eCubeShape,
-        eCapsuleShape,
-        eCylinderShape,
-        eConeShape,
-        eMeshShape,
-        ePlaneShape,
-        eCustomShape,
-        eSpherePointsShape,
+		eSphereShape,
+		eCubeShape,
+		eCapsuleShape,
+		eCylinderShape,
+		eConeShape,
+		eMeshShape,
+		ePlaneShape,
+		eCustomShape,
+		eSpherePointsShape,
 
-        eFixedJoint,
-        eRevoluteJoint,
-        ePrismaticJoint,
-        eSphericalJoint,
-        eDistanceJoint,
-        eD6Joint,
-        eCustomJoint,
+		eFixedJoint,
+		eRevoluteJoint,
+		ePrismaticJoint,
+		eSphericalJoint,
+		eDistanceJoint,
+		eD6Joint,
+		eCustomJoint,
 
-        eRigidBodyMaterial,
+		eRigidBodyMaterial,
 
-        eArticulation,
+		eArticulation,
 
-        eCollisionGroup,
+		eCollisionGroup,
 
-        eLast,
-    };
+		eLast,
+	};
 };
 
 /// \struct UsdPhysicsAxis
@@ -90,12 +73,12 @@ struct UsdPhysicsObjectType
 ///
 struct UsdPhysicsAxis
 {
-    enum Enum
-    {
-        eX,
-        eY,
-        eZ
-    };
+	enum Enum
+	{
+		eX,
+		eY,
+		eZ
+	};
 };
 
 /// \struct UsdPhysicsJointDOF
@@ -104,16 +87,16 @@ struct UsdPhysicsAxis
 ///
 struct UsdPhysicsJointDOF
 {
-    enum Enum
-    {
-        eDistance,
-        eTransX,
-        eTransY,
-        eTransZ,
-        eRotX,
-        eRotY,
-        eRotZ
-    };
+	enum Enum
+	{
+		eDistance,
+		eTransX,
+		eTransY,
+		eTransZ,
+		eRotX,
+		eRotY,
+		eRotZ
+	};
 };
 
 /// \struct UsdPhysicsObjectDesc
@@ -122,17 +105,19 @@ struct UsdPhysicsJointDOF
 ///
 struct UsdPhysicsObjectDesc
 {
-    UsdPhysicsObjectDesc() : type(UsdPhysicsObjectType::eUndefined), isValid(true)
-    {
-    }
-
-    virtual ~UsdPhysicsObjectDesc()
-    {
-    }
-
-    UsdPhysicsObjectType::Enum type;   ///< Descriptor type
-    SdfPath primPath;                ///< SdfPath for the prim from which the descriptor was parsed
-    bool isValid;                   ///< Validity of a descriptor, the parsing may succeed, but the descriptor might be not valid
+	UsdPhysicsObjectDesc() : type(UsdPhysicsObjectType::eUndefined), isValid(true)
+	{
+	}
+
+	virtual ~UsdPhysicsObjectDesc()
+	{
+	}
+
+	UsdPhysicsObjectType::Enum type;   ///< Descriptor type
+	SdfPath primPath;               ///< SdfPath for the prim from which the 
+	///< descriptor was parsed
+	bool isValid;                   ///< Validity of a descriptor, the parsing may
+	///< succeed, but the descriptor might be not valid
 };
 
 /// \struct UsdPhysicsRigidBodyMaterialDesc
@@ -141,21 +126,22 @@ struct UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsRigidBodyMaterialDesc : UsdPhysicsObjectDesc
 {
-    UsdPhysicsRigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f), restitution(0.0f), density(-1.0f)
-    {
-        type = UsdPhysicsObjectType::eRigidBodyMaterial;
-    }
-
-    bool operator == (const UsdPhysicsRigidBodyMaterialDesc&) const
-    {
-        return false;
-    }
-
-
-    float staticFriction;       ///< Static friction
-    float dynamicFriction;      ///< Dynamic friction
-    float restitution;          ///< Restitution
-    float density;              ///< Density
+	UsdPhysicsRigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f),
+		restitution(0.0f), density(-1.0f)
+	{
+		type = UsdPhysicsObjectType::eRigidBodyMaterial;
+	}
+
+	bool operator == (const UsdPhysicsRigidBodyMaterialDesc&) const
+	{
+		return false;
+	}
+
+
+	float staticFriction;       ///< Static friction
+	float dynamicFriction;      ///< Dynamic friction
+	float restitution;          ///< Restitution
+	float density;              ///< Density
 };
 
 /// \struct UsdPhysicsSceneDesc
@@ -164,18 +150,20 @@ struct UsdPhysicsRigidBodyMaterialDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsSceneDesc : UsdPhysicsObjectDesc
 {
-    UsdPhysicsSceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
-    {
-        type = UsdPhysicsObjectType::eScene;
-    }
-
-    bool operator == (const UsdPhysicsSceneDesc&) const
-    {
-        return false;
-    }
-
-    GfVec3f gravityDirection;   ///< Gravity direction, if default 0,0,0 was used negative upAxis direction will be returned
-    float gravityMagnitude;     ///< Gravity magnitude, -inf means Earth gravity adjusted by metersPerUnit will be returned
+	UsdPhysicsSceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
+	{
+		type = UsdPhysicsObjectType::eScene;
+	}
+
+	bool operator == (const UsdPhysicsSceneDesc&) const
+	{
+		return false;
+	}
+
+	GfVec3f gravityDirection;   ///< Gravity direction, if default 0,0,0 was used
+	///< negative upAxis direction will be returned
+	float gravityMagnitude;     ///< Gravity magnitude, -inf means Earth gravity 
+	///< adjusted by metersPerUnit will be returned
 };
 
 /// \struct UsdPhysicsCollisionGroupDesc
@@ -184,30 +172,31 @@ struct UsdPhysicsSceneDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsCollisionGroupDesc : UsdPhysicsObjectDesc
 {
-    UsdPhysicsCollisionGroupDesc()
-    {
-        type = UsdPhysicsObjectType::eCollisionGroup;
-    }
-
-    bool operator == (const UsdPhysicsCollisionGroupDesc&) const
-    {
-        return false;
-    }
-
-    const SdfPathVector& getFilteredGroups() const
-    {
-        return filteredGroups;
-    }
-
-    const SdfPathVector& getMergedGroups() const
-    {
-        return mergedGroups;
-    }
-
-    bool invertFilteredGroups;                      ///< If filtering is inverted or not (default does not collide with)
-    SdfPathVector filteredGroups;                   ///< Filtered groups SdfPath vector
-    std::string mergeGroupName;                     ///< Merge group name
-    SdfPathVector mergedGroups;                     ///< List of merged collision groups
+	UsdPhysicsCollisionGroupDesc()
+	{
+		type = UsdPhysicsObjectType::eCollisionGroup;
+	}
+
+	bool operator == (const UsdPhysicsCollisionGroupDesc&) const
+	{
+		return false;
+	}
+
+	const SdfPathVector& getFilteredGroups() const
+	{
+		return filteredGroups;
+	}
+
+	const SdfPathVector& getMergedGroups() const
+	{
+		return mergedGroups;
+	}
+
+	bool invertFilteredGroups;              ///< If filtering is inverted 
+	/// <or not (default does not collide with)
+	SdfPathVector filteredGroups;           ///< Filtered groups SdfPath vector
+	std::string mergeGroupName;             ///< Merge group name
+	SdfPathVector mergedGroups;             ///< List of merged collision groups
 };
 
 /// \struct UsdPhysicsShapeDesc
@@ -220,44 +209,53 @@ struct UsdPhysicsCollisionGroupDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsShapeDesc : UsdPhysicsObjectDesc
 {
-    UsdPhysicsShapeDesc()
-        : localPos(0.0f, 0.0f, 0.0f),
-          localRot(1.0f, 0.0f, 0.0f, 0.0f),
-          localScale(1.0f, 1.0f, 1.0f),
-          collisionEnabled(true)
-    {
-    }
-
-    const SdfPathVector& getMaterials() const
-    {
-        return materials;
-    }
-
-    const SdfPathVector& getSimulationOwners() const
-    {
-        return simulationOwners;
-    }
-
-    const SdfPathVector& getFilteredCollisions() const
-    {
-        return filteredCollisions;
-    }
-
-    const SdfPathVector& getCollisionGroups() const
-    {
-        return collisionGroups;
-    }
-
-
-    SdfPath rigidBody;                      ///< Rigid body the collision shape belongs to, if not set its a static collider
-    GfVec3f localPos;                       ///< Local position of the shape relative to the body world pose
-    GfQuatf localRot;                       ///< Local orientation of the shape relative to the body world pose
-    GfVec3f localScale;                     ///< Local scale of the shape relative to the body world pose
-    SdfPathVector materials;                ///< Materials assigned to the collision geometry, can be multiple materials used on UsdGeomSubset
-    SdfPathVector simulationOwners;         ///< Simulation owners list
-    SdfPathVector filteredCollisions;       ///< Filtered collisions list
-    SdfPathVector collisionGroups;          ///< List of collision groups this collision belongs to, note that only collision groups that are part of the current range are checked.
-    bool collisionEnabled;                  ///< Collision enabled/disabled bool
+	UsdPhysicsShapeDesc()
+		: localPos(0.0f, 0.0f, 0.0f),
+		localRot(1.0f, 0.0f, 0.0f, 0.0f),
+		localScale(1.0f, 1.0f, 1.0f),
+		collisionEnabled(true)
+	{
+	}
+
+	const SdfPathVector& getMaterials() const
+	{
+		return materials;
+	}
+
+	const SdfPathVector& getSimulationOwners() const
+	{
+		return simulationOwners;
+	}
+
+	const SdfPathVector& getFilteredCollisions() const
+	{
+		return filteredCollisions;
+	}
+
+	const SdfPathVector& getCollisionGroups() const
+	{
+		return collisionGroups;
+	}
+
+
+	SdfPath rigidBody;                  ///< Rigid body the collision shape 
+	///< belongs to, if not set its a static collider
+	GfVec3f localPos;                   ///< Local position of the shape relative
+	///< to the body world pose
+	GfQuatf localRot;                   ///< Local orientation of the shape relative 
+	///< to the body world pose
+	GfVec3f localScale;                 ///< Local scale of the shape relative to
+	///< the body world pose
+	SdfPathVector materials;            ///< Materials assigned to the collision 
+	///< geometry, can be multiple materials 
+	///< used on UsdGeomSubset
+	SdfPathVector simulationOwners;     ///< Simulation owners list
+	SdfPathVector filteredCollisions;   ///< Filtered collisions list
+	SdfPathVector collisionGroups;      ///< List of collision groups this collision
+	///< belongs to, note that only collision 
+	///< groups that are part of the current 
+	///< range are checked.
+	bool collisionEnabled;              ///< Collision enabled/disabled bool
 };
 
 /// \struct UsdPhysicsSphereShapeDesc
@@ -266,17 +264,17 @@ struct UsdPhysicsShapeDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsSphereShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsSphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
-    {
-        type = UsdPhysicsObjectType::eSphereShape;
-    }
+	UsdPhysicsSphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
+	{
+		type = UsdPhysicsObjectType::eSphereShape;
+	}
 
-    bool operator == (const UsdPhysicsSphereShapeDesc&) const
-    {
-        return false;
-    }
+	bool operator == (const UsdPhysicsSphereShapeDesc&) const
+	{
+		return false;
+	}
 
-    float radius;               ///< Sphere radius
+	float radius;               ///< Sphere radius
 };
 
 /// \struct UsdPhysicsCapsuleShapeDesc
@@ -285,20 +283,21 @@ struct UsdPhysicsSphereShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCapsuleShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsCapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
-        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
-    {
-        type = UsdPhysicsObjectType::eCapsuleShape;
-    }
-
-    bool operator == (const UsdPhysicsCapsuleShapeDesc&) const
-    {
-        return false;
-    }
-
-    float radius;               ///< Capsule radius
-    float halfHeight;           ///< Capsule half height
-    UsdPhysicsAxis::Enum axis;     ///< Capsule axis
+	UsdPhysicsCapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
+		UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
+		: radius(inRadius), halfHeight(half_height), axis(cap_axis)
+	{
+		type = UsdPhysicsObjectType::eCapsuleShape;
+	}
+
+	bool operator == (const UsdPhysicsCapsuleShapeDesc&) const
+	{
+		return false;
+	}
+
+	float radius;               ///< Capsule radius
+	float halfHeight;           ///< Capsule half height
+	UsdPhysicsAxis::Enum axis;     ///< Capsule axis
 };
 
 /// \struct UsdPhysicsCylinderShapeDesc
@@ -307,20 +306,21 @@ struct UsdPhysicsCapsuleShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCylinderShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsCylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
-        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
-    {
-        type = UsdPhysicsObjectType::eCylinderShape;
-    }
-
-    bool operator == (const UsdPhysicsCylinderShapeDesc&) const
-    {
-        return false;
-    }
-
-    float radius;               ///< Cylinder radius
-    float halfHeight;           ///< Cylinder half height
-    UsdPhysicsAxis::Enum axis;     ///< Cylinder axis
+	UsdPhysicsCylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
+		UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
+		: radius(inRadius), halfHeight(half_height), axis(cap_axis)
+	{
+		type = UsdPhysicsObjectType::eCylinderShape;
+	}
+
+	bool operator == (const UsdPhysicsCylinderShapeDesc&) const
+	{
+		return false;
+	}
+
+	float radius;               ///< Cylinder radius
+	float halfHeight;           ///< Cylinder half height
+	UsdPhysicsAxis::Enum axis;     ///< Cylinder axis
 };
 
 /// \struct UsdPhysicsConeShapeDesc
@@ -329,21 +329,22 @@ struct UsdPhysicsCylinderShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsConeShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f, UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
-        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
-    {
-        type = UsdPhysicsObjectType::eConeShape;
-    }
-
-    bool operator == (const UsdPhysicsConeShapeDesc&) const
-    {
-        return false;
-    }
-
-
-    float radius;               ///< Cone radius
-    float halfHeight;           ///< Cone half height
-    UsdPhysicsAxis::Enum axis;     ///< Cone axis
+	UsdPhysicsConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
+		UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
+		: radius(inRadius), halfHeight(half_height), axis(cap_axis)
+	{
+		type = UsdPhysicsObjectType::eConeShape;
+	}
+
+	bool operator == (const UsdPhysicsConeShapeDesc&) const
+	{
+		return false;
+	}
+
+
+	float radius;               ///< Cone radius
+	float halfHeight;           ///< Cone half height
+	UsdPhysicsAxis::Enum axis;     ///< Cone axis
 };
 
 /// \struct UsdPhysicsPlaneShapeDesc
@@ -352,18 +353,18 @@ struct UsdPhysicsConeShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsPlaneShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsPlaneShapeDesc(UsdPhysicsAxis::Enum up_axis = UsdPhysicsAxis::eX)
-        : axis(up_axis)
-    {
-        type = UsdPhysicsObjectType::ePlaneShape;
-    }
-    bool operator == (const UsdPhysicsPlaneShapeDesc&) const
-    {
-        return false;
-    }
-
-
-    UsdPhysicsAxis::Enum axis;     ///< Plane axis
+	UsdPhysicsPlaneShapeDesc(UsdPhysicsAxis::Enum up_axis = UsdPhysicsAxis::eX)
+		: axis(up_axis)
+	{
+		type = UsdPhysicsObjectType::ePlaneShape;
+	}
+	bool operator == (const UsdPhysicsPlaneShapeDesc&) const
+	{
+		return false;
+	}
+
+
+	UsdPhysicsAxis::Enum axis;     ///< Plane axis
 };
 
 
@@ -373,17 +374,17 @@ struct UsdPhysicsPlaneShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCustomShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsCustomShapeDesc()
-    {
-        type = UsdPhysicsObjectType::eCustomShape;
-    }
-    bool operator == (const UsdPhysicsCustomShapeDesc&) const
-    {
-        return false;
-    }
+	UsdPhysicsCustomShapeDesc()
+	{
+		type = UsdPhysicsObjectType::eCustomShape;
+	}
+	bool operator == (const UsdPhysicsCustomShapeDesc&) const
+	{
+		return false;
+	}
 
 
-    TfToken customGeometryToken;    ///< Custom geometry token for this collision
+	TfToken customGeometryToken;    ///< Custom geometry token for this collision
 };
 
 /// \struct UsdPhysicsCubeShapeDesc
@@ -392,16 +393,17 @@ struct UsdPhysicsCustomShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCubeShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsCubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f)) : halfExtents(inHalfExtents)
-    {
-        type = UsdPhysicsObjectType::eCubeShape;
-    }
-    bool operator == (const UsdPhysicsCubeShapeDesc&) const
-    {
-        return false;
-    }
-
-    GfVec3f halfExtents;        ///< Half extents of the cube
+	UsdPhysicsCubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f))
+		: halfExtents(inHalfExtents)
+	{
+		type = UsdPhysicsObjectType::eCubeShape;
+	}
+	bool operator == (const UsdPhysicsCubeShapeDesc&) const
+	{
+		return false;
+	}
+
+	GfVec3f halfExtents;        ///< Half extents of the cube
 };
 
 /// \struct UsdPhysicsMeshShapeDesc
@@ -410,28 +412,29 @@ struct UsdPhysicsCubeShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsMeshShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsMeshShapeDesc() : meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
-    {
-        type = UsdPhysicsObjectType::eMeshShape;
-    }
-    bool operator == (const UsdPhysicsMeshShapeDesc&) const
-    {
-        return false;
-    }
-
-
-    ~UsdPhysicsMeshShapeDesc()
-    {
-    }
-
-    const TfToken GetApproximation()
-    {
-        return approximation;
-    }
-
-    TfToken approximation;      ///< Desired approximation for the mesh collision
-    GfVec3f meshScale;          ///< Mesh scale
-    bool doubleSided;           ///< Bool to define whether mesh is double sided or not
+	UsdPhysicsMeshShapeDesc()
+		: meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
+	{
+		type = UsdPhysicsObjectType::eMeshShape;
+	}
+	bool operator == (const UsdPhysicsMeshShapeDesc&) const
+	{
+		return false;
+	}
+
+
+	~UsdPhysicsMeshShapeDesc()
+	{
+	}
+
+	const TfToken GetApproximation()
+	{
+		return approximation;
+	}
+
+	TfToken approximation;      ///< Desired approximation for the mesh collision
+	GfVec3f meshScale;          ///< Mesh scale
+	bool doubleSided;           ///< Bool to define whether mesh is double sided or not
 };
 
 /// \struct UsdPhysicsSpherePoint
@@ -441,13 +444,13 @@ struct UsdPhysicsMeshShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsSpherePoint
 {
-    bool operator == (const UsdPhysicsSpherePoint&) const
-    {
-        return false;
-    }
+	bool operator == (const UsdPhysicsSpherePoint&) const
+	{
+		return false;
+	}
 
-    GfVec3f center;
-    float radius;
+	GfVec3f center;
+	float radius;
 };
 
 /// \struct UsdPhysicsSpherePointsShapeDesc
@@ -459,21 +462,21 @@ struct UsdPhysicsSpherePoint
 ///
 struct UsdPhysicsSpherePointsShapeDesc : UsdPhysicsShapeDesc
 {
-    UsdPhysicsSpherePointsShapeDesc(void)
-    {
-        type = UsdPhysicsObjectType::eSpherePointsShape;
-    }
-    bool operator == (const UsdPhysicsSpherePointsShapeDesc&) const
-    {
-        return false;
-    }
+	UsdPhysicsSpherePointsShapeDesc(void)
+	{
+		type = UsdPhysicsObjectType::eSpherePointsShape;
+	}
+	bool operator == (const UsdPhysicsSpherePointsShapeDesc&) const
+	{
+		return false;
+	}
 
 
-    ~UsdPhysicsSpherePointsShapeDesc(void)
-    {
-    }
+	~UsdPhysicsSpherePointsShapeDesc(void)
+	{
+	}
 
-    std::vector<UsdPhysicsSpherePoint> spherePoints;  ///< Lit of sphere points
+	std::vector<UsdPhysicsSpherePoint> spherePoints;  ///< Lit of sphere points
 };
 
 /// \struct UsdPhysicsRigidBodyDesc
@@ -482,50 +485,52 @@ struct UsdPhysicsSpherePointsShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsRigidBodyDesc : UsdPhysicsObjectDesc
 {
-    UsdPhysicsRigidBodyDesc()
-        : position(0.0f, 0.0f, 0.0f),
-          rotation(1.0f, 0.0f, 0.0f, 0.0f),
-          scale(1.0f, 1.0f, 1.0f),
-          rigidBodyEnabled(true),
-          kinematicBody(false),
-          startsAsleep(false),
-          linearVelocity(0.0f, 0.0f, 0.0f),
-          angularVelocity(0.0f, 0.0f, 0.0f)
-    {
-        type = UsdPhysicsObjectType::eRigidBody;
-    }
-    bool operator == (const UsdPhysicsRigidBodyDesc&) const
-    {
-        return false;
-    }
-
-    const SdfPathVector& getCollisions() const
-    {
-        return collisions;
-    }
-
-    const SdfPathVector& getFilteredCollisions() const
-    {
-        return filteredCollisions;
-    }
-
-    const SdfPathVector& getSimulationOwners() const
-    {
-        return simulationOwners;
-    }
-
-    SdfPathVector collisions;               ///< List of collision shapes that belong to this rigid body
-    SdfPathVector filteredCollisions;       ///< Filtered collisions
-    SdfPathVector simulationOwners;         ///< Simulation owners list
-    GfVec3f position;                       ///< Rigid body position in world space
-    GfQuatf rotation;                       ///< Rigid body orientation in world space
-    GfVec3f scale;                          ///< Rigid body scale
-
-    bool rigidBodyEnabled;                  ///< Defines whether body is enabled or not, if not enabled its a static body
-    bool kinematicBody;                     ///< Defines if the body is kinematic or not
-    bool startsAsleep;                      ///< Defines if body starts asleep or awake
-    GfVec3f linearVelocity;                 ///< Rigid body initial linear velocity
-    GfVec3f angularVelocity;                ///< Rigid body initial angular velocity
+	UsdPhysicsRigidBodyDesc()
+		: position(0.0f, 0.0f, 0.0f),
+		rotation(1.0f, 0.0f, 0.0f, 0.0f),
+		scale(1.0f, 1.0f, 1.0f),
+		rigidBodyEnabled(true),
+		kinematicBody(false),
+		startsAsleep(false),
+		linearVelocity(0.0f, 0.0f, 0.0f),
+		angularVelocity(0.0f, 0.0f, 0.0f)
+	{
+		type = UsdPhysicsObjectType::eRigidBody;
+	}
+	bool operator == (const UsdPhysicsRigidBodyDesc&) const
+	{
+		return false;
+	}
+
+	const SdfPathVector& getCollisions() const
+	{
+		return collisions;
+	}
+
+	const SdfPathVector& getFilteredCollisions() const
+	{
+		return filteredCollisions;
+	}
+
+	const SdfPathVector& getSimulationOwners() const
+	{
+		return simulationOwners;
+	}
+
+	SdfPathVector collisions;               ///< List of collision shapes that 
+	///< belong to this rigid body
+	SdfPathVector filteredCollisions;       ///< Filtered collisions
+	SdfPathVector simulationOwners;         ///< Simulation owners list
+	GfVec3f position;                       ///< Rigid body position in world space
+	GfQuatf rotation;                       ///< Rigid body orientation in world space
+	GfVec3f scale;                          ///< Rigid body scale
+
+	bool rigidBodyEnabled;                  ///< Defines whether body is enabled 
+	///< or not, if not enabled its a static body
+	bool kinematicBody;                     ///< Defines if the body is kinematic or not
+	bool startsAsleep;                      ///< Defines if body starts asleep or awake
+	GfVec3f linearVelocity;                 ///< Rigid body initial linear velocity
+	GfVec3f angularVelocity;                ///< Rigid body initial angular velocity
 };
 
 /// \struct UsdPhysicsJointLimit
@@ -534,29 +539,29 @@ struct UsdPhysicsRigidBodyDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsJointLimit
 {
-    UsdPhysicsJointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
-    {
-    }
-
-    bool operator == (const UsdPhysicsJointLimit&) const
-    {
-        return false;
-    }
-
-
-    bool enabled;           ///< Defines whether limit is enabled or not
-    union                   ///< Min, lower, initial angle
-    {
-        float angle0;
-        float lower;
-        float minDist;
-    };
-    union                   ///< Max, upper, final angle
-    {
-        float angle1;
-        float upper;
-        float maxDist;
-    };
+	UsdPhysicsJointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
+	{
+	}
+
+	bool operator == (const UsdPhysicsJointLimit&) const
+	{
+		return false;
+	}
+
+
+	bool enabled;           ///< Defines whether limit is enabled or not
+	union                   ///< Min, lower, initial angle
+	{
+		float angle0;
+		float lower;
+		float minDist;
+	};
+	union                   ///< Max, upper, final angle
+	{
+		float angle1;
+		float upper;
+		float maxDist;
+	};
 };
 
 /// \struct UsdPhysicsJointDrive
@@ -567,29 +572,29 @@ struct UsdPhysicsJointLimit
 ///
 struct UsdPhysicsJointDrive
 {
-    UsdPhysicsJointDrive()
-        : enabled(false),
-          targetPosition(0.0f),
-          targetVelocity(0.0f),
-          forceLimit(FLT_MAX),
-          stiffness(0.0f),
-          damping(0.0f),
-          acceleration(false)
-    {
-    }
-
-    bool operator == (const UsdPhysicsJointDrive&) const
-    {
-        return false;
-    }
-
-    bool enabled;           ///< Defines whether limit is enabled or not
-    float targetPosition;   ///< Drive target position
-    float targetVelocity;   ///< Drive target velocity
-    float forceLimit;       ///< Force limit
-    float stiffness;        ///< Drive stiffness
-    float damping;          ///< Drive damping
-    bool acceleration;      ///< Drive mode is acceleration or force
+	UsdPhysicsJointDrive()
+		: enabled(false),
+		targetPosition(0.0f),
+		targetVelocity(0.0f),
+		forceLimit(FLT_MAX),
+		stiffness(0.0f),
+		damping(0.0f),
+		acceleration(false)
+	{
+	}
+
+	bool operator == (const UsdPhysicsJointDrive&) const
+	{
+		return false;
+	}
+
+	bool enabled;           ///< Defines whether limit is enabled or not
+	float targetPosition;   ///< Drive target position
+	float targetVelocity;   ///< Drive target velocity
+	float forceLimit;       ///< Force limit
+	float stiffness;        ///< Drive stiffness
+	float damping;          ///< Drive damping
+	bool acceleration;      ///< Drive mode is acceleration or force
 };
 
 
@@ -599,39 +604,40 @@ struct UsdPhysicsJointDrive
 ///
 struct UsdPhysicsArticulationDesc : UsdPhysicsObjectDesc
 {
-    UsdPhysicsArticulationDesc()
-    {
-        type = UsdPhysicsObjectType::eArticulation;
-    }
-    bool operator == (const UsdPhysicsArticulationDesc&) const
-    {
-        return false;
-    }
-
-    const SdfPathVector& GetRootPrims() const
-    {
-        return rootPrims;
-    }
-
-    const SdfPathVector& GetFilteredCollisions() const
-    {
-        return filteredCollisions;
-    }
-
-    const SdfPathVector& GetArticulatedJoints() const
-    {
-        return articulatedJoints;
-    }
-
-    const SdfPathVector& GetArticulatedBodies() const
-    {
-        return articulatedBodies;
-    }
-
-    SdfPathVector rootPrims;            ///< List of articulation roots, this defines where the articulation topology starts
-    SdfPathVector filteredCollisions;   ///< Filtered collisions
-    SdfPathVector articulatedJoints;    ///< List of joints that can be part of this articulation
-    SdfPathVector articulatedBodies;    ///< List of bodies that can be part of this articulation
+	UsdPhysicsArticulationDesc()
+	{
+		type = UsdPhysicsObjectType::eArticulation;
+	}
+	bool operator == (const UsdPhysicsArticulationDesc&) const
+	{
+		return false;
+	}
+
+	const SdfPathVector& GetRootPrims() const
+	{
+		return rootPrims;
+	}
+
+	const SdfPathVector& GetFilteredCollisions() const
+	{
+		return filteredCollisions;
+	}
+
+	const SdfPathVector& GetArticulatedJoints() const
+	{
+		return articulatedJoints;
+	}
+
+	const SdfPathVector& GetArticulatedBodies() const
+	{
+		return articulatedBodies;
+	}
+
+	SdfPathVector rootPrims;            ///< List of articulation roots, this defines
+	///<  where the articulation topology starts
+	SdfPathVector filteredCollisions;   ///< Filtered collisions
+	SdfPathVector articulatedJoints;    ///< List of joints that can be part of this articulation
+	SdfPathVector articulatedBodies;    ///< List of bodies that can be part of this articulation
 };
 
 using JointLimits = std::vector<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>;
@@ -643,36 +649,44 @@ using JointDrives = std::vector<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJo
 ///
 struct UsdPhysicsJointDesc : public UsdPhysicsObjectDesc
 {
-    UsdPhysicsJointDesc()
-        : localPose0Position(0.0f, 0.0f, 0.0f),
-          localPose0Orientation(1.0f, 0.0f, 0.0f, 0.0f),
-          localPose1Position(0.0f, 0.0f, 0.0f),
-          localPose1Orientation(1.0f, 0.0f, 0.0f, 0.0f),
-          jointEnabled(true),
-          breakForce(FLT_MAX), // USD default is none, which is not a float...
-          breakTorque(FLT_MAX),
-          excludeFromArticulation(false)
-    {
-    }
-
-    bool operator == (const UsdPhysicsJointDesc&) const
-    {
-        return false;
-    }
-
-    SdfPath rel0;                   ///< UsdPrim relationship 0 for the joint
-    SdfPath rel1;                   ///< UsdPrim relationship 1 for the joint
-    SdfPath body0;                  ///< Rigid body 0 that the joint is connected, does not have to match the rel0
-    SdfPath body1;                  ///< Rigid body 1 that the joint is connected, does not have to match the rel1
-    GfVec3f localPose0Position;     ///< Relative local position against the body0 world frame
-    GfQuatf localPose0Orientation;  ///< Relative local orientation against the body0 world frame
-    GfVec3f localPose1Position;     ///< Relative local position against the body1 world frame
-    GfQuatf localPose1Orientation;  ///< Relative local orientation against the body1 world frame
-    bool jointEnabled;              ///< Defines if joint is enabled or disabled
-    float breakForce;               ///< Joint break force
-    float breakTorque;              ///< Joint break torque
-    bool excludeFromArticulation;   ///< Defines if joints belongs to an articulation or if its a maximum coordinate joint
-    bool collisionEnabled;          ///< Defines if collision is enabled or disabled between the jointed bodies
+	UsdPhysicsJointDesc()
+		: localPose0Position(0.0f, 0.0f, 0.0f),
+		localPose0Orientation(1.0f, 0.0f, 0.0f, 0.0f),
+		localPose1Position(0.0f, 0.0f, 0.0f),
+		localPose1Orientation(1.0f, 0.0f, 0.0f, 0.0f),
+		jointEnabled(true),
+		breakForce(FLT_MAX), // USD default is none, which is not a float...
+		breakTorque(FLT_MAX),
+		excludeFromArticulation(false)
+	{
+	}
+
+	bool operator == (const UsdPhysicsJointDesc&) const
+	{
+		return false;
+	}
+
+	SdfPath rel0;                   ///< UsdPrim relationship 0 for the joint
+	SdfPath rel1;                   ///< UsdPrim relationship 1 for the joint
+	SdfPath body0;                  ///< Rigid body 0 that the joint is connected, 
+	///< does not have to match the rel0
+	SdfPath body1;                  ///< Rigid body 1 that the joint is connected, 
+	///< does not have to match the rel1
+	GfVec3f localPose0Position;     ///< Relative local position against the body0 
+	///< world frame
+	GfQuatf localPose0Orientation;  ///< Relative local orientation against the body0 
+	///< world frame
+	GfVec3f localPose1Position;     ///< Relative local position against the body1 
+	///< world frame
+	GfQuatf localPose1Orientation;  ///< Relative local orientation against the body1 
+	///< world frame
+	bool jointEnabled;              ///< Defines if joint is enabled or disabled
+	float breakForce;               ///< Joint break force
+	float breakTorque;              ///< Joint break torque
+	bool excludeFromArticulation;   ///< Defines if joints belongs to an articulation 
+	///< or if its a maximum coordinate joint
+	bool collisionEnabled;          ///< Defines if collision is enabled or disabled 
+	///< between the jointed bodies
 };
 
 /// \struct UsdPhysicsCustomJointDesc
@@ -681,14 +695,14 @@ struct UsdPhysicsJointDesc : public UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsCustomJointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsCustomJointDesc()
-    {
-        type = UsdPhysicsObjectType::eCustomJoint;
-    }
-    bool operator == (const UsdPhysicsCustomJointDesc&) const
-    {
-        return false;
-    }
+	UsdPhysicsCustomJointDesc()
+	{
+		type = UsdPhysicsObjectType::eCustomJoint;
+	}
+	bool operator == (const UsdPhysicsCustomJointDesc&) const
+	{
+		return false;
+	}
 
 };
 
@@ -698,14 +712,14 @@ struct UsdPhysicsCustomJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsFixedJointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsFixedJointDesc()
-    {
-        type = UsdPhysicsObjectType::eFixedJoint;
-    }
-    bool operator == (const UsdPhysicsFixedJointDesc&) const
-    {
-        return false;
-    }
+	UsdPhysicsFixedJointDesc()
+	{
+		type = UsdPhysicsObjectType::eFixedJoint;
+	}
+	bool operator == (const UsdPhysicsFixedJointDesc&) const
+	{
+		return false;
+	}
 };
 
 /// \struct UsdPhysicsD6JointDesc
@@ -714,17 +728,17 @@ struct UsdPhysicsFixedJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsD6JointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsD6JointDesc()
-    {
-        type = UsdPhysicsObjectType::eD6Joint;
-    }
-    bool operator == (const UsdPhysicsD6JointDesc&) const
-    {
-        return false;
-    }
-
-    JointLimits jointLimits;    ///< List of joint limits
-    JointDrives jointDrives;    ///< List of joint drives
+	UsdPhysicsD6JointDesc()
+	{
+		type = UsdPhysicsObjectType::eD6Joint;
+	}
+	bool operator == (const UsdPhysicsD6JointDesc&) const
+	{
+		return false;
+	}
+
+	JointLimits jointLimits;    ///< List of joint limits
+	JointDrives jointDrives;    ///< List of joint drives
 };
 
 /// \struct UsdPhysicsPrismaticJointDesc
@@ -733,19 +747,19 @@ struct UsdPhysicsD6JointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsPrismaticJointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsPrismaticJointDesc() : axis(UsdPhysicsAxis::eX)
-    {
-        type = UsdPhysicsObjectType::ePrismaticJoint;
-    }
-    bool operator == (const UsdPhysicsPrismaticJointDesc&) const
-    {
-        return false;
-    }
-
-
-    UsdPhysicsAxis::Enum axis; ///< The joints axis
-    UsdPhysicsJointLimit limit;       ///< Joint linear limit
-    UsdPhysicsJointDrive drive;       ///< Joint linear drive
+	UsdPhysicsPrismaticJointDesc() : axis(UsdPhysicsAxis::eX)
+	{
+		type = UsdPhysicsObjectType::ePrismaticJoint;
+	}
+	bool operator == (const UsdPhysicsPrismaticJointDesc&) const
+	{
+		return false;
+	}
+
+
+	UsdPhysicsAxis::Enum axis; ///< The joints axis
+	UsdPhysicsJointLimit limit;       ///< Joint linear limit
+	UsdPhysicsJointDrive drive;       ///< Joint linear drive
 };
 
 /// \struct UsdPhysicsSphericalJointDesc
@@ -754,17 +768,17 @@ struct UsdPhysicsPrismaticJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsSphericalJointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsSphericalJointDesc() : axis(UsdPhysicsAxis::eX)
-    {
-        type = UsdPhysicsObjectType::eSphericalJoint;
-    }
-    bool operator == (const UsdPhysicsSphericalJointDesc&) const
-    {
-        return false;
-    }
-
-    UsdPhysicsAxis::Enum axis; ///< The joints axis
-    UsdPhysicsJointLimit limit;       ///< The joint spherical limit
+	UsdPhysicsSphericalJointDesc() : axis(UsdPhysicsAxis::eX)
+	{
+		type = UsdPhysicsObjectType::eSphericalJoint;
+	}
+	bool operator == (const UsdPhysicsSphericalJointDesc&) const
+	{
+		return false;
+	}
+
+	UsdPhysicsAxis::Enum axis; ///< The joints axis
+	UsdPhysicsJointLimit limit;       ///< The joint spherical limit
 };
 
 /// \struct UsdPhysicsRevoluteJointDesc
@@ -773,18 +787,18 @@ struct UsdPhysicsSphericalJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsRevoluteJointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsRevoluteJointDesc() : axis(UsdPhysicsAxis::eX)
-    {
-        type = UsdPhysicsObjectType::eRevoluteJoint;
-    }
-    bool operator == (const UsdPhysicsRevoluteJointDesc&) const
-    {
-        return false;
-    }
-
-    UsdPhysicsAxis::Enum axis; ///< The joints axis
-    UsdPhysicsJointLimit limit;       ///< The angular limit
-    UsdPhysicsJointDrive drive;       ///< The angular drive
+	UsdPhysicsRevoluteJointDesc() : axis(UsdPhysicsAxis::eX)
+	{
+		type = UsdPhysicsObjectType::eRevoluteJoint;
+	}
+	bool operator == (const UsdPhysicsRevoluteJointDesc&) const
+	{
+		return false;
+	}
+
+	UsdPhysicsAxis::Enum axis; ///< The joints axis
+	UsdPhysicsJointLimit limit;       ///< The angular limit
+	UsdPhysicsJointDrive drive;       ///< The angular drive
 };
 
 /// \struct UsdPhysicsDistanceJointDesc
@@ -793,17 +807,17 @@ struct UsdPhysicsRevoluteJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsDistanceJointDesc : public UsdPhysicsJointDesc
 {
-    UsdPhysicsDistanceJointDesc() : minEnabled(false), maxEnabled(false)
-    {
-        type = UsdPhysicsObjectType::eDistanceJoint;
-    }
-    bool operator == (const UsdPhysicsDistanceJointDesc&) const
-    {
-        return false;
-    }
-    bool minEnabled;    ///< Defines if minimum limit is enabled
-    bool maxEnabled;    ///< Defines if maximum limit is enabled
-    UsdPhysicsJointLimit limit;   ///< The distance limit
+	UsdPhysicsDistanceJointDesc() : minEnabled(false), maxEnabled(false)
+	{
+		type = UsdPhysicsObjectType::eDistanceJoint;
+	}
+	bool operator == (const UsdPhysicsDistanceJointDesc&) const
+	{
+		return false;
+	}
+	bool minEnabled;    ///< Defines if minimum limit is enabled
+	bool maxEnabled;    ///< Defines if maximum limit is enabled
+	UsdPhysicsJointLimit limit;   ///< The distance limit
 };
 
 
diff --git a/pxr/usd/usdPhysics/parsePrimIterator.h b/pxr/usd/usdPhysics/parsePrimIterator.h
index 69d5fdfdc1..80bfb8dec0 100644
--- a/pxr/usd/usdPhysics/parsePrimIterator.h
+++ b/pxr/usd/usdPhysics/parsePrimIterator.h
@@ -1,25 +1,8 @@
 //
-// Copyright 2016 Pixar
+// Copyright 2024 Pixar
 //
-// Licensed under the Apache License, Version 2.0 (the "Apache License")
-// with the following modification; you may not use this file except in
-// compliance with the Apache License and the following modification to it:
-// Section 6. Trademarks. is deleted and replaced with:
-//
-// 6. Trademarks. This License does not grant permission to use the trade
-//    names, trademarks, service marks, or product names of the Licensor
-//    and its affiliates, except as required to comply with Section 4(c) of
-//    the License and to reproduce the content of the NOTICE file.
-//
-// You may obtain a copy of the Apache License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the Apache License with the above modification is
-// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, either express or implied. See the Apache License for the specific
-// language governing permissions and limitations under the Apache License.
+// Licensed under the terms set forth in the LICENSE.txt file available at
+// https://openusd.org/license.
 //
 #ifndef USDPHYSICS_PARSE_PRIM_ITERATOR_H
 #define USDPHYSICS_PARSE_PRIM_ITERATOR_H
@@ -47,24 +30,24 @@ using UsdPrimMap = std::map<const SdfPath, UsdPrim>;
 class ParsePrimIteratorBase
 {
 public:
-    virtual ~ParsePrimIteratorBase() = default;
+	virtual ~ParsePrimIteratorBase() = default;
 
-    /// Reset the iteration
-    virtual void reset() = 0;
+	/// Reset the iteration
+	virtual void reset() = 0;
 
-    /// Check if iterator is at the end
-    /// \return True if at the end
-    virtual bool atEnd() const = 0;
+	/// Check if iterator is at the end
+	/// \return True if at the end
+	virtual bool atEnd() const = 0;
 
-    /// Get current iterator
-    /// \return Current iterator
-    virtual UsdPrimRange::const_iterator getCurrent() = 0;
+	/// Get current iterator
+	/// \return Current iterator
+	virtual UsdPrimRange::const_iterator getCurrent() = 0;
 
-    /// Update iterator to next
-    virtual void next() = 0;
+	/// Update iterator to next
+	virtual void next() = 0;
 
-    /// Prune all children of the current iterator
-    virtual void pruneChildren() = 0;
+	/// Prune all children of the current iterator
+	virtual void pruneChildren() = 0;
 };
 
 /// \struct ParsePrimIteratorRange
@@ -74,43 +57,43 @@ class ParsePrimIteratorBase
 class ParsePrimIteratorRange : public ParsePrimIteratorBase
 {
 public:
-    ParsePrimIteratorRange(UsdPrimRange range) : mRange(range)
-    {
-        reset();
-    }
-
-    virtual void reset() override
-    {
-        mIter = mRange.begin();
-    }
-
-    virtual void pruneChildren() override
-    {
-        if (!atEnd())
-            mIter.PruneChildren();
-    }
-
-    virtual bool atEnd() const override
-    {
-        return mIter == mRange.end();
-    }
-
-    virtual UsdPrimRange::const_iterator getCurrent() override
-    {
-        return mIter;
-    }
-
-    virtual void next() override
-    {
-        if (mIter != mRange.end())
-        {
-            mIter++;
-        }
-    }
+	ParsePrimIteratorRange(UsdPrimRange range) : mRange(range)
+	{
+		reset();
+	}
+
+	virtual void reset() override
+	{
+		mIter = mRange.begin();
+	}
+
+	virtual void pruneChildren() override
+	{
+		if (!atEnd())
+			mIter.PruneChildren();
+	}
+
+	virtual bool atEnd() const override
+	{
+		return mIter == mRange.end();
+	}
+
+	virtual UsdPrimRange::const_iterator getCurrent() override
+	{
+		return mIter;
+	}
+
+	virtual void next() override
+	{
+		if (mIter != mRange.end())
+		{
+			mIter++;
+		}
+	}
 
 private:
-    UsdPrimRange mRange;
-    UsdPrimRange::const_iterator mIter;
+	UsdPrimRange mRange;
+	UsdPrimRange::const_iterator mIter;
 };
 
 /// \struct ParsePrimIteratorMapRange
@@ -121,152 +104,153 @@ class ParsePrimIteratorRange : public ParsePrimIteratorBase
 class ParsePrimIteratorMapRange : public ParsePrimIteratorBase
 {
 public:
-    ParsePrimIteratorMapRange(const UsdPrimMap& primMap) : mPrimMap(primMap)
-    {
-        reset();
-    }
-
-    virtual void reset() override
-    {
-        mAtEnd = true;
-
-        mPrimMapIter = mPrimMap.begin();
-
-        if (mPrimMapIter != mPrimMap.end())
-        {
-            mRange = UsdPrimRange(mPrimMapIter->second, UsdTraverseInstanceProxies());
-            if (mRange.begin() != mRange.end())
-            {
-                mIter = mRange.begin();
-                mAtEnd = false;
-            }
-        }
-    }
-
-    virtual bool atEnd() const override
-    {
-        return mAtEnd;
-    }
-
-    virtual void pruneChildren() override
-    {
-        if (!atEnd())
-            mIter.PruneChildren();
-    }
-
-    virtual UsdPrimRange::const_iterator getCurrent() override
-    {
-        return mIter;
-    }
-
-    virtual void next() override
-    {
-        if (mIter != mRange.end())
-        {
-            mIter++;
-
-            if (mIter == mRange.end())
-            {
-                mPrimMapIter++;
-
-                if (mPrimMapIter == mPrimMap.end())
-                {
-                    mAtEnd = true;
-                }
-                else
-                {
-                    mRange = UsdPrimRange(mPrimMapIter->second);
-                    mIter = mRange.begin();
-                }
-            }
-        }
-    }
+	ParsePrimIteratorMapRange(const UsdPrimMap& primMap) : mPrimMap(primMap)
+	{
+		reset();
+	}
+
+	virtual void reset() override
+	{
+		mAtEnd = true;
+
+		mPrimMapIter = mPrimMap.begin();
+
+		if (mPrimMapIter != mPrimMap.end())
+		{
+			mRange = UsdPrimRange(mPrimMapIter->second, UsdTraverseInstanceProxies());
+			if (mRange.begin() != mRange.end())
+			{
+				mIter = mRange.begin();
+				mAtEnd = false;
+			}
+		}
+	}
+
+	virtual bool atEnd() const override
+	{
+		return mAtEnd;
+	}
+
+	virtual void pruneChildren() override
+	{
+		if (!atEnd())
+			mIter.PruneChildren();
+	}
+
+	virtual UsdPrimRange::const_iterator getCurrent() override
+	{
+		return mIter;
+	}
+
+	virtual void next() override
+	{
+		if (mIter != mRange.end())
+		{
+			mIter++;
+
+			if (mIter == mRange.end())
+			{
+				mPrimMapIter++;
+
+				if (mPrimMapIter == mPrimMap.end())
+				{
+					mAtEnd = true;
+				}
+				else
+				{
+					mRange = UsdPrimRange(mPrimMapIter->second);
+					mIter = mRange.begin();
+				}
+			}
+		}
+	}
 
 private:
-    bool mAtEnd;
+	bool mAtEnd;
 
-    const UsdPrimMap& mPrimMap;
-    UsdPrimMap::const_iterator mPrimMapIter;
+	const UsdPrimMap& mPrimMap;
+	UsdPrimMap::const_iterator mPrimMapIter;
 
-    UsdPrimRange mRange;
-    UsdPrimRange::const_iterator mIter;
+	UsdPrimRange mRange;
+	UsdPrimRange::const_iterator mIter;
 };
 
+using ExcludePathsSet = std::unordered_set<SdfPath, SdfPath::Hash>;
 class ExcludeListPrimIteratorRange : public ParsePrimIteratorBase
 {
 public:
-    /// ExcludeListPrimIteratorRange constructor, this iterator
-    /// takes a regular range as input and exclude set for paths an
-    /// its descendants to get pruned. 
-    ///
-    /// \param[in] range      UsdPrimRange to traverse
-    /// \param[in] pathList   Paths to get pruned
-    ExcludeListPrimIteratorRange(pxr::UsdPrimRange range, const SdfPathVector& pathList)
-     : mRange(range)
-    {
-        for (const SdfPath& path : pathList)
-        {
-            mPathSet.insert(path);
-        }
-        reset();
-    }
-
-    virtual void reset() override
-    {
-        mIter = mRange.begin();
-    }
-
-    virtual void pruneChildren() override
-    {
-        mIter.PruneChildren();
-    }
-
-    virtual bool atEnd() const override
-    {
-        return mIter == mRange.end();
-    }
-
-    virtual pxr::UsdPrimRange::const_iterator getCurrent() override
-    {
-        return mIter;
-    }
-
-    virtual void next() override
-    {
-        if (mIter != mRange.end())
-        {
-            bool validPrim = false;
-            while (!validPrim)
-            {
-                mIter++;
-                if (mIter != mRange.end())
-                {
-                    const pxr::UsdPrim& prim = *mIter;
-                    if (prim)
-                    {
-                        std::unordered_set<pxr::SdfPath, pxr::SdfPath::Hash>::const_iterator fit = mPathSet.find(prim.GetPrimPath());
-                        if (fit != mPathSet.end())
-                        {
-                            mIter.PruneChildren();
-                        }
-                        else
-                        {
-                            validPrim = true;
-                        }
-                    }
-                }
-                else
-                {
-                    validPrim = true;
-                }
-            }
-        }
-    }
+	/// ExcludeListPrimIteratorRange constructor, this iterator
+	/// takes a regular range as input and exclude set for paths an
+	/// its descendants to get pruned. 
+	///
+	/// \param[in] range      UsdPrimRange to traverse
+	/// \param[in] pathList   Paths to get pruned
+	ExcludeListPrimIteratorRange(UsdPrimRange range, const SdfPathVector& pathList)
+		: mRange(range)
+	{
+		for (const SdfPath& path : pathList)
+		{
+			mPathSet.insert(path);
+		}
+		reset();
+	}
+
+	virtual void reset() override
+	{
+		mIter = mRange.begin();
+	}
+
+	virtual void pruneChildren() override
+	{
+		mIter.PruneChildren();
+	}
+
+	virtual bool atEnd() const override
+	{
+		return mIter == mRange.end();
+	}
+
+	virtual UsdPrimRange::const_iterator getCurrent() override
+	{
+		return mIter;
+	}
+
+	virtual void next() override
+	{
+		if (mIter != mRange.end())
+		{
+			bool validPrim = false;
+			while (!validPrim)
+			{
+				mIter++;
+				if (mIter != mRange.end())
+				{
+					const UsdPrim& prim = *mIter;
+					if (prim)
+					{
+						ExcludePathsSet::const_iterator fit = mPathSet.find(prim.GetPrimPath());
+						if (fit != mPathSet.end())
+						{
+							mIter.PruneChildren();
+						}
+						else
+						{
+							validPrim = true;
+						}
+					}
+				}
+				else
+				{
+					validPrim = true;
+				}
+			}
+		}
+	}
 
 private:
-    pxr::UsdPrimRange mRange;
-    pxr::UsdPrimRange::const_iterator mIter;
-    std::unordered_set<pxr::SdfPath, pxr::SdfPath::Hash> mPathSet;
+	UsdPrimRange mRange;
+	UsdPrimRange::const_iterator mIter;
+	ExcludePathsSet mPathSet;
 };
 
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/usd/usdPhysics/parseUtils.cpp b/pxr/usd/usdPhysics/parseUtils.cpp
index f941fa210f..bb0ae9fc5e 100644
--- a/pxr/usd/usdPhysics/parseUtils.cpp
+++ b/pxr/usd/usdPhysics/parseUtils.cpp
@@ -1,25 +1,8 @@
 //
-// Copyright 2021 Pixar
+// Copyright 2024 Pixar
 //
-// Licensed under the Apache License, Version 2.0 (the "Apache License")
-// with the following modification; you may not use this file except in
-// compliance with the Apache License and the following modification to it:
-// Section 6. Trademarks. is deleted and replaced with:
-//
-// 6. Trademarks. This License does not grant permission to use the trade
-//    names, trademarks, service marks, or product names of the Licensor
-//    and its affiliates, except as required to comply with Section 4(c) of
-//    the License and to reproduce the content of the NOTICE file.
-//
-// You may obtain a copy of the Apache License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the Apache License with the above modification is
-// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, either express or implied. See the Apache License for the specific
-// language governing permissions and limitations under the Apache License.
+// Licensed under the terms set forth in the LICENSE.txt file available at
+// https://openusd.org/license.
 //
 
 #include "pxr/pxr.h"
@@ -73,2871 +56,3068 @@ PXR_NAMESPACE_OPEN_SCOPE
 
 void ParseFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
 {
-    UsdPhysicsFilteredPairsAPI filteredPairsAPI = UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
-    if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
-    {
-        filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
-    }
+	UsdPhysicsFilteredPairsAPI filteredPairsAPI =
+		UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
+	if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
+	{
+		filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
+	}
 }
 
-bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI, UsdPhysicsArticulationDesc* articulationDesc)
+bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI,
+	UsdPhysicsArticulationDesc* articulationDesc)
 {
-    if (articulationDesc && articulationAPI)
-    {       
-        ParseFilteredPairs(articulationAPI.GetPrim(), articulationDesc->filteredCollisions);
-
-        articulationDesc->primPath = articulationAPI.GetPrim().GetPrimPath();
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or UsdPhysicsArticulationDesc is not valid.");
-        return false;
-
-    }
-    return true;
+	if (articulationDesc && articulationAPI)
+	{
+		ParseFilteredPairs(articulationAPI.GetPrim(), articulationDesc->filteredCollisions);
+
+		articulationDesc->primPath = articulationAPI.GetPrim().GetPrimPath();
+	}
+	else
+	{
+		TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or UsdPhysicsArticulationDesc is not valid.");
+		return false;
+	}
+	return true;
 }
 
-UsdPhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim, const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
+UsdPhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim,
+	const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
 {
-    UsdPhysicsObjectType::Enum retVal = UsdPhysicsObjectType::eUndefined;
-
-    // custom shape handling
-    bool customShape = false;
-    if (customTokens)
-    {
-        const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
-
-        const TfToken& primType = prim.GetTypeName();
-        for (size_t i = 0; i < customTokens->size(); i++)
-        {
-            for (size_t j = 0; j < apis.size(); j++)
-            {
-                if (apis[j] == (*customTokens)[i])
-                {
-                    retVal = UsdPhysicsObjectType::eCustomShape;
-                    if (customeGeometryToken)
-                        *customeGeometryToken = apis[j];
-                    break;
-                }
-            }
-            if(retVal == UsdPhysicsObjectType::eCustomShape)
-            {
-                break;
-            }
-            if (primType == (*customTokens)[i])
-            {
-                    retVal = UsdPhysicsObjectType::eCustomShape;
-                    if (customeGeometryToken)
-                        *customeGeometryToken = primType;                
-                break;
-            }
-        }
-    }
-
-    if (retVal == UsdPhysicsObjectType::eCustomShape)
-        return retVal;
-
-    // geomgprim that belongs to that collision
-    if (prim.IsA<UsdGeomGprim>())
-    {
-        // If the primitive is a UsdGeomPoints *and* it has a widths attribute
-        // corresponding to the positions attribute, then we treat it as an
-        // array of spheres corresponding to the 'UsdPhysicsSpherePointsShapeDesc'
-        if (prim.IsA<UsdGeomMesh>())
-        {
-            retVal = UsdPhysicsObjectType::eMeshShape;
-        }
-        else if (prim.IsA<UsdGeomCube>())
-        {
-            retVal = UsdPhysicsObjectType::eCubeShape;
-        }
-        else if (prim.IsA<UsdGeomSphere>())
-        {
-            retVal = UsdPhysicsObjectType::eSphereShape;
-        }
-        else if (prim.IsA<UsdGeomCapsule>())
-        {
-            retVal = UsdPhysicsObjectType::eCapsuleShape;
-        }
-        else if (prim.IsA<UsdGeomCylinder>())
-        {
-            retVal = UsdPhysicsObjectType::eCylinderShape;
-        }
-        else if (prim.IsA<UsdGeomCone>())
-        {
-            retVal = UsdPhysicsObjectType::eConeShape;
-        }
-        else if (prim.IsA<UsdGeomPlane>())
-        {
-            retVal = UsdPhysicsObjectType::ePlaneShape;
-        }
-        else if (prim.IsA<UsdGeomPoints>())
-        {
-            retVal = UsdPhysicsObjectType::eSpherePointsShape;
-        }
-    }
-    
-    return retVal;
+	UsdPhysicsObjectType::Enum retVal = UsdPhysicsObjectType::eUndefined;
+
+	// custom shape handling
+	if (customTokens)
+	{
+		const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
+
+		const TfToken& primType = prim.GetTypeName();
+		for (size_t i = 0; i < customTokens->size(); i++)
+		{
+			for (size_t j = 0; j < apis.size(); j++)
+			{
+				if (apis[j] == (*customTokens)[i])
+				{
+					retVal = UsdPhysicsObjectType::eCustomShape;
+					if (customeGeometryToken)
+						*customeGeometryToken = apis[j];
+					break;
+				}
+			}
+			if (retVal == UsdPhysicsObjectType::eCustomShape)
+			{
+				break;
+			}
+			if (primType == (*customTokens)[i])
+			{
+				retVal = UsdPhysicsObjectType::eCustomShape;
+				if (customeGeometryToken)
+					*customeGeometryToken = primType;
+				break;
+			}
+		}
+	}
+
+	if (retVal == UsdPhysicsObjectType::eCustomShape)
+		return retVal;
+
+	// geomgprim that belongs to that collision
+	if (prim.IsA<UsdGeomGprim>())
+	{
+		// If the primitive is a UsdGeomPoints *and* it has a widths attribute
+		// corresponding to the positions attribute, then we treat it as an
+		// array of spheres corresponding to the 'UsdPhysicsSpherePointsShapeDesc'
+		if (prim.IsA<UsdGeomMesh>())
+		{
+			retVal = UsdPhysicsObjectType::eMeshShape;
+		}
+		else if (prim.IsA<UsdGeomCube>())
+		{
+			retVal = UsdPhysicsObjectType::eCubeShape;
+		}
+		else if (prim.IsA<UsdGeomSphere>())
+		{
+			retVal = UsdPhysicsObjectType::eSphereShape;
+		}
+		else if (prim.IsA<UsdGeomCapsule>())
+		{
+			retVal = UsdPhysicsObjectType::eCapsuleShape;
+		}
+		else if (prim.IsA<UsdGeomCylinder>())
+		{
+			retVal = UsdPhysicsObjectType::eCylinderShape;
+		}
+		else if (prim.IsA<UsdGeomCone>())
+		{
+			retVal = UsdPhysicsObjectType::eConeShape;
+		}
+		else if (prim.IsA<UsdGeomPlane>())
+		{
+			retVal = UsdPhysicsObjectType::ePlaneShape;
+		}
+		else if (prim.IsA<UsdGeomPoints>())
+		{
+			retVal = UsdPhysicsObjectType::eSpherePointsShape;
+		}
+	}
+
+	return retVal;
 }
 
 const double tolerance = 1e-4;
 
 void CheckNonUniformScale(const GfVec3d& scale, const SdfPath& primPath)
 {
-    if (abs(scale[0] - scale[1]) > tolerance || abs(scale[0] - scale[2]) > tolerance || abs(scale[2] - scale[1]) > tolerance)
-    {
-        TF_DIAGNOSTIC_WARNING("Non-uniform scale may result in a non matching collision representation on prim: %s", primPath.GetText());
-    }
+	if (abs(scale[0] - scale[1]) > tolerance || abs(scale[0] - scale[2]) > tolerance ||
+		abs(scale[2] - scale[1]) > tolerance)
+	{
+		TF_DIAGNOSTIC_WARNING(
+			"Non-uniform scale may result in a non matching collision representation on prim : %s", primPath.GetText());
+	}
 }
 
 
 pxr::SdfPath GetMaterialBinding(const pxr::UsdPrim& usdPrim)
 {
-    SdfPath materialPath = SdfPath();
-
-    const static TfToken physicsPurpose("physics");
-    UsdShadeMaterialBindingAPI materialBindingAPI = UsdShadeMaterialBindingAPI(usdPrim);
-    if (materialBindingAPI)
-    {
-        UsdShadeMaterial material = materialBindingAPI.ComputeBoundMaterial(physicsPurpose);
-        if (material)
-        {
-            materialPath = material.GetPrim().GetPrimPath();
-        }
-    }
-    else
-    {
-        // handle material through a direct binding rel search
-        std::vector<UsdPrim> prims;
-        prims.push_back(usdPrim);
-        std::vector<UsdShadeMaterial> materials =
-            UsdShadeMaterialBindingAPI::ComputeBoundMaterials(prims, physicsPurpose);
-        if (!materials.empty() && materials[0])
-        {
-            materialPath = materials[0].GetPrim().GetPrimPath();
-        }
-    }
-
-    return materialPath;
+	SdfPath materialPath = SdfPath();
+
+	const static TfToken physicsPurpose("physics");
+	UsdShadeMaterialBindingAPI materialBindingAPI = UsdShadeMaterialBindingAPI(usdPrim);
+	if (materialBindingAPI)
+	{
+		UsdShadeMaterial material = materialBindingAPI.ComputeBoundMaterial(physicsPurpose);
+		if (material)
+		{
+			materialPath = material.GetPrim().GetPrimPath();
+		}
+	}
+	else
+	{
+		// handle material through a direct binding rel search
+		std::vector<UsdPrim> prims;
+		prims.push_back(usdPrim);
+		std::vector<UsdShadeMaterial> materials =
+			UsdShadeMaterialBindingAPI::ComputeBoundMaterials(prims, physicsPurpose);
+		if (!materials.empty() && materials[0])
+		{
+			materialPath = materials[0].GetPrim().GetPrimPath();
+		}
+	}
+
+	return materialPath;
 }
 
 static void ParseColFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
-{    
-    UsdPhysicsFilteredPairsAPI filteredPairsAPI = UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
-    if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
-    {
-        filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
-    }
+{
+	UsdPhysicsFilteredPairsAPI filteredPairsAPI =
+		UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
+	if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
+	{
+		filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
+	}
 }
 
 void FinalizeDesc(const UsdPhysicsCollisionAPI& colAPI, UsdPhysicsShapeDesc& desc)
 {
-    // set the collider material as last
-    // set SdfPath() anyway, this would indicate default material should be used, this is required for trimesh subset materials
-    // as not alway all faces are covered with a subset material
-    const SdfPath& materialPath = GetMaterialBinding(colAPI.GetPrim());
-    if (materialPath != SdfPath())
-    {
-        const UsdPrim materialPrim = colAPI.GetPrim().GetStage()->GetPrimAtPath(materialPath);
-        if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
-            desc.materials.push_back(materialPath);
-        else
-            desc.materials.push_back(SdfPath());
-    }
-    else
-    {
-        desc.materials.push_back(SdfPath());
-    }
-
-    ParseColFilteredPairs(colAPI.GetPrim(), desc.filteredCollisions);
-    colAPI.GetCollisionEnabledAttr().Get(&desc.collisionEnabled);
-    const UsdRelationship ownerRel = colAPI.GetSimulationOwnerRel();
-    if (ownerRel)
-    {
-        ownerRel.GetTargets(&desc.simulationOwners);
-    }
+	// set the collider material as last
+	// set SdfPath() anyway, this would indicate default material should be used, 
+	// this is required for trimesh subset materials
+	// as not alway all faces are covered with a subset material
+	const SdfPath& materialPath = GetMaterialBinding(colAPI.GetPrim());
+	if (materialPath != SdfPath())
+	{
+		const UsdPrim materialPrim = colAPI.GetPrim().GetStage()->GetPrimAtPath(materialPath);
+		if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
+			desc.materials.push_back(materialPath);
+		else
+			desc.materials.push_back(SdfPath());
+	}
+	else
+	{
+		desc.materials.push_back(SdfPath());
+	}
+
+	ParseColFilteredPairs(colAPI.GetPrim(), desc.filteredCollisions);
+	colAPI.GetCollisionEnabledAttr().Get(&desc.collisionEnabled);
+	const UsdRelationship ownerRel = colAPI.GetSimulationOwnerRel();
+	if (ownerRel)
+	{
+		ownerRel.GetTargets(&desc.simulationOwners);
+	}
 }
 
 
-bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsSphereShapeDesc* sphereShapeDesc)
+bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsSphereShapeDesc* sphereShapeDesc)
 {
-    if (sphereShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomSphere shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            float radius = 1.0f;
-
-            // Check scale, its part of the collision size
-            {
-                const pxr::GfVec3d sc = tr.GetScale();
-                // as we dont support scale in physics and scale can be non uniform
-                // we pick the largest scale value as the sphere radius base
-                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                radius = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))), fabsf(float(sc[2])));
-            }
-
-            // Get shape parameters
-            {
-
-                double radiusAttr;
-                shape.GetRadiusAttr().Get(&radiusAttr);
-                radius *= (float)radiusAttr;
-            }
-
-            sphereShapeDesc->radius = fabsf(radius);
-            sphereShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *sphereShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomSphere.");
-            return false;
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsSphereShapeDesc is not valid.");
-        return false;
-    }
-    return true;
-}
+	if (sphereShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomSphere shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCubeShapeDesc* cubeShapeDesc)
-{
-    if (cubeShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomCube shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            GfVec3f halfExtents;
-
-            // Add scale
-            {
-                const pxr::GfVec3d sc = tr.GetScale();
-                // scale is taken, its a part of the cube size, as the physics does not support scale
-                halfExtents = GfVec3f(sc);
-            }
-
-            // Get shape parameters
-            {
-                UsdGeomCube shape(usdPrim);
-                double sizeAttr;
-                shape.GetSizeAttr().Get(&sizeAttr);
-                sizeAttr = abs(sizeAttr) * 0.5f; // convert cube edge length to half extend
-                halfExtents *= (float)sizeAttr;
-            }
-
-            cubeShapeDesc->halfExtents = halfExtents;
-            cubeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *cubeShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCube.");
-            return false;
-        }        
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCubeShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+			float radius = 1.0f;
 
-bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCylinderShapeDesc* cylinderShapeDesc)
-{
-    if (cylinderShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomCylinder shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            float radius = 1.0f;
-            float halfHeight = 1.0f;
-            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-            // Get shape parameters
-            {
-                double radiusAttr;
-                shape.GetRadiusAttr().Get(&radiusAttr);
-                double heightAttr;
-                shape.GetHeightAttr().Get(&heightAttr);
-                radius = (float)radiusAttr;
-                halfHeight = (float)heightAttr * 0.5f;
-
-                TfToken capAxis;
-                if (shape.GetAxisAttr())
-                {
-                    shape.GetAxisAttr().Get(&capAxis);
-                    if (capAxis == UsdPhysicsTokens.Get()->y)
-                        axis = UsdPhysicsAxis::eY;
-                    else if (capAxis == UsdPhysicsTokens.Get()->z)
-                        axis = UsdPhysicsAxis::eZ;
-                }
-            }
-
-            {
-                // scale the radius and height based on the given axis token
-                const pxr::GfVec3d sc = tr.GetScale();
-                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                if (axis == UsdPhysicsAxis::eX)
-                {
-                    halfHeight *= float(sc[0]);
-                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
-                }
-                else if (axis == UsdPhysicsAxis::eY)
-                {
-                    halfHeight *= float(sc[1]);
-                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
-                }
-                else
-                {
-                    halfHeight *= float(sc[2]);
-                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
-                }
-            }
-            cylinderShapeDesc->radius = fabsf(radius);
-            cylinderShapeDesc->axis = axis;
-            cylinderShapeDesc->halfHeight = fabsf(halfHeight);
-            cylinderShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *cylinderShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCylinder.");
-            return false;
-        }        
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCylinderShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+			// Check scale, its part of the collision size
+			{
+				const pxr::GfVec3d sc = tr.GetScale();
+				// as we dont support scale in physics and scale can be non uniform
+				// we pick the largest scale value as the sphere radius base
+				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+				radius = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))),
+					fabsf(float(sc[2])));
+			}
 
-bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCapsuleShapeDesc* capsuleShapeDesc)
-{
-    if (capsuleShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomCapsule shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            float radius = 1.0f;
-            float halfHeight = 1.0f;
-            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-            // Get shape parameters
-            {
-                double radiusAttr;
-                shape.GetRadiusAttr().Get(&radiusAttr);
-                double heightAttr;
-                shape.GetHeightAttr().Get(&heightAttr);
-                radius = (float)radiusAttr;
-                halfHeight = (float)heightAttr * 0.5f;
-
-                TfToken capAxis;
-                if (shape.GetAxisAttr())
-                {
-                    shape.GetAxisAttr().Get(&capAxis);
-                    if (capAxis == UsdPhysicsTokens.Get()->y)
-                        axis = UsdPhysicsAxis::eY;
-                    else if (capAxis == UsdPhysicsTokens.Get()->z)
-                        axis = UsdPhysicsAxis::eZ;
-                }
-            }
-
-            {
-                // scale the radius and height based on the given axis token
-                const pxr::GfVec3d sc = tr.GetScale();
-                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                if (axis == UsdPhysicsAxis::eX)
-                {
-                    halfHeight *= float(sc[0]);
-                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
-                }
-                else if (axis == UsdPhysicsAxis::eY)
-                {
-                    halfHeight *= float(sc[1]);
-                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
-                }
-                else
-                {
-                    halfHeight *= float(sc[2]);
-                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
-                }
-            }
-            capsuleShapeDesc->radius = fabsf(radius);
-            capsuleShapeDesc->axis = axis;
-            capsuleShapeDesc->halfHeight = fabsf(halfHeight);
-            capsuleShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *capsuleShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCapsule.");
-            return false;
-        }        
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCapsuleShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+			// Get shape parameters
+			{
 
-bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsConeShapeDesc* coneShapeDesc)
-{
-    if (coneShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomCone shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            float radius = 1.0f;
-            float halfHeight = 1.0f;
-            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-            // Get shape parameters
-            {
-                double radiusAttr;
-                shape.GetRadiusAttr().Get(&radiusAttr);
-                double heightAttr;
-                shape.GetHeightAttr().Get(&heightAttr);
-                radius = (float)radiusAttr;
-                halfHeight = (float)heightAttr * 0.5f;
-
-                TfToken capAxis;
-                if (shape.GetAxisAttr())
-                {
-                    shape.GetAxisAttr().Get(&capAxis);
-                    if (capAxis == UsdPhysicsTokens.Get()->y)
-                        axis = UsdPhysicsAxis::eY;
-                    else if (capAxis == UsdPhysicsTokens.Get()->z)
-                        axis = UsdPhysicsAxis::eZ;
-                }
-            }
-
-            {
-                // scale the radius and height based on the given axis token
-                const pxr::GfVec3d sc = tr.GetScale();
-                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                if (axis == UsdPhysicsAxis::eX)
-                {
-                    halfHeight *= float(sc[0]);
-                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
-                }
-                else if (axis == UsdPhysicsAxis::eY)
-                {
-                    halfHeight *= float(sc[1]);
-                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
-                }
-                else
-                {
-                    halfHeight *= float(sc[2]);
-                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
-                }
-            }
-            coneShapeDesc->radius = fabsf(radius);
-            coneShapeDesc->axis = axis;
-            coneShapeDesc->halfHeight = fabsf(halfHeight);
-            coneShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *coneShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCone.");
-            return false;
-        }          
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsConeShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+				double radiusAttr;
+				shape.GetRadiusAttr().Get(&radiusAttr);
+				radius *= (float)radiusAttr;
+			}
 
-bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsMeshShapeDesc* meshShapeDesc)
-{
-    if (meshShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomMesh shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            const pxr::GfVec3d sc = tr.GetScale();
-            meshShapeDesc->meshScale = GfVec3f(sc);
-
-            // Get approximation type
-            meshShapeDesc->approximation = UsdPhysicsTokens.Get()->none;
-            UsdPhysicsMeshCollisionAPI physicsColMeshAPI(usdPrim);
-            if (physicsColMeshAPI)
-            {
-                physicsColMeshAPI.GetApproximationAttr().Get(&meshShapeDesc->approximation);
-            }
-
-            shape.GetDoubleSidedAttr().Get(&meshShapeDesc->doubleSided);
-
-            // Gather materials through subsets
-            const std::vector<pxr::UsdGeomSubset> subsets = pxr::UsdGeomSubset::GetGeomSubsets(shape, pxr::UsdGeomTokens->face);
-            if (!subsets.empty())
-            {
-                for (const pxr::UsdGeomSubset& subset : subsets)
-                {
-                    const pxr::SdfPath material = GetMaterialBinding(subset.GetPrim());
-                    if (material != SdfPath())
-                    {
-                        const UsdPrim materialPrim = usdPrim.GetStage()->GetPrimAtPath(material);
-                        if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
-                        {
-                            meshShapeDesc->materials.push_back(material);
-                        }
-                    }
-                }
-            }
-
-            meshShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *meshShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomMesh.");
-            return false;
-        }         
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsMeshShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+			sphereShapeDesc->radius = fabsf(radius);
+			sphereShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
-bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsPlaneShapeDesc* planeShapeDesc)
-{
-    if (planeShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomPlane shape(usdPrim);
-        if (shape)
-        {
-            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;     
-
-            TfToken tfAxis;            
-            shape.GetAxisAttr().Get(&tfAxis);
-            if (tfAxis == UsdPhysicsTokens.Get()->y)
-            {
-                axis = UsdPhysicsAxis::eY;
-            }
-            else if (tfAxis == UsdPhysicsTokens.Get()->z)
-            {
-                axis = UsdPhysicsAxis::eZ;
-            }
-
-            planeShapeDesc->axis = axis;            
-            planeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *planeShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPlane.");
-            return false;
-        }           
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsPlaneShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
+			FinalizeDesc(collisionAPI, *sphereShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomSphere.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsSphereShapeDesc is not valid.");
+		return false;
+	}
+	return true;
 }
 
-bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsSpherePointsShapeDesc* spherePointsShapeDesc)
+bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsCubeShapeDesc* cubeShapeDesc)
 {
-    if (spherePointsShapeDesc && collisionAPI)
-    {       
-        const UsdPrim usdPrim = collisionAPI.GetPrim();
-        const UsdGeomPoints shape(usdPrim);
-        if (shape)
-        {
-            const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-            VtArray<float> widths;
-            VtArray<GfVec3f> positions;
-            shape.GetWidthsAttr().Get(&widths);
-            if (widths.size())
-            {
-                shape.GetPointsAttr().Get(&positions);
-                if (positions.size() == widths.size())
-                {
-                    float sphereScale = 1.0f;
-                    {
-                        const pxr::GfVec3d sc = tr.GetScale();
-
-                        // as we don't support scale in physics and scale can be non uniform
-                        // we pick the largest scale value as the sphere radius base
-                        CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-                        sphereScale = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))), fabsf(float(sc[2])));
-                    }
-                    
-                    const size_t scount = positions.size();
-                    spherePointsShapeDesc->spherePoints.resize(scount);
-                    for (size_t i=0; i<scount; i++)
-                    {
-                        spherePointsShapeDesc->spherePoints[i].radius = sphereScale * widths[i] * 0.5f;
-                        spherePointsShapeDesc->spherePoints[i].center = positions[i];
-                    }                                        
-                }
-                else
-                {
-                    TF_DIAGNOSTIC_WARNING("UsdGeomPoints width array size does not match position array size: %s", usdPrim.GetPrimPath().GetText());
-                    spherePointsShapeDesc->isValid = false;
-                }
-            }
-            else
-            {
-                TF_DIAGNOSTIC_WARNING("UsdGeomPoints width array not filled: %s", usdPrim.GetPrimPath().GetText());
-                spherePointsShapeDesc->isValid = false;
-            }
-            
-            spherePointsShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-            FinalizeDesc(collisionAPI, *spherePointsShapeDesc);
-        }
-        else
-        {
-            TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPoints.");
-            return false;
-        }        
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsSpherePointsShapeDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+	if (cubeShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomCube shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI, UsdPhysicsCustomShapeDesc* customShapeDesc)
-{
-    if (customShapeDesc && collisionAPI)
-    {       
+			GfVec3f halfExtents;
 
-        customShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+			// Add scale
+			{
+				const pxr::GfVec3d sc = tr.GetScale();
+				// scale is taken, its a part of the cube size, as the physics 
+				// does not support scale
+				halfExtents = GfVec3f(sc);
+			}
 
-        FinalizeDesc(collisionAPI, *customShapeDesc);
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionAPI or UsdPhysicsCustomShapeDesc is not valid.");
-        return false;
+			// Get shape parameters
+			{
+				UsdGeomCube shape(usdPrim);
+				double sizeAttr;
+				shape.GetSizeAttr().Get(&sizeAttr);
+				// convert cube edge length to half extend
+				sizeAttr = abs(sizeAttr) * 0.5f;
+				halfExtents *= (float)sizeAttr;
+			}
 
-    }
-    return true;
-}
+			cubeShapeDesc->halfExtents = halfExtents;
+			cubeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
+			FinalizeDesc(collisionAPI, *cubeShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCube.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCubeShapeDesc is not valid.");
+		return false;
 
-bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup, UsdPhysicsCollisionGroupDesc* collisionGroupDesc)
-{
-    if (collisionGroup && collisionGroupDesc)
-    {        
-        const UsdRelationship rel = collisionGroup.GetFilteredGroupsRel();
-        if (rel)
-        {
-            rel.GetTargets(&collisionGroupDesc->filteredGroups);
-        }
-
-        collisionGroup.GetInvertFilteredGroupsAttr().Get(&collisionGroupDesc->invertFilteredGroups);
-        collisionGroup.GetMergeGroupNameAttr().Get(&collisionGroupDesc->mergeGroupName);
-
-        collisionGroupDesc->primPath = collisionGroup.GetPrim().GetPrimPath();
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsCollisionGroup or UsdPhysicsCollisionGroupDesc is not valid.");
-        return false;
-    }
-
-    return true;
+	}
+	return true;
 }
 
-SdfPath GetRel(const pxr::UsdRelationship& ref, const pxr::UsdPrim& jointPrim)
+bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsCylinderShapeDesc* cylinderShapeDesc)
 {
-    pxr::SdfPathVector targets;
-    ref.GetTargets(&targets);
-
-    if (targets.size() == 0)
-    {
-        return SdfPath();
-    }
-    if (targets.size() > 1)
-    {
-        TF_DIAGNOSTIC_WARNING("Joint prim does have relationship to multiple bodies this is not supported, jointPrim %s", jointPrim.GetPrimPath().GetText());
-        return targets.at(0);
-    }
-
-    return targets.at(0);
-}
+	if (cylinderShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomCylinder shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-bool CheckJointRel(const SdfPath& relPath, const UsdPrim& jointPrim)
-{
-    if (relPath == SdfPath())
-        return true;
-
-    const UsdPrim relPrim = jointPrim.GetStage()->GetPrimAtPath(relPath);
-    if (!relPrim)
-    {
-        TF_RUNTIME_ERROR("Joint (%s) body relationship %s points to a non existent prim, joint will not be parsed.", jointPrim.GetPrimPath().GetText(), relPath.GetText());
-        return false;
-    }
-    return true;
-}
+			float radius = 1.0f;
+			float halfHeight = 1.0f;
+			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
-pxr::UsdPrim GetBodyPrim(UsdStageWeakPtr stage, const SdfPath& relPath, UsdPrim& relPrim)
-{
-    UsdPrim parent = stage->GetPrimAtPath(relPath);
-    relPrim = parent;
-    UsdPrim collisionPrim = UsdPrim();
-    while (parent && parent != stage->GetPseudoRoot())
-    {        
-        if (parent.HasAPI<UsdPhysicsRigidBodyAPI>())
-        {
-            return parent;
-        }
-        if (parent.HasAPI<UsdPhysicsCollisionAPI>())
-        {
-            collisionPrim = parent;
-        }
-        parent = parent.GetParent();
-    }
-
-    return collisionPrim;
-}
+			// Get shape parameters
+			{
+				double radiusAttr;
+				shape.GetRadiusAttr().Get(&radiusAttr);
+				double heightAttr;
+				shape.GetHeightAttr().Get(&heightAttr);
+				radius = (float)radiusAttr;
+				halfHeight = (float)heightAttr * 0.5f;
+
+				TfToken capAxis;
+				if (shape.GetAxisAttr())
+				{
+					shape.GetAxisAttr().Get(&capAxis);
+					if (capAxis == UsdPhysicsTokens.Get()->y)
+						axis = UsdPhysicsAxis::eY;
+					else if (capAxis == UsdPhysicsTokens.Get()->z)
+						axis = UsdPhysicsAxis::eZ;
+				}
+			}
 
-SdfPath GetLocalPose(UsdStageWeakPtr stage, const SdfPath& relPath, GfVec3f& t, GfQuatf& q)
-{
-    UsdPrim relPrim;    
-    const UsdPrim body = GetBodyPrim(stage, relPath, relPrim);    
-
-    // get scale and apply it into localPositions vectors
-    const UsdGeomXformable xform(relPrim);
-    const GfMatrix4d worldRel = relPrim ? xform.ComputeLocalToWorldTransform(UsdTimeCode::Default()) : GfMatrix4d(1.0);
-
-    // we need to apply scale to the localPose, the scale comes from the rigid body
-    GfVec3f sc;
-    // if we had a rel not to rigid body, we need to recompute the localPose
-    if (relPrim != body)
-    {
-        GfMatrix4d localAnchor;
-        localAnchor.SetIdentity();
-        localAnchor.SetTranslate(GfVec3d(t));
-        localAnchor.SetRotateOnly(GfQuatd(q));
-
-        GfMatrix4d bodyMat;
-        if (body)
-            bodyMat = UsdGeomXformable(body).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-        else
-            bodyMat.SetIdentity();
-        
-        const GfMatrix4d worldAnchor = localAnchor * worldRel;
-        GfMatrix4d bodyLocalAnchor = worldAnchor * bodyMat.GetInverse();
-        bodyLocalAnchor = bodyLocalAnchor.RemoveScaleShear();
-
-        t = GfVec3f(bodyLocalAnchor.ExtractTranslation());
-        q = GfQuatf(bodyLocalAnchor.ExtractRotationQuat());
-        q.Normalize();
-
-        const GfTransform tr(bodyMat);
-        sc = GfVec3f(tr.GetScale());
-    }
-    else
-    {
-        const GfTransform tr(worldRel);
-        sc = GfVec3f(tr.GetScale());
-    }
-
-    // apply the scale, this is not obvious, but in physics there is no scale, so we need to
-    // apply it before its send to physics
-    for (int i = 0; i < 3; i++)
-    {
-        t[i] *= sc[i];
-    }
-
-    return body ? body.GetPrimPath() : SdfPath();
-}
+			{
+				// scale the radius and height based on the given axis token
+				const pxr::GfVec3d sc = tr.GetScale();
+				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+				if (axis == UsdPhysicsAxis::eX)
+				{
+					halfHeight *= float(sc[0]);
+					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+				}
+				else if (axis == UsdPhysicsAxis::eY)
+				{
+					halfHeight *= float(sc[1]);
+					radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+				}
+				else
+				{
+					halfHeight *= float(sc[2]);
+					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+				}
+			}
+			cylinderShapeDesc->radius = fabsf(radius);
+			cylinderShapeDesc->axis = axis;
+			cylinderShapeDesc->halfHeight = fabsf(halfHeight);
+			cylinderShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
-void FinalizeJoint(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
-{
-    // joint bodies anchor point local transforms    
-    GfVec3f t0(0.f);
-    GfVec3f t1(0.f);
-    GfQuatf q0(1.f);
-    GfQuatf q1(1.f);
-    jointPrim.GetLocalPos0Attr().Get(&t0);
-    jointPrim.GetLocalRot0Attr().Get(&q0);
-    jointPrim.GetLocalPos1Attr().Get(&t1);
-    jointPrim.GetLocalRot1Attr().Get(&q1);
-
-    q0.Normalize();
-    q1.Normalize();
-
-    UsdStageWeakPtr stage = jointPrim.GetPrim().GetStage();
-
-    // get scale and apply it into localPositions vectors
-    if (jointDesc->rel0 != SdfPath())
-    {
-        jointDesc->body0 = GetLocalPose(stage, jointDesc->rel0, t0, q0);
-    }
-
-    if (jointDesc->rel1 != SdfPath())
-    {
-        jointDesc->body1 = GetLocalPose(stage, jointDesc->rel1, t1, q1);
-    }
-
-    jointDesc->localPose0Position = t0;
-    jointDesc->localPose0Orientation = q0;
-    jointDesc->localPose1Position = t1;
-    jointDesc->localPose1Orientation = q1;
+			FinalizeDesc(collisionAPI, *cylinderShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCylinder.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCylinderShapeDesc is not valid.");
+		return false;
+
+	}
+	return true;
 }
 
-bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
+bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsCapsuleShapeDesc* capsuleShapeDesc)
 {
-    const UsdPrim prim = jointPrim.GetPrim();
-
-    jointDesc->primPath = prim.GetPrimPath();
+	if (capsuleShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomCapsule shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-    // parse the joint common parameters
-    jointPrim.GetJointEnabledAttr().Get(&jointDesc->jointEnabled);
-    jointPrim.GetCollisionEnabledAttr().Get(&jointDesc->collisionEnabled);
-    jointPrim.GetBreakForceAttr().Get(&jointDesc->breakForce);            
-    jointPrim.GetBreakTorqueAttr().Get(&jointDesc->breakTorque);
-    jointPrim.GetExcludeFromArticulationAttr().Get(&jointDesc->excludeFromArticulation);
+			float radius = 1.0f;
+			float halfHeight = 1.0f;
+			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
-    jointDesc->rel0 = GetRel(jointPrim.GetBody0Rel(), prim);
-    jointDesc->rel1 = GetRel(jointPrim.GetBody1Rel(), prim);
+			// Get shape parameters
+			{
+				double radiusAttr;
+				shape.GetRadiusAttr().Get(&radiusAttr);
+				double heightAttr;
+				shape.GetHeightAttr().Get(&heightAttr);
+				radius = (float)radiusAttr;
+				halfHeight = (float)heightAttr * 0.5f;
+
+				TfToken capAxis;
+				if (shape.GetAxisAttr())
+				{
+					shape.GetAxisAttr().Get(&capAxis);
+					if (capAxis == UsdPhysicsTokens.Get()->y)
+						axis = UsdPhysicsAxis::eY;
+					else if (capAxis == UsdPhysicsTokens.Get()->z)
+						axis = UsdPhysicsAxis::eZ;
+				}
+			}
 
-    // check rel validity
-    if (!CheckJointRel(jointDesc->rel0, prim) || !CheckJointRel(jointDesc->rel1, prim))
-    {
-        return false;
-    }
+			{
+				// scale the radius and height based on the given axis token
+				const pxr::GfVec3d sc = tr.GetScale();
+				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+				if (axis == UsdPhysicsAxis::eX)
+				{
+					halfHeight *= float(sc[0]);
+					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+				}
+				else if (axis == UsdPhysicsAxis::eY)
+				{
+					halfHeight *= float(sc[1]);
+					radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+				}
+				else
+				{
+					halfHeight *= float(sc[2]);
+					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+				}
+			}
+			capsuleShapeDesc->radius = fabsf(radius);
+			capsuleShapeDesc->axis = axis;
+			capsuleShapeDesc->halfHeight = fabsf(halfHeight);
+			capsuleShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
-    FinalizeJoint(jointPrim, jointDesc);
+			FinalizeDesc(collisionAPI, *capsuleShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCapsule.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCapsuleShapeDesc is not valid.");
+		return false;
 
-    return true;
+	}
+	return true;
 }
 
-bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint, UsdPhysicsDistanceJointDesc* distanceJointDesc)
+bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsConeShapeDesc* coneShapeDesc)
 {
-    if (distanceJointDesc && distanceJoint)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(distanceJoint, distanceJointDesc))
-        {
-            return false;
-        }
-
-        distanceJointDesc->maxEnabled = false;
-        distanceJointDesc->minEnabled = false;
-        distanceJoint.GetMinDistanceAttr().Get(&distanceJointDesc->limit.minDist);
-        distanceJoint.GetMaxDistanceAttr().Get(&distanceJointDesc->limit.maxDist);
-            
-        if (distanceJointDesc->limit.minDist >= 0.0f)
-        {
-            distanceJointDesc->minEnabled = true;
-                
-        }
-        if (distanceJointDesc->limit.maxDist >= 0.0f)
-        {
-            distanceJointDesc->maxEnabled = true;
-                
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsDistanceJoint or UsdPhysicsDistanceJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
-}
+	if (coneShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomCone shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-bool ParseDrive(const UsdPhysicsDriveAPI& drive, UsdPhysicsJointDrive* jointDrive)
-{
-    if (drive && jointDrive)
-    {
-        drive.GetTargetPositionAttr().Get(&jointDrive->targetPosition);
-        drive.GetTargetVelocityAttr().Get(&jointDrive->targetVelocity);
-        drive.GetMaxForceAttr().Get(&jointDrive->forceLimit);    
-
-        drive.GetDampingAttr().Get(&jointDrive->damping);
-        drive.GetStiffnessAttr().Get(&jointDrive->stiffness);    
-
-        TfToken typeToken;
-        drive.GetTypeAttr().Get(&typeToken);
-        if (typeToken == UsdPhysicsTokens->acceleration)
-            jointDrive->acceleration = true;
-        jointDrive->enabled = true;
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsDriveAPI or UsdPhysicsJointDrive is not valid.");
-        return false;
-    }
-
-    return true;
-}
+			float radius = 1.0f;
+			float halfHeight = 1.0f;
+			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
-bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint, UsdPhysicsFixedJointDesc* fixedJointDesc)
-{
-    if (fixedJointDesc && fixedJoint)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(fixedJoint, fixedJointDesc))
-        {
-            return false;
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsFixedJoint or UsdPhysicsFixedJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
-}
+			// Get shape parameters
+			{
+				double radiusAttr;
+				shape.GetRadiusAttr().Get(&radiusAttr);
+				double heightAttr;
+				shape.GetHeightAttr().Get(&heightAttr);
+				radius = (float)radiusAttr;
+				halfHeight = (float)heightAttr * 0.5f;
+
+				TfToken capAxis;
+				if (shape.GetAxisAttr())
+				{
+					shape.GetAxisAttr().Get(&capAxis);
+					if (capAxis == UsdPhysicsTokens.Get()->y)
+						axis = UsdPhysicsAxis::eY;
+					else if (capAxis == UsdPhysicsTokens.Get()->z)
+						axis = UsdPhysicsAxis::eZ;
+				}
+			}
 
-bool ParseLimit(const UsdPhysicsLimitAPI& limit, UsdPhysicsJointLimit* jointLimit)
-{
-    if (limit && jointLimit)
-    {
-        limit.GetLowAttr().Get(&jointLimit->lower);
-        limit.GetHighAttr().Get(&jointLimit->upper);
-        if ((isfinite(jointLimit->lower) && jointLimit->lower > -usdPhysicsSentinelLimit) ||
-            (isfinite(jointLimit->upper) && jointLimit->upper < usdPhysicsSentinelLimit))
-                jointLimit->enabled = true;
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsLimitAPI or UsdPhysicsJointLimit is not valid.");
-        return false;
-    }
-
-    return true;
-}
+			{
+				// scale the radius and height based on the given axis token
+				const pxr::GfVec3d sc = tr.GetScale();
+				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+				if (axis == UsdPhysicsAxis::eX)
+				{
+					halfHeight *= float(sc[0]);
+					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+				}
+				else if (axis == UsdPhysicsAxis::eY)
+				{
+					halfHeight *= float(sc[1]);
+					radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+				}
+				else
+				{
+					halfHeight *= float(sc[2]);
+					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+				}
+			}
+			coneShapeDesc->radius = fabsf(radius);
+			coneShapeDesc->axis = axis;
+			coneShapeDesc->halfHeight = fabsf(halfHeight);
+			coneShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
-bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsD6JointDesc* jointDesc)
-{    
-    if (jointDesc && jointPrim)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(jointPrim, jointDesc))
-        {
-            return false;
-        }
-
-        // D6 joint        
-        const std::array<std::pair<UsdPhysicsJointDOF::Enum, TfToken>, 7> axisVector = {
-            std::make_pair(UsdPhysicsJointDOF::eDistance, UsdPhysicsTokens->distance), std::make_pair(UsdPhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
-            std::make_pair(UsdPhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),     std::make_pair(UsdPhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
-            std::make_pair(UsdPhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),         std::make_pair(UsdPhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
-            std::make_pair(UsdPhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
-        };
-
-        for (size_t i = 0; i < axisVector.size(); i++)
-        {
-            const TfToken& axisToken = axisVector[i].second;
-
-            const UsdPhysicsLimitAPI limitAPI = UsdPhysicsLimitAPI::Get(jointPrim.GetPrim(), axisToken);
-            if (limitAPI)
-            {
-                UsdPhysicsJointLimit limit;
-                if (ParseLimit(limitAPI, &limit))
-                {
-                    jointDesc->jointLimits.push_back(std::make_pair(axisVector[i].first, limit));
-                }                
-            }
-
-            const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(jointPrim.GetPrim(), axisToken);
-            if (driveAPI)
-            {
-                UsdPhysicsJointDrive drive;
-                if (ParseDrive(driveAPI, &drive))
-                {
-                    jointDesc->jointDrives.push_back(std::make_pair(axisVector[i].first, drive));
-                }
-            }
-        }    
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
-}
+			FinalizeDesc(collisionAPI, *coneShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCone.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsConeShapeDesc is not valid.");
+		return false;
 
-bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsCustomJointDesc* customJointDesc)
-{
-    if (customJointDesc && jointPrim)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(jointPrim, customJointDesc))
-        {
-            return false;
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
+	}
+	return true;
 }
 
-bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial, UsdPhysicsRigidBodyMaterialDesc* rbMaterialDesc)
+bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsMeshShapeDesc* meshShapeDesc)
 {
-    if (rbMaterialDesc && usdMaterial)
-    {       
-        usdMaterial.GetDynamicFrictionAttr().Get(&rbMaterialDesc->dynamicFriction);
-        usdMaterial.GetStaticFrictionAttr().Get(&rbMaterialDesc->staticFriction);
+	if (meshShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomMesh shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-        usdMaterial.GetRestitutionAttr().Get(&rbMaterialDesc->restitution);
+			const pxr::GfVec3d sc = tr.GetScale();
+			meshShapeDesc->meshScale = GfVec3f(sc);
 
-        usdMaterial.GetDensityAttr().Get(&rbMaterialDesc->density);            
+			// Get approximation type
+			meshShapeDesc->approximation = UsdPhysicsTokens.Get()->none;
+			UsdPhysicsMeshCollisionAPI physicsColMeshAPI(usdPrim);
+			if (physicsColMeshAPI)
+			{
+				physicsColMeshAPI.GetApproximationAttr().Get(&meshShapeDesc->approximation);
+			}
 
-        rbMaterialDesc->primPath = usdMaterial.GetPrim().GetPrimPath();
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsMaterialAPI or UsdPhysicsRigidBodyMaterialDesc is not valid.");
-        return false;
+			shape.GetDoubleSidedAttr().Get(&meshShapeDesc->doubleSided);
 
-    }
-    return true;
-}
+			// Gather materials through subsets
+			const std::vector<pxr::UsdGeomSubset> subsets =
+				pxr::UsdGeomSubset::GetGeomSubsets(shape, pxr::UsdGeomTokens->face);
+			if (!subsets.empty())
+			{
+				for (const pxr::UsdGeomSubset& subset : subsets)
+				{
+					const pxr::SdfPath material = GetMaterialBinding(subset.GetPrim());
+					if (material != SdfPath())
+					{
+						const UsdPrim materialPrim = usdPrim.GetStage()->GetPrimAtPath(material);
+						if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
+						{
+							meshShapeDesc->materials.push_back(material);
+						}
+					}
+				}
+			}
 
-bool ParseLinearDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
-{
-    dst->enabled = false;
-    const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->linear);
-    if (driveAPI)
-    {
-        return ParseDrive(driveAPI, dst);
-    }
-
-    return true;
-}
+			meshShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
+			FinalizeDesc(collisionAPI, *meshShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomMesh.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsMeshShapeDesc is not valid.");
+		return false;
 
-bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint, UsdPhysicsPrismaticJointDesc* prismaticJointDesc)
-{
-    if (prismaticJointDesc && prismaticJoint)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(prismaticJoint, prismaticJointDesc))
-        {
-            return false;
-        }
-
-        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
-        TfToken axis = UsdPhysicsTokens->x;            
-        prismaticJoint.GetAxisAttr().Get(&axis);
-
-        if (axis == UsdPhysicsTokens->y)
-            jointAxis = UsdPhysicsAxis::eY;
-        else if (axis == UsdPhysicsTokens->z)
-            jointAxis = UsdPhysicsAxis::eZ;
-        prismaticJointDesc->axis = jointAxis;
-
-        prismaticJointDesc->limit.enabled = false;
-        prismaticJoint.GetLowerLimitAttr().Get(&prismaticJointDesc->limit.lower);
-        prismaticJoint.GetUpperLimitAttr().Get(&prismaticJointDesc->limit.upper);
-        if ((isfinite(prismaticJointDesc->limit.lower) && (prismaticJointDesc->limit.lower > -usdPhysicsSentinelLimit)) || 
-            (isfinite(prismaticJointDesc->limit.upper) && (prismaticJointDesc->limit.upper < usdPhysicsSentinelLimit)))
-        {
-            prismaticJointDesc->limit.enabled = true;
-        }
-
-        if (!ParseLinearDrive(&prismaticJointDesc->drive, prismaticJoint.GetPrim()))
-        {
-            return false;
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsPrismaticJoint or UsdPhysicsPrismaticJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
+	}
+	return true;
 }
 
-bool ParseAngularDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
+bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsPlaneShapeDesc* planeShapeDesc)
 {
-    dst->enabled = false;
-    const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->angular);
-    if (driveAPI)
-    {
-        return ParseDrive(driveAPI, dst);
-    }
-
-    return true;
-}
-
+	if (planeShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomPlane shape(usdPrim);
+		if (shape)
+		{
+			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
 
-bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint, UsdPhysicsRevoluteJointDesc* revoluteJointDesc)
-{
-    if (revoluteJointDesc && revoluteJoint)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(revoluteJoint, revoluteJointDesc))
-        {
-            return false;
-        }
-
-        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
-        TfToken axis = UsdPhysicsTokens->x;
-        revoluteJoint.GetAxisAttr().Get(&axis);
-
-        if (axis == UsdPhysicsTokens->y)
-            jointAxis = UsdPhysicsAxis::eY;
-        else if (axis == UsdPhysicsTokens->z)
-            jointAxis = UsdPhysicsAxis::eZ;
-        revoluteJointDesc->axis = jointAxis;
-
-        revoluteJointDesc->limit.enabled = false;
-
-        
-        revoluteJoint.GetLowerLimitAttr().Get(&revoluteJointDesc->limit.lower);
-        revoluteJoint.GetUpperLimitAttr().Get(&revoluteJointDesc->limit.upper);
-        if (isfinite(revoluteJointDesc->limit.lower) && isfinite(revoluteJointDesc->limit.upper)
-            && revoluteJointDesc->limit.lower > -usdPhysicsSentinelLimit && revoluteJointDesc->limit.upper < usdPhysicsSentinelLimit)
-        {
-            revoluteJointDesc->limit.enabled = true;
-        }
-
-        if (!ParseAngularDrive(&revoluteJointDesc->drive, revoluteJoint.GetPrim()))
-        {
-            return false;
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
-}
+			TfToken tfAxis;
+			shape.GetAxisAttr().Get(&tfAxis);
+			if (tfAxis == UsdPhysicsTokens.Get()->y)
+			{
+				axis = UsdPhysicsAxis::eY;
+			}
+			else if (tfAxis == UsdPhysicsTokens.Get()->z)
+			{
+				axis = UsdPhysicsAxis::eZ;
+			}
 
-template<typename T>
-inline bool ScaleIsUniform(T scaleX, T scaleY, T scaleZ, T eps = T(1.0e-5))
-{
-    // Find min and max scale values
-    T lo, hi;
-
-    if (scaleX < scaleY)
-    {
-        lo = scaleX;
-        hi = scaleY;
-    }
-    else
-    {
-        lo = scaleY;
-        hi = scaleX;
-    }
-    
-    if (scaleZ < lo)
-    {
-        lo = scaleZ;
-    }
-    else if (scaleZ > hi)
-    {
-        hi = scaleZ;
-    }
-    
-    if (lo*hi < 0.0)
-    {
-        return false;   // opposite signs
-    }
-
-    return hi > 0.0 ? hi - lo <= eps*lo : lo - hi >= eps*hi;
-}
+			planeShapeDesc->axis = axis;
+			planeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
 
+			FinalizeDesc(collisionAPI, *planeShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPlane.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsPlaneShapeDesc is not valid.");
+		return false;
 
-void GetRigidBodyTransformation(const UsdPrim& bodyPrim, UsdPhysicsRigidBodyDesc& desc)
-{
-    const GfMatrix4d mat = UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-    const GfTransform tr(mat);
-    const GfVec3d pos = tr.GetTranslation();
-    const GfQuatd rot = tr.GetRotation().GetQuat();
-    const GfVec3d sc = tr.GetScale();
-
-    if (!ScaleIsUniform(sc[0], sc[1], sc[2]) && tr.GetScaleOrientation().GetQuaternion() != GfQuaternion::GetIdentity())
-    {
-        TF_DIAGNOSTIC_WARNING("ScaleOrientation is not supported for rigid bodies, prim path: %s. You may ignore this if the scale is close to uniform.", bodyPrim.GetPrimPath().GetText());
-    }
-
-    desc.position = GfVec3f(pos);
-    desc.rotation = GfQuatf(rot);
-    desc.scale = GfVec3f(sc);
+	}
+	return true;
 }
 
-bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI, UsdPhysicsRigidBodyDesc* rigidBodyDesc)
+bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsSpherePointsShapeDesc* spherePointsShapeDesc)
 {
-    if (rigidBodyDesc && rigidBodyAPI)
-    {       
-        if (!rigidBodyAPI.GetPrim().IsA<UsdGeomXformable>())
-        {
-            TF_DIAGNOSTIC_WARNING("RigidBodyAPI applied to a non-xformable primitive. (%s)", rigidBodyAPI.GetPrim().GetPrimPath().GetText());
-            return false;
-        }
-
-        // check instancing
-        {
-            bool reportInstanceError = false;
-            if (rigidBodyAPI.GetPrim().IsInstanceProxy())
-            {
-                reportInstanceError = true;
-
-                bool kinematic = false;
-                rigidBodyAPI.GetKinematicEnabledAttr().Get(&kinematic);
-                if (kinematic)
-                    reportInstanceError = false;
-
-                bool enabled = false;
-                rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&enabled);
-                if (!enabled)
-                    reportInstanceError = false;
-
-                if (reportInstanceError)
-                {
-                    TF_DIAGNOSTIC_WARNING("RigidBodyAPI on an instance proxy not supported. %s", rigidBodyAPI.GetPrim().GetPrimPath().GetText());
-                    return false;
-                }
-            }
-        }
-
-        // transformation
-        GetRigidBodyTransformation(rigidBodyAPI.GetPrim(), *rigidBodyDesc);
-
-        // filteredPairs
-        ParseFilteredPairs(rigidBodyAPI.GetPrim(), rigidBodyDesc->filteredCollisions);
-
-        // velocity
-        rigidBodyAPI.GetVelocityAttr().Get(&rigidBodyDesc->linearVelocity);
-        rigidBodyAPI.GetAngularVelocityAttr().Get(&rigidBodyDesc->angularVelocity);
-
-        // rigid body flags
-        rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&rigidBodyDesc->rigidBodyEnabled);
-        rigidBodyAPI.GetKinematicEnabledAttr().Get(&rigidBodyDesc->kinematicBody);
-        rigidBodyAPI.GetStartsAsleepAttr().Get(&rigidBodyDesc->startsAsleep);
-
-        // simulation owner
-        const UsdRelationship ownerRel = rigidBodyAPI.GetSimulationOwnerRel();
-        if (ownerRel)
-        {
-            SdfPathVector owners;
-            ownerRel.GetTargets(&owners);
-            if (!owners.empty())
-            {
-                rigidBodyDesc->simulationOwners = owners;
-            }
-        }
-        rigidBodyDesc->primPath = rigidBodyAPI.GetPrim().GetPrimPath();
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsRigidBodyAPI or UsdPhysicsRigidBodyDesc is not valid.");
-        return false;
-
-    }
-    return true;
-}
+	if (spherePointsShapeDesc && collisionAPI)
+	{
+		const UsdPrim usdPrim = collisionAPI.GetPrim();
+		const UsdGeomPoints shape(usdPrim);
+		if (shape)
+		{
+			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
 
-bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint, UsdPhysicsSphericalJointDesc* sphericalJointDesc)
-{
-    if (sphericalJointDesc && sphericalJoint)
-    {
-        // parse the joint common parameters
-        if (!ParseCommonJointDesc(sphericalJoint, sphericalJointDesc))
-        {
-            return false;
-        }
-
-        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
-        TfToken axis = UsdPhysicsTokens->x;
-        sphericalJoint.GetAxisAttr().Get(&axis);
-
-        if (axis == UsdPhysicsTokens->y)
-            jointAxis = UsdPhysicsAxis::eY;
-        else if (axis == UsdPhysicsTokens->z)
-            jointAxis = UsdPhysicsAxis::eZ;
-        sphericalJointDesc->axis = jointAxis;
-
-        sphericalJointDesc->limit.enabled = false;
-        sphericalJoint.GetConeAngle0LimitAttr().Get(&sphericalJointDesc->limit.angle0);
-        sphericalJoint.GetConeAngle1LimitAttr().Get(&sphericalJointDesc->limit.angle1);
-
-        if (isfinite(sphericalJointDesc->limit.angle0) && isfinite(sphericalJointDesc->limit.angle1)
-            && sphericalJointDesc->limit.angle0 >= 0.0 && sphericalJointDesc->limit.angle1 >= 0.0)
-        {
-            sphericalJointDesc->limit.enabled = true;
-        }
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsSphericalJoint or UsdPhysicsSphericalJointDesc is not valid.");
-        return false;
-    }
-
-    return true;
-}
+			VtArray<float> widths;
+			VtArray<GfVec3f> positions;
+			shape.GetWidthsAttr().Get(&widths);
+			if (widths.size())
+			{
+				shape.GetPointsAttr().Get(&positions);
+				if (positions.size() == widths.size())
+				{
+					float sphereScale = 1.0f;
+					{
+						const pxr::GfVec3d sc = tr.GetScale();
 
-bool ParseSceneDesc(const UsdPhysicsScene& scene, UsdPhysicsSceneDesc* sceneDesc)
-{
-    if (sceneDesc && scene)
-    {
-        UsdStageWeakPtr stage = scene.GetPrim().GetStage();
-
-        GfVec3f gravityDirection;
-        scene.GetGravityDirectionAttr().Get(&gravityDirection);
-        if (gravityDirection == GfVec3f(0.0f))
-        {
-            TfToken upAxis = pxr::UsdGeomGetStageUpAxis(stage);
-            if (upAxis == pxr::UsdGeomTokens.Get()->x)
-                gravityDirection = GfVec3f(-1.0f, 0.0f, 0.0f);
-            else if (upAxis == pxr::UsdGeomTokens.Get()->y)
-                gravityDirection = GfVec3f(0.0f, -1.0f, 0.0f);
-            else
-                gravityDirection = GfVec3f(0.0f, 0.0f, -1.0f);
-        }
-        else
-        {
-            gravityDirection.Normalize();
-        }
-
-        float gravityMagnitude;
-        scene.GetGravityMagnitudeAttr().Get(&gravityMagnitude);
-        if (gravityMagnitude < -0.5e38f)
-        {
-            float metersPerUnit = (float)pxr::UsdGeomGetStageMetersPerUnit(stage);
-            gravityMagnitude = 9.81f / metersPerUnit;
-        }
-
-        sceneDesc->gravityMagnitude = gravityMagnitude;
-        sceneDesc->gravityDirection = gravityDirection;
-        sceneDesc->primPath = scene.GetPrim().GetPrimPath();
-    }
-    else
-    {
-        TF_RUNTIME_ERROR("Provided UsdPhysicsScene or UsdPhysicsSceneDesc is not valid.");
-        return false;
-    }
-    return true;
-}
+						// as we don't support scale in physics and scale can be non uniform
+						// we pick the largest scale value as the sphere radius base
+						CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+						sphereScale = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))),
+							fabsf(float(sc[2])));
+					}
 
-struct SchemaAPIFlag
-{
-    enum Enum
-    {
-        eArticulationRootAPI = 1 << 0,
-        eCollisionAPI   = 1 << 1,
-        eRigidBodyAPI   = 1 << 2,
-        eMaterialAPI    = 1 << 3
-    };
-};
+					const size_t scount = positions.size();
+					spherePointsShapeDesc->spherePoints.resize(scount);
+					for (size_t i = 0; i < scount; i++)
+					{
+						spherePointsShapeDesc->spherePoints[i].radius =
+							sphereScale * widths[i] * 0.5f;
+						spherePointsShapeDesc->spherePoints[i].center = positions[i];
+					}
+				}
+				else
+				{
+					TF_DIAGNOSTIC_WARNING(
+						"UsdGeomPoints width array size does not match position array size: %s",
+						usdPrim.GetPrimPath().GetText());
+					spherePointsShapeDesc->isValid = false;
+				}
+			}
+			else
+			{
+				TF_DIAGNOSTIC_WARNING(
+					"UsdGeomPoints width array not filled: %s",
+					usdPrim.GetPrimPath().GetText());
+				spherePointsShapeDesc->isValid = false;
+			}
+
+			spherePointsShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+			FinalizeDesc(collisionAPI, *spherePointsShapeDesc);
+		}
+		else
+		{
+			TF_RUNTIME_ERROR(
+				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPoints.");
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsSpherePointsShapeDesc is not valid.");
+		return false;
+	}
+	return true;
+}
 
-bool CheckNestedArticulationRoot(const pxr::UsdPrim& usdPrim, const std::unordered_set<SdfPath, SdfPath::Hash>& articulationSet)
+bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
+	UsdPhysicsCustomShapeDesc* customShapeDesc)
 {
-    UsdPrim parent = usdPrim.GetParent();
-    while (parent && parent != usdPrim.GetStage()->GetPseudoRoot())
-    {
-        if (articulationSet.find(parent.GetPrimPath()) != articulationSet.end())
-            return true;
-        parent = parent.GetParent();
-    }
-
-    return false;
+	if (customShapeDesc && collisionAPI)
+	{
+
+		customShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+		FinalizeDesc(collisionAPI, *customShapeDesc);
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCustomShapeDesc is not valid.");
+		return false;
+	}
+	return true;
 }
 
-using RigidBodyMap = std::map<pxr::SdfPath, UsdPhysicsRigidBodyDesc*>;
 
-bool IsDynamicBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, bool& physicsAPIFound)
+bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup,
+	UsdPhysicsCollisionGroupDesc* collisionGroupDesc)
 {
-    RigidBodyMap::const_iterator it = bodyMap.find(usdPrim.GetPrimPath());
-    if (it != bodyMap.end())
-    {
-        {
-            bool isAPISchemaEnabled = it->second->rigidBodyEnabled;
-
-            // Prim is dynamic body off PhysicsAPI is present and enabled
-            physicsAPIFound = true;
-            return isAPISchemaEnabled;
-        }
-    }
-
-    physicsAPIFound = false;
-    return false;
+	if (collisionGroup && collisionGroupDesc)
+	{
+		const UsdRelationship rel = collisionGroup.GetFilteredGroupsRel();
+		if (rel)
+		{
+			rel.GetTargets(&collisionGroupDesc->filteredGroups);
+		}
+
+		collisionGroup.GetInvertFilteredGroupsAttr().Get(&collisionGroupDesc->invertFilteredGroups);
+		collisionGroup.GetMergeGroupNameAttr().Get(&collisionGroupDesc->mergeGroupName);
+
+		collisionGroupDesc->primPath = collisionGroup.GetPrim().GetPrimPath();
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsCollisionGroup or UsdPhysicsCollisionGroupDesc is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
+SdfPath GetRel(const pxr::UsdRelationship& ref, const pxr::UsdPrim& jointPrim)
+{
+	pxr::SdfPathVector targets;
+	ref.GetTargets(&targets);
+
+	if (targets.size() == 0)
+	{
+		return SdfPath();
+	}
+	if (targets.size() > 1)
+	{
+		TF_DIAGNOSTIC_WARNING(
+			"Joint prim does have relationship to multiple bodies this is not supported, jointPrim %s",
+			jointPrim.GetPrimPath().GetText());
+		return targets.at(0);
+	}
+
+	return targets.at(0);
+}
 
-bool HasDynamicBodyParent(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, UsdPrim& bodyPrimPath)
+bool CheckJointRel(const SdfPath& relPath, const UsdPrim& jointPrim)
 {
-    bool physicsAPIFound = false;    
-    UsdPrim parent = usdPrim;
-    while (parent != usdPrim.GetStage()->GetPseudoRoot())
-    {
-        if (IsDynamicBody(parent, bodyMap, physicsAPIFound))
-        {
-            bodyPrimPath = parent;
-            return true;
-        }
-
-        if (physicsAPIFound)
-        {
-            bodyPrimPath = parent;
-            return false;
-        }
-
-        parent = parent.GetParent();
-    }
-    return false;
+	if (relPath == SdfPath())
+		return true;
+
+	const UsdPrim relPrim = jointPrim.GetStage()->GetPrimAtPath(relPath);
+	if (!relPrim)
+	{
+		TF_RUNTIME_ERROR(
+			"Joint (%s) body relationship %s points to a non existent prim, joint will not be parsed.",
+			jointPrim.GetPrimPath().GetText(),
+			relPath.GetText());
+		return false;
+	}
+	return true;
 }
 
+pxr::UsdPrim GetBodyPrim(UsdStageWeakPtr stage, const SdfPath& relPath, UsdPrim& relPrim)
+{
+	UsdPrim parent = stage->GetPrimAtPath(relPath);
+	relPrim = parent;
+	UsdPrim collisionPrim = UsdPrim();
+	while (parent && parent != stage->GetPseudoRoot())
+	{
+		if (parent.HasAPI<UsdPhysicsRigidBodyAPI>())
+		{
+			return parent;
+		}
+		if (parent.HasAPI<UsdPhysicsCollisionAPI>())
+		{
+			collisionPrim = parent;
+		}
+		parent = parent.GetParent();
+	}
+
+	return collisionPrim;
+}
 
-template <typename DescType, typename UsdType> 
-void ProcessPhysicsPrims(const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc, 
-    std::function<bool(const UsdType& prim, DescType* desc)> processDescFn)
+SdfPath GetLocalPose(UsdStageWeakPtr stage, const SdfPath& relPath, GfVec3f& t,
+	GfQuatf& q)
 {
-    if (!physicsPrims.empty())
-    {
-        const size_t numPrims = physicsPrims.size();
-        physicsDesc.resize(numPrims);
-
-        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
-        {
-            for (size_t i = beginIdx; i < endIdx; i++)
-            {
-                const UsdType prim(physicsPrims[i]);
-                const bool ret = processDescFn(prim, &physicsDesc[i]);
-                if (!ret)
-                {
-                    physicsDesc[i].isValid = false;
-                }
-            }
-        };
-
-        const size_t numPrimPerBatch = 10;
-        WorkParallelForN(numPrims, workLambda, numPrimPerBatch);
-    }
+	UsdPrim relPrim;
+	const UsdPrim body = GetBodyPrim(stage, relPath, relPrim);
+
+	// get scale and apply it into localPositions vectors
+	const UsdGeomXformable xform(relPrim);
+	const GfMatrix4d worldRel = relPrim ? xform.ComputeLocalToWorldTransform(UsdTimeCode::Default()) : GfMatrix4d(1.0);
+
+	// we need to apply scale to the localPose, the scale comes from the rigid body
+	GfVec3f sc;
+	// if we had a rel not to rigid body, we need to recompute the localPose
+	if (relPrim != body)
+	{
+		GfMatrix4d localAnchor;
+		localAnchor.SetIdentity();
+		localAnchor.SetTranslate(GfVec3d(t));
+		localAnchor.SetRotateOnly(GfQuatd(q));
+
+		GfMatrix4d bodyMat;
+		if (body)
+			bodyMat = UsdGeomXformable(body).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+		else
+			bodyMat.SetIdentity();
+
+		const GfMatrix4d worldAnchor = localAnchor * worldRel;
+		GfMatrix4d bodyLocalAnchor = worldAnchor * bodyMat.GetInverse();
+		bodyLocalAnchor = bodyLocalAnchor.RemoveScaleShear();
+
+		t = GfVec3f(bodyLocalAnchor.ExtractTranslation());
+		q = GfQuatf(bodyLocalAnchor.ExtractRotationQuat());
+		q.Normalize();
+
+		const GfTransform tr(bodyMat);
+		sc = GfVec3f(tr.GetScale());
+	}
+	else
+	{
+		const GfTransform tr(worldRel);
+		sc = GfVec3f(tr.GetScale());
+	}
+
+	// apply the scale, this is not obvious, but in physics there is no scale, 
+	// so we need to apply it before its send to physics
+	for (int i = 0; i < 3; i++)
+	{
+		t[i] *= sc[i];
+	}
+
+	return body ? body.GetPrimPath() : SdfPath();
 }
 
-template <typename DescType> 
-void CallReportFn(UsdPhysicsObjectType::Enum descType, const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc, 
-    UsdPhysicsReportFn reportFn, SdfPathVector& primPathsVector, void* userData)
+void FinalizeJoint(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
 {
-    primPathsVector.resize(physicsPrims.size());
-    for (size_t i = 0; i < physicsPrims.size(); i++)
-    {
-        primPathsVector[i] = physicsPrims[i].GetPrimPath();
-    }
-    reportFn(descType, primPathsVector.size(), primPathsVector.data(), physicsDesc.data(), userData);
+	// joint bodies anchor point local transforms    
+	GfVec3f t0(0.f);
+	GfVec3f t1(0.f);
+	GfQuatf q0(1.f);
+	GfQuatf q1(1.f);
+	jointPrim.GetLocalPos0Attr().Get(&t0);
+	jointPrim.GetLocalRot0Attr().Get(&q0);
+	jointPrim.GetLocalPos1Attr().Get(&t1);
+	jointPrim.GetLocalRot1Attr().Get(&q1);
+
+	q0.Normalize();
+	q1.Normalize();
+
+	UsdStageWeakPtr stage = jointPrim.GetPrim().GetStage();
+
+	// get scale and apply it into localPositions vectors
+	if (jointDesc->rel0 != SdfPath())
+	{
+		jointDesc->body0 = GetLocalPose(stage, jointDesc->rel0, t0, q0);
+	}
+
+	if (jointDesc->rel1 != SdfPath())
+	{
+		jointDesc->body1 = GetLocalPose(stage, jointDesc->rel1, t1, q1);
+	}
+
+	jointDesc->localPose0Position = t0;
+	jointDesc->localPose0Orientation = q0;
+	jointDesc->localPose1Position = t1;
+	jointDesc->localPose1Orientation = q1;
 }
 
-void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims, std::vector<UsdPhysicsRigidBodyDesc>& rigidBodyDescs, 
-    bool defaultSimulationOwner, std::unordered_set<SdfPath, SdfPath::Hash>& reportedBodies,
-    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
 {
-    for (size_t i = rigidBodyDescs.size(); i--;)
-    {
-        bool ownerFound = false;
-        const UsdPhysicsRigidBodyDesc& desc = rigidBodyDescs[i];
-        if (desc.isValid)
-        {
-            if (desc.simulationOwners.empty() && defaultSimulationOwner)
-            {                
-                reportedBodies.insert(desc.primPath);
-                ownerFound = true;
-            }
-            else
-            {
-                for (const SdfPath& owner : desc.simulationOwners)
-                {
-                    if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-                    {
-                        reportedBodies.insert(desc.primPath);
-                        ownerFound = true;
-                        break;
-                    }
-                }
-            }
-        }
-        if (!ownerFound)
-        {
-            rigidBodyDescs[i] = rigidBodyDescs.back();
-            rigidBodyDescs.pop_back();
-            rigidBodyPrims[i] = rigidBodyPrims.back();
-            rigidBodyPrims.pop_back();
-        }
-    }    
+	const UsdPrim prim = jointPrim.GetPrim();
+
+	jointDesc->primPath = prim.GetPrimPath();
+
+	// parse the joint common parameters
+	jointPrim.GetJointEnabledAttr().Get(&jointDesc->jointEnabled);
+	jointPrim.GetCollisionEnabledAttr().Get(&jointDesc->collisionEnabled);
+	jointPrim.GetBreakForceAttr().Get(&jointDesc->breakForce);
+	jointPrim.GetBreakTorqueAttr().Get(&jointDesc->breakTorque);
+	jointPrim.GetExcludeFromArticulationAttr().Get(&jointDesc->excludeFromArticulation);
+
+	jointDesc->rel0 = GetRel(jointPrim.GetBody0Rel(), prim);
+	jointDesc->rel1 = GetRel(jointPrim.GetBody1Rel(), prim);
+
+	// check rel validity
+	if (!CheckJointRel(jointDesc->rel0, prim) || !CheckJointRel(jointDesc->rel1, prim))
+	{
+		return false;
+	}
+
+	FinalizeJoint(jointPrim, jointDesc);
+
+	return true;
 }
 
-// if collision belongs to a body that we care about include it
-// if collision does not belong to a body we care about its not included
-// if collision does not have a body set, we check its own simulationOwners
-template <typename DescType> 
-void CheckCollisionSimulationOwner(std::vector<UsdPrim>& collisionPrims, std::vector<DescType>& shapeDesc, 
-    bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
-    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint,
+	UsdPhysicsDistanceJointDesc* distanceJointDesc)
 {
-	for (size_t i = shapeDesc.size(); i--;)
+	if (distanceJointDesc && distanceJoint)
 	{
-		bool ownerFound = false;
-		const UsdPhysicsShapeDesc& desc = shapeDesc[i];
-		if (desc.isValid)
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(distanceJoint, distanceJointDesc))
 		{
-			if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
-			{
-				if (desc.rigidBody != SdfPath() && rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
-				{
-					ownerFound = true;
-				}
-				else
-				{
-					if (desc.rigidBody == SdfPath())
-					{
-						if (desc.simulationOwners.empty() && defaultSimulationOwner)
-						{
-							ownerFound = true;
-						}
-						else
-						{
-							for (const SdfPath& owner : desc.simulationOwners)
-							{
-								if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-								{
-									ownerFound = true;
-									break;
-								}
-							}
-						}
-					}
-				}
-
-				ownerFound = true;
-			}
-			else
-			{
-				if (desc.rigidBody == SdfPath())
-				{
-					if (desc.simulationOwners.empty() && defaultSimulationOwner)
-					{
-						ownerFound = true;
-					}
-					else
-					{
-						for (const SdfPath& owner : desc.simulationOwners)
-						{
-							if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-							{
-								ownerFound = true;
-								break;
-							}
-						}
-					}
-				}
-			}
+			return false;
 		}
 
-		if (!ownerFound)
+		distanceJointDesc->maxEnabled = false;
+		distanceJointDesc->minEnabled = false;
+		distanceJoint.GetMinDistanceAttr().Get(&distanceJointDesc->limit.minDist);
+		distanceJoint.GetMaxDistanceAttr().Get(&distanceJointDesc->limit.maxDist);
+
+		if (distanceJointDesc->limit.minDist >= 0.0f)
 		{
-			shapeDesc[i] = shapeDesc.back();
-			shapeDesc.pop_back();
-			collisionPrims[i] = collisionPrims.back();
-			collisionPrims.pop_back();
+			distanceJointDesc->minEnabled = true;
+
+		}
+		if (distanceJointDesc->limit.maxDist >= 0.0f)
+		{
+			distanceJointDesc->maxEnabled = true;
+
 		}
 	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsDistanceJoint or UsdPhysicsDistanceJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-// Both bodies need to have simulation owners valid
-template <typename DescType> 
-void CheckJointSimulationOwner(std::vector<UsdPrim>& jointPrims, std::vector<DescType>& jointDesc, 
-    bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
-    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+bool ParseDrive(const UsdPhysicsDriveAPI& drive, UsdPhysicsJointDrive* jointDrive)
 {
-    for (size_t i = jointDesc.size(); i--;)
-    {
-        const UsdPhysicsJointDesc& desc = jointDesc[i];
-
-        bool ownersValid = false;
-        if (desc.isValid)
-        {
-            if ((desc.body0 == SdfPath() || rigidBodiesSet.find(desc.body0) != rigidBodiesSet.end()) &&
-                (desc.body1 == SdfPath() || rigidBodiesSet.find(desc.body1) != rigidBodiesSet.end()))
-                {
-                    ownersValid = true;
-                }
-        }
-
-        if (!ownersValid)
-        {
-            jointDesc[i] = jointDesc.back();
-            jointDesc.pop_back();
-            jointPrims[i] = jointPrims.back();
-            jointPrims.pop_back();
-        }
-    }
+	if (drive && jointDrive)
+	{
+		drive.GetTargetPositionAttr().Get(&jointDrive->targetPosition);
+		drive.GetTargetVelocityAttr().Get(&jointDrive->targetVelocity);
+		drive.GetMaxForceAttr().Get(&jointDrive->forceLimit);
+
+		drive.GetDampingAttr().Get(&jointDrive->damping);
+		drive.GetStiffnessAttr().Get(&jointDrive->stiffness);
+
+		TfToken typeToken;
+		drive.GetTypeAttr().Get(&typeToken);
+		if (typeToken == UsdPhysicsTokens->acceleration)
+			jointDrive->acceleration = true;
+		jointDrive->enabled = true;
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsDriveAPI or UsdPhysicsJointDrive is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-// all bodies must have valid owner
-void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims, std::vector<UsdPhysicsArticulationDesc>& articulationDescs, 
-    bool defaultSimulationOwner, const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
-    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint,
+	UsdPhysicsFixedJointDesc* fixedJointDesc)
 {
-    for (size_t i = articulationDescs.size(); i--;)
-    {
-        const UsdPhysicsArticulationDesc& desc = articulationDescs[i];
-
-        bool ownersValid = true;
-        if (desc.isValid)
-        {
-            for (const SdfPath& body : desc.articulatedBodies)
-            {
-                if (body != SdfPath() && rigidBodiesSet.find(body) == rigidBodiesSet.end())
-                {
-                    ownersValid = false;
-                    break;
-                }
-            }
-        }
-
-        if (!ownersValid)
-        {
-            articulationDescs[i] = articulationDescs.back();
-            articulationDescs.pop_back();
-            articulationPrims[i] = articulationPrims.back();
-            articulationPrims.pop_back();
-        }
-    }   
+	if (fixedJointDesc && fixedJoint)
+	{
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(fixedJoint, fixedJointDesc))
+		{
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsFixedJoint or UsdPhysicsFixedJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-SdfPath GetRigidBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap)
+bool ParseLimit(const UsdPhysicsLimitAPI& limit, UsdPhysicsJointLimit* jointLimit)
 {
-    UsdPrim bodyPrim = UsdPrim();
-    UsdPhysicsRigidBodyDesc* body = nullptr;
-    if (HasDynamicBodyParent(usdPrim, bodyMap, bodyPrim))
-    {
-       return bodyPrim.GetPrimPath();
-    }
-    else
-    {
-        // collision does not have a dynamic body parent, it is considered a static collision        
-        if (bodyPrim == UsdPrim())
-        {
-            return SdfPath();
-        }
-        else
-        {
-            return bodyPrim.GetPrimPath();
-        }
-    }
+	if (limit && jointLimit)
+	{
+		limit.GetLowAttr().Get(&jointLimit->lower);
+		limit.GetHighAttr().Get(&jointLimit->upper);
+		if ((isfinite(jointLimit->lower) && jointLimit->lower > -usdPhysicsSentinelLimit) ||
+			(isfinite(jointLimit->upper) && jointLimit->upper < usdPhysicsSentinelLimit))
+			jointLimit->enabled = true;
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsLimitAPI or UsdPhysicsJointLimit is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-void GetCollisionShapeLocalTransfrom(const UsdPrim& collisionPrim, const UsdPrim& bodyPrim,
-    GfVec3f& localPosOut,
-    GfQuatf& localRotOut,
-    GfVec3f& localScaleOut)
+bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsD6JointDesc* jointDesc)
 {
-    // body transform
-    const GfMatrix4d bodyLocalToWorldMatrix = UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-
-    // compute the shape rel transform to a body and store it.
-    pxr::GfVec3f localPos(0.0f);
-    if (collisionPrim != bodyPrim)
-    {
-        const GfMatrix4d collisionLocalToWorldMatrix = UsdGeomXformable(collisionPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-        
-        const pxr::GfMatrix4d mat = collisionLocalToWorldMatrix * bodyLocalToWorldMatrix.GetInverse();
-        GfTransform colLocalTransform(mat);
-
-        localPos = pxr::GfVec3f(colLocalTransform.GetTranslation());
-        localRotOut = pxr::GfQuatf(colLocalTransform.GetRotation().GetQuat());
-        localScaleOut = pxr::GfVec3f(colLocalTransform.GetScale());
-    }
-    else
-    {
-        const pxr::GfMatrix4d mat(1.0);
-
-        localRotOut = pxr::GfQuatf(1.0f);
-        localScaleOut = pxr::GfVec3f(1.0f);
-    }
-
-    // now apply the body scale to localPos
-    // physics does not support scales, so a rigid body scale has to be baked into the localPos
-    const pxr::GfTransform tr(bodyLocalToWorldMatrix);
-    const pxr::GfVec3d sc = tr.GetScale();
-
-    for (int i = 0; i < 3; i++)
-    {
-        localPos[i] *= (float)sc[i];
-    }
-
-    localPosOut = localPos;
+	if (jointDesc && jointPrim)
+	{
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(jointPrim, jointDesc))
+		{
+			return false;
+		}
+
+		// D6 joint        
+		const std::array<std::pair<UsdPhysicsJointDOF::Enum, TfToken>, 7> axisVector =
+		{
+			std::make_pair(UsdPhysicsJointDOF::eDistance, UsdPhysicsTokens->distance),
+			std::make_pair(UsdPhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
+			std::make_pair(UsdPhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),
+			std::make_pair(UsdPhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
+			std::make_pair(UsdPhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),
+			std::make_pair(UsdPhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
+			std::make_pair(UsdPhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
+		};
+
+		for (size_t i = 0; i < axisVector.size(); i++)
+		{
+			const TfToken& axisToken = axisVector[i].second;
+
+			const UsdPhysicsLimitAPI limitAPI = UsdPhysicsLimitAPI::Get(jointPrim.GetPrim(),
+				axisToken);
+			if (limitAPI)
+			{
+				UsdPhysicsJointLimit limit;
+				if (ParseLimit(limitAPI, &limit))
+				{
+					jointDesc->jointLimits.push_back(std::make_pair(axisVector[i].first, limit));
+				}
+			}
+
+			const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(jointPrim.GetPrim(),
+				axisToken);
+			if (driveAPI)
+			{
+				UsdPhysicsJointDrive drive;
+				if (ParseDrive(driveAPI, &drive))
+				{
+					jointDesc->jointDrives.push_back(std::make_pair(axisVector[i].first, drive));
+				}
+			}
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-void FinalizeCollision(UsdStageWeakPtr stage, const UsdPhysicsRigidBodyDesc* bodyDesc, UsdPhysicsShapeDesc* shapeDesc)
+bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim,
+	UsdPhysicsCustomJointDesc* customJointDesc)
 {
-    // get shape local pose
-    const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
-    GetCollisionShapeLocalTransfrom(shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
-        shapeDesc->localPos, shapeDesc->localRot, shapeDesc->localScale);
-
-    if (bodyDesc)
-    {
-        shapeDesc->rigidBody = bodyDesc->primPath;
-    }
+	if (customJointDesc && jointPrim)
+	{
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(jointPrim, customJointDesc))
+		{
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-template <typename DescType> 
-void FinalizeCollisionDescs(UsdGeomXformCache& xfCache, const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc, 
-    const RigidBodyMap& bodyMap, const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
+bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial,
+	UsdPhysicsRigidBodyMaterialDesc* rbMaterialDesc)
 {
-    const auto workLambda = [physicsPrims, &physicsDesc, bodyMap, collisionGroups](const size_t beginIdx, const size_t endIdx)
-    {
-        for (size_t i = beginIdx; i < endIdx; i++)        
-        {
-            DescType& colDesc = physicsDesc[i];
-            if (colDesc.isValid)
-            {
-                const UsdPrim prim = physicsPrims[i];
-                // get the body
-                SdfPath bodyPath = GetRigidBody(prim, bodyMap);
-                // body was found, add collision to the body
-                UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
-                if (bodyPath != SdfPath())
-                {
-                    RigidBodyMap::const_iterator bodyIt = bodyMap.find(bodyPath);
-                    if (bodyIt != bodyMap.end())
-                    {
-                        bodyDesc = bodyIt->second;
-                        bodyDesc->collisions.push_back(colDesc.primPath);
-                    }
-                }
-
-                // check if collision belongs to collision groups
-                for (std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
-                    it != collisionGroups.end(); ++it)
-                {
-                    if (it->second.find(colDesc.primPath) != it->second.end())
-                    {
-                        colDesc.collisionGroups.push_back(it->first);
-                    }
-                }
-
-                // finalize the collision, fill up the local transform etc
-                FinalizeCollision(prim.GetStage(), bodyDesc, &colDesc);
-            }
-        }
-    };
-
-    const size_t numPrimPerBatch = 10;
-    WorkParallelForN(physicsPrims.size(), workLambda, numPrimPerBatch);
-}
+	if (rbMaterialDesc && usdMaterial)
+	{
+		usdMaterial.GetDynamicFrictionAttr().Get(&rbMaterialDesc->dynamicFriction);
+		usdMaterial.GetStaticFrictionAttr().Get(&rbMaterialDesc->staticFriction);
 
-struct ArticulationLink
-{ 
-    SdfPathVector   childs;
-    SdfPath         rootJoint;
-    uint32_t        weight;
-    uint32_t        index;
-    bool            hasFixedJoint;
-    SdfPathVector   joints;
-};
+		usdMaterial.GetRestitutionAttr().Get(&rbMaterialDesc->restitution);
 
-using ArticulationLinkMap = std::map<pxr::SdfPath, ArticulationLink>;
-using BodyJointMap = pxr::TfHashMap<pxr::SdfPath, std::vector<const UsdPhysicsJointDesc*>, pxr::SdfPath::Hash>;
-using JointMap = std::map<pxr::SdfPath, UsdPhysicsJointDesc*>;
-using ArticulationMap = std::map<pxr::SdfPath, UsdPhysicsArticulationDesc*>;
+		usdMaterial.GetDensityAttr().Get(&rbMaterialDesc->density);
 
-bool IsInLinkMap(const SdfPath& path, const std::vector<ArticulationLinkMap>& linkMaps)
-{
-    for (size_t i = 0; i < linkMaps.size(); i++)
-    {
-        ArticulationLinkMap::const_iterator it = linkMaps[i].find(path);
-        if (it != linkMaps[i].end())
-            return true;
-    }
-
-    return false;
-}
+		rbMaterialDesc->primPath = usdMaterial.GetPrim().GetPrimPath();
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsMaterialAPI or UsdPhysicsRigidBodyMaterialDesc is not valid.");
+		return false;
 
-void TraverseHierarchy(const pxr::UsdStageWeakPtr stage, const SdfPath& linkPath, ArticulationLinkMap& articulationLinkMap, const BodyJointMap& bodyJointMap, uint32_t& index, SdfPathVector& linkOrderVector)
-{
-    // check if we already parsed this link
-    ArticulationLinkMap::const_iterator artIt = articulationLinkMap.find(linkPath);
-    if (artIt != articulationLinkMap.end())
-        return;
-
-    linkOrderVector.push_back(linkPath);
-
-    BodyJointMap::const_iterator bjIt = bodyJointMap.find(linkPath);
-    if (bjIt != bodyJointMap.end())
-    {
-        ArticulationLink& link = articulationLinkMap[linkPath];
-        link.weight = 0;
-        link.index = index++;
-        link.hasFixedJoint = false;
-        const std::vector<const UsdPhysicsJointDesc*>& joints = bjIt->second;
-        for (size_t i = 0; i < joints.size(); i++)
-        {            
-            const UsdPhysicsJointDesc* desc = joints[i];
-            link.joints.push_back(desc->primPath);
-            if (desc->body0 == SdfPath() || (bodyJointMap.find(desc->body0) == bodyJointMap.end()) ||
-                desc->body1 == SdfPath() || (bodyJointMap.find(desc->body1) == bodyJointMap.end()))
-            {
-                if (desc->excludeFromArticulation)
-                {
-                    link.weight += 1000;
-                }
-                else
-                {
-                    link.weight += 100000;
-                    link.rootJoint = desc->primPath;
-                    link.hasFixedJoint = true;
-                }                
-                link.childs.push_back(SdfPath());                                
-            }
-            else
-            {
-                if (desc->excludeFromArticulation)
-                {
-                    link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
-                    link.weight += 1000;
-                }
-                else
-                {
-                    link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
-                    link.weight += 100;
-                    TraverseHierarchy(stage, link.childs.back(), articulationLinkMap, bodyJointMap, index, linkOrderVector);
-                }
-            }
-        }
-    }
+	}
+	return true;
 }
 
-void TraverseChilds(const ArticulationLink& link, const ArticulationLinkMap& map, uint32_t startIndex, uint32_t distance, int32_t* pathMatrix)
+bool ParseLinearDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
 {
-    const size_t mapSize = map.size();
-    const uint32_t currentIndex = link.index;
-    pathMatrix[startIndex + currentIndex * mapSize] = distance;
-
-    for (size_t i = 0; i < link.childs.size(); i++)
-    {
-        ArticulationLinkMap::const_iterator it = map.find(link.childs[i]);
-        if (it != map.end())
-        {
-            const uint32_t childIndex = it->second.index;
-            if (pathMatrix[startIndex + childIndex * mapSize] < 0)
-            {
-                TraverseChilds(it->second, map, startIndex, distance + 1, pathMatrix);
-            }
-        }        
-    }
+	dst->enabled = false;
+	const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->linear);
+	if (driveAPI)
+	{
+		return ParseDrive(driveAPI, dst);
+	}
+
+	return true;
 }
 
-pxr::SdfPath GetCenterOfGraph(const ArticulationLinkMap& map, const SdfPathVector& linkOrderVector)
+
+bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint,
+	UsdPhysicsPrismaticJointDesc* prismaticJointDesc)
 {
-    const size_t size = map.size();
-    int32_t* pathMatrix = new int32_t[size * size];
-    for (size_t i = 0; i < size; i ++)
-    {
-        for (size_t j = 0; j < size; j++)
-        {
-            pathMatrix [i + j * size] = -1;
-        }
-    }
-
-    for (ArticulationLinkMap::const_reference& ref : map)
-    {
-        const uint32_t startIndex = ref.second.index;
-        uint32_t distance = 0;
-        TraverseChilds(ref.second, map, startIndex, distance, pathMatrix);
-    }
-
-    int32_t shortestDistance = INT_MAX;
-    size_t numChilds = 0;
-    SdfPath primpath = SdfPath();
-    for (ArticulationLinkMap::const_reference& ref : map)
-    {
-        const uint32_t startIndex = ref.second.index;
-        int32_t longestPath = 0;
-        for (size_t i = 0; i < size; i++)
-        {
-            if (pathMatrix[startIndex + i * size] > longestPath)
-            {
-                longestPath = pathMatrix[startIndex + i * size];
-            }
-        }
-
-        // this needs to be deterministic, get the shortest path
-        // if there are more paths with same lenght, pick the one with more childs
-        // if there are more with same path and same amount of childs, pick the one with lowest hash
-        // The lowest hash is not right, this is wrong, it has to be the first link ordered by the traversal
-        if (longestPath < shortestDistance)
-        {
-            shortestDistance = longestPath;
-            numChilds = ref.second.childs.size();
-            primpath = ref.first;
-        }
-        else if (longestPath == shortestDistance)
-        {
-            if (numChilds < ref.second.childs.size())
-            {
-                numChilds = ref.second.childs.size();
-                primpath = ref.first;
-            }
-            else if (numChilds == ref.second.childs.size())
-            {
-                for (const SdfPath& orderPath : linkOrderVector)
-                {
-                    if (orderPath == primpath)
-                    {
-                        break;
-                    }
-                    else if (orderPath == ref.first)
-                    {
-                        primpath = ref.first;
-                    }
-                }
-            }
-        }
-    }
-
-    delete [] pathMatrix;
-
-    return primpath;
+	if (prismaticJointDesc && prismaticJoint)
+	{
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(prismaticJoint, prismaticJointDesc))
+		{
+			return false;
+		}
+
+		UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
+		TfToken axis = UsdPhysicsTokens->x;
+		prismaticJoint.GetAxisAttr().Get(&axis);
+
+		if (axis == UsdPhysicsTokens->y)
+			jointAxis = UsdPhysicsAxis::eY;
+		else if (axis == UsdPhysicsTokens->z)
+			jointAxis = UsdPhysicsAxis::eZ;
+		prismaticJointDesc->axis = jointAxis;
+
+		prismaticJointDesc->limit.enabled = false;
+		prismaticJoint.GetLowerLimitAttr().Get(&prismaticJointDesc->limit.lower);
+		prismaticJoint.GetUpperLimitAttr().Get(&prismaticJointDesc->limit.upper);
+		if ((isfinite(prismaticJointDesc->limit.lower) &&
+			(prismaticJointDesc->limit.lower > -usdPhysicsSentinelLimit)) ||
+			(isfinite(prismaticJointDesc->limit.upper) &&
+				(prismaticJointDesc->limit.upper < usdPhysicsSentinelLimit)))
+		{
+			prismaticJointDesc->limit.enabled = true;
+		}
+
+		if (!ParseLinearDrive(&prismaticJointDesc->drive, prismaticJoint.GetPrim()))
+		{
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsPrismaticJoint or UsdPhysicsPrismaticJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
 }
 
-void FinalizeArticulations(const pxr::UsdStageWeakPtr stage, ArticulationMap& articulationMap, const RigidBodyMap& rigidBodyMap, const JointMap& jointMap)
+bool ParseAngularDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
 {
-    BodyJointMap bodyJointMap;
-    if (!articulationMap.empty())
-    {
-        // construct the BodyJointMap
-        bodyJointMap.reserve(rigidBodyMap.size());
-        for (JointMap::const_reference& jointIt : jointMap)
-        {
-            const UsdPhysicsJointDesc* desc = jointIt.second;
-            if (desc->jointEnabled)
-            {
-                if (desc->body0 != SdfPath())
-                {
-                    RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body0);
-                    if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled && !fit->second->kinematicBody)
-                    {
-                        bodyJointMap[desc->body0].push_back(desc);
-                    }                    
-                }
-                if (desc->body1 != SdfPath())
-                {
-                    RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body1);
-                    if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled && !fit->second->kinematicBody)
-                    {
-                        bodyJointMap[desc->body1].push_back(desc);
-                    }
-                }
-            }
-        }
-    }    
-
-    // first get user defined articulation roots
-    // then search for the best root in the articulation hierarchy
-    const auto workLambda = [rigidBodyMap, jointMap, stage, bodyJointMap](ArticulationMap::const_reference& it)    
-    {        
-        SdfPathVector articulationLinkOrderVector;
-
-        const SdfPath& articulationPath = it.first;
-        SdfPath articulationBaseLinkPath = articulationPath;
-
-        std::set<SdfPath> articulatedJoints;
-        std::set<SdfPath> articulatedBodies;
-
-        // check if its a floating articulation
-        {
-            RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(articulationPath);
-            if (bodyIt != rigidBodyMap.end())
-            {
-                if (!bodyIt->second->rigidBodyEnabled)
-                {
-                    TF_DIAGNOSTIC_WARNING(
-                        "ArticulationRootAPI definition on a static rigid body is not allowed, articulation root will be ignored. Prim: %s",
-                        articulationPath.GetText());
-                    return;
-                }
-                if (bodyIt->second->kinematicBody)
-                {
-                    TF_DIAGNOSTIC_WARNING(
-                        "ArticulationRootAPI definition on a kinematic rigid body is not allowed, articulation root will be ignored. Prim: %s",
-                        articulationPath.GetText());
-                    return;
-                }
-                it.second->rootPrims.push_back(bodyIt->first);
-            }
-            else
-            {
-                JointMap::const_iterator jointIt = jointMap.find(articulationPath);
-                if (jointIt != jointMap.end())
-                {
-                    const SdfPath& jointPath = jointIt->first;
-                    const UsdPhysicsJointDesc* jointDesc = jointIt->second;
-                    if (jointDesc->body0 == SdfPath() || jointDesc->body1 == SdfPath())
-                    {                        
-                        it.second->rootPrims.push_back(jointPath);
-                        articulationBaseLinkPath = jointDesc->body0 == SdfPath() ? jointDesc->body1 : jointDesc->body0;
-                    }
-                }
-            }
-        }
-
-        // search through the hierarchy for the best root        
-        const UsdPrim articulationPrim = stage->GetPrimAtPath(articulationBaseLinkPath);        
-        if (!articulationPrim)
-            return;
-        UsdPrimRange range(articulationPrim, UsdTraverseInstanceProxies());
-        std::vector<ArticulationLinkMap> articulationLinkMaps;
-        articulationLinkOrderVector.clear();
-
-        for (pxr::UsdPrimRange::const_iterator iter = range.begin(); iter != range.end(); ++iter)
-        {
-            const pxr::UsdPrim& prim = *iter;
-            if (!prim)
-                continue;
-            const SdfPath primPath = prim.GetPrimPath();            
-            if (IsInLinkMap(primPath, articulationLinkMaps))
-            {
-                iter.PruneChildren(); // Skip the subtree rooted at this prim
-                continue;
-            }
-
-            RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(primPath);
-            if (bodyIt != rigidBodyMap.end())
-            {
-                articulationLinkMaps.push_back(ArticulationLinkMap());
-                uint32_t index = 0;
-                TraverseHierarchy(stage, primPath, articulationLinkMaps.back(), bodyJointMap, index, articulationLinkOrderVector);
-            }
-        }
-
-        if (it.second->rootPrims.empty())
-        {
-            for (size_t i = 0; i < articulationLinkMaps.size(); i++)
-            {
-                const ArticulationLinkMap& map = articulationLinkMaps[i];
-                SdfPath linkPath = SdfPath();
-                uint32_t largestWeight = 0;
-                bool hasFixedJoint = false;
-                for (ArticulationLinkMap::const_reference& linkIt : map)
-                {
-                    if (linkIt.second.hasFixedJoint)
-                    {
-                        hasFixedJoint = true;
-                    }
-                    if (linkIt.second.weight > largestWeight)
-                    {
-                        linkPath = (linkIt.second.rootJoint != SdfPath()) ? linkIt.second.rootJoint : linkIt.first;
-                        largestWeight = linkIt.second.weight;
-                    }
-                    else if (linkIt.second.weight == largestWeight)
-                    {
-                        const SdfPath optionalLinkPath = (linkIt.second.rootJoint != SdfPath()) ? linkIt.second.rootJoint : linkIt.first;
-                        for (const SdfPath& orderPath : articulationLinkOrderVector)
-                        {
-                            if (orderPath == linkPath)
-                            {
-                                break;
-                            }
-                            else if (orderPath == optionalLinkPath)
-                            {
-                                linkPath = optionalLinkPath;
-                            }
-                        }
-                    }
-
-                    for (size_t j = linkIt.second.joints.size(); j--;)
-                    {
-                        articulatedJoints.insert(linkIt.second.joints[j]);
-                    }
-                }
-
-                // for floating articulation lets find the body with the shortest paths (center of graph)
-                if (!hasFixedJoint)
-                {
-                    linkPath = GetCenterOfGraph(map, articulationLinkOrderVector);
-                }
-
-                if (linkPath != SdfPath())
-                {
-                    it.second->rootPrims.push_back(linkPath);
-                }
-            }
-        }
-        else
-        {
-            for (size_t i = 0; i < articulationLinkMaps.size(); i++)
-            {
-                const ArticulationLinkMap& map = articulationLinkMaps[i];
-                SdfPath linkPath = SdfPath();
-                uint32_t largestWeight = 0;
-                bool hasFixedOrLoopJoint = false;
-                for (ArticulationLinkMap::const_reference& linkIt : map)
-                {
-                    for (size_t j = linkIt.second.joints.size(); j--;)
-                    {
-                        articulatedJoints.insert(linkIt.second.joints[j]);
-                    }
-                }
-            }
-        }
-        for (size_t i = 0; i < articulationLinkMaps.size(); i++)
-        {
-            const ArticulationLinkMap& map = articulationLinkMaps[i];
-            for (ArticulationLinkMap::const_reference& linkIt : map)
-            {
-                articulatedBodies.insert(linkIt.second.childs.begin(), linkIt.second.childs.end());
-            }
-        }
-
-        if (it.second->rootPrims.empty())
-        {
-            it.second->isValid = false;
-        }
-
-        for (const SdfPath& p : articulatedJoints)
-        {
-            it.second->articulatedJoints.push_back(p);
-        }
-        for (const SdfPath& p : articulatedBodies)
-        {
-            it.second->articulatedBodies.push_back(p);
-        }
-    };
-    
-    WorkParallelForEach(articulationMap.begin(), articulationMap.end(), workLambda);    
+	dst->enabled = false;
+	const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim,
+		UsdPhysicsTokens->angular);
+	if (driveAPI)
+	{
+		return ParseDrive(driveAPI, dst);
+	}
+
+	return true;
 }
 
-bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
-        ParsePrimIteratorBase& primIterator,
-        UsdPhysicsReportFn reportFn,
-        void* userData,
-        const CustomUsdPhysicsTokens* customPhysicsTokens,
-        const std::vector<SdfPath>* simulationOwners)
+
+bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint,
+	UsdPhysicsRevoluteJointDesc* revoluteJointDesc)
 {
-    bool retVal = true;
-
-    if (!stage)
-    {
-        TF_RUNTIME_ERROR("Provided stage not valid.");
-        return false;
-    }
-
-    if (!reportFn)
-    {
-        TF_RUNTIME_ERROR("Provided report callback is not valid.");
-        return false;
-    }
-    
-    
-    std::vector<UsdPrim> scenePrims;
-    std::vector<UsdPrim> collisionGroupPrims;
-    std::vector<UsdPrim> materialPrims;
-    std::vector<UsdPrim> articulationPrims;
-    std::unordered_set<SdfPath, SdfPath::Hash> articulationPathsSet;
-    std::vector<UsdPrim> physicsD6JointPrims;
-    std::vector<UsdPrim> physicsRevoluteJointPrims;
-    std::vector<UsdPrim> physicsFixedJointPrims;
-    std::vector<UsdPrim> physicsPrismaticJointPrims;
-    std::vector<UsdPrim> physicsSphericalJointPrims;
-    std::vector<UsdPrim> physicsDistanceJointPrims;
-    std::vector<UsdPrim> physicsCustomJointPrims;
-    std::vector<UsdPrim> collisionPrims;
-    std::vector<UsdPrim> rigidBodyPrims;
-
-    // parse for scene first, get the descriptors, report all prims
-    // the descriptors are not complete yet
-    primIterator.reset();
-
-    static const TfToken gRigidBodyAPIToken("PhysicsRigidBodyAPI");
-    static const TfToken gCollisionAPIToken("PhysicsCollisionAPI");
-    static const TfToken gArticulationRootAPIToken("PhysicsArticulationRootAPI");
-    static const TfToken gMaterialAPIToken("PhysicsMaterialAPI");
-
-    bool defaultSimulationOwner = false;
-    std::unordered_set<SdfPath, SdfPath::Hash> simulationOwnersSet;
-    if (simulationOwners)
-    {
-        for (const SdfPath& p : *simulationOwners)
-        {
-            if (p == SdfPath())
-            {
-                defaultSimulationOwner = true;                
-            }
-            else
-            {
-                simulationOwnersSet.insert(p);
-            }
-        }
-    }
-
-    while (!primIterator.atEnd())
-    {
-        const pxr::UsdPrim& prim = *primIterator.getCurrent();
-        if (!prim)
-        {
-            primIterator.pruneChildren();
-            primIterator.next();
-            continue;
-        }
-
-        const SdfPath primPath = prim.GetPrimPath();
-        const UsdPrimTypeInfo& typeInfo = prim.GetPrimTypeInfo();
-        UsdPhysicsObjectDesc* reportDesc = nullptr;
-
-        uint64_t apiFlags = 0;
-        const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
-        for (const TfToken& token : apis)
-        {
-            if (token == gArticulationRootAPIToken)
-            {
-                apiFlags |= SchemaAPIFlag::eArticulationRootAPI;
-            }
-            if (token == gCollisionAPIToken)
-            {
-                apiFlags |= SchemaAPIFlag::eCollisionAPI;
-            }
-            if (token == gRigidBodyAPIToken)
-            {
-                apiFlags |= SchemaAPIFlag::eRigidBodyAPI;
-            }
-            if (!apiFlags && token == gMaterialAPIToken)
-            {
-                apiFlags |= SchemaAPIFlag::eMaterialAPI;
-            }
-        }
-
-        if (typeInfo.GetSchemaType().IsA<UsdGeomPointInstancer>())
-        {
-            primIterator.pruneChildren(); // Skip the subtree for point instancers, those have to be traversed per prototype
-        }
-        else if (customPhysicsTokens && !customPhysicsTokens->instancerTokens.empty())
-        {
-            for (const TfToken& instToken : customPhysicsTokens->instancerTokens)
-            {
-                if (instToken == typeInfo.GetTypeName())
-                {
-                    primIterator.pruneChildren(); // Skip the subtree for custom instancers, those have to be traversed per prototype
-                    break;
-                }
-            }                
-        }
-
-        if (typeInfo.GetSchemaType().IsA<UsdPhysicsScene>())
-        {
-            scenePrims.push_back(prim);
-        }
-        else if (typeInfo.GetSchemaType().IsA<UsdPhysicsCollisionGroup>())
-        {
-            collisionGroupPrims.push_back(prim);
-        }
-        else if (apiFlags & SchemaAPIFlag::eMaterialAPI)
-        {
-            materialPrims.push_back(prim);
-        }
-        else if (typeInfo.GetSchemaType().IsA<UsdPhysicsJoint>())
-        {
-            if (typeInfo.GetSchemaType().IsA<UsdPhysicsFixedJoint>())
-            {
-                physicsFixedJointPrims.push_back(prim);
-            }
-            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsRevoluteJoint>())
-            {
-                physicsRevoluteJointPrims.push_back(prim);
-            }
-            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsPrismaticJoint>())
-            {
-                physicsPrismaticJointPrims.push_back(prim);
-            }
-            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsSphericalJoint>())
-            {
-                physicsSphericalJointPrims.push_back(prim);
-            }
-            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsDistanceJoint>())
-            {
-                physicsDistanceJointPrims.push_back(prim);
-            }
-            else
-            {
-                bool customJoint = false;
-                if (customPhysicsTokens)
-                {
-                    const TfToken& primType = typeInfo.GetTypeName();
-                    for (size_t i = 0; i < customPhysicsTokens->jointTokens.size(); i++)
-                    {
-                        if (primType == customPhysicsTokens->jointTokens[i])
-                        {
-                            customJoint = true;
-                            break;
-                        }
-                    }
-                }
-
-                if (customJoint)
-                {
-                    physicsCustomJointPrims.push_back(prim);
-                }
-                else
-                {
-                    physicsD6JointPrims.push_back(prim);
-                }
-            }
-
-
-            // can be articulation definition
-            if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
-            {
-                articulationPrims.push_back(prim);
-                articulationPathsSet.insert(prim.GetPrimPath());
-            }
-        }
-        else
-        {
-            if (apiFlags & SchemaAPIFlag::eCollisionAPI)
-            {
-                collisionPrims.push_back(prim);
-            }
-            if (apiFlags & SchemaAPIFlag::eRigidBodyAPI)
-            {
-                rigidBodyPrims.push_back(prim);
-            }
-            if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
-            {
-                articulationPrims.push_back(prim);
-                articulationPathsSet.insert(prim.GetPrimPath());
-            }
-        }
-
-        primIterator.next();
-    }
-
-    // process parsing
-    // 
-    // Scenes
-    std::vector<UsdPhysicsSceneDesc> sceneDescs;
-
-    // is simulation owners provided, restrict scenes to just the one specified
-    if (simulationOwners)
-    {
-        for (size_t i = scenePrims.size(); i--;)
-        {
-            const SdfPath& primPath = scenePrims[i].GetPrimPath();
-            std::unordered_set<SdfPath, SdfPath::Hash>::const_iterator fit = simulationOwnersSet.find(primPath);
-            if (fit == simulationOwnersSet.end())
-            {
-                scenePrims[i] = scenePrims.back();
-                scenePrims.pop_back();
-            }            
-        }
-    }
-    ProcessPhysicsPrims<UsdPhysicsSceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs, ParseSceneDesc);
-
-    // Collision Groups
-    std::vector<UsdPhysicsCollisionGroupDesc> collisionGroupsDescs;
-    ProcessPhysicsPrims<UsdPhysicsCollisionGroupDesc, UsdPhysicsCollisionGroup>(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
-    // Run groups merging
-    std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets;
-    std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
-    for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
-    {
-        const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
-
-        collisionGroupSets[desc.primPath];
-
-        if (!desc.mergeGroupName.empty())
-        {
-            std::unordered_map<std::string, size_t>::const_iterator fit = mergeGroupNameToIndex.find(desc.mergeGroupName);
-            if (fit != mergeGroupNameToIndex.end())
-            {                
-                UsdPhysicsCollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
-                mergeDesc.mergedGroups.push_back(desc.primPath);
-                for (const SdfPath& sp : desc.filteredGroups)
-                {
-                    mergeDesc.filteredGroups.push_back(sp);
-                }
-
-                collisionGroupsDescs[i] = collisionGroupsDescs.back();
-                collisionGroupPrims[i] = collisionGroupPrims.back();
-                collisionGroupsDescs.pop_back();
-                collisionGroupPrims.pop_back();
-                i--;
-            }
-            else
-            {                
-                mergeGroupNameToIndex[desc.mergeGroupName] = i;
-                collisionGroupsDescs[i].mergedGroups.push_back(desc.primPath);
-            }
-        }
-    } 
-
-    // Populate the sets to check collisions
-    {
-        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
-        {
-            for (size_t i = beginIdx; i < endIdx; i++)
-            {
-                const UsdPrim groupPrim = collisionGroupPrims[i];
-                UsdStageWeakPtr stage = groupPrim.GetStage();
-                const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
-
-                std::unordered_set<SdfPath, SdfPath::Hash>& hashSet = collisionGroupSets[desc.primPath];
-
-                if (desc.mergedGroups.empty())
-                {
-                    const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
-                    if (cg)
-                    {
-                        const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
-                        UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
-                        const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
-                        for (const SdfPath& path : includedPaths)
-                        {
-                            hashSet.insert(path);
-                        }
-                    }
-                }
-                else
-                {
-                    for (const SdfPath& groupPath : desc.mergedGroups)
-                    {
-                        const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
-                        if (cg)
-                        {
-                            const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
-                            UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
-                            const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
-                            for (const SdfPath& path : includedPaths)
-                            {
-                                hashSet.insert(path);
-                            }
-                        }
-                    }
-                }
-            }
-        };
-
-        const size_t numPrimPerBatch = 10;
-        WorkParallelForN(collisionGroupsDescs.size(), workLambda, numPrimPerBatch);
-    }
-
-    // Rigid body physics material
-    std::vector<UsdPhysicsRigidBodyMaterialDesc> materialDescs;
-    ProcessPhysicsPrims<UsdPhysicsRigidBodyMaterialDesc, UsdPhysicsMaterialAPI>(materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
-
-    // Joints
-    std::vector<UsdPhysicsD6JointDesc> jointDescs;
-    ProcessPhysicsPrims<UsdPhysicsD6JointDesc, UsdPhysicsJoint>(physicsD6JointPrims, jointDescs, ParseD6JointDesc);
-
-    std::vector<UsdPhysicsRevoluteJointDesc> revoluteJointDescs;
-    ProcessPhysicsPrims<UsdPhysicsRevoluteJointDesc, UsdPhysicsRevoluteJoint>(physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
-
-    std::vector<UsdPhysicsPrismaticJointDesc> prismaticJointDescs;
-    ProcessPhysicsPrims<UsdPhysicsPrismaticJointDesc, UsdPhysicsPrismaticJoint>(physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
-
-    std::vector<UsdPhysicsSphericalJointDesc> sphericalJointDescs;
-    ProcessPhysicsPrims<UsdPhysicsSphericalJointDesc, UsdPhysicsSphericalJoint>(physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
-
-    std::vector<UsdPhysicsFixedJointDesc> fixedJointDescs;
-    ProcessPhysicsPrims<UsdPhysicsFixedJointDesc, UsdPhysicsFixedJoint>(physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
-
-    std::vector<UsdPhysicsDistanceJointDesc> distanceJointDescs;
-    ProcessPhysicsPrims<UsdPhysicsDistanceJointDesc, UsdPhysicsDistanceJoint>(physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
-
-    std::vector<UsdPhysicsCustomJointDesc> customJointDescs;
-    ProcessPhysicsPrims<UsdPhysicsCustomJointDesc, UsdPhysicsJoint>(physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
-
-    // A.B. contruct joint map revisit    
-    JointMap jointMap;
-    for (UsdPhysicsD6JointDesc& desc : jointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-    for (UsdPhysicsRevoluteJointDesc& desc : revoluteJointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-    for (UsdPhysicsPrismaticJointDesc& desc : prismaticJointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-    for (UsdPhysicsSphericalJointDesc& desc : sphericalJointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-    for (UsdPhysicsFixedJointDesc& desc : fixedJointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-    for (UsdPhysicsDistanceJointDesc& desc : distanceJointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-    for (UsdPhysicsCustomJointDesc& desc : customJointDescs)
-    {
-        jointMap[desc.primPath] = &desc;
-    }
-
-
-    // collisions
-    // first get the type
-    std::vector<UsdPhysicsObjectType::Enum> collisionTypes;
-    collisionTypes.resize(collisionPrims.size());
-    std::vector<TfToken> customTokens;
-    {       
-        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
-        {
-            for (size_t i = beginIdx; i < endIdx; i++)
-            {
-                if (customPhysicsTokens)
-                {
-                    TfToken shapeToken;
-                    const UsdPhysicsObjectType::Enum shapeType = GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
-                    collisionTypes[i] = shapeType;
-                    if (shapeType == UsdPhysicsObjectType::eCustomShape)
-                    {
-                        customTokens.push_back(shapeToken);
-                    }
-                }
-                else
-                {
-                    collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
-                }
-            }
-        };
-        
-        const size_t numPrimPerBatch = 10;
-        WorkParallelForN(collisionPrims.size(), workLambda, numPrimPerBatch);
-    }
-
-    std::vector<UsdPrim> sphereShapePrims;
-    std::vector<UsdPrim> cubeShapePrims;
-    std::vector<UsdPrim> cylinderShapePrims;
-    std::vector<UsdPrim> capsuleShapePrims;
-    std::vector<UsdPrim> coneShapePrims;
-    std::vector<UsdPrim> planeShapePrims;
-    std::vector<UsdPrim> meshShapePrims;
-    std::vector<UsdPrim> spherePointsShapePrims;
-    std::vector<UsdPrim> customShapePrims;
-    for (size_t i = 0; i < collisionTypes.size(); i++)
-    {
-        UsdPhysicsObjectType::Enum type = collisionTypes[i];
-        switch (type)
-        {
-            case UsdPhysicsObjectType::eSphereShape:
-            {
-                sphereShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eCubeShape:
-            {
-                cubeShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eCapsuleShape:
-            {
-                capsuleShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eCylinderShape:
-            {
-                cylinderShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eConeShape:
-            {
-                coneShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eMeshShape:
-            {
-                meshShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::ePlaneShape:
-            {
-                planeShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eCustomShape:
-            {
-                customShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eSpherePointsShape:
-            {
-                spherePointsShapePrims.push_back(collisionPrims[i]);
-            }
-            break;
-            case UsdPhysicsObjectType::eUndefined:
-            default:            
-            {
-                TF_DIAGNOSTIC_WARNING("CollisionAPI applied to an unknown UsdGeomGPrim type, prim %s.",
-                    collisionPrims[i].GetPrimPath().GetString().c_str());
-            }
-            break;
-        }
-    }
-    std::vector<UsdPhysicsSphereShapeDesc> sphereShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsSphereShapeDesc, UsdPhysicsCollisionAPI>(sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
-
-    std::vector<UsdPhysicsCubeShapeDesc> cubeShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsCubeShapeDesc, UsdPhysicsCollisionAPI>(cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
-
-    std::vector<UsdPhysicsCylinderShapeDesc> cylinderShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsCylinderShapeDesc, UsdPhysicsCollisionAPI>(cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
-
-    std::vector<UsdPhysicsCapsuleShapeDesc> capsuleShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsCapsuleShapeDesc, UsdPhysicsCollisionAPI>(capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
-
-    std::vector<UsdPhysicsConeShapeDesc> coneShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsConeShapeDesc, UsdPhysicsCollisionAPI>(coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
-
-    std::vector<UsdPhysicsPlaneShapeDesc> planeShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsPlaneShapeDesc, UsdPhysicsCollisionAPI>(planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
-
-    std::vector<UsdPhysicsMeshShapeDesc> meshShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsMeshShapeDesc, UsdPhysicsCollisionAPI>(meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
-
-    std::vector<UsdPhysicsSpherePointsShapeDesc> spherePointsShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsSpherePointsShapeDesc, UsdPhysicsCollisionAPI>(spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
-
-    std::vector<UsdPhysicsCustomShapeDesc> customShapeDescs;
-    ProcessPhysicsPrims<UsdPhysicsCustomShapeDesc, UsdPhysicsCollisionAPI>(customShapePrims, customShapeDescs, ParseCustomShapeDesc);
-    if (customShapeDescs.size() == customTokens.size())
-    {
-        for (size_t i = 0; i < customShapeDescs.size(); i++)
-        {
-            customShapeDescs[i].customGeometryToken = customTokens[i];
-        }
-    }
-
-    // rigid bodies
-    std::vector<UsdPhysicsRigidBodyDesc> rigidBodyDescs;
-    ProcessPhysicsPrims<UsdPhysicsRigidBodyDesc, UsdPhysicsRigidBodyAPI>(rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
-    // Ensure if we have a hierarchical parent that has a dynamic parent,
-    // that we also have a reset xform stack, otherwise we should log an error.
-    // check for nested articulation roots, these are not supported
-    RigidBodyMap bodyMap;
-    for (size_t i = rigidBodyPrims.size(); i--;)
-    {
-        bodyMap[rigidBodyPrims[i].GetPrimPath()] = &rigidBodyDescs[i];
-    }
-
-    for (size_t i = rigidBodyPrims.size(); i--;)
-    {
-        const UsdPrim bodyPrim = rigidBodyPrims[i];
-        UsdPrim bodyParent = UsdPrim();
-        if (HasDynamicBodyParent(bodyPrim.GetParent(), bodyMap, bodyParent))
-        {
-            bool hasResetXformStack = false;
-            UsdPrim parent = bodyPrim;
-            while (parent != stage->GetPseudoRoot() && parent != bodyParent)
-            {
-                const UsdGeomXformable xform(parent);
-                if (xform && xform.GetResetXformStack())
-                {
-                    hasResetXformStack = true;
-                    break;
-                }
-                parent = parent.GetParent();
-            }
-            if (!hasResetXformStack)
-            {
-
-                TF_DIAGNOSTIC_WARNING("Rigid Body of (%s) missing xformstack reset when child of rigid body (%s) in hierarchy. "
-                    "Simulation of multiple RigidBodyAPI's in a hierarchy will cause unpredicted results. "
-                    "Please fix the hierarchy or use XformStack reset.",
-                    bodyPrim.GetPrimPath().GetText(),
-                    bodyParent.GetPrimPath().GetText());
-
-                rigidBodyPrims[i] = rigidBodyPrims.back();
-                rigidBodyPrims.pop_back();
-            }
-        }
-    }
-
-    // articulations
-    // check for nested articulation roots, these are not supported    
-    for (size_t i = articulationPrims.size(); i--;)
-    {
-        if (CheckNestedArticulationRoot(articulationPrims[i], articulationPathsSet))
-        {
-            TF_DIAGNOSTIC_WARNING("Nested ArticulationRootAPI not supported, API ignored, prim %s.",
-                    articulationPrims[i].GetPrimPath().GetString().c_str());
-            articulationPrims[i] = articulationPrims.back();
-            articulationPrims.pop_back();
-        }
-    }
-    std::vector<UsdPhysicsArticulationDesc> articulationDescs;
-    ProcessPhysicsPrims<UsdPhysicsArticulationDesc, UsdPhysicsArticulationRootAPI>(articulationPrims, articulationDescs, ParseArticulationDesc);
-
-    ArticulationMap articulationMap; // A.B. TODO probably not needed
-    for (size_t i = articulationPrims.size(); i--;)
-    {
-        articulationMap[articulationPrims[i].GetPrimPath()] = &articulationDescs[i];
-    }
-
-    // Finalize collisions
-    {
-        UsdGeomXformCache xfCache;
-
-        FinalizeCollisionDescs<UsdPhysicsSphereShapeDesc>(xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsCubeShapeDesc>(xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsCapsuleShapeDesc>(xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsCylinderShapeDesc>(xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsConeShapeDesc>(xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsPlaneShapeDesc>(xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsMeshShapeDesc>(xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsSpherePointsShapeDesc>(xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
-        FinalizeCollisionDescs<UsdPhysicsCustomShapeDesc>(xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
-    }
-
-    // Finalize articulations
-    {   
-        // A.B. walk through the finalize code refactor
-        FinalizeArticulations(stage, articulationMap, bodyMap, jointMap);
-    }
-
-    // if simulationOwners are in play lets shrink down the reported descriptors    
-    if (simulationOwners && !simulationOwners->empty())
-    {
-        std::unordered_set<SdfPath, SdfPath::Hash> reportedBodies;
-        // first check bodies
-        CheckRigidBodySimulationOwner(rigidBodyPrims, rigidBodyDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-
-        // check collisions
-        // if collision belongs to a body that we care about include it
-        // if collision does not belong to a body we care about its not included
-        // if collision does not have a body set, we check its own simulationOwners
-        CheckCollisionSimulationOwner(sphereShapePrims, sphereShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(cubeShapePrims, cubeShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(capsuleShapePrims, capsuleShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(cylinderShapePrims, cylinderShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(coneShapePrims, coneShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(planeShapePrims, planeShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(meshShapePrims, meshShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(spherePointsShapePrims, spherePointsShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckCollisionSimulationOwner(customShapePrims, customShapeDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-
-        // Both bodies need to have simulation owners valid
-        CheckJointSimulationOwner(physicsFixedJointPrims, fixedJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckJointSimulationOwner(physicsRevoluteJointPrims, revoluteJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckJointSimulationOwner(physicsPrismaticJointPrims, prismaticJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckJointSimulationOwner(physicsSphericalJointPrims, sphericalJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckJointSimulationOwner(physicsDistanceJointPrims, distanceJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckJointSimulationOwner(physicsD6JointPrims, jointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-        CheckJointSimulationOwner(physicsCustomJointPrims, customJointDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-
-        // All bodies need to have simulation owners valid
-        CheckArticulationSimulationOwner(articulationPrims, articulationDescs, defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-    }
-
-    SdfPathVector primPathsVector;
-    // get the descriptors, finalize them and send them out in an order
-    // 1. send out the scenes
-    {
-        CallReportFn(UsdPhysicsObjectType::eScene, scenePrims, sceneDescs, reportFn, primPathsVector, userData);
-    }
-
-    // 2. send out the CollisionGroups
-    {
-        CallReportFn(UsdPhysicsObjectType::eCollisionGroup, collisionGroupPrims, collisionGroupsDescs, reportFn, primPathsVector, userData);
-    }
-
-    // 3. send out the materials
-    {
-        CallReportFn(UsdPhysicsObjectType::eRigidBodyMaterial, materialPrims, materialDescs, reportFn, primPathsVector, userData);
-    }
-
-    // 4. finish out and send out shapes
-    {   
-        CallReportFn(UsdPhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eCapsuleShape, capsuleShapePrims, capsuleShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eCylinderShape, cylinderShapePrims, cylinderShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eSpherePointsShape, spherePointsShapePrims, spherePointsShapeDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs, reportFn, primPathsVector, userData);        
-    }
-
-    // 5. send out articulations
-    {
-        CallReportFn(UsdPhysicsObjectType::eArticulation, articulationPrims, articulationDescs, reportFn, primPathsVector, userData);        
-    }
-
-    // 6. send out bodies
-    {
-        CallReportFn(UsdPhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs, reportFn, primPathsVector, userData);                        
-    }
-
-    // 7. send out joints    
-    {
-        CallReportFn(UsdPhysicsObjectType::eFixedJoint, physicsFixedJointPrims, fixedJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims, revoluteJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims, prismaticJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims, sphericalJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims, distanceJointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs, reportFn, primPathsVector, userData);        
-        CallReportFn(UsdPhysicsObjectType::eCustomJoint, physicsCustomJointPrims, customJointDescs, reportFn, primPathsVector, userData);        
-    }
-
-    return retVal;
+	if (revoluteJointDesc && revoluteJoint)
+	{
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(revoluteJoint, revoluteJointDesc))
+		{
+			return false;
+		}
+
+		UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
+		TfToken axis = UsdPhysicsTokens->x;
+		revoluteJoint.GetAxisAttr().Get(&axis);
+
+		if (axis == UsdPhysicsTokens->y)
+			jointAxis = UsdPhysicsAxis::eY;
+		else if (axis == UsdPhysicsTokens->z)
+			jointAxis = UsdPhysicsAxis::eZ;
+		revoluteJointDesc->axis = jointAxis;
+
+		revoluteJointDesc->limit.enabled = false;
+
+
+		revoluteJoint.GetLowerLimitAttr().Get(&revoluteJointDesc->limit.lower);
+		revoluteJoint.GetUpperLimitAttr().Get(&revoluteJointDesc->limit.upper);
+		if (isfinite(revoluteJointDesc->limit.lower) && isfinite(revoluteJointDesc->limit.upper)
+			&& revoluteJointDesc->limit.lower > -usdPhysicsSentinelLimit &&
+			revoluteJointDesc->limit.upper < usdPhysicsSentinelLimit)
+		{
+			revoluteJointDesc->limit.enabled = true;
+		}
+
+		if (!ParseAngularDrive(&revoluteJointDesc->drive, revoluteJoint.GetPrim()))
+		{
+			return false;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
+}
+
+template<typename T>
+inline bool ScaleIsUniform(T scaleX, T scaleY, T scaleZ, T eps = T(1.0e-5))
+{
+	// Find min and max scale values
+	T lo, hi;
+
+	if (scaleX < scaleY)
+	{
+		lo = scaleX;
+		hi = scaleY;
+	}
+	else
+	{
+		lo = scaleY;
+		hi = scaleX;
+	}
+
+	if (scaleZ < lo)
+	{
+		lo = scaleZ;
+	}
+	else if (scaleZ > hi)
+	{
+		hi = scaleZ;
+	}
+
+	if (lo* hi < 0.0)
+	{
+		return false;   // opposite signs
+	}
+
+	return hi > 0.0 ? hi - lo <= eps * lo : lo - hi >= eps * hi;
+}
+
+
+void GetRigidBodyTransformation(const UsdPrim& bodyPrim, UsdPhysicsRigidBodyDesc& desc)
+{
+	const GfMatrix4d mat =
+		UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+	const GfTransform tr(mat);
+	const GfVec3d pos = tr.GetTranslation();
+	const GfQuatd rot = tr.GetRotation().GetQuat();
+	const GfVec3d sc = tr.GetScale();
+
+	if (!ScaleIsUniform(sc[0], sc[1], sc[2]) &&
+		tr.GetScaleOrientation().GetQuaternion() != GfQuaternion::GetIdentity())
+	{
+		TF_DIAGNOSTIC_WARNING(
+			"ScaleOrientation is not supported for rigid bodies, prim path: %s.You may ignore this if the scale is close to uniform.",
+			bodyPrim.GetPrimPath().GetText());
+	}
+
+	desc.position = GfVec3f(pos);
+	desc.rotation = GfQuatf(rot);
+	desc.scale = GfVec3f(sc);
+}
+
+bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI,
+	UsdPhysicsRigidBodyDesc* rigidBodyDesc)
+{
+	if (rigidBodyDesc && rigidBodyAPI)
+	{
+		if (!rigidBodyAPI.GetPrim().IsA<UsdGeomXformable>())
+		{
+			TF_DIAGNOSTIC_WARNING(
+				"RigidBodyAPI applied to a non-xformable primitive. (%s)",
+				rigidBodyAPI.GetPrim().GetPrimPath().GetText());
+			return false;
+		}
+
+		// check instancing
+		{
+			bool reportInstanceError = false;
+			if (rigidBodyAPI.GetPrim().IsInstanceProxy())
+			{
+				reportInstanceError = true;
+
+				bool kinematic = false;
+				rigidBodyAPI.GetKinematicEnabledAttr().Get(&kinematic);
+				if (kinematic)
+					reportInstanceError = false;
+
+				bool enabled = false;
+				rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&enabled);
+				if (!enabled)
+					reportInstanceError = false;
+
+				if (reportInstanceError)
+				{
+					TF_DIAGNOSTIC_WARNING(
+						"RigidBodyAPI on an instance proxy not supported. %s",
+						rigidBodyAPI.GetPrim().GetPrimPath().GetText());
+					return false;
+				}
+			}
+		}
+
+		// transformation
+		GetRigidBodyTransformation(rigidBodyAPI.GetPrim(), *rigidBodyDesc);
+
+		// filteredPairs
+		ParseFilteredPairs(rigidBodyAPI.GetPrim(), rigidBodyDesc->filteredCollisions);
+
+		// velocity
+		rigidBodyAPI.GetVelocityAttr().Get(&rigidBodyDesc->linearVelocity);
+		rigidBodyAPI.GetAngularVelocityAttr().Get(&rigidBodyDesc->angularVelocity);
+
+		// rigid body flags
+		rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&rigidBodyDesc->rigidBodyEnabled);
+		rigidBodyAPI.GetKinematicEnabledAttr().Get(&rigidBodyDesc->kinematicBody);
+		rigidBodyAPI.GetStartsAsleepAttr().Get(&rigidBodyDesc->startsAsleep);
+
+		// simulation owner
+		const UsdRelationship ownerRel = rigidBodyAPI.GetSimulationOwnerRel();
+		if (ownerRel)
+		{
+			SdfPathVector owners;
+			ownerRel.GetTargets(&owners);
+			if (!owners.empty())
+			{
+				rigidBodyDesc->simulationOwners = owners;
+			}
+		}
+		rigidBodyDesc->primPath = rigidBodyAPI.GetPrim().GetPrimPath();
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsRigidBodyAPI or UsdPhysicsRigidBodyDesc is not valid.");
+		return false;
+	}
+	return true;
+}
+
+bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint,
+	UsdPhysicsSphericalJointDesc* sphericalJointDesc)
+{
+	if (sphericalJointDesc && sphericalJoint)
+	{
+		// parse the joint common parameters
+		if (!ParseCommonJointDesc(sphericalJoint, sphericalJointDesc))
+		{
+			return false;
+		}
+
+		UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
+		TfToken axis = UsdPhysicsTokens->x;
+		sphericalJoint.GetAxisAttr().Get(&axis);
+
+		if (axis == UsdPhysicsTokens->y)
+			jointAxis = UsdPhysicsAxis::eY;
+		else if (axis == UsdPhysicsTokens->z)
+			jointAxis = UsdPhysicsAxis::eZ;
+		sphericalJointDesc->axis = jointAxis;
+
+		sphericalJointDesc->limit.enabled = false;
+		sphericalJoint.GetConeAngle0LimitAttr().Get(&sphericalJointDesc->limit.angle0);
+		sphericalJoint.GetConeAngle1LimitAttr().Get(&sphericalJointDesc->limit.angle1);
+
+		if (isfinite(sphericalJointDesc->limit.angle0) &&
+			isfinite(sphericalJointDesc->limit.angle1) &&
+			sphericalJointDesc->limit.angle0 >= 0.0 &&
+			sphericalJointDesc->limit.angle1 >= 0.0)
+		{
+			sphericalJointDesc->limit.enabled = true;
+		}
+	}
+	else
+	{
+		TF_RUNTIME_ERROR(
+			"Provided UsdPhysicsSphericalJoint or UsdPhysicsSphericalJointDesc is not valid.");
+		return false;
+	}
+
+	return true;
+}
+
+bool ParseSceneDesc(const UsdPhysicsScene& scene, UsdPhysicsSceneDesc* sceneDesc)
+{
+	if (sceneDesc && scene)
+	{
+		UsdStageWeakPtr stage = scene.GetPrim().GetStage();
+
+		GfVec3f gravityDirection;
+		scene.GetGravityDirectionAttr().Get(&gravityDirection);
+		if (gravityDirection == GfVec3f(0.0f))
+		{
+			TfToken upAxis = pxr::UsdGeomGetStageUpAxis(stage);
+			if (upAxis == pxr::UsdGeomTokens.Get()->x)
+				gravityDirection = GfVec3f(-1.0f, 0.0f, 0.0f);
+			else if (upAxis == pxr::UsdGeomTokens.Get()->y)
+				gravityDirection = GfVec3f(0.0f, -1.0f, 0.0f);
+			else
+				gravityDirection = GfVec3f(0.0f, 0.0f, -1.0f);
+		}
+		else
+		{
+			gravityDirection.Normalize();
+		}
+
+		float gravityMagnitude;
+		scene.GetGravityMagnitudeAttr().Get(&gravityMagnitude);
+		if (gravityMagnitude < -0.5e38f)
+		{
+			float metersPerUnit = (float)pxr::UsdGeomGetStageMetersPerUnit(stage);
+			gravityMagnitude = 9.81f / metersPerUnit;
+		}
+
+		sceneDesc->gravityMagnitude = gravityMagnitude;
+		sceneDesc->gravityDirection = gravityDirection;
+		sceneDesc->primPath = scene.GetPrim().GetPrimPath();
+	}
+	else
+	{
+		TF_RUNTIME_ERROR("Provided UsdPhysicsScene or UsdPhysicsSceneDesc is not valid.");
+		return false;
+	}
+	return true;
+}
+
+struct SchemaAPIFlag
+{
+	enum Enum
+	{
+		eArticulationRootAPI = 1 << 0,
+		eCollisionAPI = 1 << 1,
+		eRigidBodyAPI = 1 << 2,
+		eMaterialAPI = 1 << 3
+	};
+};
+
+bool CheckNestedArticulationRoot(const pxr::UsdPrim& usdPrim,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& articulationSet)
+{
+	UsdPrim parent = usdPrim.GetParent();
+	while (parent && parent != usdPrim.GetStage()->GetPseudoRoot())
+	{
+		if (articulationSet.find(parent.GetPrimPath()) != articulationSet.end())
+			return true;
+		parent = parent.GetParent();
+	}
+
+	return false;
+}
+
+using RigidBodyMap = std::map<pxr::SdfPath, UsdPhysicsRigidBodyDesc*>;
+
+bool IsDynamicBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, bool& physicsAPIFound)
+{
+	RigidBodyMap::const_iterator it = bodyMap.find(usdPrim.GetPrimPath());
+	if (it != bodyMap.end())
+	{
+		{
+			bool isAPISchemaEnabled = it->second->rigidBodyEnabled;
+
+			// Prim is dynamic body off PhysicsAPI is present and enabled
+			physicsAPIFound = true;
+			return isAPISchemaEnabled;
+		}
+	}
+
+	physicsAPIFound = false;
+	return false;
+}
+
+
+bool HasDynamicBodyParent(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap,
+	UsdPrim& bodyPrimPath)
+{
+	bool physicsAPIFound = false;
+	UsdPrim parent = usdPrim;
+	while (parent != usdPrim.GetStage()->GetPseudoRoot())
+	{
+		if (IsDynamicBody(parent, bodyMap, physicsAPIFound))
+		{
+			bodyPrimPath = parent;
+			return true;
+		}
+
+		if (physicsAPIFound)
+		{
+			bodyPrimPath = parent;
+			return false;
+		}
+
+		parent = parent.GetParent();
+	}
+	return false;
+}
+
+
+template <typename DescType, typename UsdType>
+void ProcessPhysicsPrims(const std::vector<UsdPrim>& physicsPrims,
+	std::vector<DescType>& physicsDesc,
+	std::function<bool(const UsdType& prim, DescType* desc)> processDescFn)
+{
+	if (!physicsPrims.empty())
+	{
+		const size_t numPrims = physicsPrims.size();
+		physicsDesc.resize(numPrims);
+
+		const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
+		{
+			for (size_t i = beginIdx; i < endIdx; i++)
+			{
+				const UsdType prim(physicsPrims[i]);
+				const bool ret = processDescFn(prim, &physicsDesc[i]);
+				if (!ret)
+				{
+					physicsDesc[i].isValid = false;
+				}
+			}
+		};
+
+		const size_t numPrimPerBatch = 10;
+		WorkParallelForN(numPrims, workLambda, numPrimPerBatch);
+	}
+}
+
+template <typename DescType>
+void CallReportFn(UsdPhysicsObjectType::Enum descType,
+	const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc,
+	UsdPhysicsReportFn reportFn, SdfPathVector& primPathsVector, void* userData)
+{
+	primPathsVector.resize(physicsPrims.size());
+	for (size_t i = 0; i < physicsPrims.size(); i++)
+	{
+		primPathsVector[i] = physicsPrims[i].GetPrimPath();
+	}
+	reportFn(descType, primPathsVector.size(), primPathsVector.data(), physicsDesc.data(), userData);
+}
+
+void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims,
+	std::vector<UsdPhysicsRigidBodyDesc>& rigidBodyDescs,
+	bool defaultSimulationOwner, std::unordered_set<SdfPath, SdfPath::Hash>& reportedBodies,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+	for (size_t i = rigidBodyDescs.size(); i--;)
+	{
+		bool ownerFound = false;
+		const UsdPhysicsRigidBodyDesc& desc = rigidBodyDescs[i];
+		if (desc.isValid)
+		{
+			if (desc.simulationOwners.empty() && defaultSimulationOwner)
+			{
+				reportedBodies.insert(desc.primPath);
+				ownerFound = true;
+			}
+			else
+			{
+				for (const SdfPath& owner : desc.simulationOwners)
+				{
+					if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+					{
+						reportedBodies.insert(desc.primPath);
+						ownerFound = true;
+						break;
+					}
+				}
+			}
+		}
+		if (!ownerFound)
+		{
+			rigidBodyDescs[i] = rigidBodyDescs.back();
+			rigidBodyDescs.pop_back();
+			rigidBodyPrims[i] = rigidBodyPrims.back();
+			rigidBodyPrims.pop_back();
+		}
+	}
+}
+
+// if collision belongs to a body that we care about include it
+// if collision does not belong to a body we care about its not included
+// if collision does not have a body set, we check its own simulationOwners
+template <typename DescType>
+void CheckCollisionSimulationOwner(std::vector<UsdPrim>& collisionPrims,
+	std::vector<DescType>& shapeDesc,
+	bool defaultSimulationOwner,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+	for (size_t i = shapeDesc.size(); i--;)
+	{
+		bool ownerFound = false;
+		const UsdPhysicsShapeDesc& desc = shapeDesc[i];
+		if (desc.isValid)
+		{
+			if (desc.rigidBody != SdfPath() &&
+				rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+			{
+				if (desc.rigidBody != SdfPath() &&
+					rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+				{
+					ownerFound = true;
+				}
+				else
+				{
+					if (desc.rigidBody == SdfPath())
+					{
+						if (desc.simulationOwners.empty() && defaultSimulationOwner)
+						{
+							ownerFound = true;
+						}
+						else
+						{
+							for (const SdfPath& owner : desc.simulationOwners)
+							{
+								if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+								{
+									ownerFound = true;
+									break;
+								}
+							}
+						}
+					}
+				}
+
+				ownerFound = true;
+			}
+			else
+			{
+				if (desc.rigidBody == SdfPath())
+				{
+					if (desc.simulationOwners.empty() && defaultSimulationOwner)
+					{
+						ownerFound = true;
+					}
+					else
+					{
+						for (const SdfPath& owner : desc.simulationOwners)
+						{
+							if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+							{
+								ownerFound = true;
+								break;
+							}
+						}
+					}
+				}
+			}
+		}
+
+		if (!ownerFound)
+		{
+			shapeDesc[i] = shapeDesc.back();
+			shapeDesc.pop_back();
+			collisionPrims[i] = collisionPrims.back();
+			collisionPrims.pop_back();
+		}
+	}
+}
+
+// Both bodies need to have simulation owners valid
+template <typename DescType>
+void CheckJointSimulationOwner(std::vector<UsdPrim>& jointPrims,
+	std::vector<DescType>& jointDesc,
+	bool defaultSimulationOwner, const std::unordered_set<SdfPath,
+	SdfPath::Hash>& rigidBodiesSet,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+	for (size_t i = jointDesc.size(); i--;)
+	{
+		const UsdPhysicsJointDesc& desc = jointDesc[i];
+
+		bool ownersValid = false;
+		if (desc.isValid)
+		{
+			if ((desc.body0 == SdfPath() ||
+				rigidBodiesSet.find(desc.body0) != rigidBodiesSet.end()) &&
+				(desc.body1 == SdfPath() ||
+					rigidBodiesSet.find(desc.body1) != rigidBodiesSet.end()))
+			{
+				ownersValid = true;
+			}
+		}
+
+		if (!ownersValid)
+		{
+			jointDesc[i] = jointDesc.back();
+			jointDesc.pop_back();
+			jointPrims[i] = jointPrims.back();
+			jointPrims.pop_back();
+		}
+	}
+}
+
+// all bodies must have valid owner
+void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims,
+	std::vector<UsdPhysicsArticulationDesc>& articulationDescs,
+	bool defaultSimulationOwner,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+{
+	for (size_t i = articulationDescs.size(); i--;)
+	{
+		const UsdPhysicsArticulationDesc& desc = articulationDescs[i];
+
+		bool ownersValid = true;
+		if (desc.isValid)
+		{
+			for (const SdfPath& body : desc.articulatedBodies)
+			{
+				if (body != SdfPath() && rigidBodiesSet.find(body) == rigidBodiesSet.end())
+				{
+					ownersValid = false;
+					break;
+				}
+			}
+		}
+
+		if (!ownersValid)
+		{
+			articulationDescs[i] = articulationDescs.back();
+			articulationDescs.pop_back();
+			articulationPrims[i] = articulationPrims.back();
+			articulationPrims.pop_back();
+		}
+	}
+}
+
+SdfPath GetRigidBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap)
+{
+	UsdPrim bodyPrim = UsdPrim();
+	if (HasDynamicBodyParent(usdPrim, bodyMap, bodyPrim))
+	{
+		return bodyPrim.GetPrimPath();
+	}
+	else
+	{
+		// collision does not have a dynamic body parent, it is considered a static collision        
+		if (bodyPrim == UsdPrim())
+		{
+			return SdfPath();
+		}
+		else
+		{
+			return bodyPrim.GetPrimPath();
+		}
+	}
+}
+
+void GetCollisionShapeLocalTransfrom(const UsdPrim& collisionPrim,
+	const UsdPrim& bodyPrim,
+	GfVec3f& localPosOut,
+	GfQuatf& localRotOut,
+	GfVec3f& localScaleOut)
+{
+	// body transform
+	const GfMatrix4d bodyLocalToWorldMatrix =
+		UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+
+	// compute the shape rel transform to a body and store it.
+	pxr::GfVec3f localPos(0.0f);
+	if (collisionPrim != bodyPrim)
+	{
+		const GfMatrix4d collisionLocalToWorldMatrix =
+			UsdGeomXformable(collisionPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+
+		const pxr::GfMatrix4d mat =
+			collisionLocalToWorldMatrix * bodyLocalToWorldMatrix.GetInverse();
+		GfTransform colLocalTransform(mat);
+
+		localPos = pxr::GfVec3f(colLocalTransform.GetTranslation());
+		localRotOut = pxr::GfQuatf(colLocalTransform.GetRotation().GetQuat());
+		localScaleOut = pxr::GfVec3f(colLocalTransform.GetScale());
+	}
+	else
+	{
+		const pxr::GfMatrix4d mat(1.0);
+
+		localRotOut = pxr::GfQuatf(1.0f);
+		localScaleOut = pxr::GfVec3f(1.0f);
+	}
+
+	// now apply the body scale to localPos
+	// physics does not support scales, so a rigid body scale has to be baked 
+	// into the localPos
+	const pxr::GfTransform tr(bodyLocalToWorldMatrix);
+	const pxr::GfVec3d sc = tr.GetScale();
+
+	for (int i = 0; i < 3; i++)
+	{
+		localPos[i] *= (float)sc[i];
+	}
+
+	localPosOut = localPos;
+}
+
+void FinalizeCollision(UsdStageWeakPtr stage, const UsdPhysicsRigidBodyDesc* bodyDesc,
+	UsdPhysicsShapeDesc* shapeDesc)
+{
+	// get shape local pose
+	const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
+	GetCollisionShapeLocalTransfrom(shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
+		shapeDesc->localPos, shapeDesc->localRot, shapeDesc->localScale);
+
+	if (bodyDesc)
+	{
+		shapeDesc->rigidBody = bodyDesc->primPath;
+	}
+}
+
+template <typename DescType>
+void FinalizeCollisionDescs(UsdGeomXformCache& xfCache,
+	const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc,
+	const RigidBodyMap& bodyMap,
+	const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
+{
+	const auto workLambda = [physicsPrims, &physicsDesc, bodyMap, collisionGroups]
+	(const size_t beginIdx, const size_t endIdx)
+	{
+		for (size_t i = beginIdx; i < endIdx; i++)
+		{
+			DescType& colDesc = physicsDesc[i];
+			if (colDesc.isValid)
+			{
+				const UsdPrim prim = physicsPrims[i];
+				// get the body
+				SdfPath bodyPath = GetRigidBody(prim, bodyMap);
+				// body was found, add collision to the body
+				UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
+				if (bodyPath != SdfPath())
+				{
+					RigidBodyMap::const_iterator bodyIt = bodyMap.find(bodyPath);
+					if (bodyIt != bodyMap.end())
+					{
+						bodyDesc = bodyIt->second;
+						bodyDesc->collisions.push_back(colDesc.primPath);
+					}
+				}
+
+				// check if collision belongs to collision groups
+				for (std::map<SdfPath,
+					std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
+					it != collisionGroups.end(); ++it)
+				{
+					if (it->second.find(colDesc.primPath) != it->second.end())
+					{
+						colDesc.collisionGroups.push_back(it->first);
+					}
+				}
+
+				// finalize the collision, fill up the local transform etc
+				FinalizeCollision(prim.GetStage(), bodyDesc, &colDesc);
+			}
+		}
+	};
+
+	const size_t numPrimPerBatch = 10;
+	WorkParallelForN(physicsPrims.size(), workLambda, numPrimPerBatch);
+}
+
+struct ArticulationLink
+{
+	SdfPathVector   childs;
+	SdfPath         rootJoint;
+	uint32_t        weight;
+	uint32_t        index;
+	bool            hasFixedJoint;
+	SdfPathVector   joints;
+};
+
+using ArticulationLinkMap = std::map<pxr::SdfPath, ArticulationLink>;
+using BodyJointMap =
+pxr::TfHashMap<pxr::SdfPath, std::vector<const UsdPhysicsJointDesc*>, pxr::SdfPath::Hash>;
+using JointMap = std::map<pxr::SdfPath, UsdPhysicsJointDesc*>;
+using ArticulationMap = std::map<pxr::SdfPath, UsdPhysicsArticulationDesc*>;
+
+bool IsInLinkMap(const SdfPath& path, const std::vector<ArticulationLinkMap>& linkMaps)
+{
+	for (size_t i = 0; i < linkMaps.size(); i++)
+	{
+		ArticulationLinkMap::const_iterator it = linkMaps[i].find(path);
+		if (it != linkMaps[i].end())
+			return true;
+	}
+
+	return false;
+}
+
+void TraverseHierarchy(const pxr::UsdStageWeakPtr stage, const SdfPath& linkPath,
+	ArticulationLinkMap& articulationLinkMap, const BodyJointMap& bodyJointMap,
+	uint32_t& index, SdfPathVector& linkOrderVector)
+{
+	// check if we already parsed this link
+	ArticulationLinkMap::const_iterator artIt = articulationLinkMap.find(linkPath);
+	if (artIt != articulationLinkMap.end())
+		return;
+
+	linkOrderVector.push_back(linkPath);
+
+	BodyJointMap::const_iterator bjIt = bodyJointMap.find(linkPath);
+	if (bjIt != bodyJointMap.end())
+	{
+		ArticulationLink& link = articulationLinkMap[linkPath];
+		link.weight = 0;
+		link.index = index++;
+		link.hasFixedJoint = false;
+		const std::vector<const UsdPhysicsJointDesc*>& joints = bjIt->second;
+		for (size_t i = 0; i < joints.size(); i++)
+		{
+			const UsdPhysicsJointDesc* desc = joints[i];
+			link.joints.push_back(desc->primPath);
+			if (desc->body0 == SdfPath() || (bodyJointMap.find(desc->body0) == bodyJointMap.end()) ||
+				desc->body1 == SdfPath() || (bodyJointMap.find(desc->body1) == bodyJointMap.end()))
+			{
+				if (desc->excludeFromArticulation)
+				{
+					link.weight += 1000;
+				}
+				else
+				{
+					link.weight += 100000;
+					link.rootJoint = desc->primPath;
+					link.hasFixedJoint = true;
+				}
+				link.childs.push_back(SdfPath());
+			}
+			else
+			{
+				if (desc->excludeFromArticulation)
+				{
+					link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
+					link.weight += 1000;
+				}
+				else
+				{
+					link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
+					link.weight += 100;
+					TraverseHierarchy(stage, link.childs.back(), articulationLinkMap, bodyJointMap, index, linkOrderVector);
+				}
+			}
+		}
+	}
+}
+
+void TraverseChilds(const ArticulationLink& link, const ArticulationLinkMap& map,
+	uint32_t startIndex, uint32_t distance, int32_t* pathMatrix)
+{
+	const size_t mapSize = map.size();
+	const uint32_t currentIndex = link.index;
+	pathMatrix[startIndex + currentIndex * mapSize] = distance;
+
+	for (size_t i = 0; i < link.childs.size(); i++)
+	{
+		ArticulationLinkMap::const_iterator it = map.find(link.childs[i]);
+		if (it != map.end())
+		{
+			const uint32_t childIndex = it->second.index;
+			if (pathMatrix[startIndex + childIndex * mapSize] < 0)
+			{
+				TraverseChilds(it->second, map, startIndex, distance + 1, pathMatrix);
+			}
+		}
+	}
+}
+
+pxr::SdfPath GetCenterOfGraph(const ArticulationLinkMap& map, const SdfPathVector& linkOrderVector)
+{
+	const size_t size = map.size();
+	int32_t* pathMatrix = new int32_t[size * size];
+	for (size_t i = 0; i < size; i++)
+	{
+		for (size_t j = 0; j < size; j++)
+		{
+			pathMatrix[i + j * size] = -1;
+		}
+	}
+
+	for (ArticulationLinkMap::const_reference& ref : map)
+	{
+		const uint32_t startIndex = ref.second.index;
+		uint32_t distance = 0;
+		TraverseChilds(ref.second, map, startIndex, distance, pathMatrix);
+	}
+
+	int32_t shortestDistance = INT_MAX;
+	size_t numChilds = 0;
+	SdfPath primpath = SdfPath();
+	for (ArticulationLinkMap::const_reference& ref : map)
+	{
+		const uint32_t startIndex = ref.second.index;
+		int32_t longestPath = 0;
+		for (size_t i = 0; i < size; i++)
+		{
+			if (pathMatrix[startIndex + i * size] > longestPath)
+			{
+				longestPath = pathMatrix[startIndex + i * size];
+			}
+		}
+
+		// this needs to be deterministic, get the shortest path
+		// if there are more paths with same lenght, pick the one with more childs
+		// if there are more with same path and same amount of childs, pick the 
+		// one with lowest hash
+		// The lowest hash is not right, this is wrong, it has to be the first link 
+		// ordered by the traversal
+		if (longestPath < shortestDistance)
+		{
+			shortestDistance = longestPath;
+			numChilds = ref.second.childs.size();
+			primpath = ref.first;
+		}
+		else if (longestPath == shortestDistance)
+		{
+			if (numChilds < ref.second.childs.size())
+			{
+				numChilds = ref.second.childs.size();
+				primpath = ref.first;
+			}
+			else if (numChilds == ref.second.childs.size())
+			{
+				for (const SdfPath& orderPath : linkOrderVector)
+				{
+					if (orderPath == primpath)
+					{
+						break;
+					}
+					else if (orderPath == ref.first)
+					{
+						primpath = ref.first;
+					}
+				}
+			}
+		}
+	}
+
+	delete[] pathMatrix;
+
+	return primpath;
+}
+
+void FinalizeArticulations(const pxr::UsdStageWeakPtr stage,
+	ArticulationMap& articulationMap, const RigidBodyMap& rigidBodyMap,
+	const JointMap& jointMap)
+{
+	BodyJointMap bodyJointMap;
+	if (!articulationMap.empty())
+	{
+		// construct the BodyJointMap
+		bodyJointMap.reserve(rigidBodyMap.size());
+		for (JointMap::const_reference& jointIt : jointMap)
+		{
+			const UsdPhysicsJointDesc* desc = jointIt.second;
+			if (desc->jointEnabled)
+			{
+				if (desc->body0 != SdfPath())
+				{
+					RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body0);
+					if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled &&
+						!fit->second->kinematicBody)
+					{
+						bodyJointMap[desc->body0].push_back(desc);
+					}
+				}
+				if (desc->body1 != SdfPath())
+				{
+					RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body1);
+					if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled &&
+						!fit->second->kinematicBody)
+					{
+						bodyJointMap[desc->body1].push_back(desc);
+					}
+				}
+			}
+		}
+	}
+
+	// first get user defined articulation roots
+	// then search for the best root in the articulation hierarchy
+	const auto workLambda = [rigidBodyMap, jointMap, stage, bodyJointMap]
+	(ArticulationMap::const_reference& it)
+	{
+		SdfPathVector articulationLinkOrderVector;
+
+		const SdfPath& articulationPath = it.first;
+		SdfPath articulationBaseLinkPath = articulationPath;
+
+		std::set<SdfPath> articulatedJoints;
+		std::set<SdfPath> articulatedBodies;
+
+		// check if its a floating articulation
+		{
+			RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(articulationPath);
+			if (bodyIt != rigidBodyMap.end())
+			{
+				if (!bodyIt->second->rigidBodyEnabled)
+				{
+					TF_DIAGNOSTIC_WARNING(
+						"ArticulationRootAPI definition on a static rigid body is not allowed, articulation root will be ignored.Prim: %s",
+						articulationPath.GetText());
+					return;
+				}
+				if (bodyIt->second->kinematicBody)
+				{
+					TF_DIAGNOSTIC_WARNING(
+						"ArticulationRootAPI definition on a kinematic rigid body is not allowed, articulation root will be ignored.Prim: %s",
+						articulationPath.GetText());
+					return;
+				}
+				it.second->rootPrims.push_back(bodyIt->first);
+			}
+			else
+			{
+				JointMap::const_iterator jointIt = jointMap.find(articulationPath);
+				if (jointIt != jointMap.end())
+				{
+					const SdfPath& jointPath = jointIt->first;
+					const UsdPhysicsJointDesc* jointDesc = jointIt->second;
+					if (jointDesc->body0 == SdfPath() || jointDesc->body1 == SdfPath())
+					{
+						it.second->rootPrims.push_back(jointPath);
+						articulationBaseLinkPath = jointDesc->body0 == SdfPath() ?
+							jointDesc->body1 : jointDesc->body0;
+					}
+				}
+			}
+		}
+
+		// search through the hierarchy for the best root        
+		const UsdPrim articulationPrim = stage->GetPrimAtPath(articulationBaseLinkPath);
+		if (!articulationPrim)
+			return;
+		UsdPrimRange range(articulationPrim, UsdTraverseInstanceProxies());
+		std::vector<ArticulationLinkMap> articulationLinkMaps;
+		articulationLinkOrderVector.clear();
+
+		for (pxr::UsdPrimRange::const_iterator iter = range.begin(); iter != range.end(); ++iter)
+		{
+			const pxr::UsdPrim& prim = *iter;
+			if (!prim)
+				continue;
+			const SdfPath primPath = prim.GetPrimPath();
+			if (IsInLinkMap(primPath, articulationLinkMaps))
+			{
+				iter.PruneChildren(); // Skip the subtree rooted at this prim
+				continue;
+			}
+
+			RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(primPath);
+			if (bodyIt != rigidBodyMap.end())
+			{
+				articulationLinkMaps.push_back(ArticulationLinkMap());
+				uint32_t index = 0;
+				TraverseHierarchy(stage, primPath, articulationLinkMaps.back(),
+					bodyJointMap, index, articulationLinkOrderVector);
+			}
+		}
+
+		if (it.second->rootPrims.empty())
+		{
+			for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+			{
+				const ArticulationLinkMap& map = articulationLinkMaps[i];
+				SdfPath linkPath = SdfPath();
+				uint32_t largestWeight = 0;
+				bool hasFixedJoint = false;
+				for (ArticulationLinkMap::const_reference& linkIt : map)
+				{
+					if (linkIt.second.hasFixedJoint)
+					{
+						hasFixedJoint = true;
+					}
+					if (linkIt.second.weight > largestWeight)
+					{
+						linkPath = (linkIt.second.rootJoint != SdfPath()) ?
+							linkIt.second.rootJoint : linkIt.first;
+						largestWeight = linkIt.second.weight;
+					}
+					else if (linkIt.second.weight == largestWeight)
+					{
+						const SdfPath optionalLinkPath =
+							(linkIt.second.rootJoint != SdfPath()) ?
+							linkIt.second.rootJoint : linkIt.first;
+						for (const SdfPath& orderPath : articulationLinkOrderVector)
+						{
+							if (orderPath == linkPath)
+							{
+								break;
+							}
+							else if (orderPath == optionalLinkPath)
+							{
+								linkPath = optionalLinkPath;
+							}
+						}
+					}
+
+					for (size_t j = linkIt.second.joints.size(); j--;)
+					{
+						articulatedJoints.insert(linkIt.second.joints[j]);
+					}
+				}
+
+				// for floating articulation lets find the body with the shortest 
+				// paths (center of graph)
+				if (!hasFixedJoint)
+				{
+					linkPath = GetCenterOfGraph(map, articulationLinkOrderVector);
+				}
+
+				if (linkPath != SdfPath())
+				{
+					it.second->rootPrims.push_back(linkPath);
+				}
+			}
+		}
+		else
+		{
+			for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+			{
+				const ArticulationLinkMap& map = articulationLinkMaps[i];
+				for (ArticulationLinkMap::const_reference& linkIt : map)
+				{
+					for (size_t j = linkIt.second.joints.size(); j--;)
+					{
+						articulatedJoints.insert(linkIt.second.joints[j]);
+					}
+				}
+			}
+		}
+		for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+		{
+			const ArticulationLinkMap& map = articulationLinkMaps[i];
+			for (ArticulationLinkMap::const_reference& linkIt : map)
+			{
+				articulatedBodies.insert(linkIt.second.childs.begin(), linkIt.second.childs.end());
+			}
+		}
+
+		if (it.second->rootPrims.empty())
+		{
+			it.second->isValid = false;
+		}
+
+		for (const SdfPath& p : articulatedJoints)
+		{
+			it.second->articulatedJoints.push_back(p);
+		}
+		for (const SdfPath& p : articulatedBodies)
+		{
+			it.second->articulatedBodies.push_back(p);
+		}
+	};
+
+	WorkParallelForEach(articulationMap.begin(), articulationMap.end(), workLambda);
+}
+
+bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
+	ParsePrimIteratorBase& primIterator,
+	UsdPhysicsReportFn reportFn,
+	void* userData,
+	const CustomUsdPhysicsTokens* customPhysicsTokens,
+	const std::vector<SdfPath>* simulationOwners)
+{
+	bool retVal = true;
+
+	if (!stage)
+	{
+		TF_RUNTIME_ERROR("Provided stage not valid.");
+		return false;
+	}
+
+	if (!reportFn)
+	{
+		TF_RUNTIME_ERROR("Provided report callback is not valid.");
+		return false;
+	}
+
+
+	std::vector<UsdPrim> scenePrims;
+	std::vector<UsdPrim> collisionGroupPrims;
+	std::vector<UsdPrim> materialPrims;
+	std::vector<UsdPrim> articulationPrims;
+	std::unordered_set<SdfPath, SdfPath::Hash> articulationPathsSet;
+	std::vector<UsdPrim> physicsD6JointPrims;
+	std::vector<UsdPrim> physicsRevoluteJointPrims;
+	std::vector<UsdPrim> physicsFixedJointPrims;
+	std::vector<UsdPrim> physicsPrismaticJointPrims;
+	std::vector<UsdPrim> physicsSphericalJointPrims;
+	std::vector<UsdPrim> physicsDistanceJointPrims;
+	std::vector<UsdPrim> physicsCustomJointPrims;
+	std::vector<UsdPrim> collisionPrims;
+	std::vector<UsdPrim> rigidBodyPrims;
+
+	// parse for scene first, get the descriptors, report all prims
+	// the descriptors are not complete yet
+	primIterator.reset();
+
+	static const TfToken gRigidBodyAPIToken("PhysicsRigidBodyAPI");
+	static const TfToken gCollisionAPIToken("PhysicsCollisionAPI");
+	static const TfToken gArticulationRootAPIToken("PhysicsArticulationRootAPI");
+	static const TfToken gMaterialAPIToken("PhysicsMaterialAPI");
+
+	bool defaultSimulationOwner = false;
+	std::unordered_set<SdfPath, SdfPath::Hash> simulationOwnersSet;
+	if (simulationOwners)
+	{
+		for (const SdfPath& p : *simulationOwners)
+		{
+			if (p == SdfPath())
+			{
+				defaultSimulationOwner = true;
+			}
+			else
+			{
+				simulationOwnersSet.insert(p);
+			}
+		}
+	}
+
+	while (!primIterator.atEnd())
+	{
+		const pxr::UsdPrim& prim = *primIterator.getCurrent();
+		if (!prim)
+		{
+			primIterator.pruneChildren();
+			primIterator.next();
+			continue;
+		}
+
+		const SdfPath primPath = prim.GetPrimPath();
+		const UsdPrimTypeInfo& typeInfo = prim.GetPrimTypeInfo();
+
+		uint64_t apiFlags = 0;
+		const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
+		for (const TfToken& token : apis)
+		{
+			if (token == gArticulationRootAPIToken)
+			{
+				apiFlags |= SchemaAPIFlag::eArticulationRootAPI;
+			}
+			if (token == gCollisionAPIToken)
+			{
+				apiFlags |= SchemaAPIFlag::eCollisionAPI;
+			}
+			if (token == gRigidBodyAPIToken)
+			{
+				apiFlags |= SchemaAPIFlag::eRigidBodyAPI;
+			}
+			if (!apiFlags && token == gMaterialAPIToken)
+			{
+				apiFlags |= SchemaAPIFlag::eMaterialAPI;
+			}
+		}
+
+		if (typeInfo.GetSchemaType().IsA<UsdGeomPointInstancer>())
+		{
+			primIterator.pruneChildren(); // Skip the subtree for point instancers, 
+			//those have to be traversed per prototype
+		}
+		else if (customPhysicsTokens && !customPhysicsTokens->instancerTokens.empty())
+		{
+			for (const TfToken& instToken : customPhysicsTokens->instancerTokens)
+			{
+				if (instToken == typeInfo.GetTypeName())
+				{
+					primIterator.pruneChildren(); // Skip the subtree for custom 
+					// instancers, those have to be traversed per prototype
+					break;
+				}
+			}
+		}
+
+		if (typeInfo.GetSchemaType().IsA<UsdPhysicsScene>())
+		{
+			scenePrims.push_back(prim);
+		}
+		else if (typeInfo.GetSchemaType().IsA<UsdPhysicsCollisionGroup>())
+		{
+			collisionGroupPrims.push_back(prim);
+		}
+		else if (apiFlags & SchemaAPIFlag::eMaterialAPI)
+		{
+			materialPrims.push_back(prim);
+		}
+		else if (typeInfo.GetSchemaType().IsA<UsdPhysicsJoint>())
+		{
+			if (typeInfo.GetSchemaType().IsA<UsdPhysicsFixedJoint>())
+			{
+				physicsFixedJointPrims.push_back(prim);
+			}
+			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsRevoluteJoint>())
+			{
+				physicsRevoluteJointPrims.push_back(prim);
+			}
+			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsPrismaticJoint>())
+			{
+				physicsPrismaticJointPrims.push_back(prim);
+			}
+			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsSphericalJoint>())
+			{
+				physicsSphericalJointPrims.push_back(prim);
+			}
+			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsDistanceJoint>())
+			{
+				physicsDistanceJointPrims.push_back(prim);
+			}
+			else
+			{
+				bool customJoint = false;
+				if (customPhysicsTokens)
+				{
+					const TfToken& primType = typeInfo.GetTypeName();
+					for (size_t i = 0; i < customPhysicsTokens->jointTokens.size(); i++)
+					{
+						if (primType == customPhysicsTokens->jointTokens[i])
+						{
+							customJoint = true;
+							break;
+						}
+					}
+				}
+
+				if (customJoint)
+				{
+					physicsCustomJointPrims.push_back(prim);
+				}
+				else
+				{
+					physicsD6JointPrims.push_back(prim);
+				}
+			}
+
+
+			// can be articulation definition
+			if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
+			{
+				articulationPrims.push_back(prim);
+				articulationPathsSet.insert(prim.GetPrimPath());
+			}
+		}
+		else
+		{
+			if (apiFlags & SchemaAPIFlag::eCollisionAPI)
+			{
+				collisionPrims.push_back(prim);
+			}
+			if (apiFlags & SchemaAPIFlag::eRigidBodyAPI)
+			{
+				rigidBodyPrims.push_back(prim);
+			}
+			if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
+			{
+				articulationPrims.push_back(prim);
+				articulationPathsSet.insert(prim.GetPrimPath());
+			}
+		}
+
+		primIterator.next();
+	}
+
+	// process parsing
+	// 
+	// Scenes
+	std::vector<UsdPhysicsSceneDesc> sceneDescs;
+
+	// is simulation owners provided, restrict scenes to just the one specified
+	if (simulationOwners)
+	{
+		for (size_t i = scenePrims.size(); i--;)
+		{
+			const SdfPath& primPath = scenePrims[i].GetPrimPath();
+			std::unordered_set<SdfPath, SdfPath::Hash>::const_iterator fit =
+				simulationOwnersSet.find(primPath);
+			if (fit == simulationOwnersSet.end())
+			{
+				scenePrims[i] = scenePrims.back();
+				scenePrims.pop_back();
+			}
+		}
+	}
+	ProcessPhysicsPrims<UsdPhysicsSceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs,
+		ParseSceneDesc);
+
+	// Collision Groups
+	std::vector<UsdPhysicsCollisionGroupDesc> collisionGroupsDescs;
+	ProcessPhysicsPrims<UsdPhysicsCollisionGroupDesc, UsdPhysicsCollisionGroup>
+		(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
+	// Run groups merging
+	std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets;
+	std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
+	for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
+	{
+		const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
+
+		collisionGroupSets[desc.primPath];
+
+		if (!desc.mergeGroupName.empty())
+		{
+			std::unordered_map<std::string, size_t>::const_iterator fit =
+				mergeGroupNameToIndex.find(desc.mergeGroupName);
+			if (fit != mergeGroupNameToIndex.end())
+			{
+				UsdPhysicsCollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
+				mergeDesc.mergedGroups.push_back(desc.primPath);
+				for (const SdfPath& sp : desc.filteredGroups)
+				{
+					mergeDesc.filteredGroups.push_back(sp);
+				}
+
+				collisionGroupsDescs[i] = collisionGroupsDescs.back();
+				collisionGroupPrims[i] = collisionGroupPrims.back();
+				collisionGroupsDescs.pop_back();
+				collisionGroupPrims.pop_back();
+				i--;
+			}
+			else
+			{
+				mergeGroupNameToIndex[desc.mergeGroupName] = i;
+				collisionGroupsDescs[i].mergedGroups.push_back(desc.primPath);
+			}
+		}
+	}
+
+	// Populate the sets to check collisions
+	{
+		const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
+		{
+			for (size_t i = beginIdx; i < endIdx; i++)
+			{
+				const UsdPrim groupPrim = collisionGroupPrims[i];
+				UsdStageWeakPtr stage = groupPrim.GetStage();
+				const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
+
+				std::unordered_set<SdfPath, SdfPath::Hash>& hashSet =
+					collisionGroupSets[desc.primPath];
+
+				if (desc.mergedGroups.empty())
+				{
+					const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
+					if (cg)
+					{
+						const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
+						UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
+						const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+						for (const SdfPath& path : includedPaths)
+						{
+							hashSet.insert(path);
+						}
+					}
+				}
+				else
+				{
+					for (const SdfPath& groupPath : desc.mergedGroups)
+					{
+						const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
+						if (cg)
+						{
+							const UsdCollectionAPI collectionAPI =
+								cg.GetCollidersCollectionAPI();
+							UsdCollectionMembershipQuery query =
+								collectionAPI.ComputeMembershipQuery();
+							const SdfPathSet includedPaths =
+								UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+							for (const SdfPath& path : includedPaths)
+							{
+								hashSet.insert(path);
+							}
+						}
+					}
+				}
+			}
+		};
+
+		const size_t numPrimPerBatch = 10;
+		WorkParallelForN(collisionGroupsDescs.size(), workLambda, numPrimPerBatch);
+	}
+
+	// Rigid body physics material
+	std::vector<UsdPhysicsRigidBodyMaterialDesc> materialDescs;
+	ProcessPhysicsPrims<UsdPhysicsRigidBodyMaterialDesc, UsdPhysicsMaterialAPI>
+		(materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
+
+	// Joints
+	std::vector<UsdPhysicsD6JointDesc> jointDescs;
+	ProcessPhysicsPrims<UsdPhysicsD6JointDesc, UsdPhysicsJoint>
+		(physicsD6JointPrims, jointDescs, ParseD6JointDesc);
+
+	std::vector<UsdPhysicsRevoluteJointDesc> revoluteJointDescs;
+	ProcessPhysicsPrims<UsdPhysicsRevoluteJointDesc, UsdPhysicsRevoluteJoint>
+		(physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
+
+	std::vector<UsdPhysicsPrismaticJointDesc> prismaticJointDescs;
+	ProcessPhysicsPrims<UsdPhysicsPrismaticJointDesc, UsdPhysicsPrismaticJoint>
+		(physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
+
+	std::vector<UsdPhysicsSphericalJointDesc> sphericalJointDescs;
+	ProcessPhysicsPrims<UsdPhysicsSphericalJointDesc, UsdPhysicsSphericalJoint>
+		(physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
+
+	std::vector<UsdPhysicsFixedJointDesc> fixedJointDescs;
+	ProcessPhysicsPrims<UsdPhysicsFixedJointDesc, UsdPhysicsFixedJoint>
+		(physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
+
+	std::vector<UsdPhysicsDistanceJointDesc> distanceJointDescs;
+	ProcessPhysicsPrims<UsdPhysicsDistanceJointDesc, UsdPhysicsDistanceJoint>
+		(physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
+
+	std::vector<UsdPhysicsCustomJointDesc> customJointDescs;
+	ProcessPhysicsPrims<UsdPhysicsCustomJointDesc, UsdPhysicsJoint>
+		(physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
+
+	// A.B. contruct joint map revisit    
+	JointMap jointMap;
+	for (UsdPhysicsD6JointDesc& desc : jointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+	for (UsdPhysicsRevoluteJointDesc& desc : revoluteJointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+	for (UsdPhysicsPrismaticJointDesc& desc : prismaticJointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+	for (UsdPhysicsSphericalJointDesc& desc : sphericalJointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+	for (UsdPhysicsFixedJointDesc& desc : fixedJointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+	for (UsdPhysicsDistanceJointDesc& desc : distanceJointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+	for (UsdPhysicsCustomJointDesc& desc : customJointDescs)
+	{
+		jointMap[desc.primPath] = &desc;
+	}
+
+
+	// collisions
+	// first get the type
+	std::vector<UsdPhysicsObjectType::Enum> collisionTypes;
+	collisionTypes.resize(collisionPrims.size());
+	std::vector<TfToken> customTokens;
+	{
+		const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
+		{
+			for (size_t i = beginIdx; i < endIdx; i++)
+			{
+				if (customPhysicsTokens)
+				{
+					TfToken shapeToken;
+					const UsdPhysicsObjectType::Enum shapeType =
+						GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
+					collisionTypes[i] = shapeType;
+					if (shapeType == UsdPhysicsObjectType::eCustomShape)
+					{
+						customTokens.push_back(shapeToken);
+					}
+				}
+				else
+				{
+					collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
+				}
+			}
+		};
+
+		const size_t numPrimPerBatch = 10;
+		WorkParallelForN(collisionPrims.size(), workLambda, numPrimPerBatch);
+	}
+
+	std::vector<UsdPrim> sphereShapePrims;
+	std::vector<UsdPrim> cubeShapePrims;
+	std::vector<UsdPrim> cylinderShapePrims;
+	std::vector<UsdPrim> capsuleShapePrims;
+	std::vector<UsdPrim> coneShapePrims;
+	std::vector<UsdPrim> planeShapePrims;
+	std::vector<UsdPrim> meshShapePrims;
+	std::vector<UsdPrim> spherePointsShapePrims;
+	std::vector<UsdPrim> customShapePrims;
+	for (size_t i = 0; i < collisionTypes.size(); i++)
+	{
+		UsdPhysicsObjectType::Enum type = collisionTypes[i];
+		switch (type)
+		{
+		case UsdPhysicsObjectType::eSphereShape:
+		{
+			sphereShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eCubeShape:
+		{
+			cubeShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eCapsuleShape:
+		{
+			capsuleShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eCylinderShape:
+		{
+			cylinderShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eConeShape:
+		{
+			coneShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eMeshShape:
+		{
+			meshShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::ePlaneShape:
+		{
+			planeShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eCustomShape:
+		{
+			customShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eSpherePointsShape:
+		{
+			spherePointsShapePrims.push_back(collisionPrims[i]);
+		}
+		break;
+		case UsdPhysicsObjectType::eUndefined:
+		default:
+		{
+			TF_DIAGNOSTIC_WARNING("CollisionAPI applied to an unknown UsdGeomGPrim type, prim %s.",
+				collisionPrims[i].GetPrimPath().GetString().c_str());
+		}
+		break;
+		}
+	}
+	std::vector<UsdPhysicsSphereShapeDesc> sphereShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsSphereShapeDesc, UsdPhysicsCollisionAPI>
+		(sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
+
+	std::vector<UsdPhysicsCubeShapeDesc> cubeShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsCubeShapeDesc, UsdPhysicsCollisionAPI>
+		(cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
+
+	std::vector<UsdPhysicsCylinderShapeDesc> cylinderShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsCylinderShapeDesc, UsdPhysicsCollisionAPI>
+		(cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
+
+	std::vector<UsdPhysicsCapsuleShapeDesc> capsuleShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsCapsuleShapeDesc, UsdPhysicsCollisionAPI>
+		(capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
+
+	std::vector<UsdPhysicsConeShapeDesc> coneShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsConeShapeDesc, UsdPhysicsCollisionAPI>
+		(coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
+
+	std::vector<UsdPhysicsPlaneShapeDesc> planeShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsPlaneShapeDesc, UsdPhysicsCollisionAPI>
+		(planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
+
+	std::vector<UsdPhysicsMeshShapeDesc> meshShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsMeshShapeDesc, UsdPhysicsCollisionAPI>
+		(meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
+
+	std::vector<UsdPhysicsSpherePointsShapeDesc> spherePointsShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsSpherePointsShapeDesc, UsdPhysicsCollisionAPI>
+		(spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
+
+	std::vector<UsdPhysicsCustomShapeDesc> customShapeDescs;
+	ProcessPhysicsPrims<UsdPhysicsCustomShapeDesc, UsdPhysicsCollisionAPI>
+		(customShapePrims, customShapeDescs, ParseCustomShapeDesc);
+	if (customShapeDescs.size() == customTokens.size())
+	{
+		for (size_t i = 0; i < customShapeDescs.size(); i++)
+		{
+			customShapeDescs[i].customGeometryToken = customTokens[i];
+		}
+	}
+
+	// rigid bodies
+	std::vector<UsdPhysicsRigidBodyDesc> rigidBodyDescs;
+	ProcessPhysicsPrims<UsdPhysicsRigidBodyDesc, UsdPhysicsRigidBodyAPI>
+		(rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
+	// Ensure if we have a hierarchical parent that has a dynamic parent,
+	// that we also have a reset xform stack, otherwise we should log an error.
+	// check for nested articulation roots, these are not supported
+	RigidBodyMap bodyMap;
+	for (size_t i = rigidBodyPrims.size(); i--;)
+	{
+		bodyMap[rigidBodyPrims[i].GetPrimPath()] = &rigidBodyDescs[i];
+	}
+
+	for (size_t i = rigidBodyPrims.size(); i--;)
+	{
+		const UsdPrim bodyPrim = rigidBodyPrims[i];
+		UsdPrim bodyParent = UsdPrim();
+		if (HasDynamicBodyParent(bodyPrim.GetParent(), bodyMap, bodyParent))
+		{
+			bool hasResetXformStack = false;
+			UsdPrim parent = bodyPrim;
+			while (parent != stage->GetPseudoRoot() && parent != bodyParent)
+			{
+				const UsdGeomXformable xform(parent);
+				if (xform && xform.GetResetXformStack())
+				{
+					hasResetXformStack = true;
+					break;
+				}
+				parent = parent.GetParent();
+			}
+			if (!hasResetXformStack)
+			{
+
+				TF_DIAGNOSTIC_WARNING("Rigid Body of (%s) missing xformstack reset when child of rigid body (%s) in hierarchy."
+					"Simulation of multiple RigidBodyAPI's in a hierarchy will cause unpredicted results."
+					"Please fix the hierarchy or use XformStack reset.",
+					bodyPrim.GetPrimPath().GetText(),
+					bodyParent.GetPrimPath().GetText());
+
+				rigidBodyPrims[i] = rigidBodyPrims.back();
+				rigidBodyPrims.pop_back();
+			}
+		}
+	}
+
+	// articulations
+	// check for nested articulation roots, these are not supported    
+	for (size_t i = articulationPrims.size(); i--;)
+	{
+		if (CheckNestedArticulationRoot(articulationPrims[i], articulationPathsSet))
+		{
+			TF_DIAGNOSTIC_WARNING("Nested ArticulationRootAPI not supported, API ignored, prim %s.",
+				articulationPrims[i].GetPrimPath().GetString().c_str());
+			articulationPrims[i] = articulationPrims.back();
+			articulationPrims.pop_back();
+		}
+	}
+	std::vector<UsdPhysicsArticulationDesc> articulationDescs;
+	ProcessPhysicsPrims<UsdPhysicsArticulationDesc, UsdPhysicsArticulationRootAPI>
+		(articulationPrims, articulationDescs, ParseArticulationDesc);
+
+	ArticulationMap articulationMap; // A.B. TODO probably not needed
+	for (size_t i = articulationPrims.size(); i--;)
+	{
+		articulationMap[articulationPrims[i].GetPrimPath()] = &articulationDescs[i];
+	}
+
+	// Finalize collisions
+	{
+		UsdGeomXformCache xfCache;
+
+		FinalizeCollisionDescs<UsdPhysicsSphereShapeDesc>
+			(xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsCubeShapeDesc>
+			(xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsCapsuleShapeDesc>
+			(xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsCylinderShapeDesc>
+			(xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsConeShapeDesc>
+			(xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsPlaneShapeDesc>
+			(xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsMeshShapeDesc>
+			(xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsSpherePointsShapeDesc>
+			(xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
+		FinalizeCollisionDescs<UsdPhysicsCustomShapeDesc>
+			(xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
+	}
+
+	// Finalize articulations
+	{
+		// A.B. walk through the finalize code refactor
+		FinalizeArticulations(stage, articulationMap, bodyMap, jointMap);
+	}
+
+	// if simulationOwners are in play lets shrink down the reported descriptors    
+	if (simulationOwners && !simulationOwners->empty())
+	{
+		std::unordered_set<SdfPath, SdfPath::Hash> reportedBodies;
+		// first check bodies
+		CheckRigidBodySimulationOwner(rigidBodyPrims, rigidBodyDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+		// check collisions
+		// if collision belongs to a body that we care about include it
+		// if collision does not belong to a body we care about its not included
+		// if collision does not have a body set, we check its own simulationOwners
+		CheckCollisionSimulationOwner(sphereShapePrims, sphereShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(cubeShapePrims, cubeShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(capsuleShapePrims, capsuleShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(cylinderShapePrims, cylinderShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(coneShapePrims, coneShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(planeShapePrims, planeShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(meshShapePrims, meshShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(spherePointsShapePrims, spherePointsShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckCollisionSimulationOwner(customShapePrims, customShapeDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+		// Both bodies need to have simulation owners valid
+		CheckJointSimulationOwner(physicsFixedJointPrims, fixedJointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckJointSimulationOwner(physicsRevoluteJointPrims, revoluteJointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckJointSimulationOwner(physicsPrismaticJointPrims, prismaticJointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckJointSimulationOwner(physicsSphericalJointPrims, sphericalJointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckJointSimulationOwner(physicsDistanceJointPrims, distanceJointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckJointSimulationOwner(physicsD6JointPrims, jointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+		CheckJointSimulationOwner(physicsCustomJointPrims, customJointDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+		// All bodies need to have simulation owners valid
+		CheckArticulationSimulationOwner(articulationPrims, articulationDescs,
+			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+	}
+
+	SdfPathVector primPathsVector;
+	// get the descriptors, finalize them and send them out in an order
+	// 1. send out the scenes
+	{
+		CallReportFn(UsdPhysicsObjectType::eScene, scenePrims, sceneDescs,
+			reportFn, primPathsVector, userData);
+	}
+
+	// 2. send out the CollisionGroups
+	{
+		CallReportFn(UsdPhysicsObjectType::eCollisionGroup, collisionGroupPrims,
+			collisionGroupsDescs, reportFn, primPathsVector, userData);
+	}
+
+	// 3. send out the materials
+	{
+		CallReportFn(UsdPhysicsObjectType::eRigidBodyMaterial, materialPrims,
+			materialDescs, reportFn, primPathsVector, userData);
+	}
+
+	// 4. finish out and send out shapes
+	{
+		CallReportFn(UsdPhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs,
+			reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs,
+			reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eCapsuleShape, capsuleShapePrims,
+			capsuleShapeDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eCylinderShape, cylinderShapePrims,
+			cylinderShapeDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs,
+			reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs,
+			reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs,
+			reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eSpherePointsShape, spherePointsShapePrims,
+			spherePointsShapeDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs,
+			reportFn, primPathsVector, userData);
+	}
+
+	// 5. send out articulations
+	{
+		CallReportFn(UsdPhysicsObjectType::eArticulation, articulationPrims,
+			articulationDescs, reportFn, primPathsVector, userData);
+	}
+
+	// 6. send out bodies
+	{
+		CallReportFn(UsdPhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs,
+			reportFn, primPathsVector, userData);
+	}
+
+	// 7. send out joints    
+	{
+		CallReportFn(UsdPhysicsObjectType::eFixedJoint, physicsFixedJointPrims,
+			fixedJointDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims,
+			revoluteJointDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims,
+			prismaticJointDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims,
+			sphericalJointDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims,
+			distanceJointDescs, reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs,
+			reportFn, primPathsVector, userData);
+		CallReportFn(UsdPhysicsObjectType::eCustomJoint, physicsCustomJointPrims,
+			customJointDescs, reportFn, primPathsVector, userData);
+	}
+
+	return retVal;
 }
 
 
diff --git a/pxr/usd/usdPhysics/parseUtils.h b/pxr/usd/usdPhysics/parseUtils.h
index 9f3cedb26d..cd28362098 100644
--- a/pxr/usd/usdPhysics/parseUtils.h
+++ b/pxr/usd/usdPhysics/parseUtils.h
@@ -1,25 +1,8 @@
 //
-// Copyright 2016 Pixar
+// Copyright 2024 Pixar
 //
-// Licensed under the Apache License, Version 2.0 (the "Apache License")
-// with the following modification; you may not use this file except in
-// compliance with the Apache License and the following modification to it:
-// Section 6. Trademarks. is deleted and replaced with:
-//
-// 6. Trademarks. This License does not grant permission to use the trade
-//    names, trademarks, service marks, or product names of the Licensor
-//    and its affiliates, except as required to comply with Section 4(c) of
-//    the License and to reproduce the content of the NOTICE file.
-//
-// You may obtain a copy of the Apache License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the Apache License with the above modification is
-// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, either express or implied. See the Apache License for the specific
-// language governing permissions and limitations under the Apache License.
+// Licensed under the terms set forth in the LICENSE.txt file available at
+// https://openusd.org/license.
 //
 #ifndef USDPHYSICS_PARSE_UTILS_H
 #define USDPHYSICS_PARSE_UTILS_H
@@ -51,8 +34,9 @@ PXR_NAMESPACE_OPEN_SCOPE
 /// \param[in] objectDescs  Corresponding array of object descriptors of the reported type
 /// \param[in] userData User data provided to the parsing function
 using UsdPhysicsReportFn =
-    std::function<void(UsdPhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
-        const UsdPhysicsObjectDesc* objectDescs, void* userData)>;
+std::function<void(UsdPhysicsObjectType::Enum type, size_t numDesc,
+	const SdfPath* primPaths, const UsdPhysicsObjectDesc* objectDescs,
+	void* userData)>;
 
 /// \struct CustomUsdPhysicsTokens
 ///
@@ -60,9 +44,10 @@ using UsdPhysicsReportFn =
 ///
 struct CustomUsdPhysicsTokens
 {
-    std::vector<TfToken> jointTokens;       ///< Custom joints to be reported by parsing
-    std::vector<TfToken> shapeTokens;       ///< Custom shapes to be reported by parsing
-    std::vector<TfToken> instancerTokens;   ///< Custom physics instancers to be skipped by parsing
+	std::vector<TfToken> jointTokens;       ///< Custom joints to be reported by parsing
+	std::vector<TfToken> shapeTokens;       ///< Custom shapes to be reported by parsing
+	std::vector<TfToken> instancerTokens;   ///< Custom physics instancers to be 
+	///< skipped by parsing
 };
 
 /// Load USD physics from a given range
@@ -72,15 +57,16 @@ struct CustomUsdPhysicsTokens
 /// \param[in] reportFn   Report function that gets parsed USD physics data
 /// \param[in] userData   User data passed to report function
 /// \param[in] customPhysicsTokens Custom tokens to be reported by the parsing
-/// \param[in] simulationOwners List of simulation owners that should be parsed, adding SdfPath() 
-///                         indicates that objects without a simulation owner should be parsed too.
+/// \param[in] simulationOwners List of simulation owners that should be parsed, 
+///                       adding SdfPath() indicates that objects without a 
+///                       simulation owner should be parsed too.
 /// \return True if load was successful
 USDPHYSICS_API bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
-        ParsePrimIteratorBase& range,
-        UsdPhysicsReportFn reportFn,
-        void* userData,
-        const CustomUsdPhysicsTokens* customPhysicsTokens = nullptr,
-        const std::vector<SdfPath>* simulationOwners = nullptr);
+	ParsePrimIteratorBase& range,
+	UsdPhysicsReportFn reportFn,
+	void* userData,
+	const CustomUsdPhysicsTokens* customPhysicsTokens = nullptr,
+	const std::vector<SdfPath>* simulationOwners = nullptr);
 
 
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py b/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
index 4af98e3ca3..ab5e0b182d 100644
--- a/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
+++ b/pxr/usd/usdPhysics/testenv/testUsdPhysicsParsing.py
@@ -1,26 +1,9 @@
 #!/pxrpythonsubst
 #
-# Copyright 2021 Pixar
+# Copyright 2024 Pixar
 #
-# Licensed under the Apache License, Version 2.0 (the "Apache License")
-# with the following modification; you may not use this file except in
-# compliance with the Apache License and the following modification to it:
-# Section 6. Trademarks. is deleted and replaced with:
-#
-# 6. Trademarks. This License does not grant permission to use the trade
-#    names, trademarks, service marks, or product names of the Licensor
-#    and its affiliates, except as required to comply with Section 4(c) of
-#    the License and to reproduce the content of the NOTICE file.
-#
-# You may obtain a copy of the Apache License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the Apache License with the above modification is
-# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied. See the Apache License for the specific
-# language governing permissions and limitations under the Apache License.
+# Licensed under the terms set forth in the LICENSE.txt file available at
+# https://openusd.org/license.
 
 import os, unittest
 from pxr import Usd, UsdPhysics, Gf, UsdGeom, Sdf, UsdShade
diff --git a/pxr/usd/usdPhysics/wrapParseUtils.cpp b/pxr/usd/usdPhysics/wrapParseUtils.cpp
index 24accad196..33f90c0a0f 100644
--- a/pxr/usd/usdPhysics/wrapParseUtils.cpp
+++ b/pxr/usd/usdPhysics/wrapParseUtils.cpp
@@ -1,25 +1,8 @@
 //
-// Copyright 2016 Pixar
+// Copyright 2024 Pixar
 //
-// Licensed under the Apache License, Version 2.0 (the "Apache License")
-// with the following modification; you may not use this file except in
-// compliance with the Apache License and the following modification to it:
-// Section 6. Trademarks. is deleted and replaced with:
-//
-// 6. Trademarks. This License does not grant permission to use the trade
-//    names, trademarks, service marks, or product names of the Licensor
-//    and its affiliates, except as required to comply with Section 4(c) of
-//    the License and to reproduce the content of the NOTICE file.
-//
-// You may obtain a copy of the Apache License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the Apache License with the above modification is
-// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, either express or implied. See the Apache License for the specific
-// language governing permissions and limitations under the Apache License.
+// Licensed under the terms set forth in the LICENSE.txt file available at
+// https://openusd.org/license.
 //
 #include "pxr/pxr.h"
 
@@ -52,1128 +35,1236 @@ PXR_NAMESPACE_USING_DIRECTIVE
 template <typename T>
 void registerVectorConverter(const char* name)
 {
-    pxr_boost::python::class_<std::vector<T>>(name).def(pxr_boost::python::vector_indexing_suite<std::vector<T>>());
+	pxr_boost::python::class_<std::vector<T>>(name).def(
+		pxr_boost::python::vector_indexing_suite<std::vector<T>>());
 }
 
 using namespace pxr_boost::python;
 
 
 // Wrapper class
-class ParsePrimIteratorBaseWrap : public ParsePrimIteratorBase, public pxr_boost::python::wrapper<ParsePrimIteratorBase> {
+class ParsePrimIteratorBaseWrap : public ParsePrimIteratorBase,
+	public pxr_boost::python::wrapper<ParsePrimIteratorBase>
+{
 public:
-    void reset() {
-        this->get_override("reset")();
-    }
+	void reset() {
+		this->get_override("reset")();
+	}
 
-    bool atEnd() const {
-        return this->get_override("atEnd")();
-    }
+	bool atEnd() const {
+		return this->get_override("atEnd")();
+	}
 
-    UsdPrimRange::const_iterator getCurrent() {
-        return this->get_override("getCurrent")();
-    }
+	UsdPrimRange::const_iterator getCurrent() {
+		return this->get_override("getCurrent")();
+	}
 
-    void next() {
-        this->get_override("next")();
-    }
+	void next() {
+		this->get_override("next")();
+	}
 
-    void pruneChildren() {
-        this->get_override("pruneChildren")();
-    }
+	void pruneChildren() {
+		this->get_override("pruneChildren")();
+	}
 };
 
 class MarshalCallback
 {
-public:    
+public:
 
-    SdfPathVector                   scenePrimPaths;
-    std::vector<UsdPhysicsSceneDesc>          sceneDescs;
+	SdfPathVector                   scenePrimPaths;
+	std::vector<UsdPhysicsSceneDesc>          sceneDescs;
 
-    SdfPathVector                   rigidBodyPrimPaths;
-    std::vector<UsdPhysicsRigidBodyDesc>      rigidBodyDescs;
+	SdfPathVector                   rigidBodyPrimPaths;
+	std::vector<UsdPhysicsRigidBodyDesc>      rigidBodyDescs;
 
-    SdfPathVector                   sphereShapePrimPaths;
-    std::vector<UsdPhysicsSphereShapeDesc>    sphereShapeDescs;
+	SdfPathVector                   sphereShapePrimPaths;
+	std::vector<UsdPhysicsSphereShapeDesc>    sphereShapeDescs;
 
-    SdfPathVector                   cubeShapePrimPaths;
-    std::vector<UsdPhysicsCubeShapeDesc>    cubeShapeDescs;
+	SdfPathVector                   cubeShapePrimPaths;
+	std::vector<UsdPhysicsCubeShapeDesc>    cubeShapeDescs;
 
-    SdfPathVector                   capsuleShapePrimPaths;
-    std::vector<UsdPhysicsCapsuleShapeDesc>    capsuleShapeDescs;
+	SdfPathVector                   capsuleShapePrimPaths;
+	std::vector<UsdPhysicsCapsuleShapeDesc>    capsuleShapeDescs;
 
-    SdfPathVector                   cylinderShapePrimPaths;
-    std::vector<UsdPhysicsCylinderShapeDesc>    cylinderShapeDescs;
+	SdfPathVector                   cylinderShapePrimPaths;
+	std::vector<UsdPhysicsCylinderShapeDesc>    cylinderShapeDescs;
 
-    SdfPathVector            coneShapePrimPaths;
-    std::vector<UsdPhysicsConeShapeDesc>    coneShapeDescs;
+	SdfPathVector            coneShapePrimPaths;
+	std::vector<UsdPhysicsConeShapeDesc>    coneShapeDescs;
 
-    SdfPathVector            meshShapePrimPaths;
-    std::vector<UsdPhysicsMeshShapeDesc>    meshShapeDescs;
+	SdfPathVector            meshShapePrimPaths;
+	std::vector<UsdPhysicsMeshShapeDesc>    meshShapeDescs;
 
-    SdfPathVector            planeShapePrimPaths;
-    std::vector<UsdPhysicsPlaneShapeDesc>    planeShapeDescs;
+	SdfPathVector            planeShapePrimPaths;
+	std::vector<UsdPhysicsPlaneShapeDesc>    planeShapeDescs;
 
-    SdfPathVector            customShapePrimPaths;
-    std::vector<UsdPhysicsCustomShapeDesc>    customShapeDescs;
+	SdfPathVector            customShapePrimPaths;
+	std::vector<UsdPhysicsCustomShapeDesc>    customShapeDescs;
 
-    SdfPathVector            spherePointShapePrimPaths;
-    std::vector<UsdPhysicsSpherePointsShapeDesc>    spherePointsShapeDescs;
+	SdfPathVector            spherePointShapePrimPaths;
+	std::vector<UsdPhysicsSpherePointsShapeDesc>    spherePointsShapeDescs;
 
-    SdfPathVector            fixedJointPrimPaths;
-    std::vector<UsdPhysicsFixedJointDesc>    fixedJointDescs;
+	SdfPathVector            fixedJointPrimPaths;
+	std::vector<UsdPhysicsFixedJointDesc>    fixedJointDescs;
 
-    SdfPathVector            revoluteJointPrimPaths;
-    std::vector<UsdPhysicsRevoluteJointDesc>    revoluteJointDescs;
+	SdfPathVector            revoluteJointPrimPaths;
+	std::vector<UsdPhysicsRevoluteJointDesc>    revoluteJointDescs;
 
-    SdfPathVector            prismaticJointPrimPaths;
-    std::vector<UsdPhysicsPrismaticJointDesc>    prismaticJointDescs;
+	SdfPathVector            prismaticJointPrimPaths;
+	std::vector<UsdPhysicsPrismaticJointDesc>    prismaticJointDescs;
 
-    SdfPathVector            sphericalJointPrimPaths;
-    std::vector<UsdPhysicsSphericalJointDesc>    sphericalJointDescs;
+	SdfPathVector            sphericalJointPrimPaths;
+	std::vector<UsdPhysicsSphericalJointDesc>    sphericalJointDescs;
 
-    SdfPathVector            distanceJointPrimPaths;
-    std::vector<UsdPhysicsDistanceJointDesc>    distanceJointDescs;
+	SdfPathVector            distanceJointPrimPaths;
+	std::vector<UsdPhysicsDistanceJointDesc>    distanceJointDescs;
 
-    SdfPathVector            d6JointPrimPaths;
-    std::vector<UsdPhysicsD6JointDesc>    d6JointDescs;
+	SdfPathVector            d6JointPrimPaths;
+	std::vector<UsdPhysicsD6JointDesc>    d6JointDescs;
 
-    SdfPathVector            customJointPrimPaths;
-    std::vector<UsdPhysicsCustomJointDesc>    customJointDescs;
+	SdfPathVector            customJointPrimPaths;
+	std::vector<UsdPhysicsCustomJointDesc>    customJointDescs;
 
-    SdfPathVector            rigidBodyMaterialPrimPaths;
-    std::vector<UsdPhysicsRigidBodyMaterialDesc>    rigidBodyMaterialDescs;
+	SdfPathVector            rigidBodyMaterialPrimPaths;
+	std::vector<UsdPhysicsRigidBodyMaterialDesc>    rigidBodyMaterialDescs;
 
-    SdfPathVector            articulationPrimPaths;
-    std::vector<UsdPhysicsArticulationDesc>    articulationDescs;
+	SdfPathVector            articulationPrimPaths;
+	std::vector<UsdPhysicsArticulationDesc>    articulationDescs;
 
-    SdfPathVector            collisionGroupPrimPaths;
-    std::vector<UsdPhysicsCollisionGroupDesc>    collisionGroupDescs;
+	SdfPathVector            collisionGroupPrimPaths;
+	std::vector<UsdPhysicsCollisionGroupDesc>    collisionGroupDescs;
 
-    void clear()
-    {
-        scenePrimPaths.clear();
-        sceneDescs.clear();
+	void clear()
+	{
+		scenePrimPaths.clear();
+		sceneDescs.clear();
 
-        rigidBodyPrimPaths.clear();
-        rigidBodyDescs.clear();
+		rigidBodyPrimPaths.clear();
+		rigidBodyDescs.clear();
 
-        sphereShapePrimPaths.clear();
-        sphereShapeDescs.clear();
+		sphereShapePrimPaths.clear();
+		sphereShapeDescs.clear();
 
-        cubeShapePrimPaths.clear();
-        cubeShapeDescs.clear();
+		cubeShapePrimPaths.clear();
+		cubeShapeDescs.clear();
 
-        capsuleShapePrimPaths.clear();
-        capsuleShapeDescs.clear();
+		capsuleShapePrimPaths.clear();
+		capsuleShapeDescs.clear();
 
-        cylinderShapePrimPaths.clear();
-        cylinderShapeDescs.clear();
+		cylinderShapePrimPaths.clear();
+		cylinderShapeDescs.clear();
 
-        coneShapePrimPaths.clear();
-        coneShapeDescs.clear();
+		coneShapePrimPaths.clear();
+		coneShapeDescs.clear();
 
-        meshShapePrimPaths.clear();
-        meshShapeDescs.clear();
+		meshShapePrimPaths.clear();
+		meshShapeDescs.clear();
 
-        planeShapePrimPaths.clear();
-        planeShapeDescs.clear();
+		planeShapePrimPaths.clear();
+		planeShapeDescs.clear();
 
-        customShapePrimPaths.clear();
-        customShapeDescs.clear();
+		customShapePrimPaths.clear();
+		customShapeDescs.clear();
 
-        spherePointShapePrimPaths.clear();
-        spherePointsShapeDescs.clear();
+		spherePointShapePrimPaths.clear();
+		spherePointsShapeDescs.clear();
 
-        fixedJointPrimPaths.clear();
-        fixedJointDescs.clear();
+		fixedJointPrimPaths.clear();
+		fixedJointDescs.clear();
 
-        revoluteJointPrimPaths.clear();
-        revoluteJointDescs.clear();
+		revoluteJointPrimPaths.clear();
+		revoluteJointDescs.clear();
 
-        prismaticJointPrimPaths.clear();
-        prismaticJointDescs.clear();
+		prismaticJointPrimPaths.clear();
+		prismaticJointDescs.clear();
 
-        sphericalJointPrimPaths.clear();
-        sphericalJointDescs.clear();
+		sphericalJointPrimPaths.clear();
+		sphericalJointDescs.clear();
 
-        distanceJointPrimPaths.clear();
-        distanceJointDescs.clear();
+		distanceJointPrimPaths.clear();
+		distanceJointDescs.clear();
 
-        d6JointPrimPaths.clear();
-        d6JointDescs.clear();
+		d6JointPrimPaths.clear();
+		d6JointDescs.clear();
 
-        customJointPrimPaths.clear();
-        customJointDescs.clear();
+		customJointPrimPaths.clear();
+		customJointDescs.clear();
 
-        rigidBodyMaterialPrimPaths.clear();
-        rigidBodyMaterialDescs.clear();
+		rigidBodyMaterialPrimPaths.clear();
+		rigidBodyMaterialDescs.clear();
 
-        articulationPrimPaths.clear();
-        articulationDescs.clear();
+		articulationPrimPaths.clear();
+		articulationDescs.clear();
 
-        collisionGroupPrimPaths.clear();
-        collisionGroupDescs.clear();
-    }
+		collisionGroupPrimPaths.clear();
+		collisionGroupDescs.clear();
+	}
 
 } gMarshalCallback;
 
 template <typename DescType>
-void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsDest, const UsdPhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
+void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsDest,
+	const UsdPhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
 {
-    primsDest.resize(numDesc);
-    objectDescsDest.resize(numDesc);
-
-    if (numDesc)
-    {
-        const DescType* sourceDesc = reinterpret_cast<const DescType*>(objectDescsSource);
-
-        for (size_t i = 0; i < numDesc; i++)
-        {
-            primsDest[i] = primsSource[i];
-            objectDescsDest[i] = sourceDesc[i];
-        }
-    }
+	primsDest.resize(numDesc);
+	objectDescsDest.resize(numDesc);
+
+	if (numDesc)
+	{
+		const DescType* sourceDesc = reinterpret_cast<const DescType*>(objectDescsSource);
+
+		for (size_t i = 0; i < numDesc; i++)
+		{
+			primsDest[i] = primsSource[i];
+			objectDescsDest[i] = sourceDesc[i];
+		}
+	}
 }
 
-void ReportPhysicsObjectsFn(UsdPhysicsObjectType::Enum type, size_t numDesc, const SdfPath* primPaths,
-    const UsdPhysicsObjectDesc* objectDescs, void* userData)
+void ReportPhysicsObjectsFn(UsdPhysicsObjectType::Enum type, size_t numDesc,
+	const SdfPath* primPaths,
+	const UsdPhysicsObjectDesc* objectDescs, void* userData)
 {
-    MarshalCallback* cb = (MarshalCallback*)userData;
-        
-    switch (type)
-    {
-        case UsdPhysicsObjectType::eScene:
-        {       
-            copyDescs(numDesc, primPaths, cb->scenePrimPaths, objectDescs, cb->sceneDescs);
-        }        
-        break;
-        case UsdPhysicsObjectType::eRigidBody:
-        {       
-            copyDescs(numDesc, primPaths, cb->rigidBodyPrimPaths, objectDescs, cb->rigidBodyDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eSphereShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->sphereShapePrimPaths, objectDescs, cb->sphereShapeDescs);
-        }  
-        break;      
-        case UsdPhysicsObjectType::eCubeShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->cubeShapePrimPaths, objectDescs, cb->cubeShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eCapsuleShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->capsuleShapePrimPaths, objectDescs, cb->capsuleShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eCylinderShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->cylinderShapePrimPaths, objectDescs, cb->cylinderShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eConeShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->coneShapePrimPaths, objectDescs, cb->coneShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eMeshShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->meshShapePrimPaths, objectDescs, cb->meshShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::ePlaneShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->planeShapePrimPaths, objectDescs, cb->planeShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eCustomShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->customShapePrimPaths, objectDescs, cb->customShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eSpherePointsShape:
-        {       
-            copyDescs(numDesc, primPaths, cb->spherePointShapePrimPaths, objectDescs, cb->spherePointsShapeDescs);
-        }        
-        break;        
-        case UsdPhysicsObjectType::eFixedJoint:
-        {       
-            copyDescs(numDesc, primPaths, cb->fixedJointPrimPaths, objectDescs, cb->fixedJointDescs);
-        }        
-        break;
-        case UsdPhysicsObjectType::eRevoluteJoint:
-        {       
-            copyDescs(numDesc, primPaths, cb->revoluteJointPrimPaths, objectDescs, cb->revoluteJointDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::ePrismaticJoint:
-        {       
-            copyDescs(numDesc, primPaths, cb->prismaticJointPrimPaths, objectDescs, cb->prismaticJointDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eSphericalJoint:
-        {       
-            copyDescs(numDesc, primPaths, cb->sphericalJointPrimPaths, objectDescs, cb->sphericalJointDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eDistanceJoint:
-        {       
-            copyDescs(numDesc, primPaths, cb->distanceJointPrimPaths, objectDescs, cb->distanceJointDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eD6Joint:
-        {       
-            copyDescs(numDesc, primPaths, cb->d6JointPrimPaths, objectDescs, cb->d6JointDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eCustomJoint:
-        {       
-            copyDescs(numDesc, primPaths, cb->customJointPrimPaths, objectDescs, cb->customJointDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eRigidBodyMaterial:
-        {       
-            copyDescs(numDesc, primPaths, cb->rigidBodyMaterialPrimPaths, objectDescs, cb->rigidBodyMaterialDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eArticulation:
-        {       
-            copyDescs(numDesc, primPaths, cb->articulationPrimPaths, objectDescs, cb->articulationDescs);
-        }     
-        break;   
-        case UsdPhysicsObjectType::eCollisionGroup:
-        {       
-            copyDescs(numDesc, primPaths, cb->collisionGroupPrimPaths, objectDescs, cb->collisionGroupDescs);
-        }     
-        break;   
-    }
+	MarshalCallback* cb = (MarshalCallback*)userData;
+
+	switch (type)
+	{
+	case UsdPhysicsObjectType::eScene:
+	{
+		copyDescs(numDesc, primPaths, cb->scenePrimPaths, objectDescs, cb->sceneDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eRigidBody:
+	{
+		copyDescs(numDesc, primPaths, cb->rigidBodyPrimPaths, objectDescs, cb->rigidBodyDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eSphereShape:
+	{
+		copyDescs(numDesc, primPaths, cb->sphereShapePrimPaths, objectDescs, cb->sphereShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eCubeShape:
+	{
+		copyDescs(numDesc, primPaths, cb->cubeShapePrimPaths, objectDescs, cb->cubeShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eCapsuleShape:
+	{
+		copyDescs(numDesc, primPaths, cb->capsuleShapePrimPaths, objectDescs, cb->capsuleShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eCylinderShape:
+	{
+		copyDescs(numDesc, primPaths, cb->cylinderShapePrimPaths, objectDescs, cb->cylinderShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eConeShape:
+	{
+		copyDescs(numDesc, primPaths, cb->coneShapePrimPaths, objectDescs, cb->coneShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eMeshShape:
+	{
+		copyDescs(numDesc, primPaths, cb->meshShapePrimPaths, objectDescs, cb->meshShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::ePlaneShape:
+	{
+		copyDescs(numDesc, primPaths, cb->planeShapePrimPaths, objectDescs, cb->planeShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eCustomShape:
+	{
+		copyDescs(numDesc, primPaths, cb->customShapePrimPaths, objectDescs,
+			cb->customShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eSpherePointsShape:
+	{
+		copyDescs(numDesc, primPaths, cb->spherePointShapePrimPaths, objectDescs,
+			cb->spherePointsShapeDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eFixedJoint:
+	{
+		copyDescs(numDesc, primPaths, cb->fixedJointPrimPaths, objectDescs, cb->fixedJointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eRevoluteJoint:
+	{
+		copyDescs(numDesc, primPaths, cb->revoluteJointPrimPaths, objectDescs,
+			cb->revoluteJointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::ePrismaticJoint:
+	{
+		copyDescs(numDesc, primPaths, cb->prismaticJointPrimPaths, objectDescs,
+			cb->prismaticJointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eSphericalJoint:
+	{
+		copyDescs(numDesc, primPaths, cb->sphericalJointPrimPaths, objectDescs,
+			cb->sphericalJointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eDistanceJoint:
+	{
+		copyDescs(numDesc, primPaths, cb->distanceJointPrimPaths, objectDescs,
+			cb->distanceJointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eD6Joint:
+	{
+		copyDescs(numDesc, primPaths, cb->d6JointPrimPaths, objectDescs, cb->d6JointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eCustomJoint:
+	{
+		copyDescs(numDesc, primPaths, cb->customJointPrimPaths, objectDescs,
+			cb->customJointDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eRigidBodyMaterial:
+	{
+		copyDescs(numDesc, primPaths, cb->rigidBodyMaterialPrimPaths, objectDescs,
+			cb->rigidBodyMaterialDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eArticulation:
+	{
+		copyDescs(numDesc, primPaths, cb->articulationPrimPaths, objectDescs,
+			cb->articulationDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eCollisionGroup:
+	{
+		copyDescs(numDesc, primPaths, cb->collisionGroupPrimPaths, objectDescs,
+			cb->collisionGroupDescs);
+	}
+	break;
+	case UsdPhysicsObjectType::eUndefined:
+	default:
+	{
+		TF_DIAGNOSTIC_WARNING("UsdPhysicsObject type unknown for python wrapping.");
+	}
+	break;
+	}
 }
 
 struct _CustomUsdPhysicsTokens
 {
-    _CustomUsdPhysicsTokens()
-    {
+	_CustomUsdPhysicsTokens()
+	{
 
-    }
+	}
 
-    pxr_boost::python::list jointTokens;       ///< Custom joints to be reported by parsing
-    pxr_boost::python::list shapeTokens;       ///< Custom shapes to be reported by parsing
-    pxr_boost::python::list instancerTokens;   ///< Custom physics instancers to be skipped by parsing
+	pxr_boost::python::list jointTokens;  ///< Custom joints to be reported by parsing
+	pxr_boost::python::list shapeTokens;  ///< Custom shapes to be reported by parsing
+	pxr_boost::python::list instancerTokens;  ///< Custom physics instancers to 
+	///<be skipped by parsing
 };
 
 std::string getString(const pxr_boost::python::object& po)
 {
-    if (pxr_boost::python::extract<std::string>(po).check()) {
-        std::string str = pxr_boost::python::extract<std::string>(po);
-        return str;
-    }
-    else 
-    {
-        // Handle non-string items, e.g. convert to string
-        std::string str = pxr_boost::python::extract<std::string>(pxr_boost::python::str(po));
-        return str;
-    }
+	if (pxr_boost::python::extract<std::string>(po).check()) {
+		std::string str = pxr_boost::python::extract<std::string>(po);
+		return str;
+	}
+	else
+	{
+		// Handle non-string items, e.g. convert to string
+		std::string str = pxr_boost::python::extract<std::string>(pxr_boost::python::str(po));
+		return str;
+	}
 }
 
-pxr_boost::python::dict _LoadUsdPhysicsFromRange(UsdStageWeakPtr stage, ParsePrimIteratorBase& range, const _CustomUsdPhysicsTokens& customTokens, const std::vector<SdfPath>& simulationOwners)
-{   
-    CustomUsdPhysicsTokens parsingCustomTokens;
-    bool customTokensValid = false;
-    const size_t jointTokesSize = len(customTokens.jointTokens);
-    const size_t shapeTokesSize = len(customTokens.shapeTokens);
-    const size_t instancerTokesSize = len(customTokens.instancerTokens);
-    if (jointTokesSize || shapeTokesSize || instancerTokesSize)
-    {
-        for (size_t i = 0; i < jointTokesSize; i++)
-        {
-            parsingCustomTokens.jointTokens.push_back(TfToken(getString(customTokens.jointTokens[i])));
-        }
-        for (size_t i = 0; i < shapeTokesSize; i++)
-        {
-            parsingCustomTokens.shapeTokens.push_back(TfToken(getString(customTokens.shapeTokens[i])));
-        }
-        for (size_t i = 0; i < instancerTokesSize; i++)
-        {
-            parsingCustomTokens.instancerTokens.push_back(TfToken(getString(customTokens.instancerTokens[i])));
-        }
-        customTokensValid = true;
-    }
-
-    gMarshalCallback.clear();
-    const bool ret_val = LoadUsdPhysicsFromRange(stage, range, ReportPhysicsObjectsFn, &gMarshalCallback, 
-        customTokensValid ? &parsingCustomTokens : nullptr,
-        !simulationOwners.empty() ? &simulationOwners : nullptr);
-    pxr_boost::python::dict retDict;
-    if (ret_val)
-    {
-        if (!gMarshalCallback.sceneDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eScene] = pxr_boost::python::make_tuple(gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
-        }
-        if (!gMarshalCallback.rigidBodyDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eRigidBody] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
-        }
-        if (!gMarshalCallback.sphereShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eSphereShape] = pxr_boost::python::make_tuple(gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
-        }
-        if (!gMarshalCallback.cubeShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eCubeShape] = pxr_boost::python::make_tuple(gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
-        }
-        if (!gMarshalCallback.capsuleShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eCapsuleShape] = pxr_boost::python::make_tuple(gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
-        }
-        if (!gMarshalCallback.cylinderShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eCylinderShape] = pxr_boost::python::make_tuple(gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
-        }
-        if (!gMarshalCallback.coneShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eConeShape] = pxr_boost::python::make_tuple(gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
-        }
-        if (!gMarshalCallback.meshShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eMeshShape] = pxr_boost::python::make_tuple(gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
-        }
-        if (!gMarshalCallback.planeShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::ePlaneShape] = pxr_boost::python::make_tuple(gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
-        }
-        if (!gMarshalCallback.customShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eCustomShape] = pxr_boost::python::make_tuple(gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
-        }
-        if (!gMarshalCallback.spherePointsShapeDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eSpherePointsShape] = pxr_boost::python::make_tuple(gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
-        }
-        if (!gMarshalCallback.fixedJointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eFixedJoint] = pxr_boost::python::make_tuple(gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
-        }
-        if (!gMarshalCallback.revoluteJointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eRevoluteJoint] = pxr_boost::python::make_tuple(gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
-        }
-        if (!gMarshalCallback.prismaticJointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::ePrismaticJoint] = pxr_boost::python::make_tuple(gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
-        }
-        if (!gMarshalCallback.sphericalJointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eSphericalJoint] = pxr_boost::python::make_tuple(gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
-        }
-        if (!gMarshalCallback.distanceJointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eDistanceJoint] = pxr_boost::python::make_tuple(gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
-        }
-        if (!gMarshalCallback.d6JointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eD6Joint] = pxr_boost::python::make_tuple(gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
-        }
-        if (!gMarshalCallback.customJointDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eCustomJoint] = pxr_boost::python::make_tuple(gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
-        }
-        if (!gMarshalCallback.rigidBodyMaterialDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eRigidBodyMaterial] = pxr_boost::python::make_tuple(gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
-        }
-        if (!gMarshalCallback.articulationDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eArticulation] = pxr_boost::python::make_tuple(gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
-        }
-        if (!gMarshalCallback.collisionGroupDescs.empty())
-        {
-            retDict[UsdPhysicsObjectType::eCollisionGroup] = pxr_boost::python::make_tuple(gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
-        }
-    }    
-    return retDict;
+pxr_boost::python::dict _LoadUsdPhysicsFromRange(UsdStageWeakPtr stage,
+	ParsePrimIteratorBase& range, const _CustomUsdPhysicsTokens& customTokens,
+	const std::vector<SdfPath>& simulationOwners)
+{
+	CustomUsdPhysicsTokens parsingCustomTokens;
+	bool customTokensValid = false;
+	const size_t jointTokesSize = len(customTokens.jointTokens);
+	const size_t shapeTokesSize = len(customTokens.shapeTokens);
+	const size_t instancerTokesSize = len(customTokens.instancerTokens);
+	if (jointTokesSize || shapeTokesSize || instancerTokesSize)
+	{
+		for (size_t i = 0; i < jointTokesSize; i++)
+		{
+			parsingCustomTokens.jointTokens.push_back(
+				TfToken(getString(customTokens.jointTokens[i])));
+		}
+		for (size_t i = 0; i < shapeTokesSize; i++)
+		{
+			parsingCustomTokens.shapeTokens.push_back(
+				TfToken(getString(customTokens.shapeTokens[i])));
+		}
+		for (size_t i = 0; i < instancerTokesSize; i++)
+		{
+			parsingCustomTokens.instancerTokens.push_back(
+				TfToken(getString(customTokens.instancerTokens[i])));
+		}
+		customTokensValid = true;
+	}
+
+	gMarshalCallback.clear();
+	const bool ret_val = LoadUsdPhysicsFromRange(stage, range,
+		ReportPhysicsObjectsFn, &gMarshalCallback,
+		customTokensValid ? &parsingCustomTokens : nullptr,
+		!simulationOwners.empty() ? &simulationOwners : nullptr);
+	pxr_boost::python::dict retDict;
+	if (ret_val)
+	{
+		if (!gMarshalCallback.sceneDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eScene] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
+		}
+		if (!gMarshalCallback.rigidBodyDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eRigidBody] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
+		}
+		if (!gMarshalCallback.sphereShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eSphereShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
+		}
+		if (!gMarshalCallback.cubeShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eCubeShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
+		}
+		if (!gMarshalCallback.capsuleShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eCapsuleShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
+		}
+		if (!gMarshalCallback.cylinderShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eCylinderShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
+		}
+		if (!gMarshalCallback.coneShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eConeShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
+		}
+		if (!gMarshalCallback.meshShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eMeshShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
+		}
+		if (!gMarshalCallback.planeShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::ePlaneShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
+		}
+		if (!gMarshalCallback.customShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eCustomShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
+		}
+		if (!gMarshalCallback.spherePointsShapeDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eSpherePointsShape] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
+		}
+		if (!gMarshalCallback.fixedJointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eFixedJoint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
+		}
+		if (!gMarshalCallback.revoluteJointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eRevoluteJoint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
+		}
+		if (!gMarshalCallback.prismaticJointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::ePrismaticJoint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
+		}
+		if (!gMarshalCallback.sphericalJointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eSphericalJoint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
+		}
+		if (!gMarshalCallback.distanceJointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eDistanceJoint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
+		}
+		if (!gMarshalCallback.d6JointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eD6Joint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
+		}
+		if (!gMarshalCallback.customJointDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eCustomJoint] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
+		}
+		if (!gMarshalCallback.rigidBodyMaterialDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eRigidBodyMaterial] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
+		}
+		if (!gMarshalCallback.articulationDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eArticulation] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
+		}
+		if (!gMarshalCallback.collisionGroupDescs.empty())
+		{
+			retDict[UsdPhysicsObjectType::eCollisionGroup] =
+				pxr_boost::python::make_tuple(
+					gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
+		}
+	}
+	return retDict;
 }
 
 static std::string
 _CustomUsdPhysicsTokens_Repr(const CustomUsdPhysicsTokens& self)
 {
-    return TfStringPrintf("%sCustomUsdPhysicsTokens(jointTokens=%s, shapeTokens=%s, instancerTokens=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.jointTokens).c_str(),
-        TfPyRepr(self.shapeTokens).c_str(),
-        TfPyRepr(self.instancerTokens).c_str());
+	return TfStringPrintf(
+		"%sCustomUsdPhysicsTokens(jointTokens=%s, shapeTokens=%s, instancerTokens=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.jointTokens).c_str(),
+		TfPyRepr(self.shapeTokens).c_str(),
+		TfPyRepr(self.instancerTokens).c_str());
 }
 
 static std::string
 _PhysicsObjectDesc_Repr(const UsdPhysicsObjectDesc& self)
 {
-    return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.type).c_str(),
-        TfPyRepr(self.primPath).c_str(),
-        TfPyRepr(self.isValid).c_str());
+	return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.type).c_str(),
+		TfPyRepr(self.primPath).c_str(),
+		TfPyRepr(self.isValid).c_str());
 }
 
 static std::string
 _SceneDesc_Repr(const UsdPhysicsSceneDesc& self)
 {
-    return TfStringPrintf("%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.gravityDirection).c_str(),
-        TfPyRepr(self.gravityMagnitude).c_str(),
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.gravityDirection).c_str(),
+		TfPyRepr(self.gravityMagnitude).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _CollisionGroupDesc_Repr(const UsdPhysicsCollisionGroupDesc& self)
 {
-    return TfStringPrintf("%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.invertFilteredGroups).c_str(),
-        TfPyRepr(self.mergeGroupName).c_str(),
-        TfPyRepr(self.mergedGroups).c_str(),
-        TfPyRepr(self.filteredGroups).c_str(),        
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.invertFilteredGroups).c_str(),
+		TfPyRepr(self.mergeGroupName).c_str(),
+		TfPyRepr(self.mergedGroups).c_str(),
+		TfPyRepr(self.filteredGroups).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _RigidBodyMaterialDesc_Repr(const UsdPhysicsRigidBodyMaterialDesc& self)
 {
-    return TfStringPrintf("%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.staticFriction).c_str(),
-        TfPyRepr(self.dynamicFriction).c_str(),
-        TfPyRepr(self.restitution).c_str(),
-        TfPyRepr(self.density).c_str(),
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.staticFriction).c_str(),
+		TfPyRepr(self.dynamicFriction).c_str(),
+		TfPyRepr(self.restitution).c_str(),
+		TfPyRepr(self.density).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _ShapeDesc_Repr(const UsdPhysicsShapeDesc& self)
 {
-    return TfStringPrintf("%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.rigidBody).c_str(),
-        TfPyRepr(self.localPos).c_str(),
-        TfPyRepr(self.localRot).c_str(),
-        TfPyRepr(self.localScale).c_str(),
-        TfPyRepr(self.materials).c_str(),
-        TfPyRepr(self.simulationOwners).c_str(),
-        TfPyRepr(self.filteredCollisions).c_str(),
-        TfPyRepr(self.collisionGroups).c_str(),
-        TfPyRepr(self.collisionEnabled).c_str(),
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.rigidBody).c_str(),
+		TfPyRepr(self.localPos).c_str(),
+		TfPyRepr(self.localRot).c_str(),
+		TfPyRepr(self.localScale).c_str(),
+		TfPyRepr(self.materials).c_str(),
+		TfPyRepr(self.simulationOwners).c_str(),
+		TfPyRepr(self.filteredCollisions).c_str(),
+		TfPyRepr(self.collisionGroups).c_str(),
+		TfPyRepr(self.collisionEnabled).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _SphereShapeDesc_Repr(const UsdPhysicsSphereShapeDesc& self)
 {
-    return TfStringPrintf("%sSphereShapeDesc(radius=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.radius).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sSphereShapeDesc(radius=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.radius).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CapsuleShapeDesc_Repr(const UsdPhysicsCapsuleShapeDesc& self)
 {
-    return TfStringPrintf("%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.radius).c_str(),
-        TfPyRepr(self.halfHeight).c_str(),
-        TfPyRepr(self.axis).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.radius).c_str(),
+		TfPyRepr(self.halfHeight).c_str(),
+		TfPyRepr(self.axis).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CylinderShapeDesc_Repr(const UsdPhysicsCylinderShapeDesc& self)
 {
-    return TfStringPrintf("%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.radius).c_str(),
-        TfPyRepr(self.halfHeight).c_str(),
-        TfPyRepr(self.axis).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.radius).c_str(),
+		TfPyRepr(self.halfHeight).c_str(),
+		TfPyRepr(self.axis).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _ConeShapeDesc_Repr(const UsdPhysicsConeShapeDesc& self)
 {
-    return TfStringPrintf("%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.radius).c_str(),
-        TfPyRepr(self.halfHeight).c_str(),
-        TfPyRepr(self.axis).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.radius).c_str(),
+		TfPyRepr(self.halfHeight).c_str(),
+		TfPyRepr(self.axis).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _PlaneShapeDesc_Repr(const UsdPhysicsPlaneShapeDesc& self)
 {
-    return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.axis).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.axis).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CustomShapeDesc_Repr(const UsdPhysicsCustomShapeDesc& self)
 {
-    return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.customGeometryToken).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.customGeometryToken).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CubeShapeDesc_Repr(const UsdPhysicsCubeShapeDesc& self)
 {
-    return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.halfExtents).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.halfExtents).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _MeshShapeDesc_Repr(const UsdPhysicsMeshShapeDesc& self)
 {
-    return TfStringPrintf("%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.approximation).c_str(),
-        TfPyRepr(self.meshScale).c_str(),
-        TfPyRepr(self.doubleSided).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.approximation).c_str(),
+		TfPyRepr(self.meshScale).c_str(),
+		TfPyRepr(self.doubleSided).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _SpherePoint_Repr(const UsdPhysicsSpherePoint& self)
 {
-    return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.center).c_str(),
-        TfPyRepr(self.radius).c_str());
+	return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.center).c_str(),
+		TfPyRepr(self.radius).c_str());
 }
 
 static std::string
 _SpherePointsShapeDesc_Repr(const UsdPhysicsSpherePointsShapeDesc& self)
 {
-    return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.spherePoints).c_str(),
-        _ShapeDesc_Repr(self).c_str());
+	return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.spherePoints).c_str(),
+		_ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _RigidBodyDesc_Repr(const UsdPhysicsRigidBodyDesc& self)
 {
-    return TfStringPrintf("%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, simulationOwners=%s, position=%s, rotation=%s, scale=%s, rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, linearVelocity=%s, angularVelocity=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.collisions).c_str(),
-        TfPyRepr(self.filteredCollisions).c_str(),
-        TfPyRepr(self.simulationOwners).c_str(),
-        TfPyRepr(self.position).c_str(),
-        TfPyRepr(self.rotation).c_str(),
-        TfPyRepr(self.scale).c_str(),
-        TfPyRepr(self.rigidBodyEnabled).c_str(),
-        TfPyRepr(self.kinematicBody).c_str(),
-        TfPyRepr(self.startsAsleep).c_str(),
-        TfPyRepr(self.linearVelocity).c_str(),
-        TfPyRepr(self.angularVelocity).c_str(),
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, "
+		"simulationOwners=%s, position=%s, rotation=%s, scale=%s, "
+		"rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, "
+		"linearVelocity=%s, angularVelocity=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.collisions).c_str(),
+		TfPyRepr(self.filteredCollisions).c_str(),
+		TfPyRepr(self.simulationOwners).c_str(),
+		TfPyRepr(self.position).c_str(),
+		TfPyRepr(self.rotation).c_str(),
+		TfPyRepr(self.scale).c_str(),
+		TfPyRepr(self.rigidBodyEnabled).c_str(),
+		TfPyRepr(self.kinematicBody).c_str(),
+		TfPyRepr(self.startsAsleep).c_str(),
+		TfPyRepr(self.linearVelocity).c_str(),
+		TfPyRepr(self.angularVelocity).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _JointLimit_Repr(const UsdPhysicsJointLimit& self)
 {
-    return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.enabled).c_str(),
-        TfPyRepr(self.lower).c_str(),
-        TfPyRepr(self.upper).c_str());
+	return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.enabled).c_str(),
+		TfPyRepr(self.lower).c_str(),
+		TfPyRepr(self.upper).c_str());
 }
 
 static std::string
 _JointDrive_Repr(const UsdPhysicsJointDrive& self)
 {
-    return TfStringPrintf("%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.enabled).c_str(),
-        TfPyRepr(self.targetPosition).c_str(),
-        TfPyRepr(self.targetVelocity).c_str(),
-        TfPyRepr(self.forceLimit).c_str(),
-        TfPyRepr(self.stiffness).c_str(),
-        TfPyRepr(self.damping).c_str(),
-        TfPyRepr(self.acceleration).c_str());
+	return TfStringPrintf(
+		"%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, "
+		"forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.enabled).c_str(),
+		TfPyRepr(self.targetPosition).c_str(),
+		TfPyRepr(self.targetVelocity).c_str(),
+		TfPyRepr(self.forceLimit).c_str(),
+		TfPyRepr(self.stiffness).c_str(),
+		TfPyRepr(self.damping).c_str(),
+		TfPyRepr(self.acceleration).c_str());
 }
 
 static std::string
 _ArticulationDesc_Repr(const UsdPhysicsArticulationDesc& self)
 {
-    return TfStringPrintf("%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, articulatedJoints=%s, articulatedBodies=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.rootPrims).c_str(),
-        TfPyRepr(self.filteredCollisions).c_str(),
-        TfPyRepr(self.articulatedJoints).c_str(),
-        TfPyRepr(self.articulatedBodies).c_str(),
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, "
+		"articulatedJoints=%s, articulatedBodies=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.rootPrims).c_str(),
+		TfPyRepr(self.filteredCollisions).c_str(),
+		TfPyRepr(self.articulatedJoints).c_str(),
+		TfPyRepr(self.articulatedBodies).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _JointDesc_Repr(const UsdPhysicsJointDesc& self)
 {
-    return TfStringPrintf("%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, localPose0Position=%s, localPose0Orientation=%s, localPose1Position=%s, localPose1Orientation=%s, jointEnabled=%s, breakForce=%s, breakTorque=%s, excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.rel0).c_str(),
-        TfPyRepr(self.rel1).c_str(),
-        TfPyRepr(self.body0).c_str(),
-        TfPyRepr(self.body1).c_str(),
-        TfPyRepr(self.localPose0Position).c_str(),
-        TfPyRepr(self.localPose0Orientation).c_str(),
-        TfPyRepr(self.localPose1Position).c_str(),
-        TfPyRepr(self.localPose1Orientation).c_str(),
-        TfPyRepr(self.jointEnabled).c_str(),
-        TfPyRepr(self.breakForce).c_str(),
-        TfPyRepr(self.breakTorque).c_str(),
-        TfPyRepr(self.excludeFromArticulation).c_str(),
-        TfPyRepr(self.collisionEnabled).c_str(),
-        _PhysicsObjectDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, "
+		"localPose0Position=%s, localPose0Orientation=%s, "
+		"localPose1Position=%s, localPose1Orientation=%s, "
+		"jointEnabled=%s, breakForce=%s, breakTorque=%s, "
+		"excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.rel0).c_str(),
+		TfPyRepr(self.rel1).c_str(),
+		TfPyRepr(self.body0).c_str(),
+		TfPyRepr(self.body1).c_str(),
+		TfPyRepr(self.localPose0Position).c_str(),
+		TfPyRepr(self.localPose0Orientation).c_str(),
+		TfPyRepr(self.localPose1Position).c_str(),
+		TfPyRepr(self.localPose1Orientation).c_str(),
+		TfPyRepr(self.jointEnabled).c_str(),
+		TfPyRepr(self.breakForce).c_str(),
+		TfPyRepr(self.breakTorque).c_str(),
+		TfPyRepr(self.excludeFromArticulation).c_str(),
+		TfPyRepr(self.collisionEnabled).c_str(),
+		_PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _JointLimitDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>& self)
 {
-    return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.first).c_str(),
-        TfPyRepr(self.second).c_str());
+	return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.first).c_str(),
+		TfPyRepr(self.second).c_str());
 }
 
 static std::string
 _JointDriveDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>& self)
 {
-    return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.first).c_str(),
-        TfPyRepr(self.second).c_str());
+	return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.first).c_str(),
+		TfPyRepr(self.second).c_str());
 }
 
 static std::string
 _D6JointDesc_Repr(const UsdPhysicsD6JointDesc& self)
 {
-    return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.jointLimits).c_str(),
-        TfPyRepr(self.jointDrives).c_str(),
-        _JointDesc_Repr(self).c_str());
+	return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.jointLimits).c_str(),
+		TfPyRepr(self.jointDrives).c_str(),
+		_JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _PrismaticJointDesc_Repr(const UsdPhysicsPrismaticJointDesc& self)
 {
-    return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.axis).c_str(),
-        TfPyRepr(self.limit).c_str(),
-        TfPyRepr(self.drive).c_str(),
-        _JointDesc_Repr(self).c_str());
+	return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.axis).c_str(),
+		TfPyRepr(self.limit).c_str(),
+		TfPyRepr(self.drive).c_str(),
+		_JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _SphericalJointDesc_Repr(const UsdPhysicsSphericalJointDesc& self)
 {
-    return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.axis).c_str(),
-        TfPyRepr(self.limit).c_str(),
-        _JointDesc_Repr(self).c_str());
+	return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.axis).c_str(),
+		TfPyRepr(self.limit).c_str(),
+		_JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _RevoluteJointDesc_Repr(const UsdPhysicsRevoluteJointDesc& self)
 {
-    return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.axis).c_str(),
-        TfPyRepr(self.limit).c_str(),
-        TfPyRepr(self.drive).c_str(),
-        _JointDesc_Repr(self).c_str());
+	return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.axis).c_str(),
+		TfPyRepr(self.limit).c_str(),
+		TfPyRepr(self.drive).c_str(),
+		_JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _DistanceJointDesc_Repr(const UsdPhysicsDistanceJointDesc& self)
 {
-    return TfStringPrintf("%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
-        TF_PY_REPR_PREFIX.c_str(),
-        TfPyRepr(self.minEnabled).c_str(),
-        TfPyRepr(self.limit).c_str(),
-        TfPyRepr(self.maxEnabled).c_str(),
-        _JointDesc_Repr(self).c_str());
+	return TfStringPrintf(
+		"%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
+		TF_PY_REPR_PREFIX.c_str(),
+		TfPyRepr(self.minEnabled).c_str(),
+		TfPyRepr(self.limit).c_str(),
+		TfPyRepr(self.maxEnabled).c_str(),
+		_JointDesc_Repr(self).c_str());
 }
 
 void wrapParseUtils()
 {
-    pxr_boost::python::enum_<UsdPhysicsObjectType::Enum>("ObjectType")
-    .value("Undefined", UsdPhysicsObjectType::eUndefined)
-    .value("Scene", UsdPhysicsObjectType::eScene)
-    .value("RigidBody", UsdPhysicsObjectType::eRigidBody)
-    .value("SphereShape", UsdPhysicsObjectType::eSphereShape)
-    .value("CubeShape", UsdPhysicsObjectType::eCubeShape)
-    .value("CapsuleShape", UsdPhysicsObjectType::eCapsuleShape)
-    .value("CylinderShape", UsdPhysicsObjectType::eCylinderShape)
-    .value("ConeShape", UsdPhysicsObjectType::eConeShape)
-    .value("MeshShape", UsdPhysicsObjectType::eMeshShape)
-    .value("PlaneShape", UsdPhysicsObjectType::ePlaneShape)
-    .value("CustomShape", UsdPhysicsObjectType::eCustomShape)
-    .value("SpherePointsShape", UsdPhysicsObjectType::eSpherePointsShape)
-    .value("FixedJoint", UsdPhysicsObjectType::eFixedJoint)
-    .value("RevoluteJoint", UsdPhysicsObjectType::eRevoluteJoint)
-    .value("PrismaticJoint", UsdPhysicsObjectType::ePrismaticJoint)
-    .value("SphericalJoint", UsdPhysicsObjectType::eSphericalJoint)
-    .value("DistanceJoint", UsdPhysicsObjectType::eDistanceJoint)
-    .value("D6Joint", UsdPhysicsObjectType::eD6Joint)
-    .value("CustomJoint", UsdPhysicsObjectType::eCustomJoint)
-    .value("RigidBodyMaterial", UsdPhysicsObjectType::eRigidBodyMaterial)
-    .value("Articulation", UsdPhysicsObjectType::eArticulation)
-    .value("CollisionGroup", UsdPhysicsObjectType::eCollisionGroup)
-    ;
-
-    pxr_boost::python::enum_<UsdPhysicsAxis::Enum>("Axis")
-    .value("X", UsdPhysicsAxis::eX)
-    .value("Y", UsdPhysicsAxis::eY)
-    .value("Z", UsdPhysicsAxis::eZ)
-    ;
-
-    pxr_boost::python::enum_<UsdPhysicsJointDOF::Enum>("JointDOF")
-    .value("Distance", UsdPhysicsJointDOF::eDistance)
-    .value("TransX", UsdPhysicsJointDOF::eTransX)
-    .value("TransY", UsdPhysicsJointDOF::eTransY)
-    .value("TransZ", UsdPhysicsJointDOF::eTransZ)
-    .value("RotX", UsdPhysicsJointDOF::eRotX)
-    .value("RotY", UsdPhysicsJointDOF::eRotY)
-    .value("RotZ", UsdPhysicsJointDOF::eRotZ)
-    ;
-    
-    pxr_boost::python::class_<_CustomUsdPhysicsTokens>
-        cupt("CustomUsdPhysicsTokens");
-    cupt
-        .def_readwrite("jointTokens", &_CustomUsdPhysicsTokens::jointTokens)
-        .def_readwrite("shapeTokens", &_CustomUsdPhysicsTokens::shapeTokens)
-        .def_readwrite("instancerTokens", &_CustomUsdPhysicsTokens::instancerTokens)
-        .def("__repr__", _CustomUsdPhysicsTokens_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsObjectDesc>
-        podcls("ObjectDesc", pxr_boost::python::no_init);
-    podcls
-        .def_readonly("type", &UsdPhysicsObjectDesc::type)
-        .def_readonly("primPath", &UsdPhysicsObjectDesc::primPath)
-        .def_readonly("isValid", &UsdPhysicsObjectDesc::isValid)
-        .def("__repr__", _PhysicsObjectDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsSceneDesc, bases<UsdPhysicsObjectDesc>>
-        sdcls("SceneDesc", pxr_boost::python::no_init);
-    sdcls
-        .def_readonly("gravityDirection", &UsdPhysicsSceneDesc::gravityDirection)        
-        .def_readonly("gravityMagnitude", &UsdPhysicsSceneDesc::gravityMagnitude)
-        .def("__repr__", _SceneDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsCollisionGroupDesc, bases<UsdPhysicsObjectDesc>>
-        cgcls("CollisionGroupDesc", pxr_boost::python::no_init);
-    cgcls
-        .def_readonly("invertFilteredGroups", &UsdPhysicsCollisionGroupDesc::invertFilteredGroups)
-        .add_property("mergedGroups", make_function(&UsdPhysicsCollisionGroupDesc::getMergedGroups,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredGroups", make_function(&UsdPhysicsCollisionGroupDesc::getFilteredGroups,
-            return_value_policy<TfPySequenceToList>()))
-        .def_readonly("mergeGroupName", &UsdPhysicsCollisionGroupDesc::mergeGroupName)
-        .def("__repr__", _CollisionGroupDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsRigidBodyMaterialDesc, bases<UsdPhysicsObjectDesc>>
-        rbmcls("RigidBodyMaterialDesc", pxr_boost::python::no_init);
-    rbmcls
-        .def_readonly("staticFriction", &UsdPhysicsRigidBodyMaterialDesc::staticFriction)
-        .def_readonly("dynamicFriction", &UsdPhysicsRigidBodyMaterialDesc::dynamicFriction)
-        .def_readonly("restitution", &UsdPhysicsRigidBodyMaterialDesc::restitution)
-        .def_readonly("density", &UsdPhysicsRigidBodyMaterialDesc::density)
-        .def("__repr__", _RigidBodyMaterialDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsShapeDesc, bases<UsdPhysicsObjectDesc>>
-        shdcls("ShapeDesc", pxr_boost::python::no_init);
-    shdcls
-        .def_readonly("rigidBody", &UsdPhysicsShapeDesc::rigidBody)
-        .def_readonly("localPos", &UsdPhysicsShapeDesc::localPos)
-        .def_readonly("localRot", &UsdPhysicsShapeDesc::localRot)
-        .def_readonly("localScale", &UsdPhysicsShapeDesc::localScale)
-        .add_property("materials", make_function(&UsdPhysicsShapeDesc::getMaterials,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("simulationOwners", make_function(&UsdPhysicsShapeDesc::getSimulationOwners,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredCollisions", make_function(&UsdPhysicsShapeDesc::getFilteredCollisions,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("collisionGroups", make_function(&UsdPhysicsShapeDesc::getCollisionGroups,
-            return_value_policy<TfPySequenceToList>()))
-        .def_readonly("collisionEnabled", &UsdPhysicsShapeDesc::collisionEnabled)
-        .def("__repr__", _ShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsSphereShapeDesc, bases<UsdPhysicsShapeDesc>>
-        ssdcls("SphereShapeDesc", pxr_boost::python::no_init);
-    ssdcls
-        .def_readonly("radius", &UsdPhysicsSphereShapeDesc::radius)
-        .def("__repr__", _SphereShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsCapsuleShapeDesc, bases<UsdPhysicsShapeDesc>>
-        csdcls("CapsuleShapeDesc", pxr_boost::python::no_init);
-    csdcls
-        .def_readonly("radius", &UsdPhysicsCapsuleShapeDesc::radius)
-        .def_readonly("halfHeight", &UsdPhysicsCapsuleShapeDesc::halfHeight)
-        .def_readonly("axis", &UsdPhysicsCapsuleShapeDesc::axis)
-        .def("__repr__", _CapsuleShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsCylinderShapeDesc, bases<UsdPhysicsShapeDesc>>
-        cysdcls("CylinderShapeDesc", pxr_boost::python::no_init);
-    cysdcls
-        .def_readonly("radius", &UsdPhysicsCylinderShapeDesc::radius)
-        .def_readonly("halfHeight", &UsdPhysicsCylinderShapeDesc::halfHeight)
-        .def_readonly("axis", &UsdPhysicsCylinderShapeDesc::axis)
-        .def("__repr__", _CylinderShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsConeShapeDesc, bases<UsdPhysicsShapeDesc>>
-        cosdcls("ConeShapeDesc", pxr_boost::python::no_init);
-    cosdcls
-        .def_readonly("radius", &UsdPhysicsConeShapeDesc::radius)
-        .def_readonly("halfHeight", &UsdPhysicsConeShapeDesc::halfHeight)
-        .def_readonly("axis", &UsdPhysicsConeShapeDesc::axis)
-        .def("__repr__", _ConeShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsPlaneShapeDesc, bases<UsdPhysicsShapeDesc>>
-        pscls("PlaneShapeDesc", pxr_boost::python::no_init);
-    pscls
-        .def_readonly("axis", &UsdPhysicsPlaneShapeDesc::axis)
-        .def("__repr__", _PlaneShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsCustomShapeDesc, bases<UsdPhysicsShapeDesc>>
-        cuscls("CustomShapeDesc", pxr_boost::python::no_init);
-    cuscls
-        .def_readonly("customGeometryToken", &UsdPhysicsCustomShapeDesc::customGeometryToken)
-        .def("__repr__", _CustomShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsCubeShapeDesc, bases<UsdPhysicsShapeDesc>>
-        cubescls("CubeShapeDesc", pxr_boost::python::no_init);
-    cubescls
-        .def_readonly("halfExtents", &UsdPhysicsCubeShapeDesc::halfExtents)
-        .def("__repr__", _CubeShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsMeshShapeDesc, bases<UsdPhysicsShapeDesc>>
-        mscls("MeshShapeDesc", pxr_boost::python::no_init);
-    mscls
-        .add_property("approximation", &UsdPhysicsMeshShapeDesc::GetApproximation)
-        .def_readonly("meshScale", &UsdPhysicsMeshShapeDesc::meshScale)
-        .def_readonly("doubleSided", &UsdPhysicsMeshShapeDesc::doubleSided)
-        .def("__repr__", _MeshShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsSpherePoint>
-        sppb("SpherePoint", pxr_boost::python::no_init);
-    sppb
-        .def_readonly("center", &UsdPhysicsSpherePoint::center)
-        .def_readonly("radius", &UsdPhysicsSpherePoint::radius)
-        .def("__repr__", _SpherePoint_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsSpherePointsShapeDesc, bases<UsdPhysicsShapeDesc>>
-        spmscls("SpherePointsShapeDesc", pxr_boost::python::no_init);
-    spmscls
-        .add_property("spherePoints", &UsdPhysicsSpherePointsShapeDesc::spherePoints)
-        .def("__repr__", _SpherePointsShapeDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsRigidBodyDesc, bases<UsdPhysicsObjectDesc>>
-        rbcls("RigidBodyDesc", pxr_boost::python::no_init);
-    rbcls
-        .add_property("collisions", make_function(&UsdPhysicsRigidBodyDesc::getCollisions,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredCollisions", make_function(&UsdPhysicsRigidBodyDesc::getFilteredCollisions,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("simulationOwners", make_function(&UsdPhysicsRigidBodyDesc::getSimulationOwners,
-            return_value_policy<TfPySequenceToList>()))
-        .def_readonly("position", &UsdPhysicsRigidBodyDesc::position)
-        .def_readonly("rotation", &UsdPhysicsRigidBodyDesc::rotation)
-        .def_readonly("scale", &UsdPhysicsRigidBodyDesc::scale)
-        .def_readonly("rigidBodyEnabled", &UsdPhysicsRigidBodyDesc::rigidBodyEnabled)
-        .def_readonly("kinematicBody", &UsdPhysicsRigidBodyDesc::kinematicBody)
-        .def_readonly("startsAsleep", &UsdPhysicsRigidBodyDesc::startsAsleep)
-        .def_readonly("linearVelocity", &UsdPhysicsRigidBodyDesc::linearVelocity)
-        .def_readonly("angularVelocity", &UsdPhysicsRigidBodyDesc::angularVelocity)
-        .def("__repr__", _RigidBodyDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsJointLimit>
-        jlcls("JointLimit", pxr_boost::python::no_init);
-    jlcls
-        .def_readonly("enabled", &UsdPhysicsJointLimit::enabled)
-        .def_readonly("lower", &UsdPhysicsJointLimit::lower)
-        .def_readonly("upper", &UsdPhysicsJointLimit::upper)
-        .def("__repr__", _JointLimit_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsJointDrive>
-        jdcls("JointDrive", pxr_boost::python::no_init);
-    jdcls
-        .def_readonly("enabled", &UsdPhysicsJointDrive::enabled)
-        .def_readonly("targetPosition", &UsdPhysicsJointDrive::targetPosition)
-        .def_readonly("targetVelocity", &UsdPhysicsJointDrive::targetVelocity)
-        .def_readonly("forceLimit", &UsdPhysicsJointDrive::forceLimit)
-        .def_readonly("stiffness", &UsdPhysicsJointDrive::stiffness)
-        .def_readonly("damping", &UsdPhysicsJointDrive::damping)
-        .def_readonly("acceleration", &UsdPhysicsJointDrive::acceleration)
-        .def("__repr__", _JointDrive_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsArticulationDesc, bases<UsdPhysicsObjectDesc>>
-        adcls("ArticulationDesc", pxr_boost::python::no_init);
-    adcls
-        .add_property("rootPrims", make_function(&UsdPhysicsArticulationDesc::GetRootPrims,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("filteredCollisions", make_function(&UsdPhysicsArticulationDesc::GetFilteredCollisions,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("articulatedJoints", make_function(&UsdPhysicsArticulationDesc::GetArticulatedJoints,
-            return_value_policy<TfPySequenceToList>()))
-        .add_property("articulatedBodies", make_function(&UsdPhysicsArticulationDesc::GetArticulatedBodies,
-            return_value_policy<TfPySequenceToList>()))
-        .def("__repr__", _ArticulationDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsJointDesc, bases<UsdPhysicsObjectDesc>>
-        jdscls("JointDesc", pxr_boost::python::no_init);
-    jdscls
-        .def_readonly("rel0", &UsdPhysicsJointDesc::rel0)
-        .def_readonly("rel1", &UsdPhysicsJointDesc::rel1)
-        .def_readonly("body0", &UsdPhysicsJointDesc::body0)
-        .def_readonly("body1", &UsdPhysicsJointDesc::body1)
-        .def_readonly("localPose0Position", &UsdPhysicsJointDesc::localPose0Position)
-        .def_readonly("localPose0Orientation", &UsdPhysicsJointDesc::localPose0Orientation)
-        .def_readonly("localPose1Position", &UsdPhysicsJointDesc::localPose1Position)
-        .def_readonly("localPose1Orientation", &UsdPhysicsJointDesc::localPose1Orientation)
-        .def_readonly("jointEnabled", &UsdPhysicsJointDesc::jointEnabled)
-        .def_readonly("breakForce", &UsdPhysicsJointDesc::breakForce)
-        .def_readonly("breakTorque", &UsdPhysicsJointDesc::breakTorque)
-        .def_readonly("excludeFromArticulation", &UsdPhysicsJointDesc::excludeFromArticulation)
-        .def_readonly("collisionEnabled", &UsdPhysicsJointDesc::collisionEnabled)
-        .def("__repr__", _JointDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsCustomJointDesc, bases<UsdPhysicsJointDesc>>
-        cjdscls("CustomJointDesc", pxr_boost::python::no_init);
-
-    pxr_boost::python::class_<UsdPhysicsFixedJointDesc, bases<UsdPhysicsJointDesc>>
-        fjdscls("FixedJointDesc", pxr_boost::python::no_init);
-
-    class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit> >("JointLimitDOFPair")
-        .def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::first)
-        .def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::second)
-        .def("__repr__", _JointLimitDOFPair_Repr);
-
-    class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive> >("JointDriveDOFPair")
-        .def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::first)
-        .def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::second)
-        .def("__repr__", _JointDriveDOFPair_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsD6JointDesc, bases<UsdPhysicsJointDesc>>
-        d6jdscls("D6JointDesc", pxr_boost::python::no_init);
-    d6jdscls
-        .def_readonly("jointLimits", &UsdPhysicsD6JointDesc::jointLimits)
-        .def_readonly("jointDrives", &UsdPhysicsD6JointDesc::jointDrives)
-        .def("__repr__", _D6JointDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsPrismaticJointDesc, bases<UsdPhysicsJointDesc>>
-        pjdscls("PrismaticJointDesc", pxr_boost::python::no_init);
-    pjdscls
-        .def_readonly("axis", &UsdPhysicsPrismaticJointDesc::axis)
-        .def_readonly("limit", &UsdPhysicsPrismaticJointDesc::limit)
-        .def_readonly("drive", &UsdPhysicsPrismaticJointDesc::drive)
-        .def("__repr__", _PrismaticJointDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsSphericalJointDesc, bases<UsdPhysicsJointDesc>>
-        sjdscls("SphericalJointDesc", pxr_boost::python::no_init);
-    sjdscls
-        .def_readonly("axis", &UsdPhysicsSphericalJointDesc::axis)
-        .def_readonly("limit", &UsdPhysicsSphericalJointDesc::limit)
-        .def("__repr__", _SphericalJointDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsRevoluteJointDesc, bases<UsdPhysicsJointDesc>>
-        rjdscls("RevoluteJointDesc", pxr_boost::python::no_init);
-    rjdscls
-        .def_readonly("axis", &UsdPhysicsRevoluteJointDesc::axis)
-        .def_readonly("limit", &UsdPhysicsRevoluteJointDesc::limit)
-        .def_readonly("drive", &UsdPhysicsRevoluteJointDesc::drive)
-        .def("__repr__", _RevoluteJointDesc_Repr);
-
-    pxr_boost::python::class_<UsdPhysicsDistanceJointDesc, bases<UsdPhysicsJointDesc>>
-        djdscls("DistanceJointDesc", pxr_boost::python::no_init);
-    djdscls
-        .def_readonly("minEnabled", &UsdPhysicsDistanceJointDesc::minEnabled)
-        .def_readonly("limit", &UsdPhysicsDistanceJointDesc::limit)
-        .def_readonly("maxEnabled", &UsdPhysicsDistanceJointDesc::maxEnabled)
-        .def("__repr__", _DistanceJointDesc_Repr);
-
-    registerVectorConverter<UsdCollectionMembershipQuery>("PhysicsCollectionMembershipQueryVector");
-
-    registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>("PhysicsJointLimitDOFVector");
+	pxr_boost::python::enum_<UsdPhysicsObjectType::Enum>("ObjectType")
+		.value("Undefined", UsdPhysicsObjectType::eUndefined)
+		.value("Scene", UsdPhysicsObjectType::eScene)
+		.value("RigidBody", UsdPhysicsObjectType::eRigidBody)
+		.value("SphereShape", UsdPhysicsObjectType::eSphereShape)
+		.value("CubeShape", UsdPhysicsObjectType::eCubeShape)
+		.value("CapsuleShape", UsdPhysicsObjectType::eCapsuleShape)
+		.value("CylinderShape", UsdPhysicsObjectType::eCylinderShape)
+		.value("ConeShape", UsdPhysicsObjectType::eConeShape)
+		.value("MeshShape", UsdPhysicsObjectType::eMeshShape)
+		.value("PlaneShape", UsdPhysicsObjectType::ePlaneShape)
+		.value("CustomShape", UsdPhysicsObjectType::eCustomShape)
+		.value("SpherePointsShape", UsdPhysicsObjectType::eSpherePointsShape)
+		.value("FixedJoint", UsdPhysicsObjectType::eFixedJoint)
+		.value("RevoluteJoint", UsdPhysicsObjectType::eRevoluteJoint)
+		.value("PrismaticJoint", UsdPhysicsObjectType::ePrismaticJoint)
+		.value("SphericalJoint", UsdPhysicsObjectType::eSphericalJoint)
+		.value("DistanceJoint", UsdPhysicsObjectType::eDistanceJoint)
+		.value("D6Joint", UsdPhysicsObjectType::eD6Joint)
+		.value("CustomJoint", UsdPhysicsObjectType::eCustomJoint)
+		.value("RigidBodyMaterial", UsdPhysicsObjectType::eRigidBodyMaterial)
+		.value("Articulation", UsdPhysicsObjectType::eArticulation)
+		.value("CollisionGroup", UsdPhysicsObjectType::eCollisionGroup)
+		;
+
+	pxr_boost::python::enum_<UsdPhysicsAxis::Enum>("Axis")
+		.value("X", UsdPhysicsAxis::eX)
+		.value("Y", UsdPhysicsAxis::eY)
+		.value("Z", UsdPhysicsAxis::eZ)
+		;
+
+	pxr_boost::python::enum_<UsdPhysicsJointDOF::Enum>("JointDOF")
+		.value("Distance", UsdPhysicsJointDOF::eDistance)
+		.value("TransX", UsdPhysicsJointDOF::eTransX)
+		.value("TransY", UsdPhysicsJointDOF::eTransY)
+		.value("TransZ", UsdPhysicsJointDOF::eTransZ)
+		.value("RotX", UsdPhysicsJointDOF::eRotX)
+		.value("RotY", UsdPhysicsJointDOF::eRotY)
+		.value("RotZ", UsdPhysicsJointDOF::eRotZ)
+		;
+
+	pxr_boost::python::class_<_CustomUsdPhysicsTokens>
+		cupt("CustomUsdPhysicsTokens");
+	cupt
+		.def_readwrite("jointTokens", &_CustomUsdPhysicsTokens::jointTokens)
+		.def_readwrite("shapeTokens", &_CustomUsdPhysicsTokens::shapeTokens)
+		.def_readwrite("instancerTokens", &_CustomUsdPhysicsTokens::instancerTokens)
+		.def("__repr__", _CustomUsdPhysicsTokens_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsObjectDesc>
+		podcls("ObjectDesc", pxr_boost::python::no_init);
+	podcls
+		.def_readonly("type", &UsdPhysicsObjectDesc::type)
+		.def_readonly("primPath", &UsdPhysicsObjectDesc::primPath)
+		.def_readonly("isValid", &UsdPhysicsObjectDesc::isValid)
+		.def("__repr__", _PhysicsObjectDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsSceneDesc, bases<UsdPhysicsObjectDesc>>
+		sdcls("SceneDesc", pxr_boost::python::no_init);
+	sdcls
+		.def_readonly("gravityDirection", &UsdPhysicsSceneDesc::gravityDirection)
+		.def_readonly("gravityMagnitude", &UsdPhysicsSceneDesc::gravityMagnitude)
+		.def("__repr__", _SceneDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsCollisionGroupDesc, bases<UsdPhysicsObjectDesc>>
+		cgcls("CollisionGroupDesc", pxr_boost::python::no_init);
+	cgcls
+		.def_readonly("invertFilteredGroups", &UsdPhysicsCollisionGroupDesc::invertFilteredGroups)
+		.add_property("mergedGroups",
+			make_function(&UsdPhysicsCollisionGroupDesc::getMergedGroups,
+				return_value_policy<TfPySequenceToList>()))
+		.add_property("filteredGroups",
+			make_function(&UsdPhysicsCollisionGroupDesc::getFilteredGroups,
+				return_value_policy<TfPySequenceToList>()))
+		.def_readonly("mergeGroupName", &UsdPhysicsCollisionGroupDesc::mergeGroupName)
+		.def("__repr__", _CollisionGroupDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsRigidBodyMaterialDesc, bases<UsdPhysicsObjectDesc>>
+		rbmcls("RigidBodyMaterialDesc", pxr_boost::python::no_init);
+	rbmcls
+		.def_readonly("staticFriction", &UsdPhysicsRigidBodyMaterialDesc::staticFriction)
+		.def_readonly("dynamicFriction", &UsdPhysicsRigidBodyMaterialDesc::dynamicFriction)
+		.def_readonly("restitution", &UsdPhysicsRigidBodyMaterialDesc::restitution)
+		.def_readonly("density", &UsdPhysicsRigidBodyMaterialDesc::density)
+		.def("__repr__", _RigidBodyMaterialDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsShapeDesc, bases<UsdPhysicsObjectDesc>>
+		shdcls("ShapeDesc", pxr_boost::python::no_init);
+	shdcls
+		.def_readonly("rigidBody", &UsdPhysicsShapeDesc::rigidBody)
+		.def_readonly("localPos", &UsdPhysicsShapeDesc::localPos)
+		.def_readonly("localRot", &UsdPhysicsShapeDesc::localRot)
+		.def_readonly("localScale", &UsdPhysicsShapeDesc::localScale)
+		.add_property("materials", make_function(&UsdPhysicsShapeDesc::getMaterials,
+			return_value_policy<TfPySequenceToList>()))
+		.add_property("simulationOwners",
+			make_function(&UsdPhysicsShapeDesc::getSimulationOwners,
+				return_value_policy<TfPySequenceToList>()))
+		.add_property("filteredCollisions",
+			make_function(&UsdPhysicsShapeDesc::getFilteredCollisions,
+				return_value_policy<TfPySequenceToList>()))
+		.add_property("collisionGroups",
+			make_function(&UsdPhysicsShapeDesc::getCollisionGroups,
+				return_value_policy<TfPySequenceToList>()))
+		.def_readonly("collisionEnabled", &UsdPhysicsShapeDesc::collisionEnabled)
+		.def("__repr__", _ShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsSphereShapeDesc, bases<UsdPhysicsShapeDesc>>
+		ssdcls("SphereShapeDesc", pxr_boost::python::no_init);
+	ssdcls
+		.def_readonly("radius", &UsdPhysicsSphereShapeDesc::radius)
+		.def("__repr__", _SphereShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsCapsuleShapeDesc, bases<UsdPhysicsShapeDesc>>
+		csdcls("CapsuleShapeDesc", pxr_boost::python::no_init);
+	csdcls
+		.def_readonly("radius", &UsdPhysicsCapsuleShapeDesc::radius)
+		.def_readonly("halfHeight", &UsdPhysicsCapsuleShapeDesc::halfHeight)
+		.def_readonly("axis", &UsdPhysicsCapsuleShapeDesc::axis)
+		.def("__repr__", _CapsuleShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsCylinderShapeDesc, bases<UsdPhysicsShapeDesc>>
+		cysdcls("CylinderShapeDesc", pxr_boost::python::no_init);
+	cysdcls
+		.def_readonly("radius", &UsdPhysicsCylinderShapeDesc::radius)
+		.def_readonly("halfHeight", &UsdPhysicsCylinderShapeDesc::halfHeight)
+		.def_readonly("axis", &UsdPhysicsCylinderShapeDesc::axis)
+		.def("__repr__", _CylinderShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsConeShapeDesc, bases<UsdPhysicsShapeDesc>>
+		cosdcls("ConeShapeDesc", pxr_boost::python::no_init);
+	cosdcls
+		.def_readonly("radius", &UsdPhysicsConeShapeDesc::radius)
+		.def_readonly("halfHeight", &UsdPhysicsConeShapeDesc::halfHeight)
+		.def_readonly("axis", &UsdPhysicsConeShapeDesc::axis)
+		.def("__repr__", _ConeShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsPlaneShapeDesc, bases<UsdPhysicsShapeDesc>>
+		pscls("PlaneShapeDesc", pxr_boost::python::no_init);
+	pscls
+		.def_readonly("axis", &UsdPhysicsPlaneShapeDesc::axis)
+		.def("__repr__", _PlaneShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsCustomShapeDesc, bases<UsdPhysicsShapeDesc>>
+		cuscls("CustomShapeDesc", pxr_boost::python::no_init);
+	cuscls
+		.def_readonly("customGeometryToken", &UsdPhysicsCustomShapeDesc::customGeometryToken)
+		.def("__repr__", _CustomShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsCubeShapeDesc, bases<UsdPhysicsShapeDesc>>
+		cubescls("CubeShapeDesc", pxr_boost::python::no_init);
+	cubescls
+		.def_readonly("halfExtents", &UsdPhysicsCubeShapeDesc::halfExtents)
+		.def("__repr__", _CubeShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsMeshShapeDesc, bases<UsdPhysicsShapeDesc>>
+		mscls("MeshShapeDesc", pxr_boost::python::no_init);
+	mscls
+		.add_property("approximation", &UsdPhysicsMeshShapeDesc::GetApproximation)
+		.def_readonly("meshScale", &UsdPhysicsMeshShapeDesc::meshScale)
+		.def_readonly("doubleSided", &UsdPhysicsMeshShapeDesc::doubleSided)
+		.def("__repr__", _MeshShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsSpherePoint>
+		sppb("SpherePoint", pxr_boost::python::no_init);
+	sppb
+		.def_readonly("center", &UsdPhysicsSpherePoint::center)
+		.def_readonly("radius", &UsdPhysicsSpherePoint::radius)
+		.def("__repr__", _SpherePoint_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsSpherePointsShapeDesc, bases<UsdPhysicsShapeDesc>>
+		spmscls("SpherePointsShapeDesc", pxr_boost::python::no_init);
+	spmscls
+		.add_property("spherePoints", &UsdPhysicsSpherePointsShapeDesc::spherePoints)
+		.def("__repr__", _SpherePointsShapeDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsRigidBodyDesc, bases<UsdPhysicsObjectDesc>>
+		rbcls("RigidBodyDesc", pxr_boost::python::no_init);
+	rbcls
+		.add_property("collisions", make_function(&UsdPhysicsRigidBodyDesc::getCollisions,
+			return_value_policy<TfPySequenceToList>()))
+		.add_property("filteredCollisions",
+			make_function(&UsdPhysicsRigidBodyDesc::getFilteredCollisions,
+				return_value_policy<TfPySequenceToList>()))
+		.add_property("simulationOwners",
+			make_function(&UsdPhysicsRigidBodyDesc::getSimulationOwners,
+				return_value_policy<TfPySequenceToList>()))
+		.def_readonly("position", &UsdPhysicsRigidBodyDesc::position)
+		.def_readonly("rotation", &UsdPhysicsRigidBodyDesc::rotation)
+		.def_readonly("scale", &UsdPhysicsRigidBodyDesc::scale)
+		.def_readonly("rigidBodyEnabled", &UsdPhysicsRigidBodyDesc::rigidBodyEnabled)
+		.def_readonly("kinematicBody", &UsdPhysicsRigidBodyDesc::kinematicBody)
+		.def_readonly("startsAsleep", &UsdPhysicsRigidBodyDesc::startsAsleep)
+		.def_readonly("linearVelocity", &UsdPhysicsRigidBodyDesc::linearVelocity)
+		.def_readonly("angularVelocity", &UsdPhysicsRigidBodyDesc::angularVelocity)
+		.def("__repr__", _RigidBodyDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsJointLimit>
+		jlcls("JointLimit", pxr_boost::python::no_init);
+	jlcls
+		.def_readonly("enabled", &UsdPhysicsJointLimit::enabled)
+		.def_readonly("lower", &UsdPhysicsJointLimit::lower)
+		.def_readonly("upper", &UsdPhysicsJointLimit::upper)
+		.def("__repr__", _JointLimit_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsJointDrive>
+		jdcls("JointDrive", pxr_boost::python::no_init);
+	jdcls
+		.def_readonly("enabled", &UsdPhysicsJointDrive::enabled)
+		.def_readonly("targetPosition", &UsdPhysicsJointDrive::targetPosition)
+		.def_readonly("targetVelocity", &UsdPhysicsJointDrive::targetVelocity)
+		.def_readonly("forceLimit", &UsdPhysicsJointDrive::forceLimit)
+		.def_readonly("stiffness", &UsdPhysicsJointDrive::stiffness)
+		.def_readonly("damping", &UsdPhysicsJointDrive::damping)
+		.def_readonly("acceleration", &UsdPhysicsJointDrive::acceleration)
+		.def("__repr__", _JointDrive_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsArticulationDesc, bases<UsdPhysicsObjectDesc>>
+		adcls("ArticulationDesc", pxr_boost::python::no_init);
+	adcls
+		.add_property("rootPrims", make_function(&UsdPhysicsArticulationDesc::GetRootPrims,
+			return_value_policy<TfPySequenceToList>()))
+		.add_property("filteredCollisions",
+			make_function(&UsdPhysicsArticulationDesc::GetFilteredCollisions,
+				return_value_policy<TfPySequenceToList>()))
+		.add_property("articulatedJoints",
+			make_function(&UsdPhysicsArticulationDesc::GetArticulatedJoints,
+				return_value_policy<TfPySequenceToList>()))
+		.add_property("articulatedBodies",
+			make_function(&UsdPhysicsArticulationDesc::GetArticulatedBodies,
+				return_value_policy<TfPySequenceToList>()))
+		.def("__repr__", _ArticulationDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsJointDesc, bases<UsdPhysicsObjectDesc>>
+		jdscls("JointDesc", pxr_boost::python::no_init);
+	jdscls
+		.def_readonly("rel0", &UsdPhysicsJointDesc::rel0)
+		.def_readonly("rel1", &UsdPhysicsJointDesc::rel1)
+		.def_readonly("body0", &UsdPhysicsJointDesc::body0)
+		.def_readonly("body1", &UsdPhysicsJointDesc::body1)
+		.def_readonly("localPose0Position", &UsdPhysicsJointDesc::localPose0Position)
+		.def_readonly("localPose0Orientation", &UsdPhysicsJointDesc::localPose0Orientation)
+		.def_readonly("localPose1Position", &UsdPhysicsJointDesc::localPose1Position)
+		.def_readonly("localPose1Orientation", &UsdPhysicsJointDesc::localPose1Orientation)
+		.def_readonly("jointEnabled", &UsdPhysicsJointDesc::jointEnabled)
+		.def_readonly("breakForce", &UsdPhysicsJointDesc::breakForce)
+		.def_readonly("breakTorque", &UsdPhysicsJointDesc::breakTorque)
+		.def_readonly("excludeFromArticulation", &UsdPhysicsJointDesc::excludeFromArticulation)
+		.def_readonly("collisionEnabled", &UsdPhysicsJointDesc::collisionEnabled)
+		.def("__repr__", _JointDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsCustomJointDesc, bases<UsdPhysicsJointDesc>>
+		cjdscls("CustomJointDesc", pxr_boost::python::no_init);
+
+	pxr_boost::python::class_<UsdPhysicsFixedJointDesc, bases<UsdPhysicsJointDesc>>
+		fjdscls("FixedJointDesc", pxr_boost::python::no_init);
+
+	class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit> >("JointLimitDOFPair")
+		.def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::first)
+		.def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::second)
+		.def("__repr__", _JointLimitDOFPair_Repr);
+
+	class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive> >("JointDriveDOFPair")
+		.def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::first)
+		.def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::second)
+		.def("__repr__", _JointDriveDOFPair_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsD6JointDesc, bases<UsdPhysicsJointDesc>>
+		d6jdscls("D6JointDesc", pxr_boost::python::no_init);
+	d6jdscls
+		.def_readonly("jointLimits", &UsdPhysicsD6JointDesc::jointLimits)
+		.def_readonly("jointDrives", &UsdPhysicsD6JointDesc::jointDrives)
+		.def("__repr__", _D6JointDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsPrismaticJointDesc, bases<UsdPhysicsJointDesc>>
+		pjdscls("PrismaticJointDesc", pxr_boost::python::no_init);
+	pjdscls
+		.def_readonly("axis", &UsdPhysicsPrismaticJointDesc::axis)
+		.def_readonly("limit", &UsdPhysicsPrismaticJointDesc::limit)
+		.def_readonly("drive", &UsdPhysicsPrismaticJointDesc::drive)
+		.def("__repr__", _PrismaticJointDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsSphericalJointDesc, bases<UsdPhysicsJointDesc>>
+		sjdscls("SphericalJointDesc", pxr_boost::python::no_init);
+	sjdscls
+		.def_readonly("axis", &UsdPhysicsSphericalJointDesc::axis)
+		.def_readonly("limit", &UsdPhysicsSphericalJointDesc::limit)
+		.def("__repr__", _SphericalJointDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsRevoluteJointDesc, bases<UsdPhysicsJointDesc>>
+		rjdscls("RevoluteJointDesc", pxr_boost::python::no_init);
+	rjdscls
+		.def_readonly("axis", &UsdPhysicsRevoluteJointDesc::axis)
+		.def_readonly("limit", &UsdPhysicsRevoluteJointDesc::limit)
+		.def_readonly("drive", &UsdPhysicsRevoluteJointDesc::drive)
+		.def("__repr__", _RevoluteJointDesc_Repr);
+
+	pxr_boost::python::class_<UsdPhysicsDistanceJointDesc, bases<UsdPhysicsJointDesc>>
+		djdscls("DistanceJointDesc", pxr_boost::python::no_init);
+	djdscls
+		.def_readonly("minEnabled", &UsdPhysicsDistanceJointDesc::minEnabled)
+		.def_readonly("limit", &UsdPhysicsDistanceJointDesc::limit)
+		.def_readonly("maxEnabled", &UsdPhysicsDistanceJointDesc::maxEnabled)
+		.def("__repr__", _DistanceJointDesc_Repr);
+
+	registerVectorConverter<UsdCollectionMembershipQuery>
+		("PhysicsCollectionMembershipQueryVector");
+
+	registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>
+		("PhysicsJointLimitDOFVector");
 
-    registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>>("PhysicsJointDriveDOFVector");
+	registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>>
+		("PhysicsJointDriveDOFVector");
 
-    registerVectorConverter<UsdPhysicsSpherePoint>("PhysicsSpherePointVector");
+	registerVectorConverter<UsdPhysicsSpherePoint>("PhysicsSpherePointVector");
 
-    registerVectorConverter<UsdPhysicsSceneDesc>("SceneDescVector");
+	registerVectorConverter<UsdPhysicsSceneDesc>("SceneDescVector");
 
-    registerVectorConverter<UsdPhysicsRigidBodyDesc>("RigidBodyDescVector");
+	registerVectorConverter<UsdPhysicsRigidBodyDesc>("RigidBodyDescVector");
 
-    registerVectorConverter<UsdPhysicsSphereShapeDesc>("SphereShapeDescVector");
+	registerVectorConverter<UsdPhysicsSphereShapeDesc>("SphereShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsCapsuleShapeDesc>("CapsuleShapeDescVector");
+	registerVectorConverter<UsdPhysicsCapsuleShapeDesc>("CapsuleShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsCylinderShapeDesc>("CylinderShapeDescVector");
+	registerVectorConverter<UsdPhysicsCylinderShapeDesc>("CylinderShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsConeShapeDesc>("ConeShapeDescVector");
+	registerVectorConverter<UsdPhysicsConeShapeDesc>("ConeShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsCubeShapeDesc>("CubeShapeDescVector");
+	registerVectorConverter<UsdPhysicsCubeShapeDesc>("CubeShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsMeshShapeDesc>("MeshShapeDescVector");
+	registerVectorConverter<UsdPhysicsMeshShapeDesc>("MeshShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsPlaneShapeDesc>("PlaneShapeDescVector");
+	registerVectorConverter<UsdPhysicsPlaneShapeDesc>("PlaneShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsCustomShapeDesc>("CustomShapeDescVector");
+	registerVectorConverter<UsdPhysicsCustomShapeDesc>("CustomShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsSpherePointsShapeDesc>("SpherePointsShapeDescVector");
+	registerVectorConverter<UsdPhysicsSpherePointsShapeDesc>("SpherePointsShapeDescVector");
 
-    registerVectorConverter<UsdPhysicsJointDesc>("JointDescVector");
+	registerVectorConverter<UsdPhysicsJointDesc>("JointDescVector");
 
-    registerVectorConverter<UsdPhysicsFixedJointDesc>("FixedJointDescVector");
+	registerVectorConverter<UsdPhysicsFixedJointDesc>("FixedJointDescVector");
 
-    registerVectorConverter<UsdPhysicsDistanceJointDesc>("DistanceJointDescVector");
+	registerVectorConverter<UsdPhysicsDistanceJointDesc>("DistanceJointDescVector");
 
-    registerVectorConverter<UsdPhysicsRevoluteJointDesc>("RevoluteJointDescVector");
+	registerVectorConverter<UsdPhysicsRevoluteJointDesc>("RevoluteJointDescVector");
 
-    registerVectorConverter<UsdPhysicsPrismaticJointDesc>("PrismaticJointDescVector");
+	registerVectorConverter<UsdPhysicsPrismaticJointDesc>("PrismaticJointDescVector");
 
-    registerVectorConverter<UsdPhysicsSphericalJointDesc>("SphericalJointDescVector");
+	registerVectorConverter<UsdPhysicsSphericalJointDesc>("SphericalJointDescVector");
 
-    registerVectorConverter<UsdPhysicsD6JointDesc>("D6JointDescVector");
+	registerVectorConverter<UsdPhysicsD6JointDesc>("D6JointDescVector");
 
-    registerVectorConverter<UsdPhysicsCustomJointDesc>("CustomJointDescVector");
+	registerVectorConverter<UsdPhysicsCustomJointDesc>("CustomJointDescVector");
 
-    registerVectorConverter<UsdPhysicsRigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
+	registerVectorConverter<UsdPhysicsRigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
 
-    registerVectorConverter<UsdPhysicsArticulationDesc>("ArticulationDescVector");
+	registerVectorConverter<UsdPhysicsArticulationDesc>("ArticulationDescVector");
 
-    registerVectorConverter<UsdPhysicsCollisionGroupDesc>("CollisionGroupDescVector");
+	registerVectorConverter<UsdPhysicsCollisionGroupDesc>("CollisionGroupDescVector");
 
-    pxr_boost::python::class_<ParsePrimIteratorBaseWrap, noncopyable>
-        vparseitclsvv("ParsePrimIteratorBaseWrap", no_init);
-      vparseitclsvv.def(init<>());
+	pxr_boost::python::class_<ParsePrimIteratorBaseWrap, noncopyable>
+		vparseitclsvv("ParsePrimIteratorBaseWrap", no_init);
+	vparseitclsvv.def(init<>());
 
-    pxr_boost::python::class_<ParsePrimIteratorRange, bases<ParsePrimIteratorBase>>
-        parseitcls("ParsePrimIteratorRange", no_init);
-    parseitcls
-        .def(init<UsdPrimRange>(arg("primRange")));        
+	pxr_boost::python::class_<ParsePrimIteratorRange, bases<ParsePrimIteratorBase>>
+		parseitcls("ParsePrimIteratorRange", no_init);
+	parseitcls
+		.def(init<UsdPrimRange>(arg("primRange")));
 
-    pxr_boost::python::class_<ExcludeListPrimIteratorRange, bases<ParsePrimIteratorBase>>
-        parseitExccls("ExcludeListPrimIteratorRange", no_init);
-    parseitExccls
-        .def(init<UsdPrimRange,SdfPathVector>());
+	pxr_boost::python::class_<ExcludeListPrimIteratorRange, bases<ParsePrimIteratorBase>>
+		parseitExccls("ExcludeListPrimIteratorRange", no_init);
+	parseitExccls
+		.def(init<UsdPrimRange, SdfPathVector>());
 
-    def("LoadUsdPhysicsFromRange", _LoadUsdPhysicsFromRange, 
-            (args("stage"), args("range"), args("customTokens") = _CustomUsdPhysicsTokens(), args("simulationOwners") = std::vector<SdfPath>()));
+	def("LoadUsdPhysicsFromRange", _LoadUsdPhysicsFromRange,
+		(args("stage"), args("range"), args("customTokens") = _CustomUsdPhysicsTokens(),
+			args("simulationOwners") = std::vector<SdfPath>()));
 }

From 913b66dd4e91d01678920dd5a8b83cdb94f10952 Mon Sep 17 00:00:00 2001
From: Ales Borovicka <aborovicka@nvidia.com>
Date: Wed, 30 Oct 2024 17:13:02 +0100
Subject: [PATCH 8/8] converted tabs to spaces and removed pxr namespace

---
 pxr/usd/usdPhysics/parseDesc.h         | 1046 ++---
 pxr/usd/usdPhysics/parsePrimIterator.h |  366 +-
 pxr/usd/usdPhysics/parseUtils.cpp      | 5602 ++++++++++++------------
 pxr/usd/usdPhysics/parseUtils.h        |   22 +-
 pxr/usd/usdPhysics/wrapParseUtils.cpp  | 1952 ++++-----
 5 files changed, 4494 insertions(+), 4494 deletions(-)

diff --git a/pxr/usd/usdPhysics/parseDesc.h b/pxr/usd/usdPhysics/parseDesc.h
index ef53b8139e..21e492b94a 100644
--- a/pxr/usd/usdPhysics/parseDesc.h
+++ b/pxr/usd/usdPhysics/parseDesc.h
@@ -31,40 +31,40 @@ const float usdPhysicsSentinelLimit = 0.5e38f;
 ///
 struct UsdPhysicsObjectType
 {
-	enum Enum
-	{
-		eUndefined,
+    enum Enum
+    {
+        eUndefined,
 
-		eScene,
+        eScene,
 
-		eRigidBody,
+        eRigidBody,
 
-		eSphereShape,
-		eCubeShape,
-		eCapsuleShape,
-		eCylinderShape,
-		eConeShape,
-		eMeshShape,
-		ePlaneShape,
-		eCustomShape,
-		eSpherePointsShape,
+        eSphereShape,
+        eCubeShape,
+        eCapsuleShape,
+        eCylinderShape,
+        eConeShape,
+        eMeshShape,
+        ePlaneShape,
+        eCustomShape,
+        eSpherePointsShape,
 
-		eFixedJoint,
-		eRevoluteJoint,
-		ePrismaticJoint,
-		eSphericalJoint,
-		eDistanceJoint,
-		eD6Joint,
-		eCustomJoint,
+        eFixedJoint,
+        eRevoluteJoint,
+        ePrismaticJoint,
+        eSphericalJoint,
+        eDistanceJoint,
+        eD6Joint,
+        eCustomJoint,
 
-		eRigidBodyMaterial,
+        eRigidBodyMaterial,
 
-		eArticulation,
+        eArticulation,
 
-		eCollisionGroup,
+        eCollisionGroup,
 
-		eLast,
-	};
+        eLast,
+    };
 };
 
 /// \struct UsdPhysicsAxis
@@ -73,12 +73,12 @@ struct UsdPhysicsObjectType
 ///
 struct UsdPhysicsAxis
 {
-	enum Enum
-	{
-		eX,
-		eY,
-		eZ
-	};
+    enum Enum
+    {
+        eX,
+        eY,
+        eZ
+    };
 };
 
 /// \struct UsdPhysicsJointDOF
@@ -87,16 +87,16 @@ struct UsdPhysicsAxis
 ///
 struct UsdPhysicsJointDOF
 {
-	enum Enum
-	{
-		eDistance,
-		eTransX,
-		eTransY,
-		eTransZ,
-		eRotX,
-		eRotY,
-		eRotZ
-	};
+    enum Enum
+    {
+        eDistance,
+        eTransX,
+        eTransY,
+        eTransZ,
+        eRotX,
+        eRotY,
+        eRotZ
+    };
 };
 
 /// \struct UsdPhysicsObjectDesc
@@ -105,19 +105,19 @@ struct UsdPhysicsJointDOF
 ///
 struct UsdPhysicsObjectDesc
 {
-	UsdPhysicsObjectDesc() : type(UsdPhysicsObjectType::eUndefined), isValid(true)
-	{
-	}
-
-	virtual ~UsdPhysicsObjectDesc()
-	{
-	}
-
-	UsdPhysicsObjectType::Enum type;   ///< Descriptor type
-	SdfPath primPath;               ///< SdfPath for the prim from which the 
-	///< descriptor was parsed
-	bool isValid;                   ///< Validity of a descriptor, the parsing may
-	///< succeed, but the descriptor might be not valid
+    UsdPhysicsObjectDesc() : type(UsdPhysicsObjectType::eUndefined), isValid(true)
+    {
+    }
+
+    virtual ~UsdPhysicsObjectDesc()
+    {
+    }
+
+    UsdPhysicsObjectType::Enum type;   ///< Descriptor type
+    SdfPath primPath;               ///< SdfPath for the prim from which the 
+    ///< descriptor was parsed
+    bool isValid;                   ///< Validity of a descriptor, the parsing may
+    ///< succeed, but the descriptor might be not valid
 };
 
 /// \struct UsdPhysicsRigidBodyMaterialDesc
@@ -126,22 +126,22 @@ struct UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsRigidBodyMaterialDesc : UsdPhysicsObjectDesc
 {
-	UsdPhysicsRigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f),
-		restitution(0.0f), density(-1.0f)
-	{
-		type = UsdPhysicsObjectType::eRigidBodyMaterial;
-	}
-
-	bool operator == (const UsdPhysicsRigidBodyMaterialDesc&) const
-	{
-		return false;
-	}
-
-
-	float staticFriction;       ///< Static friction
-	float dynamicFriction;      ///< Dynamic friction
-	float restitution;          ///< Restitution
-	float density;              ///< Density
+    UsdPhysicsRigidBodyMaterialDesc() : staticFriction(0.0f), dynamicFriction(0.0f),
+        restitution(0.0f), density(-1.0f)
+    {
+        type = UsdPhysicsObjectType::eRigidBodyMaterial;
+    }
+
+    bool operator == (const UsdPhysicsRigidBodyMaterialDesc&) const
+    {
+        return false;
+    }
+
+
+    float staticFriction;       ///< Static friction
+    float dynamicFriction;      ///< Dynamic friction
+    float restitution;          ///< Restitution
+    float density;              ///< Density
 };
 
 /// \struct UsdPhysicsSceneDesc
@@ -150,20 +150,20 @@ struct UsdPhysicsRigidBodyMaterialDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsSceneDesc : UsdPhysicsObjectDesc
 {
-	UsdPhysicsSceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
-	{
-		type = UsdPhysicsObjectType::eScene;
-	}
-
-	bool operator == (const UsdPhysicsSceneDesc&) const
-	{
-		return false;
-	}
-
-	GfVec3f gravityDirection;   ///< Gravity direction, if default 0,0,0 was used
-	///< negative upAxis direction will be returned
-	float gravityMagnitude;     ///< Gravity magnitude, -inf means Earth gravity 
-	///< adjusted by metersPerUnit will be returned
+    UsdPhysicsSceneDesc() : gravityDirection(0.0f, 0.0f, 0.0f), gravityMagnitude(-INFINITY)
+    {
+        type = UsdPhysicsObjectType::eScene;
+    }
+
+    bool operator == (const UsdPhysicsSceneDesc&) const
+    {
+        return false;
+    }
+
+    GfVec3f gravityDirection;   ///< Gravity direction, if default 0,0,0 was used
+    ///< negative upAxis direction will be returned
+    float gravityMagnitude;     ///< Gravity magnitude, -inf means Earth gravity 
+    ///< adjusted by metersPerUnit will be returned
 };
 
 /// \struct UsdPhysicsCollisionGroupDesc
@@ -172,31 +172,31 @@ struct UsdPhysicsSceneDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsCollisionGroupDesc : UsdPhysicsObjectDesc
 {
-	UsdPhysicsCollisionGroupDesc()
-	{
-		type = UsdPhysicsObjectType::eCollisionGroup;
-	}
-
-	bool operator == (const UsdPhysicsCollisionGroupDesc&) const
-	{
-		return false;
-	}
-
-	const SdfPathVector& getFilteredGroups() const
-	{
-		return filteredGroups;
-	}
-
-	const SdfPathVector& getMergedGroups() const
-	{
-		return mergedGroups;
-	}
-
-	bool invertFilteredGroups;              ///< If filtering is inverted 
-	/// <or not (default does not collide with)
-	SdfPathVector filteredGroups;           ///< Filtered groups SdfPath vector
-	std::string mergeGroupName;             ///< Merge group name
-	SdfPathVector mergedGroups;             ///< List of merged collision groups
+    UsdPhysicsCollisionGroupDesc()
+    {
+        type = UsdPhysicsObjectType::eCollisionGroup;
+    }
+
+    bool operator == (const UsdPhysicsCollisionGroupDesc&) const
+    {
+        return false;
+    }
+
+    const SdfPathVector& getFilteredGroups() const
+    {
+        return filteredGroups;
+    }
+
+    const SdfPathVector& getMergedGroups() const
+    {
+        return mergedGroups;
+    }
+
+    bool invertFilteredGroups;              ///< If filtering is inverted 
+    /// <or not (default does not collide with)
+    SdfPathVector filteredGroups;           ///< Filtered groups SdfPath vector
+    std::string mergeGroupName;             ///< Merge group name
+    SdfPathVector mergedGroups;             ///< List of merged collision groups
 };
 
 /// \struct UsdPhysicsShapeDesc
@@ -209,53 +209,53 @@ struct UsdPhysicsCollisionGroupDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsShapeDesc : UsdPhysicsObjectDesc
 {
-	UsdPhysicsShapeDesc()
-		: localPos(0.0f, 0.0f, 0.0f),
-		localRot(1.0f, 0.0f, 0.0f, 0.0f),
-		localScale(1.0f, 1.0f, 1.0f),
-		collisionEnabled(true)
-	{
-	}
-
-	const SdfPathVector& getMaterials() const
-	{
-		return materials;
-	}
-
-	const SdfPathVector& getSimulationOwners() const
-	{
-		return simulationOwners;
-	}
-
-	const SdfPathVector& getFilteredCollisions() const
-	{
-		return filteredCollisions;
-	}
-
-	const SdfPathVector& getCollisionGroups() const
-	{
-		return collisionGroups;
-	}
-
-
-	SdfPath rigidBody;                  ///< Rigid body the collision shape 
-	///< belongs to, if not set its a static collider
-	GfVec3f localPos;                   ///< Local position of the shape relative
-	///< to the body world pose
-	GfQuatf localRot;                   ///< Local orientation of the shape relative 
-	///< to the body world pose
-	GfVec3f localScale;                 ///< Local scale of the shape relative to
-	///< the body world pose
-	SdfPathVector materials;            ///< Materials assigned to the collision 
-	///< geometry, can be multiple materials 
-	///< used on UsdGeomSubset
-	SdfPathVector simulationOwners;     ///< Simulation owners list
-	SdfPathVector filteredCollisions;   ///< Filtered collisions list
-	SdfPathVector collisionGroups;      ///< List of collision groups this collision
-	///< belongs to, note that only collision 
-	///< groups that are part of the current 
-	///< range are checked.
-	bool collisionEnabled;              ///< Collision enabled/disabled bool
+    UsdPhysicsShapeDesc()
+        : localPos(0.0f, 0.0f, 0.0f),
+        localRot(1.0f, 0.0f, 0.0f, 0.0f),
+        localScale(1.0f, 1.0f, 1.0f),
+        collisionEnabled(true)
+    {
+    }
+
+    const SdfPathVector& getMaterials() const
+    {
+        return materials;
+    }
+
+    const SdfPathVector& getSimulationOwners() const
+    {
+        return simulationOwners;
+    }
+
+    const SdfPathVector& getFilteredCollisions() const
+    {
+        return filteredCollisions;
+    }
+
+    const SdfPathVector& getCollisionGroups() const
+    {
+        return collisionGroups;
+    }
+
+
+    SdfPath rigidBody;                  ///< Rigid body the collision shape 
+    ///< belongs to, if not set its a static collider
+    GfVec3f localPos;                   ///< Local position of the shape relative
+    ///< to the body world pose
+    GfQuatf localRot;                   ///< Local orientation of the shape relative 
+    ///< to the body world pose
+    GfVec3f localScale;                 ///< Local scale of the shape relative to
+    ///< the body world pose
+    SdfPathVector materials;            ///< Materials assigned to the collision 
+    ///< geometry, can be multiple materials 
+    ///< used on UsdGeomSubset
+    SdfPathVector simulationOwners;     ///< Simulation owners list
+    SdfPathVector filteredCollisions;   ///< Filtered collisions list
+    SdfPathVector collisionGroups;      ///< List of collision groups this collision
+    ///< belongs to, note that only collision 
+    ///< groups that are part of the current 
+    ///< range are checked.
+    bool collisionEnabled;              ///< Collision enabled/disabled bool
 };
 
 /// \struct UsdPhysicsSphereShapeDesc
@@ -264,17 +264,17 @@ struct UsdPhysicsShapeDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsSphereShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsSphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
-	{
-		type = UsdPhysicsObjectType::eSphereShape;
-	}
+    UsdPhysicsSphereShapeDesc(float inRadius = 0.0f) : radius(inRadius)
+    {
+        type = UsdPhysicsObjectType::eSphereShape;
+    }
 
-	bool operator == (const UsdPhysicsSphereShapeDesc&) const
-	{
-		return false;
-	}
+    bool operator == (const UsdPhysicsSphereShapeDesc&) const
+    {
+        return false;
+    }
 
-	float radius;               ///< Sphere radius
+    float radius;               ///< Sphere radius
 };
 
 /// \struct UsdPhysicsCapsuleShapeDesc
@@ -283,21 +283,21 @@ struct UsdPhysicsSphereShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCapsuleShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsCapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
-		UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
-		: radius(inRadius), halfHeight(half_height), axis(cap_axis)
-	{
-		type = UsdPhysicsObjectType::eCapsuleShape;
-	}
-
-	bool operator == (const UsdPhysicsCapsuleShapeDesc&) const
-	{
-		return false;
-	}
-
-	float radius;               ///< Capsule radius
-	float halfHeight;           ///< Capsule half height
-	UsdPhysicsAxis::Enum axis;     ///< Capsule axis
+    UsdPhysicsCapsuleShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
+        UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
+        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
+    {
+        type = UsdPhysicsObjectType::eCapsuleShape;
+    }
+
+    bool operator == (const UsdPhysicsCapsuleShapeDesc&) const
+    {
+        return false;
+    }
+
+    float radius;               ///< Capsule radius
+    float halfHeight;           ///< Capsule half height
+    UsdPhysicsAxis::Enum axis;     ///< Capsule axis
 };
 
 /// \struct UsdPhysicsCylinderShapeDesc
@@ -306,21 +306,21 @@ struct UsdPhysicsCapsuleShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCylinderShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsCylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
-		UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
-		: radius(inRadius), halfHeight(half_height), axis(cap_axis)
-	{
-		type = UsdPhysicsObjectType::eCylinderShape;
-	}
-
-	bool operator == (const UsdPhysicsCylinderShapeDesc&) const
-	{
-		return false;
-	}
-
-	float radius;               ///< Cylinder radius
-	float halfHeight;           ///< Cylinder half height
-	UsdPhysicsAxis::Enum axis;     ///< Cylinder axis
+    UsdPhysicsCylinderShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
+        UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
+        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
+    {
+        type = UsdPhysicsObjectType::eCylinderShape;
+    }
+
+    bool operator == (const UsdPhysicsCylinderShapeDesc&) const
+    {
+        return false;
+    }
+
+    float radius;               ///< Cylinder radius
+    float halfHeight;           ///< Cylinder half height
+    UsdPhysicsAxis::Enum axis;     ///< Cylinder axis
 };
 
 /// \struct UsdPhysicsConeShapeDesc
@@ -329,22 +329,22 @@ struct UsdPhysicsCylinderShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsConeShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
-		UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
-		: radius(inRadius), halfHeight(half_height), axis(cap_axis)
-	{
-		type = UsdPhysicsObjectType::eConeShape;
-	}
-
-	bool operator == (const UsdPhysicsConeShapeDesc&) const
-	{
-		return false;
-	}
-
-
-	float radius;               ///< Cone radius
-	float halfHeight;           ///< Cone half height
-	UsdPhysicsAxis::Enum axis;     ///< Cone axis
+    UsdPhysicsConeShapeDesc(float inRadius = 0.0f, float half_height = 0.0f,
+        UsdPhysicsAxis::Enum cap_axis = UsdPhysicsAxis::eX)
+        : radius(inRadius), halfHeight(half_height), axis(cap_axis)
+    {
+        type = UsdPhysicsObjectType::eConeShape;
+    }
+
+    bool operator == (const UsdPhysicsConeShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    float radius;               ///< Cone radius
+    float halfHeight;           ///< Cone half height
+    UsdPhysicsAxis::Enum axis;     ///< Cone axis
 };
 
 /// \struct UsdPhysicsPlaneShapeDesc
@@ -353,18 +353,18 @@ struct UsdPhysicsConeShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsPlaneShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsPlaneShapeDesc(UsdPhysicsAxis::Enum up_axis = UsdPhysicsAxis::eX)
-		: axis(up_axis)
-	{
-		type = UsdPhysicsObjectType::ePlaneShape;
-	}
-	bool operator == (const UsdPhysicsPlaneShapeDesc&) const
-	{
-		return false;
-	}
-
-
-	UsdPhysicsAxis::Enum axis;     ///< Plane axis
+    UsdPhysicsPlaneShapeDesc(UsdPhysicsAxis::Enum up_axis = UsdPhysicsAxis::eX)
+        : axis(up_axis)
+    {
+        type = UsdPhysicsObjectType::ePlaneShape;
+    }
+    bool operator == (const UsdPhysicsPlaneShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    UsdPhysicsAxis::Enum axis;     ///< Plane axis
 };
 
 
@@ -374,17 +374,17 @@ struct UsdPhysicsPlaneShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCustomShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsCustomShapeDesc()
-	{
-		type = UsdPhysicsObjectType::eCustomShape;
-	}
-	bool operator == (const UsdPhysicsCustomShapeDesc&) const
-	{
-		return false;
-	}
+    UsdPhysicsCustomShapeDesc()
+    {
+        type = UsdPhysicsObjectType::eCustomShape;
+    }
+    bool operator == (const UsdPhysicsCustomShapeDesc&) const
+    {
+        return false;
+    }
 
 
-	TfToken customGeometryToken;    ///< Custom geometry token for this collision
+    TfToken customGeometryToken;    ///< Custom geometry token for this collision
 };
 
 /// \struct UsdPhysicsCubeShapeDesc
@@ -393,17 +393,17 @@ struct UsdPhysicsCustomShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsCubeShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsCubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f))
-		: halfExtents(inHalfExtents)
-	{
-		type = UsdPhysicsObjectType::eCubeShape;
-	}
-	bool operator == (const UsdPhysicsCubeShapeDesc&) const
-	{
-		return false;
-	}
-
-	GfVec3f halfExtents;        ///< Half extents of the cube
+    UsdPhysicsCubeShapeDesc(const GfVec3f& inHalfExtents = GfVec3f(1.0f))
+        : halfExtents(inHalfExtents)
+    {
+        type = UsdPhysicsObjectType::eCubeShape;
+    }
+    bool operator == (const UsdPhysicsCubeShapeDesc&) const
+    {
+        return false;
+    }
+
+    GfVec3f halfExtents;        ///< Half extents of the cube
 };
 
 /// \struct UsdPhysicsMeshShapeDesc
@@ -412,29 +412,29 @@ struct UsdPhysicsCubeShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsMeshShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsMeshShapeDesc()
-		: meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
-	{
-		type = UsdPhysicsObjectType::eMeshShape;
-	}
-	bool operator == (const UsdPhysicsMeshShapeDesc&) const
-	{
-		return false;
-	}
-
-
-	~UsdPhysicsMeshShapeDesc()
-	{
-	}
-
-	const TfToken GetApproximation()
-	{
-		return approximation;
-	}
-
-	TfToken approximation;      ///< Desired approximation for the mesh collision
-	GfVec3f meshScale;          ///< Mesh scale
-	bool doubleSided;           ///< Bool to define whether mesh is double sided or not
+    UsdPhysicsMeshShapeDesc()
+        : meshScale(1.0f, 1.0f, 1.0f), doubleSided(false)
+    {
+        type = UsdPhysicsObjectType::eMeshShape;
+    }
+    bool operator == (const UsdPhysicsMeshShapeDesc&) const
+    {
+        return false;
+    }
+
+
+    ~UsdPhysicsMeshShapeDesc()
+    {
+    }
+
+    const TfToken GetApproximation()
+    {
+        return approximation;
+    }
+
+    TfToken approximation;      ///< Desired approximation for the mesh collision
+    GfVec3f meshScale;          ///< Mesh scale
+    bool doubleSided;           ///< Bool to define whether mesh is double sided or not
 };
 
 /// \struct UsdPhysicsSpherePoint
@@ -444,13 +444,13 @@ struct UsdPhysicsMeshShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsSpherePoint
 {
-	bool operator == (const UsdPhysicsSpherePoint&) const
-	{
-		return false;
-	}
+    bool operator == (const UsdPhysicsSpherePoint&) const
+    {
+        return false;
+    }
 
-	GfVec3f center;
-	float radius;
+    GfVec3f center;
+    float radius;
 };
 
 /// \struct UsdPhysicsSpherePointsShapeDesc
@@ -462,21 +462,21 @@ struct UsdPhysicsSpherePoint
 ///
 struct UsdPhysicsSpherePointsShapeDesc : UsdPhysicsShapeDesc
 {
-	UsdPhysicsSpherePointsShapeDesc(void)
-	{
-		type = UsdPhysicsObjectType::eSpherePointsShape;
-	}
-	bool operator == (const UsdPhysicsSpherePointsShapeDesc&) const
-	{
-		return false;
-	}
+    UsdPhysicsSpherePointsShapeDesc(void)
+    {
+        type = UsdPhysicsObjectType::eSpherePointsShape;
+    }
+    bool operator == (const UsdPhysicsSpherePointsShapeDesc&) const
+    {
+        return false;
+    }
 
 
-	~UsdPhysicsSpherePointsShapeDesc(void)
-	{
-	}
+    ~UsdPhysicsSpherePointsShapeDesc(void)
+    {
+    }
 
-	std::vector<UsdPhysicsSpherePoint> spherePoints;  ///< Lit of sphere points
+    std::vector<UsdPhysicsSpherePoint> spherePoints;  ///< Lit of sphere points
 };
 
 /// \struct UsdPhysicsRigidBodyDesc
@@ -485,52 +485,52 @@ struct UsdPhysicsSpherePointsShapeDesc : UsdPhysicsShapeDesc
 ///
 struct UsdPhysicsRigidBodyDesc : UsdPhysicsObjectDesc
 {
-	UsdPhysicsRigidBodyDesc()
-		: position(0.0f, 0.0f, 0.0f),
-		rotation(1.0f, 0.0f, 0.0f, 0.0f),
-		scale(1.0f, 1.0f, 1.0f),
-		rigidBodyEnabled(true),
-		kinematicBody(false),
-		startsAsleep(false),
-		linearVelocity(0.0f, 0.0f, 0.0f),
-		angularVelocity(0.0f, 0.0f, 0.0f)
-	{
-		type = UsdPhysicsObjectType::eRigidBody;
-	}
-	bool operator == (const UsdPhysicsRigidBodyDesc&) const
-	{
-		return false;
-	}
-
-	const SdfPathVector& getCollisions() const
-	{
-		return collisions;
-	}
-
-	const SdfPathVector& getFilteredCollisions() const
-	{
-		return filteredCollisions;
-	}
-
-	const SdfPathVector& getSimulationOwners() const
-	{
-		return simulationOwners;
-	}
-
-	SdfPathVector collisions;               ///< List of collision shapes that 
-	///< belong to this rigid body
-	SdfPathVector filteredCollisions;       ///< Filtered collisions
-	SdfPathVector simulationOwners;         ///< Simulation owners list
-	GfVec3f position;                       ///< Rigid body position in world space
-	GfQuatf rotation;                       ///< Rigid body orientation in world space
-	GfVec3f scale;                          ///< Rigid body scale
-
-	bool rigidBodyEnabled;                  ///< Defines whether body is enabled 
-	///< or not, if not enabled its a static body
-	bool kinematicBody;                     ///< Defines if the body is kinematic or not
-	bool startsAsleep;                      ///< Defines if body starts asleep or awake
-	GfVec3f linearVelocity;                 ///< Rigid body initial linear velocity
-	GfVec3f angularVelocity;                ///< Rigid body initial angular velocity
+    UsdPhysicsRigidBodyDesc()
+        : position(0.0f, 0.0f, 0.0f),
+        rotation(1.0f, 0.0f, 0.0f, 0.0f),
+        scale(1.0f, 1.0f, 1.0f),
+        rigidBodyEnabled(true),
+        kinematicBody(false),
+        startsAsleep(false),
+        linearVelocity(0.0f, 0.0f, 0.0f),
+        angularVelocity(0.0f, 0.0f, 0.0f)
+    {
+        type = UsdPhysicsObjectType::eRigidBody;
+    }
+    bool operator == (const UsdPhysicsRigidBodyDesc&) const
+    {
+        return false;
+    }
+
+    const SdfPathVector& getCollisions() const
+    {
+        return collisions;
+    }
+
+    const SdfPathVector& getFilteredCollisions() const
+    {
+        return filteredCollisions;
+    }
+
+    const SdfPathVector& getSimulationOwners() const
+    {
+        return simulationOwners;
+    }
+
+    SdfPathVector collisions;               ///< List of collision shapes that 
+    ///< belong to this rigid body
+    SdfPathVector filteredCollisions;       ///< Filtered collisions
+    SdfPathVector simulationOwners;         ///< Simulation owners list
+    GfVec3f position;                       ///< Rigid body position in world space
+    GfQuatf rotation;                       ///< Rigid body orientation in world space
+    GfVec3f scale;                          ///< Rigid body scale
+
+    bool rigidBodyEnabled;                  ///< Defines whether body is enabled 
+    ///< or not, if not enabled its a static body
+    bool kinematicBody;                     ///< Defines if the body is kinematic or not
+    bool startsAsleep;                      ///< Defines if body starts asleep or awake
+    GfVec3f linearVelocity;                 ///< Rigid body initial linear velocity
+    GfVec3f angularVelocity;                ///< Rigid body initial angular velocity
 };
 
 /// \struct UsdPhysicsJointLimit
@@ -539,29 +539,29 @@ struct UsdPhysicsRigidBodyDesc : UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsJointLimit
 {
-	UsdPhysicsJointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
-	{
-	}
-
-	bool operator == (const UsdPhysicsJointLimit&) const
-	{
-		return false;
-	}
-
-
-	bool enabled;           ///< Defines whether limit is enabled or not
-	union                   ///< Min, lower, initial angle
-	{
-		float angle0;
-		float lower;
-		float minDist;
-	};
-	union                   ///< Max, upper, final angle
-	{
-		float angle1;
-		float upper;
-		float maxDist;
-	};
+    UsdPhysicsJointLimit() : enabled(false), angle0(90.0), angle1(-90.0)
+    {
+    }
+
+    bool operator == (const UsdPhysicsJointLimit&) const
+    {
+        return false;
+    }
+
+
+    bool enabled;           ///< Defines whether limit is enabled or not
+    union                   ///< Min, lower, initial angle
+    {
+        float angle0;
+        float lower;
+        float minDist;
+    };
+    union                   ///< Max, upper, final angle
+    {
+        float angle1;
+        float upper;
+        float maxDist;
+    };
 };
 
 /// \struct UsdPhysicsJointDrive
@@ -572,29 +572,29 @@ struct UsdPhysicsJointLimit
 ///
 struct UsdPhysicsJointDrive
 {
-	UsdPhysicsJointDrive()
-		: enabled(false),
-		targetPosition(0.0f),
-		targetVelocity(0.0f),
-		forceLimit(FLT_MAX),
-		stiffness(0.0f),
-		damping(0.0f),
-		acceleration(false)
-	{
-	}
-
-	bool operator == (const UsdPhysicsJointDrive&) const
-	{
-		return false;
-	}
-
-	bool enabled;           ///< Defines whether limit is enabled or not
-	float targetPosition;   ///< Drive target position
-	float targetVelocity;   ///< Drive target velocity
-	float forceLimit;       ///< Force limit
-	float stiffness;        ///< Drive stiffness
-	float damping;          ///< Drive damping
-	bool acceleration;      ///< Drive mode is acceleration or force
+    UsdPhysicsJointDrive()
+        : enabled(false),
+        targetPosition(0.0f),
+        targetVelocity(0.0f),
+        forceLimit(FLT_MAX),
+        stiffness(0.0f),
+        damping(0.0f),
+        acceleration(false)
+    {
+    }
+
+    bool operator == (const UsdPhysicsJointDrive&) const
+    {
+        return false;
+    }
+
+    bool enabled;           ///< Defines whether limit is enabled or not
+    float targetPosition;   ///< Drive target position
+    float targetVelocity;   ///< Drive target velocity
+    float forceLimit;       ///< Force limit
+    float stiffness;        ///< Drive stiffness
+    float damping;          ///< Drive damping
+    bool acceleration;      ///< Drive mode is acceleration or force
 };
 
 
@@ -604,40 +604,40 @@ struct UsdPhysicsJointDrive
 ///
 struct UsdPhysicsArticulationDesc : UsdPhysicsObjectDesc
 {
-	UsdPhysicsArticulationDesc()
-	{
-		type = UsdPhysicsObjectType::eArticulation;
-	}
-	bool operator == (const UsdPhysicsArticulationDesc&) const
-	{
-		return false;
-	}
-
-	const SdfPathVector& GetRootPrims() const
-	{
-		return rootPrims;
-	}
-
-	const SdfPathVector& GetFilteredCollisions() const
-	{
-		return filteredCollisions;
-	}
-
-	const SdfPathVector& GetArticulatedJoints() const
-	{
-		return articulatedJoints;
-	}
-
-	const SdfPathVector& GetArticulatedBodies() const
-	{
-		return articulatedBodies;
-	}
-
-	SdfPathVector rootPrims;            ///< List of articulation roots, this defines
-	///<  where the articulation topology starts
-	SdfPathVector filteredCollisions;   ///< Filtered collisions
-	SdfPathVector articulatedJoints;    ///< List of joints that can be part of this articulation
-	SdfPathVector articulatedBodies;    ///< List of bodies that can be part of this articulation
+    UsdPhysicsArticulationDesc()
+    {
+        type = UsdPhysicsObjectType::eArticulation;
+    }
+    bool operator == (const UsdPhysicsArticulationDesc&) const
+    {
+        return false;
+    }
+
+    const SdfPathVector& GetRootPrims() const
+    {
+        return rootPrims;
+    }
+
+    const SdfPathVector& GetFilteredCollisions() const
+    {
+        return filteredCollisions;
+    }
+
+    const SdfPathVector& GetArticulatedJoints() const
+    {
+        return articulatedJoints;
+    }
+
+    const SdfPathVector& GetArticulatedBodies() const
+    {
+        return articulatedBodies;
+    }
+
+    SdfPathVector rootPrims;            ///< List of articulation roots, this defines
+    ///<  where the articulation topology starts
+    SdfPathVector filteredCollisions;   ///< Filtered collisions
+    SdfPathVector articulatedJoints;    ///< List of joints that can be part of this articulation
+    SdfPathVector articulatedBodies;    ///< List of bodies that can be part of this articulation
 };
 
 using JointLimits = std::vector<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>;
@@ -649,44 +649,44 @@ using JointDrives = std::vector<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJo
 ///
 struct UsdPhysicsJointDesc : public UsdPhysicsObjectDesc
 {
-	UsdPhysicsJointDesc()
-		: localPose0Position(0.0f, 0.0f, 0.0f),
-		localPose0Orientation(1.0f, 0.0f, 0.0f, 0.0f),
-		localPose1Position(0.0f, 0.0f, 0.0f),
-		localPose1Orientation(1.0f, 0.0f, 0.0f, 0.0f),
-		jointEnabled(true),
-		breakForce(FLT_MAX), // USD default is none, which is not a float...
-		breakTorque(FLT_MAX),
-		excludeFromArticulation(false)
-	{
-	}
-
-	bool operator == (const UsdPhysicsJointDesc&) const
-	{
-		return false;
-	}
-
-	SdfPath rel0;                   ///< UsdPrim relationship 0 for the joint
-	SdfPath rel1;                   ///< UsdPrim relationship 1 for the joint
-	SdfPath body0;                  ///< Rigid body 0 that the joint is connected, 
-	///< does not have to match the rel0
-	SdfPath body1;                  ///< Rigid body 1 that the joint is connected, 
-	///< does not have to match the rel1
-	GfVec3f localPose0Position;     ///< Relative local position against the body0 
-	///< world frame
-	GfQuatf localPose0Orientation;  ///< Relative local orientation against the body0 
-	///< world frame
-	GfVec3f localPose1Position;     ///< Relative local position against the body1 
-	///< world frame
-	GfQuatf localPose1Orientation;  ///< Relative local orientation against the body1 
-	///< world frame
-	bool jointEnabled;              ///< Defines if joint is enabled or disabled
-	float breakForce;               ///< Joint break force
-	float breakTorque;              ///< Joint break torque
-	bool excludeFromArticulation;   ///< Defines if joints belongs to an articulation 
-	///< or if its a maximum coordinate joint
-	bool collisionEnabled;          ///< Defines if collision is enabled or disabled 
-	///< between the jointed bodies
+    UsdPhysicsJointDesc()
+        : localPose0Position(0.0f, 0.0f, 0.0f),
+        localPose0Orientation(1.0f, 0.0f, 0.0f, 0.0f),
+        localPose1Position(0.0f, 0.0f, 0.0f),
+        localPose1Orientation(1.0f, 0.0f, 0.0f, 0.0f),
+        jointEnabled(true),
+        breakForce(FLT_MAX), // USD default is none, which is not a float...
+        breakTorque(FLT_MAX),
+        excludeFromArticulation(false)
+    {
+    }
+
+    bool operator == (const UsdPhysicsJointDesc&) const
+    {
+        return false;
+    }
+
+    SdfPath rel0;                   ///< UsdPrim relationship 0 for the joint
+    SdfPath rel1;                   ///< UsdPrim relationship 1 for the joint
+    SdfPath body0;                  ///< Rigid body 0 that the joint is connected, 
+    ///< does not have to match the rel0
+    SdfPath body1;                  ///< Rigid body 1 that the joint is connected, 
+    ///< does not have to match the rel1
+    GfVec3f localPose0Position;     ///< Relative local position against the body0 
+    ///< world frame
+    GfQuatf localPose0Orientation;  ///< Relative local orientation against the body0 
+    ///< world frame
+    GfVec3f localPose1Position;     ///< Relative local position against the body1 
+    ///< world frame
+    GfQuatf localPose1Orientation;  ///< Relative local orientation against the body1 
+    ///< world frame
+    bool jointEnabled;              ///< Defines if joint is enabled or disabled
+    float breakForce;               ///< Joint break force
+    float breakTorque;              ///< Joint break torque
+    bool excludeFromArticulation;   ///< Defines if joints belongs to an articulation 
+    ///< or if its a maximum coordinate joint
+    bool collisionEnabled;          ///< Defines if collision is enabled or disabled 
+    ///< between the jointed bodies
 };
 
 /// \struct UsdPhysicsCustomJointDesc
@@ -695,14 +695,14 @@ struct UsdPhysicsJointDesc : public UsdPhysicsObjectDesc
 ///
 struct UsdPhysicsCustomJointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsCustomJointDesc()
-	{
-		type = UsdPhysicsObjectType::eCustomJoint;
-	}
-	bool operator == (const UsdPhysicsCustomJointDesc&) const
-	{
-		return false;
-	}
+    UsdPhysicsCustomJointDesc()
+    {
+        type = UsdPhysicsObjectType::eCustomJoint;
+    }
+    bool operator == (const UsdPhysicsCustomJointDesc&) const
+    {
+        return false;
+    }
 
 };
 
@@ -712,14 +712,14 @@ struct UsdPhysicsCustomJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsFixedJointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsFixedJointDesc()
-	{
-		type = UsdPhysicsObjectType::eFixedJoint;
-	}
-	bool operator == (const UsdPhysicsFixedJointDesc&) const
-	{
-		return false;
-	}
+    UsdPhysicsFixedJointDesc()
+    {
+        type = UsdPhysicsObjectType::eFixedJoint;
+    }
+    bool operator == (const UsdPhysicsFixedJointDesc&) const
+    {
+        return false;
+    }
 };
 
 /// \struct UsdPhysicsD6JointDesc
@@ -728,17 +728,17 @@ struct UsdPhysicsFixedJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsD6JointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsD6JointDesc()
-	{
-		type = UsdPhysicsObjectType::eD6Joint;
-	}
-	bool operator == (const UsdPhysicsD6JointDesc&) const
-	{
-		return false;
-	}
-
-	JointLimits jointLimits;    ///< List of joint limits
-	JointDrives jointDrives;    ///< List of joint drives
+    UsdPhysicsD6JointDesc()
+    {
+        type = UsdPhysicsObjectType::eD6Joint;
+    }
+    bool operator == (const UsdPhysicsD6JointDesc&) const
+    {
+        return false;
+    }
+
+    JointLimits jointLimits;    ///< List of joint limits
+    JointDrives jointDrives;    ///< List of joint drives
 };
 
 /// \struct UsdPhysicsPrismaticJointDesc
@@ -747,19 +747,19 @@ struct UsdPhysicsD6JointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsPrismaticJointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsPrismaticJointDesc() : axis(UsdPhysicsAxis::eX)
-	{
-		type = UsdPhysicsObjectType::ePrismaticJoint;
-	}
-	bool operator == (const UsdPhysicsPrismaticJointDesc&) const
-	{
-		return false;
-	}
-
-
-	UsdPhysicsAxis::Enum axis; ///< The joints axis
-	UsdPhysicsJointLimit limit;       ///< Joint linear limit
-	UsdPhysicsJointDrive drive;       ///< Joint linear drive
+    UsdPhysicsPrismaticJointDesc() : axis(UsdPhysicsAxis::eX)
+    {
+        type = UsdPhysicsObjectType::ePrismaticJoint;
+    }
+    bool operator == (const UsdPhysicsPrismaticJointDesc&) const
+    {
+        return false;
+    }
+
+
+    UsdPhysicsAxis::Enum axis; ///< The joints axis
+    UsdPhysicsJointLimit limit;       ///< Joint linear limit
+    UsdPhysicsJointDrive drive;       ///< Joint linear drive
 };
 
 /// \struct UsdPhysicsSphericalJointDesc
@@ -768,17 +768,17 @@ struct UsdPhysicsPrismaticJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsSphericalJointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsSphericalJointDesc() : axis(UsdPhysicsAxis::eX)
-	{
-		type = UsdPhysicsObjectType::eSphericalJoint;
-	}
-	bool operator == (const UsdPhysicsSphericalJointDesc&) const
-	{
-		return false;
-	}
-
-	UsdPhysicsAxis::Enum axis; ///< The joints axis
-	UsdPhysicsJointLimit limit;       ///< The joint spherical limit
+    UsdPhysicsSphericalJointDesc() : axis(UsdPhysicsAxis::eX)
+    {
+        type = UsdPhysicsObjectType::eSphericalJoint;
+    }
+    bool operator == (const UsdPhysicsSphericalJointDesc&) const
+    {
+        return false;
+    }
+
+    UsdPhysicsAxis::Enum axis; ///< The joints axis
+    UsdPhysicsJointLimit limit;       ///< The joint spherical limit
 };
 
 /// \struct UsdPhysicsRevoluteJointDesc
@@ -787,18 +787,18 @@ struct UsdPhysicsSphericalJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsRevoluteJointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsRevoluteJointDesc() : axis(UsdPhysicsAxis::eX)
-	{
-		type = UsdPhysicsObjectType::eRevoluteJoint;
-	}
-	bool operator == (const UsdPhysicsRevoluteJointDesc&) const
-	{
-		return false;
-	}
-
-	UsdPhysicsAxis::Enum axis; ///< The joints axis
-	UsdPhysicsJointLimit limit;       ///< The angular limit
-	UsdPhysicsJointDrive drive;       ///< The angular drive
+    UsdPhysicsRevoluteJointDesc() : axis(UsdPhysicsAxis::eX)
+    {
+        type = UsdPhysicsObjectType::eRevoluteJoint;
+    }
+    bool operator == (const UsdPhysicsRevoluteJointDesc&) const
+    {
+        return false;
+    }
+
+    UsdPhysicsAxis::Enum axis; ///< The joints axis
+    UsdPhysicsJointLimit limit;       ///< The angular limit
+    UsdPhysicsJointDrive drive;       ///< The angular drive
 };
 
 /// \struct UsdPhysicsDistanceJointDesc
@@ -807,17 +807,17 @@ struct UsdPhysicsRevoluteJointDesc : public UsdPhysicsJointDesc
 ///
 struct UsdPhysicsDistanceJointDesc : public UsdPhysicsJointDesc
 {
-	UsdPhysicsDistanceJointDesc() : minEnabled(false), maxEnabled(false)
-	{
-		type = UsdPhysicsObjectType::eDistanceJoint;
-	}
-	bool operator == (const UsdPhysicsDistanceJointDesc&) const
-	{
-		return false;
-	}
-	bool minEnabled;    ///< Defines if minimum limit is enabled
-	bool maxEnabled;    ///< Defines if maximum limit is enabled
-	UsdPhysicsJointLimit limit;   ///< The distance limit
+    UsdPhysicsDistanceJointDesc() : minEnabled(false), maxEnabled(false)
+    {
+        type = UsdPhysicsObjectType::eDistanceJoint;
+    }
+    bool operator == (const UsdPhysicsDistanceJointDesc&) const
+    {
+        return false;
+    }
+    bool minEnabled;    ///< Defines if minimum limit is enabled
+    bool maxEnabled;    ///< Defines if maximum limit is enabled
+    UsdPhysicsJointLimit limit;   ///< The distance limit
 };
 
 
diff --git a/pxr/usd/usdPhysics/parsePrimIterator.h b/pxr/usd/usdPhysics/parsePrimIterator.h
index 80bfb8dec0..d74ac96d7a 100644
--- a/pxr/usd/usdPhysics/parsePrimIterator.h
+++ b/pxr/usd/usdPhysics/parsePrimIterator.h
@@ -30,24 +30,24 @@ using UsdPrimMap = std::map<const SdfPath, UsdPrim>;
 class ParsePrimIteratorBase
 {
 public:
-	virtual ~ParsePrimIteratorBase() = default;
+    virtual ~ParsePrimIteratorBase() = default;
 
-	/// Reset the iteration
-	virtual void reset() = 0;
+    /// Reset the iteration
+    virtual void reset() = 0;
 
-	/// Check if iterator is at the end
-	/// \return True if at the end
-	virtual bool atEnd() const = 0;
+    /// Check if iterator is at the end
+    /// \return True if at the end
+    virtual bool atEnd() const = 0;
 
-	/// Get current iterator
-	/// \return Current iterator
-	virtual UsdPrimRange::const_iterator getCurrent() = 0;
+    /// Get current iterator
+    /// \return Current iterator
+    virtual UsdPrimRange::const_iterator getCurrent() = 0;
 
-	/// Update iterator to next
-	virtual void next() = 0;
+    /// Update iterator to next
+    virtual void next() = 0;
 
-	/// Prune all children of the current iterator
-	virtual void pruneChildren() = 0;
+    /// Prune all children of the current iterator
+    virtual void pruneChildren() = 0;
 };
 
 /// \struct ParsePrimIteratorRange
@@ -57,43 +57,43 @@ class ParsePrimIteratorBase
 class ParsePrimIteratorRange : public ParsePrimIteratorBase
 {
 public:
-	ParsePrimIteratorRange(UsdPrimRange range) : mRange(range)
-	{
-		reset();
-	}
-
-	virtual void reset() override
-	{
-		mIter = mRange.begin();
-	}
-
-	virtual void pruneChildren() override
-	{
-		if (!atEnd())
-			mIter.PruneChildren();
-	}
-
-	virtual bool atEnd() const override
-	{
-		return mIter == mRange.end();
-	}
-
-	virtual UsdPrimRange::const_iterator getCurrent() override
-	{
-		return mIter;
-	}
-
-	virtual void next() override
-	{
-		if (mIter != mRange.end())
-		{
-			mIter++;
-		}
-	}
+    ParsePrimIteratorRange(UsdPrimRange range) : mRange(range)
+    {
+        reset();
+    }
+
+    virtual void reset() override
+    {
+        mIter = mRange.begin();
+    }
+
+    virtual void pruneChildren() override
+    {
+        if (!atEnd())
+            mIter.PruneChildren();
+    }
+
+    virtual bool atEnd() const override
+    {
+        return mIter == mRange.end();
+    }
+
+    virtual UsdPrimRange::const_iterator getCurrent() override
+    {
+        return mIter;
+    }
+
+    virtual void next() override
+    {
+        if (mIter != mRange.end())
+        {
+            mIter++;
+        }
+    }
 
 private:
-	UsdPrimRange mRange;
-	UsdPrimRange::const_iterator mIter;
+    UsdPrimRange mRange;
+    UsdPrimRange::const_iterator mIter;
 };
 
 /// \struct ParsePrimIteratorMapRange
@@ -104,153 +104,153 @@ class ParsePrimIteratorRange : public ParsePrimIteratorBase
 class ParsePrimIteratorMapRange : public ParsePrimIteratorBase
 {
 public:
-	ParsePrimIteratorMapRange(const UsdPrimMap& primMap) : mPrimMap(primMap)
-	{
-		reset();
-	}
-
-	virtual void reset() override
-	{
-		mAtEnd = true;
-
-		mPrimMapIter = mPrimMap.begin();
-
-		if (mPrimMapIter != mPrimMap.end())
-		{
-			mRange = UsdPrimRange(mPrimMapIter->second, UsdTraverseInstanceProxies());
-			if (mRange.begin() != mRange.end())
-			{
-				mIter = mRange.begin();
-				mAtEnd = false;
-			}
-		}
-	}
-
-	virtual bool atEnd() const override
-	{
-		return mAtEnd;
-	}
-
-	virtual void pruneChildren() override
-	{
-		if (!atEnd())
-			mIter.PruneChildren();
-	}
-
-	virtual UsdPrimRange::const_iterator getCurrent() override
-	{
-		return mIter;
-	}
-
-	virtual void next() override
-	{
-		if (mIter != mRange.end())
-		{
-			mIter++;
-
-			if (mIter == mRange.end())
-			{
-				mPrimMapIter++;
-
-				if (mPrimMapIter == mPrimMap.end())
-				{
-					mAtEnd = true;
-				}
-				else
-				{
-					mRange = UsdPrimRange(mPrimMapIter->second);
-					mIter = mRange.begin();
-				}
-			}
-		}
-	}
+    ParsePrimIteratorMapRange(const UsdPrimMap& primMap) : mPrimMap(primMap)
+    {
+        reset();
+    }
+
+    virtual void reset() override
+    {
+        mAtEnd = true;
+
+        mPrimMapIter = mPrimMap.begin();
+
+        if (mPrimMapIter != mPrimMap.end())
+        {
+            mRange = UsdPrimRange(mPrimMapIter->second, UsdTraverseInstanceProxies());
+            if (mRange.begin() != mRange.end())
+            {
+                mIter = mRange.begin();
+                mAtEnd = false;
+            }
+        }
+    }
+
+    virtual bool atEnd() const override
+    {
+        return mAtEnd;
+    }
+
+    virtual void pruneChildren() override
+    {
+        if (!atEnd())
+            mIter.PruneChildren();
+    }
+
+    virtual UsdPrimRange::const_iterator getCurrent() override
+    {
+        return mIter;
+    }
+
+    virtual void next() override
+    {
+        if (mIter != mRange.end())
+        {
+            mIter++;
+
+            if (mIter == mRange.end())
+            {
+                mPrimMapIter++;
+
+                if (mPrimMapIter == mPrimMap.end())
+                {
+                    mAtEnd = true;
+                }
+                else
+                {
+                    mRange = UsdPrimRange(mPrimMapIter->second);
+                    mIter = mRange.begin();
+                }
+            }
+        }
+    }
 
 private:
-	bool mAtEnd;
+    bool mAtEnd;
 
-	const UsdPrimMap& mPrimMap;
-	UsdPrimMap::const_iterator mPrimMapIter;
+    const UsdPrimMap& mPrimMap;
+    UsdPrimMap::const_iterator mPrimMapIter;
 
-	UsdPrimRange mRange;
-	UsdPrimRange::const_iterator mIter;
+    UsdPrimRange mRange;
+    UsdPrimRange::const_iterator mIter;
 };
 
 using ExcludePathsSet = std::unordered_set<SdfPath, SdfPath::Hash>;
 class ExcludeListPrimIteratorRange : public ParsePrimIteratorBase
 {
 public:
-	/// ExcludeListPrimIteratorRange constructor, this iterator
-	/// takes a regular range as input and exclude set for paths an
-	/// its descendants to get pruned. 
-	///
-	/// \param[in] range      UsdPrimRange to traverse
-	/// \param[in] pathList   Paths to get pruned
-	ExcludeListPrimIteratorRange(UsdPrimRange range, const SdfPathVector& pathList)
-		: mRange(range)
-	{
-		for (const SdfPath& path : pathList)
-		{
-			mPathSet.insert(path);
-		}
-		reset();
-	}
-
-	virtual void reset() override
-	{
-		mIter = mRange.begin();
-	}
-
-	virtual void pruneChildren() override
-	{
-		mIter.PruneChildren();
-	}
-
-	virtual bool atEnd() const override
-	{
-		return mIter == mRange.end();
-	}
-
-	virtual UsdPrimRange::const_iterator getCurrent() override
-	{
-		return mIter;
-	}
-
-	virtual void next() override
-	{
-		if (mIter != mRange.end())
-		{
-			bool validPrim = false;
-			while (!validPrim)
-			{
-				mIter++;
-				if (mIter != mRange.end())
-				{
-					const UsdPrim& prim = *mIter;
-					if (prim)
-					{
-						ExcludePathsSet::const_iterator fit = mPathSet.find(prim.GetPrimPath());
-						if (fit != mPathSet.end())
-						{
-							mIter.PruneChildren();
-						}
-						else
-						{
-							validPrim = true;
-						}
-					}
-				}
-				else
-				{
-					validPrim = true;
-				}
-			}
-		}
-	}
+    /// ExcludeListPrimIteratorRange constructor, this iterator
+    /// takes a regular range as input and exclude set for paths an
+    /// its descendants to get pruned. 
+    ///
+    /// \param[in] range      UsdPrimRange to traverse
+    /// \param[in] pathList   Paths to get pruned
+    ExcludeListPrimIteratorRange(UsdPrimRange range, const SdfPathVector& pathList)
+        : mRange(range)
+    {
+        for (const SdfPath& path : pathList)
+        {
+            mPathSet.insert(path);
+        }
+        reset();
+    }
+
+    virtual void reset() override
+    {
+        mIter = mRange.begin();
+    }
+
+    virtual void pruneChildren() override
+    {
+        mIter.PruneChildren();
+    }
+
+    virtual bool atEnd() const override
+    {
+        return mIter == mRange.end();
+    }
+
+    virtual UsdPrimRange::const_iterator getCurrent() override
+    {
+        return mIter;
+    }
+
+    virtual void next() override
+    {
+        if (mIter != mRange.end())
+        {
+            bool validPrim = false;
+            while (!validPrim)
+            {
+                mIter++;
+                if (mIter != mRange.end())
+                {
+                    const UsdPrim& prim = *mIter;
+                    if (prim)
+                    {
+                        ExcludePathsSet::const_iterator fit = mPathSet.find(prim.GetPrimPath());
+                        if (fit != mPathSet.end())
+                        {
+                            mIter.PruneChildren();
+                        }
+                        else
+                        {
+                            validPrim = true;
+                        }
+                    }
+                }
+                else
+                {
+                    validPrim = true;
+                }
+            }
+        }
+    }
 
 private:
-	UsdPrimRange mRange;
-	UsdPrimRange::const_iterator mIter;
-	ExcludePathsSet mPathSet;
+    UsdPrimRange mRange;
+    UsdPrimRange::const_iterator mIter;
+    ExcludePathsSet mPathSet;
 };
 
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/usd/usdPhysics/parseUtils.cpp b/pxr/usd/usdPhysics/parseUtils.cpp
index bb0ae9fc5e..eb0e3eb100 100644
--- a/pxr/usd/usdPhysics/parseUtils.cpp
+++ b/pxr/usd/usdPhysics/parseUtils.cpp
@@ -54,1639 +54,1639 @@
 
 PXR_NAMESPACE_OPEN_SCOPE
 
-void ParseFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
+void ParseFilteredPairs(const UsdPrim& usdPrim, SdfPathVector& filteredPairs)
 {
-	UsdPhysicsFilteredPairsAPI filteredPairsAPI =
-		UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
-	if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
-	{
-		filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
-	}
+    UsdPhysicsFilteredPairsAPI filteredPairsAPI =
+        UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
+    if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
+    {
+        filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
+    }
 }
 
 bool ParseArticulationDesc(const UsdPhysicsArticulationRootAPI& articulationAPI,
-	UsdPhysicsArticulationDesc* articulationDesc)
+    UsdPhysicsArticulationDesc* articulationDesc)
 {
-	if (articulationDesc && articulationAPI)
-	{
-		ParseFilteredPairs(articulationAPI.GetPrim(), articulationDesc->filteredCollisions);
-
-		articulationDesc->primPath = articulationAPI.GetPrim().GetPrimPath();
-	}
-	else
-	{
-		TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or UsdPhysicsArticulationDesc is not valid.");
-		return false;
-	}
-	return true;
+    if (articulationDesc && articulationAPI)
+    {
+        ParseFilteredPairs(articulationAPI.GetPrim(), articulationDesc->filteredCollisions);
+
+        articulationDesc->primPath = articulationAPI.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsArticulationRootAPI or UsdPhysicsArticulationDesc is not valid.");
+        return false;
+    }
+    return true;
 }
 
 UsdPhysicsObjectType::Enum GetCollisionType(const UsdPrim& prim,
-	const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
+    const std::vector<TfToken>* customTokens, TfToken* customeGeometryToken)
 {
-	UsdPhysicsObjectType::Enum retVal = UsdPhysicsObjectType::eUndefined;
-
-	// custom shape handling
-	if (customTokens)
-	{
-		const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
-
-		const TfToken& primType = prim.GetTypeName();
-		for (size_t i = 0; i < customTokens->size(); i++)
-		{
-			for (size_t j = 0; j < apis.size(); j++)
-			{
-				if (apis[j] == (*customTokens)[i])
-				{
-					retVal = UsdPhysicsObjectType::eCustomShape;
-					if (customeGeometryToken)
-						*customeGeometryToken = apis[j];
-					break;
-				}
-			}
-			if (retVal == UsdPhysicsObjectType::eCustomShape)
-			{
-				break;
-			}
-			if (primType == (*customTokens)[i])
-			{
-				retVal = UsdPhysicsObjectType::eCustomShape;
-				if (customeGeometryToken)
-					*customeGeometryToken = primType;
-				break;
-			}
-		}
-	}
-
-	if (retVal == UsdPhysicsObjectType::eCustomShape)
-		return retVal;
-
-	// geomgprim that belongs to that collision
-	if (prim.IsA<UsdGeomGprim>())
-	{
-		// If the primitive is a UsdGeomPoints *and* it has a widths attribute
-		// corresponding to the positions attribute, then we treat it as an
-		// array of spheres corresponding to the 'UsdPhysicsSpherePointsShapeDesc'
-		if (prim.IsA<UsdGeomMesh>())
-		{
-			retVal = UsdPhysicsObjectType::eMeshShape;
-		}
-		else if (prim.IsA<UsdGeomCube>())
-		{
-			retVal = UsdPhysicsObjectType::eCubeShape;
-		}
-		else if (prim.IsA<UsdGeomSphere>())
-		{
-			retVal = UsdPhysicsObjectType::eSphereShape;
-		}
-		else if (prim.IsA<UsdGeomCapsule>())
-		{
-			retVal = UsdPhysicsObjectType::eCapsuleShape;
-		}
-		else if (prim.IsA<UsdGeomCylinder>())
-		{
-			retVal = UsdPhysicsObjectType::eCylinderShape;
-		}
-		else if (prim.IsA<UsdGeomCone>())
-		{
-			retVal = UsdPhysicsObjectType::eConeShape;
-		}
-		else if (prim.IsA<UsdGeomPlane>())
-		{
-			retVal = UsdPhysicsObjectType::ePlaneShape;
-		}
-		else if (prim.IsA<UsdGeomPoints>())
-		{
-			retVal = UsdPhysicsObjectType::eSpherePointsShape;
-		}
-	}
-
-	return retVal;
+    UsdPhysicsObjectType::Enum retVal = UsdPhysicsObjectType::eUndefined;
+
+    // custom shape handling
+    if (customTokens)
+    {
+        const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
+
+        const TfToken& primType = prim.GetTypeName();
+        for (size_t i = 0; i < customTokens->size(); i++)
+        {
+            for (size_t j = 0; j < apis.size(); j++)
+            {
+                if (apis[j] == (*customTokens)[i])
+                {
+                    retVal = UsdPhysicsObjectType::eCustomShape;
+                    if (customeGeometryToken)
+                        *customeGeometryToken = apis[j];
+                    break;
+                }
+            }
+            if (retVal == UsdPhysicsObjectType::eCustomShape)
+            {
+                break;
+            }
+            if (primType == (*customTokens)[i])
+            {
+                retVal = UsdPhysicsObjectType::eCustomShape;
+                if (customeGeometryToken)
+                    *customeGeometryToken = primType;
+                break;
+            }
+        }
+    }
+
+    if (retVal == UsdPhysicsObjectType::eCustomShape)
+        return retVal;
+
+    // geomgprim that belongs to that collision
+    if (prim.IsA<UsdGeomGprim>())
+    {
+        // If the primitive is a UsdGeomPoints *and* it has a widths attribute
+        // corresponding to the positions attribute, then we treat it as an
+        // array of spheres corresponding to the 'UsdPhysicsSpherePointsShapeDesc'
+        if (prim.IsA<UsdGeomMesh>())
+        {
+            retVal = UsdPhysicsObjectType::eMeshShape;
+        }
+        else if (prim.IsA<UsdGeomCube>())
+        {
+            retVal = UsdPhysicsObjectType::eCubeShape;
+        }
+        else if (prim.IsA<UsdGeomSphere>())
+        {
+            retVal = UsdPhysicsObjectType::eSphereShape;
+        }
+        else if (prim.IsA<UsdGeomCapsule>())
+        {
+            retVal = UsdPhysicsObjectType::eCapsuleShape;
+        }
+        else if (prim.IsA<UsdGeomCylinder>())
+        {
+            retVal = UsdPhysicsObjectType::eCylinderShape;
+        }
+        else if (prim.IsA<UsdGeomCone>())
+        {
+            retVal = UsdPhysicsObjectType::eConeShape;
+        }
+        else if (prim.IsA<UsdGeomPlane>())
+        {
+            retVal = UsdPhysicsObjectType::ePlaneShape;
+        }
+        else if (prim.IsA<UsdGeomPoints>())
+        {
+            retVal = UsdPhysicsObjectType::eSpherePointsShape;
+        }
+    }
+
+    return retVal;
 }
 
 const double tolerance = 1e-4;
 
 void CheckNonUniformScale(const GfVec3d& scale, const SdfPath& primPath)
 {
-	if (abs(scale[0] - scale[1]) > tolerance || abs(scale[0] - scale[2]) > tolerance ||
-		abs(scale[2] - scale[1]) > tolerance)
-	{
-		TF_DIAGNOSTIC_WARNING(
-			"Non-uniform scale may result in a non matching collision representation on prim : %s", primPath.GetText());
-	}
+    if (abs(scale[0] - scale[1]) > tolerance || abs(scale[0] - scale[2]) > tolerance ||
+        abs(scale[2] - scale[1]) > tolerance)
+    {
+        TF_DIAGNOSTIC_WARNING(
+            "Non-uniform scale may result in a non matching collision representation on prim : %s", primPath.GetText());
+    }
 }
 
 
-pxr::SdfPath GetMaterialBinding(const pxr::UsdPrim& usdPrim)
+SdfPath GetMaterialBinding(const UsdPrim& usdPrim)
 {
-	SdfPath materialPath = SdfPath();
-
-	const static TfToken physicsPurpose("physics");
-	UsdShadeMaterialBindingAPI materialBindingAPI = UsdShadeMaterialBindingAPI(usdPrim);
-	if (materialBindingAPI)
-	{
-		UsdShadeMaterial material = materialBindingAPI.ComputeBoundMaterial(physicsPurpose);
-		if (material)
-		{
-			materialPath = material.GetPrim().GetPrimPath();
-		}
-	}
-	else
-	{
-		// handle material through a direct binding rel search
-		std::vector<UsdPrim> prims;
-		prims.push_back(usdPrim);
-		std::vector<UsdShadeMaterial> materials =
-			UsdShadeMaterialBindingAPI::ComputeBoundMaterials(prims, physicsPurpose);
-		if (!materials.empty() && materials[0])
-		{
-			materialPath = materials[0].GetPrim().GetPrimPath();
-		}
-	}
-
-	return materialPath;
+    SdfPath materialPath = SdfPath();
+
+    const static TfToken physicsPurpose("physics");
+    UsdShadeMaterialBindingAPI materialBindingAPI = UsdShadeMaterialBindingAPI(usdPrim);
+    if (materialBindingAPI)
+    {
+        UsdShadeMaterial material = materialBindingAPI.ComputeBoundMaterial(physicsPurpose);
+        if (material)
+        {
+            materialPath = material.GetPrim().GetPrimPath();
+        }
+    }
+    else
+    {
+        // handle material through a direct binding rel search
+        std::vector<UsdPrim> prims;
+        prims.push_back(usdPrim);
+        std::vector<UsdShadeMaterial> materials =
+            UsdShadeMaterialBindingAPI::ComputeBoundMaterials(prims, physicsPurpose);
+        if (!materials.empty() && materials[0])
+        {
+            materialPath = materials[0].GetPrim().GetPrimPath();
+        }
+    }
+
+    return materialPath;
 }
 
-static void ParseColFilteredPairs(const pxr::UsdPrim& usdPrim, pxr::SdfPathVector& filteredPairs)
+static void ParseColFilteredPairs(const UsdPrim& usdPrim, SdfPathVector& filteredPairs)
 {
-	UsdPhysicsFilteredPairsAPI filteredPairsAPI =
-		UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
-	if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
-	{
-		filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
-	}
+    UsdPhysicsFilteredPairsAPI filteredPairsAPI =
+        UsdPhysicsFilteredPairsAPI::Get(usdPrim.GetStage(), usdPrim.GetPrimPath());
+    if (filteredPairsAPI && filteredPairsAPI.GetFilteredPairsRel())
+    {
+        filteredPairsAPI.GetFilteredPairsRel().GetTargets(&filteredPairs);
+    }
 }
 
 void FinalizeDesc(const UsdPhysicsCollisionAPI& colAPI, UsdPhysicsShapeDesc& desc)
 {
-	// set the collider material as last
-	// set SdfPath() anyway, this would indicate default material should be used, 
-	// this is required for trimesh subset materials
-	// as not alway all faces are covered with a subset material
-	const SdfPath& materialPath = GetMaterialBinding(colAPI.GetPrim());
-	if (materialPath != SdfPath())
-	{
-		const UsdPrim materialPrim = colAPI.GetPrim().GetStage()->GetPrimAtPath(materialPath);
-		if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
-			desc.materials.push_back(materialPath);
-		else
-			desc.materials.push_back(SdfPath());
-	}
-	else
-	{
-		desc.materials.push_back(SdfPath());
-	}
-
-	ParseColFilteredPairs(colAPI.GetPrim(), desc.filteredCollisions);
-	colAPI.GetCollisionEnabledAttr().Get(&desc.collisionEnabled);
-	const UsdRelationship ownerRel = colAPI.GetSimulationOwnerRel();
-	if (ownerRel)
-	{
-		ownerRel.GetTargets(&desc.simulationOwners);
-	}
+    // set the collider material as last
+    // set SdfPath() anyway, this would indicate default material should be used, 
+    // this is required for trimesh subset materials
+    // as not alway all faces are covered with a subset material
+    const SdfPath& materialPath = GetMaterialBinding(colAPI.GetPrim());
+    if (materialPath != SdfPath())
+    {
+        const UsdPrim materialPrim = colAPI.GetPrim().GetStage()->GetPrimAtPath(materialPath);
+        if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
+            desc.materials.push_back(materialPath);
+        else
+            desc.materials.push_back(SdfPath());
+    }
+    else
+    {
+        desc.materials.push_back(SdfPath());
+    }
+
+    ParseColFilteredPairs(colAPI.GetPrim(), desc.filteredCollisions);
+    colAPI.GetCollisionEnabledAttr().Get(&desc.collisionEnabled);
+    const UsdRelationship ownerRel = colAPI.GetSimulationOwnerRel();
+    if (ownerRel)
+    {
+        ownerRel.GetTargets(&desc.simulationOwners);
+    }
 }
 
 
 bool ParseSphereShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsSphereShapeDesc* sphereShapeDesc)
+    UsdPhysicsSphereShapeDesc* sphereShapeDesc)
 {
-	if (sphereShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomSphere shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			float radius = 1.0f;
-
-			// Check scale, its part of the collision size
-			{
-				const pxr::GfVec3d sc = tr.GetScale();
-				// as we dont support scale in physics and scale can be non uniform
-				// we pick the largest scale value as the sphere radius base
-				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-				radius = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))),
-					fabsf(float(sc[2])));
-			}
-
-			// Get shape parameters
-			{
-
-				double radiusAttr;
-				shape.GetRadiusAttr().Get(&radiusAttr);
-				radius *= (float)radiusAttr;
-			}
-
-			sphereShapeDesc->radius = fabsf(radius);
-			sphereShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *sphereShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomSphere.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsSphereShapeDesc is not valid.");
-		return false;
-	}
-	return true;
+    if (sphereShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomSphere shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+
+            // Check scale, its part of the collision size
+            {
+                const GfVec3d sc = tr.GetScale();
+                // as we dont support scale in physics and scale can be non uniform
+                // we pick the largest scale value as the sphere radius base
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                radius = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))),
+                    fabsf(float(sc[2])));
+            }
+
+            // Get shape parameters
+            {
+
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                radius *= (float)radiusAttr;
+            }
+
+            sphereShapeDesc->radius = fabsf(radius);
+            sphereShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *sphereShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomSphere.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsSphereShapeDesc is not valid.");
+        return false;
+    }
+    return true;
 }
 
 bool ParseCubeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsCubeShapeDesc* cubeShapeDesc)
+    UsdPhysicsCubeShapeDesc* cubeShapeDesc)
 {
-	if (cubeShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomCube shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			GfVec3f halfExtents;
-
-			// Add scale
-			{
-				const pxr::GfVec3d sc = tr.GetScale();
-				// scale is taken, its a part of the cube size, as the physics 
-				// does not support scale
-				halfExtents = GfVec3f(sc);
-			}
-
-			// Get shape parameters
-			{
-				UsdGeomCube shape(usdPrim);
-				double sizeAttr;
-				shape.GetSizeAttr().Get(&sizeAttr);
-				// convert cube edge length to half extend
-				sizeAttr = abs(sizeAttr) * 0.5f;
-				halfExtents *= (float)sizeAttr;
-			}
-
-			cubeShapeDesc->halfExtents = halfExtents;
-			cubeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *cubeShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCube.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCubeShapeDesc is not valid.");
-		return false;
-
-	}
-	return true;
+    if (cubeShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCube shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            GfVec3f halfExtents;
+
+            // Add scale
+            {
+                const GfVec3d sc = tr.GetScale();
+                // scale is taken, its a part of the cube size, as the physics 
+                // does not support scale
+                halfExtents = GfVec3f(sc);
+            }
+
+            // Get shape parameters
+            {
+                UsdGeomCube shape(usdPrim);
+                double sizeAttr;
+                shape.GetSizeAttr().Get(&sizeAttr);
+                // convert cube edge length to half extend
+                sizeAttr = abs(sizeAttr) * 0.5f;
+                halfExtents *= (float)sizeAttr;
+            }
+
+            cubeShapeDesc->halfExtents = halfExtents;
+            cubeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *cubeShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCube.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsCubeShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
 }
 
 bool ParseCylinderShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsCylinderShapeDesc* cylinderShapeDesc)
+    UsdPhysicsCylinderShapeDesc* cylinderShapeDesc)
 {
-	if (cylinderShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomCylinder shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			float radius = 1.0f;
-			float halfHeight = 1.0f;
-			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-			// Get shape parameters
-			{
-				double radiusAttr;
-				shape.GetRadiusAttr().Get(&radiusAttr);
-				double heightAttr;
-				shape.GetHeightAttr().Get(&heightAttr);
-				radius = (float)radiusAttr;
-				halfHeight = (float)heightAttr * 0.5f;
-
-				TfToken capAxis;
-				if (shape.GetAxisAttr())
-				{
-					shape.GetAxisAttr().Get(&capAxis);
-					if (capAxis == UsdPhysicsTokens.Get()->y)
-						axis = UsdPhysicsAxis::eY;
-					else if (capAxis == UsdPhysicsTokens.Get()->z)
-						axis = UsdPhysicsAxis::eZ;
-				}
-			}
-
-			{
-				// scale the radius and height based on the given axis token
-				const pxr::GfVec3d sc = tr.GetScale();
-				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-				if (axis == UsdPhysicsAxis::eX)
-				{
-					halfHeight *= float(sc[0]);
-					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
-				}
-				else if (axis == UsdPhysicsAxis::eY)
-				{
-					halfHeight *= float(sc[1]);
-					radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
-				}
-				else
-				{
-					halfHeight *= float(sc[2]);
-					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
-				}
-			}
-			cylinderShapeDesc->radius = fabsf(radius);
-			cylinderShapeDesc->axis = axis;
-			cylinderShapeDesc->halfHeight = fabsf(halfHeight);
-			cylinderShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *cylinderShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCylinder.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCylinderShapeDesc is not valid.");
-		return false;
-
-	}
-	return true;
+    if (cylinderShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCylinder shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+            float halfHeight = 1.0f;
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
+
+            // Get shape parameters
+            {
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                double heightAttr;
+                shape.GetHeightAttr().Get(&heightAttr);
+                radius = (float)radiusAttr;
+                halfHeight = (float)heightAttr * 0.5f;
+
+                TfToken capAxis;
+                if (shape.GetAxisAttr())
+                {
+                    shape.GetAxisAttr().Get(&capAxis);
+                    if (capAxis == UsdPhysicsTokens.Get()->y)
+                        axis = UsdPhysicsAxis::eY;
+                    else if (capAxis == UsdPhysicsTokens.Get()->z)
+                        axis = UsdPhysicsAxis::eZ;
+                }
+            }
+
+            {
+                // scale the radius and height based on the given axis token
+                const GfVec3d sc = tr.GetScale();
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                if (axis == UsdPhysicsAxis::eX)
+                {
+                    halfHeight *= float(sc[0]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+                }
+                else if (axis == UsdPhysicsAxis::eY)
+                {
+                    halfHeight *= float(sc[1]);
+                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+                }
+                else
+                {
+                    halfHeight *= float(sc[2]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+                }
+            }
+            cylinderShapeDesc->radius = fabsf(radius);
+            cylinderShapeDesc->axis = axis;
+            cylinderShapeDesc->halfHeight = fabsf(halfHeight);
+            cylinderShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *cylinderShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCylinder.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsCylinderShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
 }
 
 bool ParseCapsuleShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsCapsuleShapeDesc* capsuleShapeDesc)
+    UsdPhysicsCapsuleShapeDesc* capsuleShapeDesc)
 {
-	if (capsuleShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomCapsule shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			float radius = 1.0f;
-			float halfHeight = 1.0f;
-			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-			// Get shape parameters
-			{
-				double radiusAttr;
-				shape.GetRadiusAttr().Get(&radiusAttr);
-				double heightAttr;
-				shape.GetHeightAttr().Get(&heightAttr);
-				radius = (float)radiusAttr;
-				halfHeight = (float)heightAttr * 0.5f;
-
-				TfToken capAxis;
-				if (shape.GetAxisAttr())
-				{
-					shape.GetAxisAttr().Get(&capAxis);
-					if (capAxis == UsdPhysicsTokens.Get()->y)
-						axis = UsdPhysicsAxis::eY;
-					else if (capAxis == UsdPhysicsTokens.Get()->z)
-						axis = UsdPhysicsAxis::eZ;
-				}
-			}
-
-			{
-				// scale the radius and height based on the given axis token
-				const pxr::GfVec3d sc = tr.GetScale();
-				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-				if (axis == UsdPhysicsAxis::eX)
-				{
-					halfHeight *= float(sc[0]);
-					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
-				}
-				else if (axis == UsdPhysicsAxis::eY)
-				{
-					halfHeight *= float(sc[1]);
-					radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
-				}
-				else
-				{
-					halfHeight *= float(sc[2]);
-					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
-				}
-			}
-			capsuleShapeDesc->radius = fabsf(radius);
-			capsuleShapeDesc->axis = axis;
-			capsuleShapeDesc->halfHeight = fabsf(halfHeight);
-			capsuleShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *capsuleShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCapsule.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCapsuleShapeDesc is not valid.");
-		return false;
-
-	}
-	return true;
+    if (capsuleShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCapsule shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+            float halfHeight = 1.0f;
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
+
+            // Get shape parameters
+            {
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                double heightAttr;
+                shape.GetHeightAttr().Get(&heightAttr);
+                radius = (float)radiusAttr;
+                halfHeight = (float)heightAttr * 0.5f;
+
+                TfToken capAxis;
+                if (shape.GetAxisAttr())
+                {
+                    shape.GetAxisAttr().Get(&capAxis);
+                    if (capAxis == UsdPhysicsTokens.Get()->y)
+                        axis = UsdPhysicsAxis::eY;
+                    else if (capAxis == UsdPhysicsTokens.Get()->z)
+                        axis = UsdPhysicsAxis::eZ;
+                }
+            }
+
+            {
+                // scale the radius and height based on the given axis token
+                const GfVec3d sc = tr.GetScale();
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                if (axis == UsdPhysicsAxis::eX)
+                {
+                    halfHeight *= float(sc[0]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+                }
+                else if (axis == UsdPhysicsAxis::eY)
+                {
+                    halfHeight *= float(sc[1]);
+                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+                }
+                else
+                {
+                    halfHeight *= float(sc[2]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+                }
+            }
+            capsuleShapeDesc->radius = fabsf(radius);
+            capsuleShapeDesc->axis = axis;
+            capsuleShapeDesc->halfHeight = fabsf(halfHeight);
+            capsuleShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *capsuleShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCapsule.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsCapsuleShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
 }
 
 bool ParseConeShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsConeShapeDesc* coneShapeDesc)
+    UsdPhysicsConeShapeDesc* coneShapeDesc)
 {
-	if (coneShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomCone shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			float radius = 1.0f;
-			float halfHeight = 1.0f;
-			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-			// Get shape parameters
-			{
-				double radiusAttr;
-				shape.GetRadiusAttr().Get(&radiusAttr);
-				double heightAttr;
-				shape.GetHeightAttr().Get(&heightAttr);
-				radius = (float)radiusAttr;
-				halfHeight = (float)heightAttr * 0.5f;
-
-				TfToken capAxis;
-				if (shape.GetAxisAttr())
-				{
-					shape.GetAxisAttr().Get(&capAxis);
-					if (capAxis == UsdPhysicsTokens.Get()->y)
-						axis = UsdPhysicsAxis::eY;
-					else if (capAxis == UsdPhysicsTokens.Get()->z)
-						axis = UsdPhysicsAxis::eZ;
-				}
-			}
-
-			{
-				// scale the radius and height based on the given axis token
-				const pxr::GfVec3d sc = tr.GetScale();
-				CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-				if (axis == UsdPhysicsAxis::eX)
-				{
-					halfHeight *= float(sc[0]);
-					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
-				}
-				else if (axis == UsdPhysicsAxis::eY)
-				{
-					halfHeight *= float(sc[1]);
-					radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
-				}
-				else
-				{
-					halfHeight *= float(sc[2]);
-					radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
-				}
-			}
-			coneShapeDesc->radius = fabsf(radius);
-			coneShapeDesc->axis = axis;
-			coneShapeDesc->halfHeight = fabsf(halfHeight);
-			coneShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *coneShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCone.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsConeShapeDesc is not valid.");
-		return false;
-
-	}
-	return true;
+    if (coneShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomCone shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            float radius = 1.0f;
+            float halfHeight = 1.0f;
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
+
+            // Get shape parameters
+            {
+                double radiusAttr;
+                shape.GetRadiusAttr().Get(&radiusAttr);
+                double heightAttr;
+                shape.GetHeightAttr().Get(&heightAttr);
+                radius = (float)radiusAttr;
+                halfHeight = (float)heightAttr * 0.5f;
+
+                TfToken capAxis;
+                if (shape.GetAxisAttr())
+                {
+                    shape.GetAxisAttr().Get(&capAxis);
+                    if (capAxis == UsdPhysicsTokens.Get()->y)
+                        axis = UsdPhysicsAxis::eY;
+                    else if (capAxis == UsdPhysicsTokens.Get()->z)
+                        axis = UsdPhysicsAxis::eZ;
+                }
+            }
+
+            {
+                // scale the radius and height based on the given axis token
+                const GfVec3d sc = tr.GetScale();
+                CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                if (axis == UsdPhysicsAxis::eX)
+                {
+                    halfHeight *= float(sc[0]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[2])));
+                }
+                else if (axis == UsdPhysicsAxis::eY)
+                {
+                    halfHeight *= float(sc[1]);
+                    radius *= fmaxf(fabsf(float(sc[0])), fabsf(float(sc[2])));
+                }
+                else
+                {
+                    halfHeight *= float(sc[2]);
+                    radius *= fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0])));
+                }
+            }
+            coneShapeDesc->radius = fabsf(radius);
+            coneShapeDesc->axis = axis;
+            coneShapeDesc->halfHeight = fabsf(halfHeight);
+            coneShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *coneShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomCone.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsConeShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
 }
 
 bool ParseMeshShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsMeshShapeDesc* meshShapeDesc)
+    UsdPhysicsMeshShapeDesc* meshShapeDesc)
 {
-	if (meshShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomMesh shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			const pxr::GfVec3d sc = tr.GetScale();
-			meshShapeDesc->meshScale = GfVec3f(sc);
-
-			// Get approximation type
-			meshShapeDesc->approximation = UsdPhysicsTokens.Get()->none;
-			UsdPhysicsMeshCollisionAPI physicsColMeshAPI(usdPrim);
-			if (physicsColMeshAPI)
-			{
-				physicsColMeshAPI.GetApproximationAttr().Get(&meshShapeDesc->approximation);
-			}
-
-			shape.GetDoubleSidedAttr().Get(&meshShapeDesc->doubleSided);
-
-			// Gather materials through subsets
-			const std::vector<pxr::UsdGeomSubset> subsets =
-				pxr::UsdGeomSubset::GetGeomSubsets(shape, pxr::UsdGeomTokens->face);
-			if (!subsets.empty())
-			{
-				for (const pxr::UsdGeomSubset& subset : subsets)
-				{
-					const pxr::SdfPath material = GetMaterialBinding(subset.GetPrim());
-					if (material != SdfPath())
-					{
-						const UsdPrim materialPrim = usdPrim.GetStage()->GetPrimAtPath(material);
-						if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
-						{
-							meshShapeDesc->materials.push_back(material);
-						}
-					}
-				}
-			}
-
-			meshShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *meshShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomMesh.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsMeshShapeDesc is not valid.");
-		return false;
-
-	}
-	return true;
+    if (meshShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomMesh shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            const GfVec3d sc = tr.GetScale();
+            meshShapeDesc->meshScale = GfVec3f(sc);
+
+            // Get approximation type
+            meshShapeDesc->approximation = UsdPhysicsTokens.Get()->none;
+            UsdPhysicsMeshCollisionAPI physicsColMeshAPI(usdPrim);
+            if (physicsColMeshAPI)
+            {
+                physicsColMeshAPI.GetApproximationAttr().Get(&meshShapeDesc->approximation);
+            }
+
+            shape.GetDoubleSidedAttr().Get(&meshShapeDesc->doubleSided);
+
+            // Gather materials through subsets
+            const std::vector<UsdGeomSubset> subsets =
+                UsdGeomSubset::GetGeomSubsets(shape, UsdGeomTokens->face);
+            if (!subsets.empty())
+            {
+                for (const UsdGeomSubset& subset : subsets)
+                {
+                    const SdfPath material = GetMaterialBinding(subset.GetPrim());
+                    if (material != SdfPath())
+                    {
+                        const UsdPrim materialPrim = usdPrim.GetStage()->GetPrimAtPath(material);
+                        if (materialPrim && materialPrim.HasAPI<UsdPhysicsMaterialAPI>())
+                        {
+                            meshShapeDesc->materials.push_back(material);
+                        }
+                    }
+                }
+            }
+
+            meshShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *meshShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomMesh.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsMeshShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
 }
 
 bool ParsePlaneShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsPlaneShapeDesc* planeShapeDesc)
+    UsdPhysicsPlaneShapeDesc* planeShapeDesc)
 {
-	if (planeShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomPlane shape(usdPrim);
-		if (shape)
-		{
-			UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
-
-			TfToken tfAxis;
-			shape.GetAxisAttr().Get(&tfAxis);
-			if (tfAxis == UsdPhysicsTokens.Get()->y)
-			{
-				axis = UsdPhysicsAxis::eY;
-			}
-			else if (tfAxis == UsdPhysicsTokens.Get()->z)
-			{
-				axis = UsdPhysicsAxis::eZ;
-			}
-
-			planeShapeDesc->axis = axis;
-			planeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *planeShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPlane.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsPlaneShapeDesc is not valid.");
-		return false;
-
-	}
-	return true;
+    if (planeShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomPlane shape(usdPrim);
+        if (shape)
+        {
+            UsdPhysicsAxis::Enum axis = UsdPhysicsAxis::eX;
+
+            TfToken tfAxis;
+            shape.GetAxisAttr().Get(&tfAxis);
+            if (tfAxis == UsdPhysicsTokens.Get()->y)
+            {
+                axis = UsdPhysicsAxis::eY;
+            }
+            else if (tfAxis == UsdPhysicsTokens.Get()->z)
+            {
+                axis = UsdPhysicsAxis::eZ;
+            }
+
+            planeShapeDesc->axis = axis;
+            planeShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *planeShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPlane.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsPlaneShapeDesc is not valid.");
+        return false;
+
+    }
+    return true;
 }
 
 bool ParseSpherePointsShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsSpherePointsShapeDesc* spherePointsShapeDesc)
+    UsdPhysicsSpherePointsShapeDesc* spherePointsShapeDesc)
 {
-	if (spherePointsShapeDesc && collisionAPI)
-	{
-		const UsdPrim usdPrim = collisionAPI.GetPrim();
-		const UsdGeomPoints shape(usdPrim);
-		if (shape)
-		{
-			const pxr::GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
-
-			VtArray<float> widths;
-			VtArray<GfVec3f> positions;
-			shape.GetWidthsAttr().Get(&widths);
-			if (widths.size())
-			{
-				shape.GetPointsAttr().Get(&positions);
-				if (positions.size() == widths.size())
-				{
-					float sphereScale = 1.0f;
-					{
-						const pxr::GfVec3d sc = tr.GetScale();
-
-						// as we don't support scale in physics and scale can be non uniform
-						// we pick the largest scale value as the sphere radius base
-						CheckNonUniformScale(sc, usdPrim.GetPrimPath());
-						sphereScale = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))),
-							fabsf(float(sc[2])));
-					}
-
-					const size_t scount = positions.size();
-					spherePointsShapeDesc->spherePoints.resize(scount);
-					for (size_t i = 0; i < scount; i++)
-					{
-						spherePointsShapeDesc->spherePoints[i].radius =
-							sphereScale * widths[i] * 0.5f;
-						spherePointsShapeDesc->spherePoints[i].center = positions[i];
-					}
-				}
-				else
-				{
-					TF_DIAGNOSTIC_WARNING(
-						"UsdGeomPoints width array size does not match position array size: %s",
-						usdPrim.GetPrimPath().GetText());
-					spherePointsShapeDesc->isValid = false;
-				}
-			}
-			else
-			{
-				TF_DIAGNOSTIC_WARNING(
-					"UsdGeomPoints width array not filled: %s",
-					usdPrim.GetPrimPath().GetText());
-				spherePointsShapeDesc->isValid = false;
-			}
-
-			spherePointsShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-			FinalizeDesc(collisionAPI, *spherePointsShapeDesc);
-		}
-		else
-		{
-			TF_RUNTIME_ERROR(
-				"Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPoints.");
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsSpherePointsShapeDesc is not valid.");
-		return false;
-	}
-	return true;
+    if (spherePointsShapeDesc && collisionAPI)
+    {
+        const UsdPrim usdPrim = collisionAPI.GetPrim();
+        const UsdGeomPoints shape(usdPrim);
+        if (shape)
+        {
+            const GfTransform tr(shape.ComputeLocalToWorldTransform(UsdTimeCode::Default()));
+
+            VtArray<float> widths;
+            VtArray<GfVec3f> positions;
+            shape.GetWidthsAttr().Get(&widths);
+            if (widths.size())
+            {
+                shape.GetPointsAttr().Get(&positions);
+                if (positions.size() == widths.size())
+                {
+                    float sphereScale = 1.0f;
+                    {
+                        const GfVec3d sc = tr.GetScale();
+
+                        // as we don't support scale in physics and scale can be non uniform
+                        // we pick the largest scale value as the sphere radius base
+                        CheckNonUniformScale(sc, usdPrim.GetPrimPath());
+                        sphereScale = fmaxf(fmaxf(fabsf(float(sc[1])), fabsf(float(sc[0]))),
+                            fabsf(float(sc[2])));
+                    }
+
+                    const size_t scount = positions.size();
+                    spherePointsShapeDesc->spherePoints.resize(scount);
+                    for (size_t i = 0; i < scount; i++)
+                    {
+                        spherePointsShapeDesc->spherePoints[i].radius =
+                            sphereScale * widths[i] * 0.5f;
+                        spherePointsShapeDesc->spherePoints[i].center = positions[i];
+                    }
+                }
+                else
+                {
+                    TF_DIAGNOSTIC_WARNING(
+                        "UsdGeomPoints width array size does not match position array size: %s",
+                        usdPrim.GetPrimPath().GetText());
+                    spherePointsShapeDesc->isValid = false;
+                }
+            }
+            else
+            {
+                TF_DIAGNOSTIC_WARNING(
+                    "UsdGeomPoints width array not filled: %s",
+                    usdPrim.GetPrimPath().GetText());
+                spherePointsShapeDesc->isValid = false;
+            }
+
+            spherePointsShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+            FinalizeDesc(collisionAPI, *spherePointsShapeDesc);
+        }
+        else
+        {
+            TF_RUNTIME_ERROR(
+                "Provided UsdPhysicsCollisionAPI is not applied to a UsdGeomPoints.");
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsSpherePointsShapeDesc is not valid.");
+        return false;
+    }
+    return true;
 }
 
 bool ParseCustomShapeDesc(const UsdPhysicsCollisionAPI& collisionAPI,
-	UsdPhysicsCustomShapeDesc* customShapeDesc)
+    UsdPhysicsCustomShapeDesc* customShapeDesc)
 {
-	if (customShapeDesc && collisionAPI)
-	{
-
-		customShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
-
-		FinalizeDesc(collisionAPI, *customShapeDesc);
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionAPI or UsdPhysicsCustomShapeDesc is not valid.");
-		return false;
-	}
-	return true;
+    if (customShapeDesc && collisionAPI)
+    {
+
+        customShapeDesc->primPath = collisionAPI.GetPrim().GetPrimPath();
+
+        FinalizeDesc(collisionAPI, *customShapeDesc);
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionAPI or UsdPhysicsCustomShapeDesc is not valid.");
+        return false;
+    }
+    return true;
 }
 
 
 bool ParseCollisionGroupDesc(const UsdPhysicsCollisionGroup& collisionGroup,
-	UsdPhysicsCollisionGroupDesc* collisionGroupDesc)
+    UsdPhysicsCollisionGroupDesc* collisionGroupDesc)
 {
-	if (collisionGroup && collisionGroupDesc)
-	{
-		const UsdRelationship rel = collisionGroup.GetFilteredGroupsRel();
-		if (rel)
-		{
-			rel.GetTargets(&collisionGroupDesc->filteredGroups);
-		}
-
-		collisionGroup.GetInvertFilteredGroupsAttr().Get(&collisionGroupDesc->invertFilteredGroups);
-		collisionGroup.GetMergeGroupNameAttr().Get(&collisionGroupDesc->mergeGroupName);
-
-		collisionGroupDesc->primPath = collisionGroup.GetPrim().GetPrimPath();
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsCollisionGroup or UsdPhysicsCollisionGroupDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (collisionGroup && collisionGroupDesc)
+    {
+        const UsdRelationship rel = collisionGroup.GetFilteredGroupsRel();
+        if (rel)
+        {
+            rel.GetTargets(&collisionGroupDesc->filteredGroups);
+        }
+
+        collisionGroup.GetInvertFilteredGroupsAttr().Get(&collisionGroupDesc->invertFilteredGroups);
+        collisionGroup.GetMergeGroupNameAttr().Get(&collisionGroupDesc->mergeGroupName);
+
+        collisionGroupDesc->primPath = collisionGroup.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsCollisionGroup or UsdPhysicsCollisionGroupDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
-SdfPath GetRel(const pxr::UsdRelationship& ref, const pxr::UsdPrim& jointPrim)
+SdfPath GetRel(const UsdRelationship& ref, const UsdPrim& jointPrim)
 {
-	pxr::SdfPathVector targets;
-	ref.GetTargets(&targets);
-
-	if (targets.size() == 0)
-	{
-		return SdfPath();
-	}
-	if (targets.size() > 1)
-	{
-		TF_DIAGNOSTIC_WARNING(
-			"Joint prim does have relationship to multiple bodies this is not supported, jointPrim %s",
-			jointPrim.GetPrimPath().GetText());
-		return targets.at(0);
-	}
-
-	return targets.at(0);
+    SdfPathVector targets;
+    ref.GetTargets(&targets);
+
+    if (targets.size() == 0)
+    {
+        return SdfPath();
+    }
+    if (targets.size() > 1)
+    {
+        TF_DIAGNOSTIC_WARNING(
+            "Joint prim does have relationship to multiple bodies this is not supported, jointPrim %s",
+            jointPrim.GetPrimPath().GetText());
+        return targets.at(0);
+    }
+
+    return targets.at(0);
 }
 
 bool CheckJointRel(const SdfPath& relPath, const UsdPrim& jointPrim)
 {
-	if (relPath == SdfPath())
-		return true;
-
-	const UsdPrim relPrim = jointPrim.GetStage()->GetPrimAtPath(relPath);
-	if (!relPrim)
-	{
-		TF_RUNTIME_ERROR(
-			"Joint (%s) body relationship %s points to a non existent prim, joint will not be parsed.",
-			jointPrim.GetPrimPath().GetText(),
-			relPath.GetText());
-		return false;
-	}
-	return true;
+    if (relPath == SdfPath())
+        return true;
+
+    const UsdPrim relPrim = jointPrim.GetStage()->GetPrimAtPath(relPath);
+    if (!relPrim)
+    {
+        TF_RUNTIME_ERROR(
+            "Joint (%s) body relationship %s points to a non existent prim, joint will not be parsed.",
+            jointPrim.GetPrimPath().GetText(),
+            relPath.GetText());
+        return false;
+    }
+    return true;
 }
 
-pxr::UsdPrim GetBodyPrim(UsdStageWeakPtr stage, const SdfPath& relPath, UsdPrim& relPrim)
+UsdPrim GetBodyPrim(UsdStageWeakPtr stage, const SdfPath& relPath, UsdPrim& relPrim)
 {
-	UsdPrim parent = stage->GetPrimAtPath(relPath);
-	relPrim = parent;
-	UsdPrim collisionPrim = UsdPrim();
-	while (parent && parent != stage->GetPseudoRoot())
-	{
-		if (parent.HasAPI<UsdPhysicsRigidBodyAPI>())
-		{
-			return parent;
-		}
-		if (parent.HasAPI<UsdPhysicsCollisionAPI>())
-		{
-			collisionPrim = parent;
-		}
-		parent = parent.GetParent();
-	}
-
-	return collisionPrim;
+    UsdPrim parent = stage->GetPrimAtPath(relPath);
+    relPrim = parent;
+    UsdPrim collisionPrim = UsdPrim();
+    while (parent && parent != stage->GetPseudoRoot())
+    {
+        if (parent.HasAPI<UsdPhysicsRigidBodyAPI>())
+        {
+            return parent;
+        }
+        if (parent.HasAPI<UsdPhysicsCollisionAPI>())
+        {
+            collisionPrim = parent;
+        }
+        parent = parent.GetParent();
+    }
+
+    return collisionPrim;
 }
 
 SdfPath GetLocalPose(UsdStageWeakPtr stage, const SdfPath& relPath, GfVec3f& t,
-	GfQuatf& q)
+    GfQuatf& q)
 {
-	UsdPrim relPrim;
-	const UsdPrim body = GetBodyPrim(stage, relPath, relPrim);
-
-	// get scale and apply it into localPositions vectors
-	const UsdGeomXformable xform(relPrim);
-	const GfMatrix4d worldRel = relPrim ? xform.ComputeLocalToWorldTransform(UsdTimeCode::Default()) : GfMatrix4d(1.0);
-
-	// we need to apply scale to the localPose, the scale comes from the rigid body
-	GfVec3f sc;
-	// if we had a rel not to rigid body, we need to recompute the localPose
-	if (relPrim != body)
-	{
-		GfMatrix4d localAnchor;
-		localAnchor.SetIdentity();
-		localAnchor.SetTranslate(GfVec3d(t));
-		localAnchor.SetRotateOnly(GfQuatd(q));
-
-		GfMatrix4d bodyMat;
-		if (body)
-			bodyMat = UsdGeomXformable(body).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-		else
-			bodyMat.SetIdentity();
-
-		const GfMatrix4d worldAnchor = localAnchor * worldRel;
-		GfMatrix4d bodyLocalAnchor = worldAnchor * bodyMat.GetInverse();
-		bodyLocalAnchor = bodyLocalAnchor.RemoveScaleShear();
-
-		t = GfVec3f(bodyLocalAnchor.ExtractTranslation());
-		q = GfQuatf(bodyLocalAnchor.ExtractRotationQuat());
-		q.Normalize();
-
-		const GfTransform tr(bodyMat);
-		sc = GfVec3f(tr.GetScale());
-	}
-	else
-	{
-		const GfTransform tr(worldRel);
-		sc = GfVec3f(tr.GetScale());
-	}
-
-	// apply the scale, this is not obvious, but in physics there is no scale, 
-	// so we need to apply it before its send to physics
-	for (int i = 0; i < 3; i++)
-	{
-		t[i] *= sc[i];
-	}
-
-	return body ? body.GetPrimPath() : SdfPath();
+    UsdPrim relPrim;
+    const UsdPrim body = GetBodyPrim(stage, relPath, relPrim);
+
+    // get scale and apply it into localPositions vectors
+    const UsdGeomXformable xform(relPrim);
+    const GfMatrix4d worldRel = relPrim ? xform.ComputeLocalToWorldTransform(UsdTimeCode::Default()) : GfMatrix4d(1.0);
+
+    // we need to apply scale to the localPose, the scale comes from the rigid body
+    GfVec3f sc;
+    // if we had a rel not to rigid body, we need to recompute the localPose
+    if (relPrim != body)
+    {
+        GfMatrix4d localAnchor;
+        localAnchor.SetIdentity();
+        localAnchor.SetTranslate(GfVec3d(t));
+        localAnchor.SetRotateOnly(GfQuatd(q));
+
+        GfMatrix4d bodyMat;
+        if (body)
+            bodyMat = UsdGeomXformable(body).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+        else
+            bodyMat.SetIdentity();
+
+        const GfMatrix4d worldAnchor = localAnchor * worldRel;
+        GfMatrix4d bodyLocalAnchor = worldAnchor * bodyMat.GetInverse();
+        bodyLocalAnchor = bodyLocalAnchor.RemoveScaleShear();
+
+        t = GfVec3f(bodyLocalAnchor.ExtractTranslation());
+        q = GfQuatf(bodyLocalAnchor.ExtractRotationQuat());
+        q.Normalize();
+
+        const GfTransform tr(bodyMat);
+        sc = GfVec3f(tr.GetScale());
+    }
+    else
+    {
+        const GfTransform tr(worldRel);
+        sc = GfVec3f(tr.GetScale());
+    }
+
+    // apply the scale, this is not obvious, but in physics there is no scale, 
+    // so we need to apply it before its send to physics
+    for (int i = 0; i < 3; i++)
+    {
+        t[i] *= sc[i];
+    }
+
+    return body ? body.GetPrimPath() : SdfPath();
 }
 
 void FinalizeJoint(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
 {
-	// joint bodies anchor point local transforms    
-	GfVec3f t0(0.f);
-	GfVec3f t1(0.f);
-	GfQuatf q0(1.f);
-	GfQuatf q1(1.f);
-	jointPrim.GetLocalPos0Attr().Get(&t0);
-	jointPrim.GetLocalRot0Attr().Get(&q0);
-	jointPrim.GetLocalPos1Attr().Get(&t1);
-	jointPrim.GetLocalRot1Attr().Get(&q1);
-
-	q0.Normalize();
-	q1.Normalize();
-
-	UsdStageWeakPtr stage = jointPrim.GetPrim().GetStage();
-
-	// get scale and apply it into localPositions vectors
-	if (jointDesc->rel0 != SdfPath())
-	{
-		jointDesc->body0 = GetLocalPose(stage, jointDesc->rel0, t0, q0);
-	}
-
-	if (jointDesc->rel1 != SdfPath())
-	{
-		jointDesc->body1 = GetLocalPose(stage, jointDesc->rel1, t1, q1);
-	}
-
-	jointDesc->localPose0Position = t0;
-	jointDesc->localPose0Orientation = q0;
-	jointDesc->localPose1Position = t1;
-	jointDesc->localPose1Orientation = q1;
+    // joint bodies anchor point local transforms    
+    GfVec3f t0(0.f);
+    GfVec3f t1(0.f);
+    GfQuatf q0(1.f);
+    GfQuatf q1(1.f);
+    jointPrim.GetLocalPos0Attr().Get(&t0);
+    jointPrim.GetLocalRot0Attr().Get(&q0);
+    jointPrim.GetLocalPos1Attr().Get(&t1);
+    jointPrim.GetLocalRot1Attr().Get(&q1);
+
+    q0.Normalize();
+    q1.Normalize();
+
+    UsdStageWeakPtr stage = jointPrim.GetPrim().GetStage();
+
+    // get scale and apply it into localPositions vectors
+    if (jointDesc->rel0 != SdfPath())
+    {
+        jointDesc->body0 = GetLocalPose(stage, jointDesc->rel0, t0, q0);
+    }
+
+    if (jointDesc->rel1 != SdfPath())
+    {
+        jointDesc->body1 = GetLocalPose(stage, jointDesc->rel1, t1, q1);
+    }
+
+    jointDesc->localPose0Position = t0;
+    jointDesc->localPose0Orientation = q0;
+    jointDesc->localPose1Position = t1;
+    jointDesc->localPose1Orientation = q1;
 }
 
 bool ParseCommonJointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsJointDesc* jointDesc)
 {
-	const UsdPrim prim = jointPrim.GetPrim();
+    const UsdPrim prim = jointPrim.GetPrim();
 
-	jointDesc->primPath = prim.GetPrimPath();
+    jointDesc->primPath = prim.GetPrimPath();
 
-	// parse the joint common parameters
-	jointPrim.GetJointEnabledAttr().Get(&jointDesc->jointEnabled);
-	jointPrim.GetCollisionEnabledAttr().Get(&jointDesc->collisionEnabled);
-	jointPrim.GetBreakForceAttr().Get(&jointDesc->breakForce);
-	jointPrim.GetBreakTorqueAttr().Get(&jointDesc->breakTorque);
-	jointPrim.GetExcludeFromArticulationAttr().Get(&jointDesc->excludeFromArticulation);
+    // parse the joint common parameters
+    jointPrim.GetJointEnabledAttr().Get(&jointDesc->jointEnabled);
+    jointPrim.GetCollisionEnabledAttr().Get(&jointDesc->collisionEnabled);
+    jointPrim.GetBreakForceAttr().Get(&jointDesc->breakForce);
+    jointPrim.GetBreakTorqueAttr().Get(&jointDesc->breakTorque);
+    jointPrim.GetExcludeFromArticulationAttr().Get(&jointDesc->excludeFromArticulation);
 
-	jointDesc->rel0 = GetRel(jointPrim.GetBody0Rel(), prim);
-	jointDesc->rel1 = GetRel(jointPrim.GetBody1Rel(), prim);
+    jointDesc->rel0 = GetRel(jointPrim.GetBody0Rel(), prim);
+    jointDesc->rel1 = GetRel(jointPrim.GetBody1Rel(), prim);
 
-	// check rel validity
-	if (!CheckJointRel(jointDesc->rel0, prim) || !CheckJointRel(jointDesc->rel1, prim))
-	{
-		return false;
-	}
+    // check rel validity
+    if (!CheckJointRel(jointDesc->rel0, prim) || !CheckJointRel(jointDesc->rel1, prim))
+    {
+        return false;
+    }
 
-	FinalizeJoint(jointPrim, jointDesc);
+    FinalizeJoint(jointPrim, jointDesc);
 
-	return true;
+    return true;
 }
 
 bool ParseDistanceJointDesc(const UsdPhysicsDistanceJoint& distanceJoint,
-	UsdPhysicsDistanceJointDesc* distanceJointDesc)
+    UsdPhysicsDistanceJointDesc* distanceJointDesc)
 {
-	if (distanceJointDesc && distanceJoint)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(distanceJoint, distanceJointDesc))
-		{
-			return false;
-		}
-
-		distanceJointDesc->maxEnabled = false;
-		distanceJointDesc->minEnabled = false;
-		distanceJoint.GetMinDistanceAttr().Get(&distanceJointDesc->limit.minDist);
-		distanceJoint.GetMaxDistanceAttr().Get(&distanceJointDesc->limit.maxDist);
-
-		if (distanceJointDesc->limit.minDist >= 0.0f)
-		{
-			distanceJointDesc->minEnabled = true;
-
-		}
-		if (distanceJointDesc->limit.maxDist >= 0.0f)
-		{
-			distanceJointDesc->maxEnabled = true;
-
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsDistanceJoint or UsdPhysicsDistanceJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (distanceJointDesc && distanceJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(distanceJoint, distanceJointDesc))
+        {
+            return false;
+        }
+
+        distanceJointDesc->maxEnabled = false;
+        distanceJointDesc->minEnabled = false;
+        distanceJoint.GetMinDistanceAttr().Get(&distanceJointDesc->limit.minDist);
+        distanceJoint.GetMaxDistanceAttr().Get(&distanceJointDesc->limit.maxDist);
+
+        if (distanceJointDesc->limit.minDist >= 0.0f)
+        {
+            distanceJointDesc->minEnabled = true;
+
+        }
+        if (distanceJointDesc->limit.maxDist >= 0.0f)
+        {
+            distanceJointDesc->maxEnabled = true;
+
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsDistanceJoint or UsdPhysicsDistanceJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseDrive(const UsdPhysicsDriveAPI& drive, UsdPhysicsJointDrive* jointDrive)
 {
-	if (drive && jointDrive)
-	{
-		drive.GetTargetPositionAttr().Get(&jointDrive->targetPosition);
-		drive.GetTargetVelocityAttr().Get(&jointDrive->targetVelocity);
-		drive.GetMaxForceAttr().Get(&jointDrive->forceLimit);
-
-		drive.GetDampingAttr().Get(&jointDrive->damping);
-		drive.GetStiffnessAttr().Get(&jointDrive->stiffness);
-
-		TfToken typeToken;
-		drive.GetTypeAttr().Get(&typeToken);
-		if (typeToken == UsdPhysicsTokens->acceleration)
-			jointDrive->acceleration = true;
-		jointDrive->enabled = true;
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsDriveAPI or UsdPhysicsJointDrive is not valid.");
-		return false;
-	}
-
-	return true;
+    if (drive && jointDrive)
+    {
+        drive.GetTargetPositionAttr().Get(&jointDrive->targetPosition);
+        drive.GetTargetVelocityAttr().Get(&jointDrive->targetVelocity);
+        drive.GetMaxForceAttr().Get(&jointDrive->forceLimit);
+
+        drive.GetDampingAttr().Get(&jointDrive->damping);
+        drive.GetStiffnessAttr().Get(&jointDrive->stiffness);
+
+        TfToken typeToken;
+        drive.GetTypeAttr().Get(&typeToken);
+        if (typeToken == UsdPhysicsTokens->acceleration)
+            jointDrive->acceleration = true;
+        jointDrive->enabled = true;
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsDriveAPI or UsdPhysicsJointDrive is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseFixedJointDesc(const UsdPhysicsFixedJoint& fixedJoint,
-	UsdPhysicsFixedJointDesc* fixedJointDesc)
+    UsdPhysicsFixedJointDesc* fixedJointDesc)
 {
-	if (fixedJointDesc && fixedJoint)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(fixedJoint, fixedJointDesc))
-		{
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsFixedJoint or UsdPhysicsFixedJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (fixedJointDesc && fixedJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(fixedJoint, fixedJointDesc))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsFixedJoint or UsdPhysicsFixedJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseLimit(const UsdPhysicsLimitAPI& limit, UsdPhysicsJointLimit* jointLimit)
 {
-	if (limit && jointLimit)
-	{
-		limit.GetLowAttr().Get(&jointLimit->lower);
-		limit.GetHighAttr().Get(&jointLimit->upper);
-		if ((isfinite(jointLimit->lower) && jointLimit->lower > -usdPhysicsSentinelLimit) ||
-			(isfinite(jointLimit->upper) && jointLimit->upper < usdPhysicsSentinelLimit))
-			jointLimit->enabled = true;
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsLimitAPI or UsdPhysicsJointLimit is not valid.");
-		return false;
-	}
-
-	return true;
+    if (limit && jointLimit)
+    {
+        limit.GetLowAttr().Get(&jointLimit->lower);
+        limit.GetHighAttr().Get(&jointLimit->upper);
+        if ((isfinite(jointLimit->lower) && jointLimit->lower > -usdPhysicsSentinelLimit) ||
+            (isfinite(jointLimit->upper) && jointLimit->upper < usdPhysicsSentinelLimit))
+            jointLimit->enabled = true;
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsLimitAPI or UsdPhysicsJointLimit is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseD6JointDesc(const UsdPhysicsJoint& jointPrim, UsdPhysicsD6JointDesc* jointDesc)
 {
-	if (jointDesc && jointPrim)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(jointPrim, jointDesc))
-		{
-			return false;
-		}
-
-		// D6 joint        
-		const std::array<std::pair<UsdPhysicsJointDOF::Enum, TfToken>, 7> axisVector =
-		{
-			std::make_pair(UsdPhysicsJointDOF::eDistance, UsdPhysicsTokens->distance),
-			std::make_pair(UsdPhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
-			std::make_pair(UsdPhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),
-			std::make_pair(UsdPhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
-			std::make_pair(UsdPhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),
-			std::make_pair(UsdPhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
-			std::make_pair(UsdPhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
-		};
-
-		for (size_t i = 0; i < axisVector.size(); i++)
-		{
-			const TfToken& axisToken = axisVector[i].second;
-
-			const UsdPhysicsLimitAPI limitAPI = UsdPhysicsLimitAPI::Get(jointPrim.GetPrim(),
-				axisToken);
-			if (limitAPI)
-			{
-				UsdPhysicsJointLimit limit;
-				if (ParseLimit(limitAPI, &limit))
-				{
-					jointDesc->jointLimits.push_back(std::make_pair(axisVector[i].first, limit));
-				}
-			}
-
-			const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(jointPrim.GetPrim(),
-				axisToken);
-			if (driveAPI)
-			{
-				UsdPhysicsJointDrive drive;
-				if (ParseDrive(driveAPI, &drive))
-				{
-					jointDesc->jointDrives.push_back(std::make_pair(axisVector[i].first, drive));
-				}
-			}
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (jointDesc && jointPrim)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(jointPrim, jointDesc))
+        {
+            return false;
+        }
+
+        // D6 joint        
+        const std::array<std::pair<UsdPhysicsJointDOF::Enum, TfToken>, 7> axisVector =
+        {
+            std::make_pair(UsdPhysicsJointDOF::eDistance, UsdPhysicsTokens->distance),
+            std::make_pair(UsdPhysicsJointDOF::eTransX, UsdPhysicsTokens->transX),
+            std::make_pair(UsdPhysicsJointDOF::eTransY, UsdPhysicsTokens->transY),
+            std::make_pair(UsdPhysicsJointDOF::eTransZ, UsdPhysicsTokens->transZ),
+            std::make_pair(UsdPhysicsJointDOF::eRotX, UsdPhysicsTokens->rotX),
+            std::make_pair(UsdPhysicsJointDOF::eRotY, UsdPhysicsTokens->rotY),
+            std::make_pair(UsdPhysicsJointDOF::eRotZ, UsdPhysicsTokens->rotZ)
+        };
+
+        for (size_t i = 0; i < axisVector.size(); i++)
+        {
+            const TfToken& axisToken = axisVector[i].second;
+
+            const UsdPhysicsLimitAPI limitAPI = UsdPhysicsLimitAPI::Get(jointPrim.GetPrim(),
+                axisToken);
+            if (limitAPI)
+            {
+                UsdPhysicsJointLimit limit;
+                if (ParseLimit(limitAPI, &limit))
+                {
+                    jointDesc->jointLimits.push_back(std::make_pair(axisVector[i].first, limit));
+                }
+            }
+
+            const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(jointPrim.GetPrim(),
+                axisToken);
+            if (driveAPI)
+            {
+                UsdPhysicsJointDrive drive;
+                if (ParseDrive(driveAPI, &drive))
+                {
+                    jointDesc->jointDrives.push_back(std::make_pair(axisVector[i].first, drive));
+                }
+            }
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseCustomJointDesc(const UsdPhysicsJoint& jointPrim,
-	UsdPhysicsCustomJointDesc* customJointDesc)
+    UsdPhysicsCustomJointDesc* customJointDesc)
 {
-	if (customJointDesc && jointPrim)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(jointPrim, customJointDesc))
-		{
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (customJointDesc && jointPrim)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(jointPrim, customJointDesc))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseRigidBodyMaterialDesc(const UsdPhysicsMaterialAPI& usdMaterial,
-	UsdPhysicsRigidBodyMaterialDesc* rbMaterialDesc)
+    UsdPhysicsRigidBodyMaterialDesc* rbMaterialDesc)
 {
-	if (rbMaterialDesc && usdMaterial)
-	{
-		usdMaterial.GetDynamicFrictionAttr().Get(&rbMaterialDesc->dynamicFriction);
-		usdMaterial.GetStaticFrictionAttr().Get(&rbMaterialDesc->staticFriction);
+    if (rbMaterialDesc && usdMaterial)
+    {
+        usdMaterial.GetDynamicFrictionAttr().Get(&rbMaterialDesc->dynamicFriction);
+        usdMaterial.GetStaticFrictionAttr().Get(&rbMaterialDesc->staticFriction);
 
-		usdMaterial.GetRestitutionAttr().Get(&rbMaterialDesc->restitution);
+        usdMaterial.GetRestitutionAttr().Get(&rbMaterialDesc->restitution);
 
-		usdMaterial.GetDensityAttr().Get(&rbMaterialDesc->density);
+        usdMaterial.GetDensityAttr().Get(&rbMaterialDesc->density);
 
-		rbMaterialDesc->primPath = usdMaterial.GetPrim().GetPrimPath();
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsMaterialAPI or UsdPhysicsRigidBodyMaterialDesc is not valid.");
-		return false;
+        rbMaterialDesc->primPath = usdMaterial.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsMaterialAPI or UsdPhysicsRigidBodyMaterialDesc is not valid.");
+        return false;
 
-	}
-	return true;
+    }
+    return true;
 }
 
 bool ParseLinearDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
 {
-	dst->enabled = false;
-	const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->linear);
-	if (driveAPI)
-	{
-		return ParseDrive(driveAPI, dst);
-	}
-
-	return true;
+    dst->enabled = false;
+    const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim, UsdPhysicsTokens->linear);
+    if (driveAPI)
+    {
+        return ParseDrive(driveAPI, dst);
+    }
+
+    return true;
 }
 
 
 bool ParsePrismaticJointDesc(const UsdPhysicsPrismaticJoint& prismaticJoint,
-	UsdPhysicsPrismaticJointDesc* prismaticJointDesc)
+    UsdPhysicsPrismaticJointDesc* prismaticJointDesc)
 {
-	if (prismaticJointDesc && prismaticJoint)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(prismaticJoint, prismaticJointDesc))
-		{
-			return false;
-		}
-
-		UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
-		TfToken axis = UsdPhysicsTokens->x;
-		prismaticJoint.GetAxisAttr().Get(&axis);
-
-		if (axis == UsdPhysicsTokens->y)
-			jointAxis = UsdPhysicsAxis::eY;
-		else if (axis == UsdPhysicsTokens->z)
-			jointAxis = UsdPhysicsAxis::eZ;
-		prismaticJointDesc->axis = jointAxis;
-
-		prismaticJointDesc->limit.enabled = false;
-		prismaticJoint.GetLowerLimitAttr().Get(&prismaticJointDesc->limit.lower);
-		prismaticJoint.GetUpperLimitAttr().Get(&prismaticJointDesc->limit.upper);
-		if ((isfinite(prismaticJointDesc->limit.lower) &&
-			(prismaticJointDesc->limit.lower > -usdPhysicsSentinelLimit)) ||
-			(isfinite(prismaticJointDesc->limit.upper) &&
-				(prismaticJointDesc->limit.upper < usdPhysicsSentinelLimit)))
-		{
-			prismaticJointDesc->limit.enabled = true;
-		}
-
-		if (!ParseLinearDrive(&prismaticJointDesc->drive, prismaticJoint.GetPrim()))
-		{
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsPrismaticJoint or UsdPhysicsPrismaticJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (prismaticJointDesc && prismaticJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(prismaticJoint, prismaticJointDesc))
+        {
+            return false;
+        }
+
+        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
+        TfToken axis = UsdPhysicsTokens->x;
+        prismaticJoint.GetAxisAttr().Get(&axis);
+
+        if (axis == UsdPhysicsTokens->y)
+            jointAxis = UsdPhysicsAxis::eY;
+        else if (axis == UsdPhysicsTokens->z)
+            jointAxis = UsdPhysicsAxis::eZ;
+        prismaticJointDesc->axis = jointAxis;
+
+        prismaticJointDesc->limit.enabled = false;
+        prismaticJoint.GetLowerLimitAttr().Get(&prismaticJointDesc->limit.lower);
+        prismaticJoint.GetUpperLimitAttr().Get(&prismaticJointDesc->limit.upper);
+        if ((isfinite(prismaticJointDesc->limit.lower) &&
+            (prismaticJointDesc->limit.lower > -usdPhysicsSentinelLimit)) ||
+            (isfinite(prismaticJointDesc->limit.upper) &&
+                (prismaticJointDesc->limit.upper < usdPhysicsSentinelLimit)))
+        {
+            prismaticJointDesc->limit.enabled = true;
+        }
+
+        if (!ParseLinearDrive(&prismaticJointDesc->drive, prismaticJoint.GetPrim()))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsPrismaticJoint or UsdPhysicsPrismaticJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseAngularDrive(UsdPhysicsJointDrive* dst, const UsdPrim& usdPrim)
 {
-	dst->enabled = false;
-	const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim,
-		UsdPhysicsTokens->angular);
-	if (driveAPI)
-	{
-		return ParseDrive(driveAPI, dst);
-	}
-
-	return true;
+    dst->enabled = false;
+    const UsdPhysicsDriveAPI driveAPI = UsdPhysicsDriveAPI::Get(usdPrim,
+        UsdPhysicsTokens->angular);
+    if (driveAPI)
+    {
+        return ParseDrive(driveAPI, dst);
+    }
+
+    return true;
 }
 
 
 bool ParseRevoluteJointDesc(const UsdPhysicsRevoluteJoint& revoluteJoint,
-	UsdPhysicsRevoluteJointDesc* revoluteJointDesc)
+    UsdPhysicsRevoluteJointDesc* revoluteJointDesc)
 {
-	if (revoluteJointDesc && revoluteJoint)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(revoluteJoint, revoluteJointDesc))
-		{
-			return false;
-		}
-
-		UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
-		TfToken axis = UsdPhysicsTokens->x;
-		revoluteJoint.GetAxisAttr().Get(&axis);
-
-		if (axis == UsdPhysicsTokens->y)
-			jointAxis = UsdPhysicsAxis::eY;
-		else if (axis == UsdPhysicsTokens->z)
-			jointAxis = UsdPhysicsAxis::eZ;
-		revoluteJointDesc->axis = jointAxis;
-
-		revoluteJointDesc->limit.enabled = false;
-
-
-		revoluteJoint.GetLowerLimitAttr().Get(&revoluteJointDesc->limit.lower);
-		revoluteJoint.GetUpperLimitAttr().Get(&revoluteJointDesc->limit.upper);
-		if (isfinite(revoluteJointDesc->limit.lower) && isfinite(revoluteJointDesc->limit.upper)
-			&& revoluteJointDesc->limit.lower > -usdPhysicsSentinelLimit &&
-			revoluteJointDesc->limit.upper < usdPhysicsSentinelLimit)
-		{
-			revoluteJointDesc->limit.enabled = true;
-		}
-
-		if (!ParseAngularDrive(&revoluteJointDesc->drive, revoluteJoint.GetPrim()))
-		{
-			return false;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (revoluteJointDesc && revoluteJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(revoluteJoint, revoluteJointDesc))
+        {
+            return false;
+        }
+
+        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
+        TfToken axis = UsdPhysicsTokens->x;
+        revoluteJoint.GetAxisAttr().Get(&axis);
+
+        if (axis == UsdPhysicsTokens->y)
+            jointAxis = UsdPhysicsAxis::eY;
+        else if (axis == UsdPhysicsTokens->z)
+            jointAxis = UsdPhysicsAxis::eZ;
+        revoluteJointDesc->axis = jointAxis;
+
+        revoluteJointDesc->limit.enabled = false;
+
+
+        revoluteJoint.GetLowerLimitAttr().Get(&revoluteJointDesc->limit.lower);
+        revoluteJoint.GetUpperLimitAttr().Get(&revoluteJointDesc->limit.upper);
+        if (isfinite(revoluteJointDesc->limit.lower) && isfinite(revoluteJointDesc->limit.upper)
+            && revoluteJointDesc->limit.lower > -usdPhysicsSentinelLimit &&
+            revoluteJointDesc->limit.upper < usdPhysicsSentinelLimit)
+        {
+            revoluteJointDesc->limit.enabled = true;
+        }
+
+        if (!ParseAngularDrive(&revoluteJointDesc->drive, revoluteJoint.GetPrim()))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsJoint or UsdPhysicsJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 template<typename T>
 inline bool ScaleIsUniform(T scaleX, T scaleY, T scaleZ, T eps = T(1.0e-5))
 {
-	// Find min and max scale values
-	T lo, hi;
-
-	if (scaleX < scaleY)
-	{
-		lo = scaleX;
-		hi = scaleY;
-	}
-	else
-	{
-		lo = scaleY;
-		hi = scaleX;
-	}
-
-	if (scaleZ < lo)
-	{
-		lo = scaleZ;
-	}
-	else if (scaleZ > hi)
-	{
-		hi = scaleZ;
-	}
-
-	if (lo* hi < 0.0)
-	{
-		return false;   // opposite signs
-	}
-
-	return hi > 0.0 ? hi - lo <= eps * lo : lo - hi >= eps * hi;
+    // Find min and max scale values
+    T lo, hi;
+
+    if (scaleX < scaleY)
+    {
+        lo = scaleX;
+        hi = scaleY;
+    }
+    else
+    {
+        lo = scaleY;
+        hi = scaleX;
+    }
+
+    if (scaleZ < lo)
+    {
+        lo = scaleZ;
+    }
+    else if (scaleZ > hi)
+    {
+        hi = scaleZ;
+    }
+
+    if (lo* hi < 0.0)
+    {
+        return false;   // opposite signs
+    }
+
+    return hi > 0.0 ? hi - lo <= eps * lo : lo - hi >= eps * hi;
 }
 
 
 void GetRigidBodyTransformation(const UsdPrim& bodyPrim, UsdPhysicsRigidBodyDesc& desc)
 {
-	const GfMatrix4d mat =
-		UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-	const GfTransform tr(mat);
-	const GfVec3d pos = tr.GetTranslation();
-	const GfQuatd rot = tr.GetRotation().GetQuat();
-	const GfVec3d sc = tr.GetScale();
-
-	if (!ScaleIsUniform(sc[0], sc[1], sc[2]) &&
-		tr.GetScaleOrientation().GetQuaternion() != GfQuaternion::GetIdentity())
-	{
-		TF_DIAGNOSTIC_WARNING(
-			"ScaleOrientation is not supported for rigid bodies, prim path: %s.You may ignore this if the scale is close to uniform.",
-			bodyPrim.GetPrimPath().GetText());
-	}
-
-	desc.position = GfVec3f(pos);
-	desc.rotation = GfQuatf(rot);
-	desc.scale = GfVec3f(sc);
+    const GfMatrix4d mat =
+        UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+    const GfTransform tr(mat);
+    const GfVec3d pos = tr.GetTranslation();
+    const GfQuatd rot = tr.GetRotation().GetQuat();
+    const GfVec3d sc = tr.GetScale();
+
+    if (!ScaleIsUniform(sc[0], sc[1], sc[2]) &&
+        tr.GetScaleOrientation().GetQuaternion() != GfQuaternion::GetIdentity())
+    {
+        TF_DIAGNOSTIC_WARNING(
+            "ScaleOrientation is not supported for rigid bodies, prim path: %s.You may ignore this if the scale is close to uniform.",
+            bodyPrim.GetPrimPath().GetText());
+    }
+
+    desc.position = GfVec3f(pos);
+    desc.rotation = GfQuatf(rot);
+    desc.scale = GfVec3f(sc);
 }
 
 bool ParseRigidBodyDesc(const UsdPhysicsRigidBodyAPI& rigidBodyAPI,
-	UsdPhysicsRigidBodyDesc* rigidBodyDesc)
+    UsdPhysicsRigidBodyDesc* rigidBodyDesc)
 {
-	if (rigidBodyDesc && rigidBodyAPI)
-	{
-		if (!rigidBodyAPI.GetPrim().IsA<UsdGeomXformable>())
-		{
-			TF_DIAGNOSTIC_WARNING(
-				"RigidBodyAPI applied to a non-xformable primitive. (%s)",
-				rigidBodyAPI.GetPrim().GetPrimPath().GetText());
-			return false;
-		}
-
-		// check instancing
-		{
-			bool reportInstanceError = false;
-			if (rigidBodyAPI.GetPrim().IsInstanceProxy())
-			{
-				reportInstanceError = true;
-
-				bool kinematic = false;
-				rigidBodyAPI.GetKinematicEnabledAttr().Get(&kinematic);
-				if (kinematic)
-					reportInstanceError = false;
-
-				bool enabled = false;
-				rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&enabled);
-				if (!enabled)
-					reportInstanceError = false;
-
-				if (reportInstanceError)
-				{
-					TF_DIAGNOSTIC_WARNING(
-						"RigidBodyAPI on an instance proxy not supported. %s",
-						rigidBodyAPI.GetPrim().GetPrimPath().GetText());
-					return false;
-				}
-			}
-		}
-
-		// transformation
-		GetRigidBodyTransformation(rigidBodyAPI.GetPrim(), *rigidBodyDesc);
-
-		// filteredPairs
-		ParseFilteredPairs(rigidBodyAPI.GetPrim(), rigidBodyDesc->filteredCollisions);
-
-		// velocity
-		rigidBodyAPI.GetVelocityAttr().Get(&rigidBodyDesc->linearVelocity);
-		rigidBodyAPI.GetAngularVelocityAttr().Get(&rigidBodyDesc->angularVelocity);
-
-		// rigid body flags
-		rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&rigidBodyDesc->rigidBodyEnabled);
-		rigidBodyAPI.GetKinematicEnabledAttr().Get(&rigidBodyDesc->kinematicBody);
-		rigidBodyAPI.GetStartsAsleepAttr().Get(&rigidBodyDesc->startsAsleep);
-
-		// simulation owner
-		const UsdRelationship ownerRel = rigidBodyAPI.GetSimulationOwnerRel();
-		if (ownerRel)
-		{
-			SdfPathVector owners;
-			ownerRel.GetTargets(&owners);
-			if (!owners.empty())
-			{
-				rigidBodyDesc->simulationOwners = owners;
-			}
-		}
-		rigidBodyDesc->primPath = rigidBodyAPI.GetPrim().GetPrimPath();
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsRigidBodyAPI or UsdPhysicsRigidBodyDesc is not valid.");
-		return false;
-	}
-	return true;
+    if (rigidBodyDesc && rigidBodyAPI)
+    {
+        if (!rigidBodyAPI.GetPrim().IsA<UsdGeomXformable>())
+        {
+            TF_DIAGNOSTIC_WARNING(
+                "RigidBodyAPI applied to a non-xformable primitive. (%s)",
+                rigidBodyAPI.GetPrim().GetPrimPath().GetText());
+            return false;
+        }
+
+        // check instancing
+        {
+            bool reportInstanceError = false;
+            if (rigidBodyAPI.GetPrim().IsInstanceProxy())
+            {
+                reportInstanceError = true;
+
+                bool kinematic = false;
+                rigidBodyAPI.GetKinematicEnabledAttr().Get(&kinematic);
+                if (kinematic)
+                    reportInstanceError = false;
+
+                bool enabled = false;
+                rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&enabled);
+                if (!enabled)
+                    reportInstanceError = false;
+
+                if (reportInstanceError)
+                {
+                    TF_DIAGNOSTIC_WARNING(
+                        "RigidBodyAPI on an instance proxy not supported. %s",
+                        rigidBodyAPI.GetPrim().GetPrimPath().GetText());
+                    return false;
+                }
+            }
+        }
+
+        // transformation
+        GetRigidBodyTransformation(rigidBodyAPI.GetPrim(), *rigidBodyDesc);
+
+        // filteredPairs
+        ParseFilteredPairs(rigidBodyAPI.GetPrim(), rigidBodyDesc->filteredCollisions);
+
+        // velocity
+        rigidBodyAPI.GetVelocityAttr().Get(&rigidBodyDesc->linearVelocity);
+        rigidBodyAPI.GetAngularVelocityAttr().Get(&rigidBodyDesc->angularVelocity);
+
+        // rigid body flags
+        rigidBodyAPI.GetRigidBodyEnabledAttr().Get(&rigidBodyDesc->rigidBodyEnabled);
+        rigidBodyAPI.GetKinematicEnabledAttr().Get(&rigidBodyDesc->kinematicBody);
+        rigidBodyAPI.GetStartsAsleepAttr().Get(&rigidBodyDesc->startsAsleep);
+
+        // simulation owner
+        const UsdRelationship ownerRel = rigidBodyAPI.GetSimulationOwnerRel();
+        if (ownerRel)
+        {
+            SdfPathVector owners;
+            ownerRel.GetTargets(&owners);
+            if (!owners.empty())
+            {
+                rigidBodyDesc->simulationOwners = owners;
+            }
+        }
+        rigidBodyDesc->primPath = rigidBodyAPI.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsRigidBodyAPI or UsdPhysicsRigidBodyDesc is not valid.");
+        return false;
+    }
+    return true;
 }
 
 bool ParseSphericalJointDesc(const UsdPhysicsSphericalJoint& sphericalJoint,
-	UsdPhysicsSphericalJointDesc* sphericalJointDesc)
+    UsdPhysicsSphericalJointDesc* sphericalJointDesc)
 {
-	if (sphericalJointDesc && sphericalJoint)
-	{
-		// parse the joint common parameters
-		if (!ParseCommonJointDesc(sphericalJoint, sphericalJointDesc))
-		{
-			return false;
-		}
-
-		UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
-		TfToken axis = UsdPhysicsTokens->x;
-		sphericalJoint.GetAxisAttr().Get(&axis);
-
-		if (axis == UsdPhysicsTokens->y)
-			jointAxis = UsdPhysicsAxis::eY;
-		else if (axis == UsdPhysicsTokens->z)
-			jointAxis = UsdPhysicsAxis::eZ;
-		sphericalJointDesc->axis = jointAxis;
-
-		sphericalJointDesc->limit.enabled = false;
-		sphericalJoint.GetConeAngle0LimitAttr().Get(&sphericalJointDesc->limit.angle0);
-		sphericalJoint.GetConeAngle1LimitAttr().Get(&sphericalJointDesc->limit.angle1);
-
-		if (isfinite(sphericalJointDesc->limit.angle0) &&
-			isfinite(sphericalJointDesc->limit.angle1) &&
-			sphericalJointDesc->limit.angle0 >= 0.0 &&
-			sphericalJointDesc->limit.angle1 >= 0.0)
-		{
-			sphericalJointDesc->limit.enabled = true;
-		}
-	}
-	else
-	{
-		TF_RUNTIME_ERROR(
-			"Provided UsdPhysicsSphericalJoint or UsdPhysicsSphericalJointDesc is not valid.");
-		return false;
-	}
-
-	return true;
+    if (sphericalJointDesc && sphericalJoint)
+    {
+        // parse the joint common parameters
+        if (!ParseCommonJointDesc(sphericalJoint, sphericalJointDesc))
+        {
+            return false;
+        }
+
+        UsdPhysicsAxis::Enum jointAxis = UsdPhysicsAxis::eX;
+        TfToken axis = UsdPhysicsTokens->x;
+        sphericalJoint.GetAxisAttr().Get(&axis);
+
+        if (axis == UsdPhysicsTokens->y)
+            jointAxis = UsdPhysicsAxis::eY;
+        else if (axis == UsdPhysicsTokens->z)
+            jointAxis = UsdPhysicsAxis::eZ;
+        sphericalJointDesc->axis = jointAxis;
+
+        sphericalJointDesc->limit.enabled = false;
+        sphericalJoint.GetConeAngle0LimitAttr().Get(&sphericalJointDesc->limit.angle0);
+        sphericalJoint.GetConeAngle1LimitAttr().Get(&sphericalJointDesc->limit.angle1);
+
+        if (isfinite(sphericalJointDesc->limit.angle0) &&
+            isfinite(sphericalJointDesc->limit.angle1) &&
+            sphericalJointDesc->limit.angle0 >= 0.0 &&
+            sphericalJointDesc->limit.angle1 >= 0.0)
+        {
+            sphericalJointDesc->limit.enabled = true;
+        }
+    }
+    else
+    {
+        TF_RUNTIME_ERROR(
+            "Provided UsdPhysicsSphericalJoint or UsdPhysicsSphericalJointDesc is not valid.");
+        return false;
+    }
+
+    return true;
 }
 
 bool ParseSceneDesc(const UsdPhysicsScene& scene, UsdPhysicsSceneDesc* sceneDesc)
 {
-	if (sceneDesc && scene)
-	{
-		UsdStageWeakPtr stage = scene.GetPrim().GetStage();
-
-		GfVec3f gravityDirection;
-		scene.GetGravityDirectionAttr().Get(&gravityDirection);
-		if (gravityDirection == GfVec3f(0.0f))
-		{
-			TfToken upAxis = pxr::UsdGeomGetStageUpAxis(stage);
-			if (upAxis == pxr::UsdGeomTokens.Get()->x)
-				gravityDirection = GfVec3f(-1.0f, 0.0f, 0.0f);
-			else if (upAxis == pxr::UsdGeomTokens.Get()->y)
-				gravityDirection = GfVec3f(0.0f, -1.0f, 0.0f);
-			else
-				gravityDirection = GfVec3f(0.0f, 0.0f, -1.0f);
-		}
-		else
-		{
-			gravityDirection.Normalize();
-		}
-
-		float gravityMagnitude;
-		scene.GetGravityMagnitudeAttr().Get(&gravityMagnitude);
-		if (gravityMagnitude < -0.5e38f)
-		{
-			float metersPerUnit = (float)pxr::UsdGeomGetStageMetersPerUnit(stage);
-			gravityMagnitude = 9.81f / metersPerUnit;
-		}
-
-		sceneDesc->gravityMagnitude = gravityMagnitude;
-		sceneDesc->gravityDirection = gravityDirection;
-		sceneDesc->primPath = scene.GetPrim().GetPrimPath();
-	}
-	else
-	{
-		TF_RUNTIME_ERROR("Provided UsdPhysicsScene or UsdPhysicsSceneDesc is not valid.");
-		return false;
-	}
-	return true;
+    if (sceneDesc && scene)
+    {
+        UsdStageWeakPtr stage = scene.GetPrim().GetStage();
+
+        GfVec3f gravityDirection;
+        scene.GetGravityDirectionAttr().Get(&gravityDirection);
+        if (gravityDirection == GfVec3f(0.0f))
+        {
+            TfToken upAxis = UsdGeomGetStageUpAxis(stage);
+            if (upAxis == UsdGeomTokens.Get()->x)
+                gravityDirection = GfVec3f(-1.0f, 0.0f, 0.0f);
+            else if (upAxis == UsdGeomTokens.Get()->y)
+                gravityDirection = GfVec3f(0.0f, -1.0f, 0.0f);
+            else
+                gravityDirection = GfVec3f(0.0f, 0.0f, -1.0f);
+        }
+        else
+        {
+            gravityDirection.Normalize();
+        }
+
+        float gravityMagnitude;
+        scene.GetGravityMagnitudeAttr().Get(&gravityMagnitude);
+        if (gravityMagnitude < -0.5e38f)
+        {
+            float metersPerUnit = (float)UsdGeomGetStageMetersPerUnit(stage);
+            gravityMagnitude = 9.81f / metersPerUnit;
+        }
+
+        sceneDesc->gravityMagnitude = gravityMagnitude;
+        sceneDesc->gravityDirection = gravityDirection;
+        sceneDesc->primPath = scene.GetPrim().GetPrimPath();
+    }
+    else
+    {
+        TF_RUNTIME_ERROR("Provided UsdPhysicsScene or UsdPhysicsSceneDesc is not valid.");
+        return false;
+    }
+    return true;
 }
 
 struct SchemaAPIFlag
 {
-	enum Enum
-	{
-		eArticulationRootAPI = 1 << 0,
-		eCollisionAPI = 1 << 1,
-		eRigidBodyAPI = 1 << 2,
-		eMaterialAPI = 1 << 3
-	};
+    enum Enum
+    {
+        eArticulationRootAPI = 1 << 0,
+        eCollisionAPI = 1 << 1,
+        eRigidBodyAPI = 1 << 2,
+        eMaterialAPI = 1 << 3
+    };
 };
 
-bool CheckNestedArticulationRoot(const pxr::UsdPrim& usdPrim,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& articulationSet)
+bool CheckNestedArticulationRoot(const UsdPrim& usdPrim,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& articulationSet)
 {
-	UsdPrim parent = usdPrim.GetParent();
-	while (parent && parent != usdPrim.GetStage()->GetPseudoRoot())
-	{
-		if (articulationSet.find(parent.GetPrimPath()) != articulationSet.end())
-			return true;
-		parent = parent.GetParent();
-	}
-
-	return false;
+    UsdPrim parent = usdPrim.GetParent();
+    while (parent && parent != usdPrim.GetStage()->GetPseudoRoot())
+    {
+        if (articulationSet.find(parent.GetPrimPath()) != articulationSet.end())
+            return true;
+        parent = parent.GetParent();
+    }
+
+    return false;
 }
 
-using RigidBodyMap = std::map<pxr::SdfPath, UsdPhysicsRigidBodyDesc*>;
+using RigidBodyMap = std::map<SdfPath, UsdPhysicsRigidBodyDesc*>;
 
 bool IsDynamicBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap, bool& physicsAPIFound)
 {
-	RigidBodyMap::const_iterator it = bodyMap.find(usdPrim.GetPrimPath());
-	if (it != bodyMap.end())
-	{
-		{
-			bool isAPISchemaEnabled = it->second->rigidBodyEnabled;
-
-			// Prim is dynamic body off PhysicsAPI is present and enabled
-			physicsAPIFound = true;
-			return isAPISchemaEnabled;
-		}
-	}
-
-	physicsAPIFound = false;
-	return false;
+    RigidBodyMap::const_iterator it = bodyMap.find(usdPrim.GetPrimPath());
+    if (it != bodyMap.end())
+    {
+        {
+            bool isAPISchemaEnabled = it->second->rigidBodyEnabled;
+
+            // Prim is dynamic body off PhysicsAPI is present and enabled
+            physicsAPIFound = true;
+            return isAPISchemaEnabled;
+        }
+    }
+
+    physicsAPIFound = false;
+    return false;
 }
 
 
 bool HasDynamicBodyParent(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap,
-	UsdPrim& bodyPrimPath)
+    UsdPrim& bodyPrimPath)
 {
-	bool physicsAPIFound = false;
-	UsdPrim parent = usdPrim;
-	while (parent != usdPrim.GetStage()->GetPseudoRoot())
-	{
-		if (IsDynamicBody(parent, bodyMap, physicsAPIFound))
-		{
-			bodyPrimPath = parent;
-			return true;
-		}
-
-		if (physicsAPIFound)
-		{
-			bodyPrimPath = parent;
-			return false;
-		}
-
-		parent = parent.GetParent();
-	}
-	return false;
+    bool physicsAPIFound = false;
+    UsdPrim parent = usdPrim;
+    while (parent != usdPrim.GetStage()->GetPseudoRoot())
+    {
+        if (IsDynamicBody(parent, bodyMap, physicsAPIFound))
+        {
+            bodyPrimPath = parent;
+            return true;
+        }
+
+        if (physicsAPIFound)
+        {
+            bodyPrimPath = parent;
+            return false;
+        }
+
+        parent = parent.GetParent();
+    }
+    return false;
 }
 
 
 template <typename DescType, typename UsdType>
 void ProcessPhysicsPrims(const std::vector<UsdPrim>& physicsPrims,
-	std::vector<DescType>& physicsDesc,
-	std::function<bool(const UsdType& prim, DescType* desc)> processDescFn)
+    std::vector<DescType>& physicsDesc,
+    std::function<bool(const UsdType& prim, DescType* desc)> processDescFn)
 {
-	if (!physicsPrims.empty())
-	{
-		const size_t numPrims = physicsPrims.size();
-		physicsDesc.resize(numPrims);
-
-		const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
-		{
-			for (size_t i = beginIdx; i < endIdx; i++)
-			{
-				const UsdType prim(physicsPrims[i]);
-				const bool ret = processDescFn(prim, &physicsDesc[i]);
-				if (!ret)
-				{
-					physicsDesc[i].isValid = false;
-				}
-			}
-		};
-
-		const size_t numPrimPerBatch = 10;
-		WorkParallelForN(numPrims, workLambda, numPrimPerBatch);
-	}
+    if (!physicsPrims.empty())
+    {
+        const size_t numPrims = physicsPrims.size();
+        physicsDesc.resize(numPrims);
+
+        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
+        {
+            for (size_t i = beginIdx; i < endIdx; i++)
+            {
+                const UsdType prim(physicsPrims[i]);
+                const bool ret = processDescFn(prim, &physicsDesc[i]);
+                if (!ret)
+                {
+                    physicsDesc[i].isValid = false;
+                }
+            }
+        };
+
+        const size_t numPrimPerBatch = 10;
+        WorkParallelForN(numPrims, workLambda, numPrimPerBatch);
+    }
 }
 
 template <typename DescType>
 void CallReportFn(UsdPhysicsObjectType::Enum descType,
-	const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc,
-	UsdPhysicsReportFn reportFn, SdfPathVector& primPathsVector, void* userData)
+    const std::vector<UsdPrim>& physicsPrims, const std::vector<DescType>& physicsDesc,
+    UsdPhysicsReportFn reportFn, SdfPathVector& primPathsVector, void* userData)
 {
-	primPathsVector.resize(physicsPrims.size());
-	for (size_t i = 0; i < physicsPrims.size(); i++)
-	{
-		primPathsVector[i] = physicsPrims[i].GetPrimPath();
-	}
-	reportFn(descType, primPathsVector.size(), primPathsVector.data(), physicsDesc.data(), userData);
+    primPathsVector.resize(physicsPrims.size());
+    for (size_t i = 0; i < physicsPrims.size(); i++)
+    {
+        primPathsVector[i] = physicsPrims[i].GetPrimPath();
+    }
+    reportFn(descType, primPathsVector.size(), primPathsVector.data(), physicsDesc.data(), userData);
 }
 
 void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims,
-	std::vector<UsdPhysicsRigidBodyDesc>& rigidBodyDescs,
-	bool defaultSimulationOwner, std::unordered_set<SdfPath, SdfPath::Hash>& reportedBodies,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+    std::vector<UsdPhysicsRigidBodyDesc>& rigidBodyDescs,
+    bool defaultSimulationOwner, std::unordered_set<SdfPath, SdfPath::Hash>& reportedBodies,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
-	for (size_t i = rigidBodyDescs.size(); i--;)
-	{
-		bool ownerFound = false;
-		const UsdPhysicsRigidBodyDesc& desc = rigidBodyDescs[i];
-		if (desc.isValid)
-		{
-			if (desc.simulationOwners.empty() && defaultSimulationOwner)
-			{
-				reportedBodies.insert(desc.primPath);
-				ownerFound = true;
-			}
-			else
-			{
-				for (const SdfPath& owner : desc.simulationOwners)
-				{
-					if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-					{
-						reportedBodies.insert(desc.primPath);
-						ownerFound = true;
-						break;
-					}
-				}
-			}
-		}
-		if (!ownerFound)
-		{
-			rigidBodyDescs[i] = rigidBodyDescs.back();
-			rigidBodyDescs.pop_back();
-			rigidBodyPrims[i] = rigidBodyPrims.back();
-			rigidBodyPrims.pop_back();
-		}
-	}
+    for (size_t i = rigidBodyDescs.size(); i--;)
+    {
+        bool ownerFound = false;
+        const UsdPhysicsRigidBodyDesc& desc = rigidBodyDescs[i];
+        if (desc.isValid)
+        {
+            if (desc.simulationOwners.empty() && defaultSimulationOwner)
+            {
+                reportedBodies.insert(desc.primPath);
+                ownerFound = true;
+            }
+            else
+            {
+                for (const SdfPath& owner : desc.simulationOwners)
+                {
+                    if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+                    {
+                        reportedBodies.insert(desc.primPath);
+                        ownerFound = true;
+                        break;
+                    }
+                }
+            }
+        }
+        if (!ownerFound)
+        {
+            rigidBodyDescs[i] = rigidBodyDescs.back();
+            rigidBodyDescs.pop_back();
+            rigidBodyPrims[i] = rigidBodyPrims.back();
+            rigidBodyPrims.pop_back();
+        }
+    }
 }
 
 // if collision belongs to a body that we care about include it
@@ -1694,1430 +1694,1430 @@ void CheckRigidBodySimulationOwner(std::vector<UsdPrim>& rigidBodyPrims,
 // if collision does not have a body set, we check its own simulationOwners
 template <typename DescType>
 void CheckCollisionSimulationOwner(std::vector<UsdPrim>& collisionPrims,
-	std::vector<DescType>& shapeDesc,
-	bool defaultSimulationOwner,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+    std::vector<DescType>& shapeDesc,
+    bool defaultSimulationOwner,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
-	for (size_t i = shapeDesc.size(); i--;)
-	{
-		bool ownerFound = false;
-		const UsdPhysicsShapeDesc& desc = shapeDesc[i];
-		if (desc.isValid)
-		{
-			if (desc.rigidBody != SdfPath() &&
-				rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
-			{
-				if (desc.rigidBody != SdfPath() &&
-					rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
-				{
-					ownerFound = true;
-				}
-				else
-				{
-					if (desc.rigidBody == SdfPath())
-					{
-						if (desc.simulationOwners.empty() && defaultSimulationOwner)
-						{
-							ownerFound = true;
-						}
-						else
-						{
-							for (const SdfPath& owner : desc.simulationOwners)
-							{
-								if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-								{
-									ownerFound = true;
-									break;
-								}
-							}
-						}
-					}
-				}
-
-				ownerFound = true;
-			}
-			else
-			{
-				if (desc.rigidBody == SdfPath())
-				{
-					if (desc.simulationOwners.empty() && defaultSimulationOwner)
-					{
-						ownerFound = true;
-					}
-					else
-					{
-						for (const SdfPath& owner : desc.simulationOwners)
-						{
-							if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
-							{
-								ownerFound = true;
-								break;
-							}
-						}
-					}
-				}
-			}
-		}
-
-		if (!ownerFound)
-		{
-			shapeDesc[i] = shapeDesc.back();
-			shapeDesc.pop_back();
-			collisionPrims[i] = collisionPrims.back();
-			collisionPrims.pop_back();
-		}
-	}
+    for (size_t i = shapeDesc.size(); i--;)
+    {
+        bool ownerFound = false;
+        const UsdPhysicsShapeDesc& desc = shapeDesc[i];
+        if (desc.isValid)
+        {
+            if (desc.rigidBody != SdfPath() &&
+                rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+            {
+                if (desc.rigidBody != SdfPath() &&
+                    rigidBodiesSet.find(desc.rigidBody) != rigidBodiesSet.end())
+                {
+                    ownerFound = true;
+                }
+                else
+                {
+                    if (desc.rigidBody == SdfPath())
+                    {
+                        if (desc.simulationOwners.empty() && defaultSimulationOwner)
+                        {
+                            ownerFound = true;
+                        }
+                        else
+                        {
+                            for (const SdfPath& owner : desc.simulationOwners)
+                            {
+                                if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+                                {
+                                    ownerFound = true;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                ownerFound = true;
+            }
+            else
+            {
+                if (desc.rigidBody == SdfPath())
+                {
+                    if (desc.simulationOwners.empty() && defaultSimulationOwner)
+                    {
+                        ownerFound = true;
+                    }
+                    else
+                    {
+                        for (const SdfPath& owner : desc.simulationOwners)
+                        {
+                            if (simulationOwnersSet.find(owner) != simulationOwnersSet.end())
+                            {
+                                ownerFound = true;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!ownerFound)
+        {
+            shapeDesc[i] = shapeDesc.back();
+            shapeDesc.pop_back();
+            collisionPrims[i] = collisionPrims.back();
+            collisionPrims.pop_back();
+        }
+    }
 }
 
 // Both bodies need to have simulation owners valid
 template <typename DescType>
 void CheckJointSimulationOwner(std::vector<UsdPrim>& jointPrims,
-	std::vector<DescType>& jointDesc,
-	bool defaultSimulationOwner, const std::unordered_set<SdfPath,
-	SdfPath::Hash>& rigidBodiesSet,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+    std::vector<DescType>& jointDesc,
+    bool defaultSimulationOwner, const std::unordered_set<SdfPath,
+    SdfPath::Hash>& rigidBodiesSet,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
-	for (size_t i = jointDesc.size(); i--;)
-	{
-		const UsdPhysicsJointDesc& desc = jointDesc[i];
-
-		bool ownersValid = false;
-		if (desc.isValid)
-		{
-			if ((desc.body0 == SdfPath() ||
-				rigidBodiesSet.find(desc.body0) != rigidBodiesSet.end()) &&
-				(desc.body1 == SdfPath() ||
-					rigidBodiesSet.find(desc.body1) != rigidBodiesSet.end()))
-			{
-				ownersValid = true;
-			}
-		}
-
-		if (!ownersValid)
-		{
-			jointDesc[i] = jointDesc.back();
-			jointDesc.pop_back();
-			jointPrims[i] = jointPrims.back();
-			jointPrims.pop_back();
-		}
-	}
+    for (size_t i = jointDesc.size(); i--;)
+    {
+        const UsdPhysicsJointDesc& desc = jointDesc[i];
+
+        bool ownersValid = false;
+        if (desc.isValid)
+        {
+            if ((desc.body0 == SdfPath() ||
+                rigidBodiesSet.find(desc.body0) != rigidBodiesSet.end()) &&
+                (desc.body1 == SdfPath() ||
+                    rigidBodiesSet.find(desc.body1) != rigidBodiesSet.end()))
+            {
+                ownersValid = true;
+            }
+        }
+
+        if (!ownersValid)
+        {
+            jointDesc[i] = jointDesc.back();
+            jointDesc.pop_back();
+            jointPrims[i] = jointPrims.back();
+            jointPrims.pop_back();
+        }
+    }
 }
 
 // all bodies must have valid owner
 void CheckArticulationSimulationOwner(std::vector<UsdPrim>& articulationPrims,
-	std::vector<UsdPhysicsArticulationDesc>& articulationDescs,
-	bool defaultSimulationOwner,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
-	const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
+    std::vector<UsdPhysicsArticulationDesc>& articulationDescs,
+    bool defaultSimulationOwner,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& rigidBodiesSet,
+    const std::unordered_set<SdfPath, SdfPath::Hash>& simulationOwnersSet)
 {
-	for (size_t i = articulationDescs.size(); i--;)
-	{
-		const UsdPhysicsArticulationDesc& desc = articulationDescs[i];
-
-		bool ownersValid = true;
-		if (desc.isValid)
-		{
-			for (const SdfPath& body : desc.articulatedBodies)
-			{
-				if (body != SdfPath() && rigidBodiesSet.find(body) == rigidBodiesSet.end())
-				{
-					ownersValid = false;
-					break;
-				}
-			}
-		}
-
-		if (!ownersValid)
-		{
-			articulationDescs[i] = articulationDescs.back();
-			articulationDescs.pop_back();
-			articulationPrims[i] = articulationPrims.back();
-			articulationPrims.pop_back();
-		}
-	}
+    for (size_t i = articulationDescs.size(); i--;)
+    {
+        const UsdPhysicsArticulationDesc& desc = articulationDescs[i];
+
+        bool ownersValid = true;
+        if (desc.isValid)
+        {
+            for (const SdfPath& body : desc.articulatedBodies)
+            {
+                if (body != SdfPath() && rigidBodiesSet.find(body) == rigidBodiesSet.end())
+                {
+                    ownersValid = false;
+                    break;
+                }
+            }
+        }
+
+        if (!ownersValid)
+        {
+            articulationDescs[i] = articulationDescs.back();
+            articulationDescs.pop_back();
+            articulationPrims[i] = articulationPrims.back();
+            articulationPrims.pop_back();
+        }
+    }
 }
 
 SdfPath GetRigidBody(const UsdPrim& usdPrim, const RigidBodyMap& bodyMap)
 {
-	UsdPrim bodyPrim = UsdPrim();
-	if (HasDynamicBodyParent(usdPrim, bodyMap, bodyPrim))
-	{
-		return bodyPrim.GetPrimPath();
-	}
-	else
-	{
-		// collision does not have a dynamic body parent, it is considered a static collision        
-		if (bodyPrim == UsdPrim())
-		{
-			return SdfPath();
-		}
-		else
-		{
-			return bodyPrim.GetPrimPath();
-		}
-	}
+    UsdPrim bodyPrim = UsdPrim();
+    if (HasDynamicBodyParent(usdPrim, bodyMap, bodyPrim))
+    {
+        return bodyPrim.GetPrimPath();
+    }
+    else
+    {
+        // collision does not have a dynamic body parent, it is considered a static collision        
+        if (bodyPrim == UsdPrim())
+        {
+            return SdfPath();
+        }
+        else
+        {
+            return bodyPrim.GetPrimPath();
+        }
+    }
 }
 
 void GetCollisionShapeLocalTransfrom(const UsdPrim& collisionPrim,
-	const UsdPrim& bodyPrim,
-	GfVec3f& localPosOut,
-	GfQuatf& localRotOut,
-	GfVec3f& localScaleOut)
+    const UsdPrim& bodyPrim,
+    GfVec3f& localPosOut,
+    GfQuatf& localRotOut,
+    GfVec3f& localScaleOut)
 {
-	// body transform
-	const GfMatrix4d bodyLocalToWorldMatrix =
-		UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-
-	// compute the shape rel transform to a body and store it.
-	pxr::GfVec3f localPos(0.0f);
-	if (collisionPrim != bodyPrim)
-	{
-		const GfMatrix4d collisionLocalToWorldMatrix =
-			UsdGeomXformable(collisionPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
-
-		const pxr::GfMatrix4d mat =
-			collisionLocalToWorldMatrix * bodyLocalToWorldMatrix.GetInverse();
-		GfTransform colLocalTransform(mat);
-
-		localPos = pxr::GfVec3f(colLocalTransform.GetTranslation());
-		localRotOut = pxr::GfQuatf(colLocalTransform.GetRotation().GetQuat());
-		localScaleOut = pxr::GfVec3f(colLocalTransform.GetScale());
-	}
-	else
-	{
-		const pxr::GfMatrix4d mat(1.0);
-
-		localRotOut = pxr::GfQuatf(1.0f);
-		localScaleOut = pxr::GfVec3f(1.0f);
-	}
-
-	// now apply the body scale to localPos
-	// physics does not support scales, so a rigid body scale has to be baked 
-	// into the localPos
-	const pxr::GfTransform tr(bodyLocalToWorldMatrix);
-	const pxr::GfVec3d sc = tr.GetScale();
-
-	for (int i = 0; i < 3; i++)
-	{
-		localPos[i] *= (float)sc[i];
-	}
-
-	localPosOut = localPos;
+    // body transform
+    const GfMatrix4d bodyLocalToWorldMatrix =
+        UsdGeomXformable(bodyPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+
+    // compute the shape rel transform to a body and store it.
+    GfVec3f localPos(0.0f);
+    if (collisionPrim != bodyPrim)
+    {
+        const GfMatrix4d collisionLocalToWorldMatrix =
+            UsdGeomXformable(collisionPrim).ComputeLocalToWorldTransform(UsdTimeCode::Default());
+
+        const GfMatrix4d mat =
+            collisionLocalToWorldMatrix * bodyLocalToWorldMatrix.GetInverse();
+        GfTransform colLocalTransform(mat);
+
+        localPos = GfVec3f(colLocalTransform.GetTranslation());
+        localRotOut = GfQuatf(colLocalTransform.GetRotation().GetQuat());
+        localScaleOut = GfVec3f(colLocalTransform.GetScale());
+    }
+    else
+    {
+        const GfMatrix4d mat(1.0);
+
+        localRotOut = GfQuatf(1.0f);
+        localScaleOut = GfVec3f(1.0f);
+    }
+
+    // now apply the body scale to localPos
+    // physics does not support scales, so a rigid body scale has to be baked 
+    // into the localPos
+    const GfTransform tr(bodyLocalToWorldMatrix);
+    const GfVec3d sc = tr.GetScale();
+
+    for (int i = 0; i < 3; i++)
+    {
+        localPos[i] *= (float)sc[i];
+    }
+
+    localPosOut = localPos;
 }
 
 void FinalizeCollision(UsdStageWeakPtr stage, const UsdPhysicsRigidBodyDesc* bodyDesc,
-	UsdPhysicsShapeDesc* shapeDesc)
+    UsdPhysicsShapeDesc* shapeDesc)
 {
-	// get shape local pose
-	const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
-	GetCollisionShapeLocalTransfrom(shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
-		shapeDesc->localPos, shapeDesc->localRot, shapeDesc->localScale);
-
-	if (bodyDesc)
-	{
-		shapeDesc->rigidBody = bodyDesc->primPath;
-	}
+    // get shape local pose
+    const UsdPrim shapePrim = stage->GetPrimAtPath(shapeDesc->primPath);
+    GetCollisionShapeLocalTransfrom(shapePrim, bodyDesc ? stage->GetPrimAtPath(bodyDesc->primPath) : stage->GetPseudoRoot(),
+        shapeDesc->localPos, shapeDesc->localRot, shapeDesc->localScale);
+
+    if (bodyDesc)
+    {
+        shapeDesc->rigidBody = bodyDesc->primPath;
+    }
 }
 
 template <typename DescType>
 void FinalizeCollisionDescs(UsdGeomXformCache& xfCache,
-	const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc,
-	const RigidBodyMap& bodyMap,
-	const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
+    const std::vector<UsdPrim>& physicsPrims, std::vector<DescType>& physicsDesc,
+    const RigidBodyMap& bodyMap,
+    const std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>>& collisionGroups)
 {
-	const auto workLambda = [physicsPrims, &physicsDesc, bodyMap, collisionGroups]
-	(const size_t beginIdx, const size_t endIdx)
-	{
-		for (size_t i = beginIdx; i < endIdx; i++)
-		{
-			DescType& colDesc = physicsDesc[i];
-			if (colDesc.isValid)
-			{
-				const UsdPrim prim = physicsPrims[i];
-				// get the body
-				SdfPath bodyPath = GetRigidBody(prim, bodyMap);
-				// body was found, add collision to the body
-				UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
-				if (bodyPath != SdfPath())
-				{
-					RigidBodyMap::const_iterator bodyIt = bodyMap.find(bodyPath);
-					if (bodyIt != bodyMap.end())
-					{
-						bodyDesc = bodyIt->second;
-						bodyDesc->collisions.push_back(colDesc.primPath);
-					}
-				}
-
-				// check if collision belongs to collision groups
-				for (std::map<SdfPath,
-					std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
-					it != collisionGroups.end(); ++it)
-				{
-					if (it->second.find(colDesc.primPath) != it->second.end())
-					{
-						colDesc.collisionGroups.push_back(it->first);
-					}
-				}
-
-				// finalize the collision, fill up the local transform etc
-				FinalizeCollision(prim.GetStage(), bodyDesc, &colDesc);
-			}
-		}
-	};
-
-	const size_t numPrimPerBatch = 10;
-	WorkParallelForN(physicsPrims.size(), workLambda, numPrimPerBatch);
+    const auto workLambda = [physicsPrims, &physicsDesc, bodyMap, collisionGroups]
+    (const size_t beginIdx, const size_t endIdx)
+    {
+        for (size_t i = beginIdx; i < endIdx; i++)
+        {
+            DescType& colDesc = physicsDesc[i];
+            if (colDesc.isValid)
+            {
+                const UsdPrim prim = physicsPrims[i];
+                // get the body
+                SdfPath bodyPath = GetRigidBody(prim, bodyMap);
+                // body was found, add collision to the body
+                UsdPhysicsRigidBodyDesc* bodyDesc = nullptr;
+                if (bodyPath != SdfPath())
+                {
+                    RigidBodyMap::const_iterator bodyIt = bodyMap.find(bodyPath);
+                    if (bodyIt != bodyMap.end())
+                    {
+                        bodyDesc = bodyIt->second;
+                        bodyDesc->collisions.push_back(colDesc.primPath);
+                    }
+                }
+
+                // check if collision belongs to collision groups
+                for (std::map<SdfPath,
+                    std::unordered_set<SdfPath, SdfPath::Hash>>::const_iterator it = collisionGroups.begin();
+                    it != collisionGroups.end(); ++it)
+                {
+                    if (it->second.find(colDesc.primPath) != it->second.end())
+                    {
+                        colDesc.collisionGroups.push_back(it->first);
+                    }
+                }
+
+                // finalize the collision, fill up the local transform etc
+                FinalizeCollision(prim.GetStage(), bodyDesc, &colDesc);
+            }
+        }
+    };
+
+    const size_t numPrimPerBatch = 10;
+    WorkParallelForN(physicsPrims.size(), workLambda, numPrimPerBatch);
 }
 
 struct ArticulationLink
 {
-	SdfPathVector   childs;
-	SdfPath         rootJoint;
-	uint32_t        weight;
-	uint32_t        index;
-	bool            hasFixedJoint;
-	SdfPathVector   joints;
+    SdfPathVector   childs;
+    SdfPath         rootJoint;
+    uint32_t        weight;
+    uint32_t        index;
+    bool            hasFixedJoint;
+    SdfPathVector   joints;
 };
 
-using ArticulationLinkMap = std::map<pxr::SdfPath, ArticulationLink>;
+using ArticulationLinkMap = std::map<SdfPath, ArticulationLink>;
 using BodyJointMap =
-pxr::TfHashMap<pxr::SdfPath, std::vector<const UsdPhysicsJointDesc*>, pxr::SdfPath::Hash>;
-using JointMap = std::map<pxr::SdfPath, UsdPhysicsJointDesc*>;
-using ArticulationMap = std::map<pxr::SdfPath, UsdPhysicsArticulationDesc*>;
+TfHashMap<SdfPath, std::vector<const UsdPhysicsJointDesc*>, SdfPath::Hash>;
+using JointMap = std::map<SdfPath, UsdPhysicsJointDesc*>;
+using ArticulationMap = std::map<SdfPath, UsdPhysicsArticulationDesc*>;
 
 bool IsInLinkMap(const SdfPath& path, const std::vector<ArticulationLinkMap>& linkMaps)
 {
-	for (size_t i = 0; i < linkMaps.size(); i++)
-	{
-		ArticulationLinkMap::const_iterator it = linkMaps[i].find(path);
-		if (it != linkMaps[i].end())
-			return true;
-	}
-
-	return false;
+    for (size_t i = 0; i < linkMaps.size(); i++)
+    {
+        ArticulationLinkMap::const_iterator it = linkMaps[i].find(path);
+        if (it != linkMaps[i].end())
+            return true;
+    }
+
+    return false;
 }
 
-void TraverseHierarchy(const pxr::UsdStageWeakPtr stage, const SdfPath& linkPath,
-	ArticulationLinkMap& articulationLinkMap, const BodyJointMap& bodyJointMap,
-	uint32_t& index, SdfPathVector& linkOrderVector)
+void TraverseHierarchy(const UsdStageWeakPtr stage, const SdfPath& linkPath,
+    ArticulationLinkMap& articulationLinkMap, const BodyJointMap& bodyJointMap,
+    uint32_t& index, SdfPathVector& linkOrderVector)
 {
-	// check if we already parsed this link
-	ArticulationLinkMap::const_iterator artIt = articulationLinkMap.find(linkPath);
-	if (artIt != articulationLinkMap.end())
-		return;
-
-	linkOrderVector.push_back(linkPath);
-
-	BodyJointMap::const_iterator bjIt = bodyJointMap.find(linkPath);
-	if (bjIt != bodyJointMap.end())
-	{
-		ArticulationLink& link = articulationLinkMap[linkPath];
-		link.weight = 0;
-		link.index = index++;
-		link.hasFixedJoint = false;
-		const std::vector<const UsdPhysicsJointDesc*>& joints = bjIt->second;
-		for (size_t i = 0; i < joints.size(); i++)
-		{
-			const UsdPhysicsJointDesc* desc = joints[i];
-			link.joints.push_back(desc->primPath);
-			if (desc->body0 == SdfPath() || (bodyJointMap.find(desc->body0) == bodyJointMap.end()) ||
-				desc->body1 == SdfPath() || (bodyJointMap.find(desc->body1) == bodyJointMap.end()))
-			{
-				if (desc->excludeFromArticulation)
-				{
-					link.weight += 1000;
-				}
-				else
-				{
-					link.weight += 100000;
-					link.rootJoint = desc->primPath;
-					link.hasFixedJoint = true;
-				}
-				link.childs.push_back(SdfPath());
-			}
-			else
-			{
-				if (desc->excludeFromArticulation)
-				{
-					link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
-					link.weight += 1000;
-				}
-				else
-				{
-					link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
-					link.weight += 100;
-					TraverseHierarchy(stage, link.childs.back(), articulationLinkMap, bodyJointMap, index, linkOrderVector);
-				}
-			}
-		}
-	}
+    // check if we already parsed this link
+    ArticulationLinkMap::const_iterator artIt = articulationLinkMap.find(linkPath);
+    if (artIt != articulationLinkMap.end())
+        return;
+
+    linkOrderVector.push_back(linkPath);
+
+    BodyJointMap::const_iterator bjIt = bodyJointMap.find(linkPath);
+    if (bjIt != bodyJointMap.end())
+    {
+        ArticulationLink& link = articulationLinkMap[linkPath];
+        link.weight = 0;
+        link.index = index++;
+        link.hasFixedJoint = false;
+        const std::vector<const UsdPhysicsJointDesc*>& joints = bjIt->second;
+        for (size_t i = 0; i < joints.size(); i++)
+        {
+            const UsdPhysicsJointDesc* desc = joints[i];
+            link.joints.push_back(desc->primPath);
+            if (desc->body0 == SdfPath() || (bodyJointMap.find(desc->body0) == bodyJointMap.end()) ||
+                desc->body1 == SdfPath() || (bodyJointMap.find(desc->body1) == bodyJointMap.end()))
+            {
+                if (desc->excludeFromArticulation)
+                {
+                    link.weight += 1000;
+                }
+                else
+                {
+                    link.weight += 100000;
+                    link.rootJoint = desc->primPath;
+                    link.hasFixedJoint = true;
+                }
+                link.childs.push_back(SdfPath());
+            }
+            else
+            {
+                if (desc->excludeFromArticulation)
+                {
+                    link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
+                    link.weight += 1000;
+                }
+                else
+                {
+                    link.childs.push_back(desc->body0 == linkPath ? desc->body1 : desc->body0);
+                    link.weight += 100;
+                    TraverseHierarchy(stage, link.childs.back(), articulationLinkMap, bodyJointMap, index, linkOrderVector);
+                }
+            }
+        }
+    }
 }
 
 void TraverseChilds(const ArticulationLink& link, const ArticulationLinkMap& map,
-	uint32_t startIndex, uint32_t distance, int32_t* pathMatrix)
+    uint32_t startIndex, uint32_t distance, int32_t* pathMatrix)
 {
-	const size_t mapSize = map.size();
-	const uint32_t currentIndex = link.index;
-	pathMatrix[startIndex + currentIndex * mapSize] = distance;
-
-	for (size_t i = 0; i < link.childs.size(); i++)
-	{
-		ArticulationLinkMap::const_iterator it = map.find(link.childs[i]);
-		if (it != map.end())
-		{
-			const uint32_t childIndex = it->second.index;
-			if (pathMatrix[startIndex + childIndex * mapSize] < 0)
-			{
-				TraverseChilds(it->second, map, startIndex, distance + 1, pathMatrix);
-			}
-		}
-	}
+    const size_t mapSize = map.size();
+    const uint32_t currentIndex = link.index;
+    pathMatrix[startIndex + currentIndex * mapSize] = distance;
+
+    for (size_t i = 0; i < link.childs.size(); i++)
+    {
+        ArticulationLinkMap::const_iterator it = map.find(link.childs[i]);
+        if (it != map.end())
+        {
+            const uint32_t childIndex = it->second.index;
+            if (pathMatrix[startIndex + childIndex * mapSize] < 0)
+            {
+                TraverseChilds(it->second, map, startIndex, distance + 1, pathMatrix);
+            }
+        }
+    }
 }
 
-pxr::SdfPath GetCenterOfGraph(const ArticulationLinkMap& map, const SdfPathVector& linkOrderVector)
+SdfPath GetCenterOfGraph(const ArticulationLinkMap& map, const SdfPathVector& linkOrderVector)
 {
-	const size_t size = map.size();
-	int32_t* pathMatrix = new int32_t[size * size];
-	for (size_t i = 0; i < size; i++)
-	{
-		for (size_t j = 0; j < size; j++)
-		{
-			pathMatrix[i + j * size] = -1;
-		}
-	}
-
-	for (ArticulationLinkMap::const_reference& ref : map)
-	{
-		const uint32_t startIndex = ref.second.index;
-		uint32_t distance = 0;
-		TraverseChilds(ref.second, map, startIndex, distance, pathMatrix);
-	}
-
-	int32_t shortestDistance = INT_MAX;
-	size_t numChilds = 0;
-	SdfPath primpath = SdfPath();
-	for (ArticulationLinkMap::const_reference& ref : map)
-	{
-		const uint32_t startIndex = ref.second.index;
-		int32_t longestPath = 0;
-		for (size_t i = 0; i < size; i++)
-		{
-			if (pathMatrix[startIndex + i * size] > longestPath)
-			{
-				longestPath = pathMatrix[startIndex + i * size];
-			}
-		}
-
-		// this needs to be deterministic, get the shortest path
-		// if there are more paths with same lenght, pick the one with more childs
-		// if there are more with same path and same amount of childs, pick the 
-		// one with lowest hash
-		// The lowest hash is not right, this is wrong, it has to be the first link 
-		// ordered by the traversal
-		if (longestPath < shortestDistance)
-		{
-			shortestDistance = longestPath;
-			numChilds = ref.second.childs.size();
-			primpath = ref.first;
-		}
-		else if (longestPath == shortestDistance)
-		{
-			if (numChilds < ref.second.childs.size())
-			{
-				numChilds = ref.second.childs.size();
-				primpath = ref.first;
-			}
-			else if (numChilds == ref.second.childs.size())
-			{
-				for (const SdfPath& orderPath : linkOrderVector)
-				{
-					if (orderPath == primpath)
-					{
-						break;
-					}
-					else if (orderPath == ref.first)
-					{
-						primpath = ref.first;
-					}
-				}
-			}
-		}
-	}
-
-	delete[] pathMatrix;
-
-	return primpath;
+    const size_t size = map.size();
+    int32_t* pathMatrix = new int32_t[size * size];
+    for (size_t i = 0; i < size; i++)
+    {
+        for (size_t j = 0; j < size; j++)
+        {
+            pathMatrix[i + j * size] = -1;
+        }
+    }
+
+    for (ArticulationLinkMap::const_reference& ref : map)
+    {
+        const uint32_t startIndex = ref.second.index;
+        uint32_t distance = 0;
+        TraverseChilds(ref.second, map, startIndex, distance, pathMatrix);
+    }
+
+    int32_t shortestDistance = INT_MAX;
+    size_t numChilds = 0;
+    SdfPath primpath = SdfPath();
+    for (ArticulationLinkMap::const_reference& ref : map)
+    {
+        const uint32_t startIndex = ref.second.index;
+        int32_t longestPath = 0;
+        for (size_t i = 0; i < size; i++)
+        {
+            if (pathMatrix[startIndex + i * size] > longestPath)
+            {
+                longestPath = pathMatrix[startIndex + i * size];
+            }
+        }
+
+        // this needs to be deterministic, get the shortest path
+        // if there are more paths with same lenght, pick the one with more childs
+        // if there are more with same path and same amount of childs, pick the 
+        // one with lowest hash
+        // The lowest hash is not right, this is wrong, it has to be the first link 
+        // ordered by the traversal
+        if (longestPath < shortestDistance)
+        {
+            shortestDistance = longestPath;
+            numChilds = ref.second.childs.size();
+            primpath = ref.first;
+        }
+        else if (longestPath == shortestDistance)
+        {
+            if (numChilds < ref.second.childs.size())
+            {
+                numChilds = ref.second.childs.size();
+                primpath = ref.first;
+            }
+            else if (numChilds == ref.second.childs.size())
+            {
+                for (const SdfPath& orderPath : linkOrderVector)
+                {
+                    if (orderPath == primpath)
+                    {
+                        break;
+                    }
+                    else if (orderPath == ref.first)
+                    {
+                        primpath = ref.first;
+                    }
+                }
+            }
+        }
+    }
+
+    delete[] pathMatrix;
+
+    return primpath;
 }
 
-void FinalizeArticulations(const pxr::UsdStageWeakPtr stage,
-	ArticulationMap& articulationMap, const RigidBodyMap& rigidBodyMap,
-	const JointMap& jointMap)
+void FinalizeArticulations(const UsdStageWeakPtr stage,
+    ArticulationMap& articulationMap, const RigidBodyMap& rigidBodyMap,
+    const JointMap& jointMap)
 {
-	BodyJointMap bodyJointMap;
-	if (!articulationMap.empty())
-	{
-		// construct the BodyJointMap
-		bodyJointMap.reserve(rigidBodyMap.size());
-		for (JointMap::const_reference& jointIt : jointMap)
-		{
-			const UsdPhysicsJointDesc* desc = jointIt.second;
-			if (desc->jointEnabled)
-			{
-				if (desc->body0 != SdfPath())
-				{
-					RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body0);
-					if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled &&
-						!fit->second->kinematicBody)
-					{
-						bodyJointMap[desc->body0].push_back(desc);
-					}
-				}
-				if (desc->body1 != SdfPath())
-				{
-					RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body1);
-					if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled &&
-						!fit->second->kinematicBody)
-					{
-						bodyJointMap[desc->body1].push_back(desc);
-					}
-				}
-			}
-		}
-	}
-
-	// first get user defined articulation roots
-	// then search for the best root in the articulation hierarchy
-	const auto workLambda = [rigidBodyMap, jointMap, stage, bodyJointMap]
-	(ArticulationMap::const_reference& it)
-	{
-		SdfPathVector articulationLinkOrderVector;
-
-		const SdfPath& articulationPath = it.first;
-		SdfPath articulationBaseLinkPath = articulationPath;
-
-		std::set<SdfPath> articulatedJoints;
-		std::set<SdfPath> articulatedBodies;
-
-		// check if its a floating articulation
-		{
-			RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(articulationPath);
-			if (bodyIt != rigidBodyMap.end())
-			{
-				if (!bodyIt->second->rigidBodyEnabled)
-				{
-					TF_DIAGNOSTIC_WARNING(
-						"ArticulationRootAPI definition on a static rigid body is not allowed, articulation root will be ignored.Prim: %s",
-						articulationPath.GetText());
-					return;
-				}
-				if (bodyIt->second->kinematicBody)
-				{
-					TF_DIAGNOSTIC_WARNING(
-						"ArticulationRootAPI definition on a kinematic rigid body is not allowed, articulation root will be ignored.Prim: %s",
-						articulationPath.GetText());
-					return;
-				}
-				it.second->rootPrims.push_back(bodyIt->first);
-			}
-			else
-			{
-				JointMap::const_iterator jointIt = jointMap.find(articulationPath);
-				if (jointIt != jointMap.end())
-				{
-					const SdfPath& jointPath = jointIt->first;
-					const UsdPhysicsJointDesc* jointDesc = jointIt->second;
-					if (jointDesc->body0 == SdfPath() || jointDesc->body1 == SdfPath())
-					{
-						it.second->rootPrims.push_back(jointPath);
-						articulationBaseLinkPath = jointDesc->body0 == SdfPath() ?
-							jointDesc->body1 : jointDesc->body0;
-					}
-				}
-			}
-		}
-
-		// search through the hierarchy for the best root        
-		const UsdPrim articulationPrim = stage->GetPrimAtPath(articulationBaseLinkPath);
-		if (!articulationPrim)
-			return;
-		UsdPrimRange range(articulationPrim, UsdTraverseInstanceProxies());
-		std::vector<ArticulationLinkMap> articulationLinkMaps;
-		articulationLinkOrderVector.clear();
-
-		for (pxr::UsdPrimRange::const_iterator iter = range.begin(); iter != range.end(); ++iter)
-		{
-			const pxr::UsdPrim& prim = *iter;
-			if (!prim)
-				continue;
-			const SdfPath primPath = prim.GetPrimPath();
-			if (IsInLinkMap(primPath, articulationLinkMaps))
-			{
-				iter.PruneChildren(); // Skip the subtree rooted at this prim
-				continue;
-			}
-
-			RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(primPath);
-			if (bodyIt != rigidBodyMap.end())
-			{
-				articulationLinkMaps.push_back(ArticulationLinkMap());
-				uint32_t index = 0;
-				TraverseHierarchy(stage, primPath, articulationLinkMaps.back(),
-					bodyJointMap, index, articulationLinkOrderVector);
-			}
-		}
-
-		if (it.second->rootPrims.empty())
-		{
-			for (size_t i = 0; i < articulationLinkMaps.size(); i++)
-			{
-				const ArticulationLinkMap& map = articulationLinkMaps[i];
-				SdfPath linkPath = SdfPath();
-				uint32_t largestWeight = 0;
-				bool hasFixedJoint = false;
-				for (ArticulationLinkMap::const_reference& linkIt : map)
-				{
-					if (linkIt.second.hasFixedJoint)
-					{
-						hasFixedJoint = true;
-					}
-					if (linkIt.second.weight > largestWeight)
-					{
-						linkPath = (linkIt.second.rootJoint != SdfPath()) ?
-							linkIt.second.rootJoint : linkIt.first;
-						largestWeight = linkIt.second.weight;
-					}
-					else if (linkIt.second.weight == largestWeight)
-					{
-						const SdfPath optionalLinkPath =
-							(linkIt.second.rootJoint != SdfPath()) ?
-							linkIt.second.rootJoint : linkIt.first;
-						for (const SdfPath& orderPath : articulationLinkOrderVector)
-						{
-							if (orderPath == linkPath)
-							{
-								break;
-							}
-							else if (orderPath == optionalLinkPath)
-							{
-								linkPath = optionalLinkPath;
-							}
-						}
-					}
-
-					for (size_t j = linkIt.second.joints.size(); j--;)
-					{
-						articulatedJoints.insert(linkIt.second.joints[j]);
-					}
-				}
-
-				// for floating articulation lets find the body with the shortest 
-				// paths (center of graph)
-				if (!hasFixedJoint)
-				{
-					linkPath = GetCenterOfGraph(map, articulationLinkOrderVector);
-				}
-
-				if (linkPath != SdfPath())
-				{
-					it.second->rootPrims.push_back(linkPath);
-				}
-			}
-		}
-		else
-		{
-			for (size_t i = 0; i < articulationLinkMaps.size(); i++)
-			{
-				const ArticulationLinkMap& map = articulationLinkMaps[i];
-				for (ArticulationLinkMap::const_reference& linkIt : map)
-				{
-					for (size_t j = linkIt.second.joints.size(); j--;)
-					{
-						articulatedJoints.insert(linkIt.second.joints[j]);
-					}
-				}
-			}
-		}
-		for (size_t i = 0; i < articulationLinkMaps.size(); i++)
-		{
-			const ArticulationLinkMap& map = articulationLinkMaps[i];
-			for (ArticulationLinkMap::const_reference& linkIt : map)
-			{
-				articulatedBodies.insert(linkIt.second.childs.begin(), linkIt.second.childs.end());
-			}
-		}
-
-		if (it.second->rootPrims.empty())
-		{
-			it.second->isValid = false;
-		}
-
-		for (const SdfPath& p : articulatedJoints)
-		{
-			it.second->articulatedJoints.push_back(p);
-		}
-		for (const SdfPath& p : articulatedBodies)
-		{
-			it.second->articulatedBodies.push_back(p);
-		}
-	};
-
-	WorkParallelForEach(articulationMap.begin(), articulationMap.end(), workLambda);
+    BodyJointMap bodyJointMap;
+    if (!articulationMap.empty())
+    {
+        // construct the BodyJointMap
+        bodyJointMap.reserve(rigidBodyMap.size());
+        for (JointMap::const_reference& jointIt : jointMap)
+        {
+            const UsdPhysicsJointDesc* desc = jointIt.second;
+            if (desc->jointEnabled)
+            {
+                if (desc->body0 != SdfPath())
+                {
+                    RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body0);
+                    if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled &&
+                        !fit->second->kinematicBody)
+                    {
+                        bodyJointMap[desc->body0].push_back(desc);
+                    }
+                }
+                if (desc->body1 != SdfPath())
+                {
+                    RigidBodyMap::const_iterator fit = rigidBodyMap.find(desc->body1);
+                    if (fit != rigidBodyMap.end() && fit->second->rigidBodyEnabled &&
+                        !fit->second->kinematicBody)
+                    {
+                        bodyJointMap[desc->body1].push_back(desc);
+                    }
+                }
+            }
+        }
+    }
+
+    // first get user defined articulation roots
+    // then search for the best root in the articulation hierarchy
+    const auto workLambda = [rigidBodyMap, jointMap, stage, bodyJointMap]
+    (ArticulationMap::const_reference& it)
+    {
+        SdfPathVector articulationLinkOrderVector;
+
+        const SdfPath& articulationPath = it.first;
+        SdfPath articulationBaseLinkPath = articulationPath;
+
+        std::set<SdfPath> articulatedJoints;
+        std::set<SdfPath> articulatedBodies;
+
+        // check if its a floating articulation
+        {
+            RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(articulationPath);
+            if (bodyIt != rigidBodyMap.end())
+            {
+                if (!bodyIt->second->rigidBodyEnabled)
+                {
+                    TF_DIAGNOSTIC_WARNING(
+                        "ArticulationRootAPI definition on a static rigid body is not allowed, articulation root will be ignored.Prim: %s",
+                        articulationPath.GetText());
+                    return;
+                }
+                if (bodyIt->second->kinematicBody)
+                {
+                    TF_DIAGNOSTIC_WARNING(
+                        "ArticulationRootAPI definition on a kinematic rigid body is not allowed, articulation root will be ignored.Prim: %s",
+                        articulationPath.GetText());
+                    return;
+                }
+                it.second->rootPrims.push_back(bodyIt->first);
+            }
+            else
+            {
+                JointMap::const_iterator jointIt = jointMap.find(articulationPath);
+                if (jointIt != jointMap.end())
+                {
+                    const SdfPath& jointPath = jointIt->first;
+                    const UsdPhysicsJointDesc* jointDesc = jointIt->second;
+                    if (jointDesc->body0 == SdfPath() || jointDesc->body1 == SdfPath())
+                    {
+                        it.second->rootPrims.push_back(jointPath);
+                        articulationBaseLinkPath = jointDesc->body0 == SdfPath() ?
+                            jointDesc->body1 : jointDesc->body0;
+                    }
+                }
+            }
+        }
+
+        // search through the hierarchy for the best root        
+        const UsdPrim articulationPrim = stage->GetPrimAtPath(articulationBaseLinkPath);
+        if (!articulationPrim)
+            return;
+        UsdPrimRange range(articulationPrim, UsdTraverseInstanceProxies());
+        std::vector<ArticulationLinkMap> articulationLinkMaps;
+        articulationLinkOrderVector.clear();
+
+        for (UsdPrimRange::const_iterator iter = range.begin(); iter != range.end(); ++iter)
+        {
+            const UsdPrim& prim = *iter;
+            if (!prim)
+                continue;
+            const SdfPath primPath = prim.GetPrimPath();
+            if (IsInLinkMap(primPath, articulationLinkMaps))
+            {
+                iter.PruneChildren(); // Skip the subtree rooted at this prim
+                continue;
+            }
+
+            RigidBodyMap::const_iterator bodyIt = rigidBodyMap.find(primPath);
+            if (bodyIt != rigidBodyMap.end())
+            {
+                articulationLinkMaps.push_back(ArticulationLinkMap());
+                uint32_t index = 0;
+                TraverseHierarchy(stage, primPath, articulationLinkMaps.back(),
+                    bodyJointMap, index, articulationLinkOrderVector);
+            }
+        }
+
+        if (it.second->rootPrims.empty())
+        {
+            for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+            {
+                const ArticulationLinkMap& map = articulationLinkMaps[i];
+                SdfPath linkPath = SdfPath();
+                uint32_t largestWeight = 0;
+                bool hasFixedJoint = false;
+                for (ArticulationLinkMap::const_reference& linkIt : map)
+                {
+                    if (linkIt.second.hasFixedJoint)
+                    {
+                        hasFixedJoint = true;
+                    }
+                    if (linkIt.second.weight > largestWeight)
+                    {
+                        linkPath = (linkIt.second.rootJoint != SdfPath()) ?
+                            linkIt.second.rootJoint : linkIt.first;
+                        largestWeight = linkIt.second.weight;
+                    }
+                    else if (linkIt.second.weight == largestWeight)
+                    {
+                        const SdfPath optionalLinkPath =
+                            (linkIt.second.rootJoint != SdfPath()) ?
+                            linkIt.second.rootJoint : linkIt.first;
+                        for (const SdfPath& orderPath : articulationLinkOrderVector)
+                        {
+                            if (orderPath == linkPath)
+                            {
+                                break;
+                            }
+                            else if (orderPath == optionalLinkPath)
+                            {
+                                linkPath = optionalLinkPath;
+                            }
+                        }
+                    }
+
+                    for (size_t j = linkIt.second.joints.size(); j--;)
+                    {
+                        articulatedJoints.insert(linkIt.second.joints[j]);
+                    }
+                }
+
+                // for floating articulation lets find the body with the shortest 
+                // paths (center of graph)
+                if (!hasFixedJoint)
+                {
+                    linkPath = GetCenterOfGraph(map, articulationLinkOrderVector);
+                }
+
+                if (linkPath != SdfPath())
+                {
+                    it.second->rootPrims.push_back(linkPath);
+                }
+            }
+        }
+        else
+        {
+            for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+            {
+                const ArticulationLinkMap& map = articulationLinkMaps[i];
+                for (ArticulationLinkMap::const_reference& linkIt : map)
+                {
+                    for (size_t j = linkIt.second.joints.size(); j--;)
+                    {
+                        articulatedJoints.insert(linkIt.second.joints[j]);
+                    }
+                }
+            }
+        }
+        for (size_t i = 0; i < articulationLinkMaps.size(); i++)
+        {
+            const ArticulationLinkMap& map = articulationLinkMaps[i];
+            for (ArticulationLinkMap::const_reference& linkIt : map)
+            {
+                articulatedBodies.insert(linkIt.second.childs.begin(), linkIt.second.childs.end());
+            }
+        }
+
+        if (it.second->rootPrims.empty())
+        {
+            it.second->isValid = false;
+        }
+
+        for (const SdfPath& p : articulatedJoints)
+        {
+            it.second->articulatedJoints.push_back(p);
+        }
+        for (const SdfPath& p : articulatedBodies)
+        {
+            it.second->articulatedBodies.push_back(p);
+        }
+    };
+
+    WorkParallelForEach(articulationMap.begin(), articulationMap.end(), workLambda);
 }
 
 bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
-	ParsePrimIteratorBase& primIterator,
-	UsdPhysicsReportFn reportFn,
-	void* userData,
-	const CustomUsdPhysicsTokens* customPhysicsTokens,
-	const std::vector<SdfPath>* simulationOwners)
+    ParsePrimIteratorBase& primIterator,
+    UsdPhysicsReportFn reportFn,
+    void* userData,
+    const CustomUsdPhysicsTokens* customPhysicsTokens,
+    const std::vector<SdfPath>* simulationOwners)
 {
-	bool retVal = true;
-
-	if (!stage)
-	{
-		TF_RUNTIME_ERROR("Provided stage not valid.");
-		return false;
-	}
-
-	if (!reportFn)
-	{
-		TF_RUNTIME_ERROR("Provided report callback is not valid.");
-		return false;
-	}
-
-
-	std::vector<UsdPrim> scenePrims;
-	std::vector<UsdPrim> collisionGroupPrims;
-	std::vector<UsdPrim> materialPrims;
-	std::vector<UsdPrim> articulationPrims;
-	std::unordered_set<SdfPath, SdfPath::Hash> articulationPathsSet;
-	std::vector<UsdPrim> physicsD6JointPrims;
-	std::vector<UsdPrim> physicsRevoluteJointPrims;
-	std::vector<UsdPrim> physicsFixedJointPrims;
-	std::vector<UsdPrim> physicsPrismaticJointPrims;
-	std::vector<UsdPrim> physicsSphericalJointPrims;
-	std::vector<UsdPrim> physicsDistanceJointPrims;
-	std::vector<UsdPrim> physicsCustomJointPrims;
-	std::vector<UsdPrim> collisionPrims;
-	std::vector<UsdPrim> rigidBodyPrims;
-
-	// parse for scene first, get the descriptors, report all prims
-	// the descriptors are not complete yet
-	primIterator.reset();
-
-	static const TfToken gRigidBodyAPIToken("PhysicsRigidBodyAPI");
-	static const TfToken gCollisionAPIToken("PhysicsCollisionAPI");
-	static const TfToken gArticulationRootAPIToken("PhysicsArticulationRootAPI");
-	static const TfToken gMaterialAPIToken("PhysicsMaterialAPI");
-
-	bool defaultSimulationOwner = false;
-	std::unordered_set<SdfPath, SdfPath::Hash> simulationOwnersSet;
-	if (simulationOwners)
-	{
-		for (const SdfPath& p : *simulationOwners)
-		{
-			if (p == SdfPath())
-			{
-				defaultSimulationOwner = true;
-			}
-			else
-			{
-				simulationOwnersSet.insert(p);
-			}
-		}
-	}
-
-	while (!primIterator.atEnd())
-	{
-		const pxr::UsdPrim& prim = *primIterator.getCurrent();
-		if (!prim)
-		{
-			primIterator.pruneChildren();
-			primIterator.next();
-			continue;
-		}
-
-		const SdfPath primPath = prim.GetPrimPath();
-		const UsdPrimTypeInfo& typeInfo = prim.GetPrimTypeInfo();
-
-		uint64_t apiFlags = 0;
-		const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
-		for (const TfToken& token : apis)
-		{
-			if (token == gArticulationRootAPIToken)
-			{
-				apiFlags |= SchemaAPIFlag::eArticulationRootAPI;
-			}
-			if (token == gCollisionAPIToken)
-			{
-				apiFlags |= SchemaAPIFlag::eCollisionAPI;
-			}
-			if (token == gRigidBodyAPIToken)
-			{
-				apiFlags |= SchemaAPIFlag::eRigidBodyAPI;
-			}
-			if (!apiFlags && token == gMaterialAPIToken)
-			{
-				apiFlags |= SchemaAPIFlag::eMaterialAPI;
-			}
-		}
-
-		if (typeInfo.GetSchemaType().IsA<UsdGeomPointInstancer>())
-		{
-			primIterator.pruneChildren(); // Skip the subtree for point instancers, 
-			//those have to be traversed per prototype
-		}
-		else if (customPhysicsTokens && !customPhysicsTokens->instancerTokens.empty())
-		{
-			for (const TfToken& instToken : customPhysicsTokens->instancerTokens)
-			{
-				if (instToken == typeInfo.GetTypeName())
-				{
-					primIterator.pruneChildren(); // Skip the subtree for custom 
-					// instancers, those have to be traversed per prototype
-					break;
-				}
-			}
-		}
-
-		if (typeInfo.GetSchemaType().IsA<UsdPhysicsScene>())
-		{
-			scenePrims.push_back(prim);
-		}
-		else if (typeInfo.GetSchemaType().IsA<UsdPhysicsCollisionGroup>())
-		{
-			collisionGroupPrims.push_back(prim);
-		}
-		else if (apiFlags & SchemaAPIFlag::eMaterialAPI)
-		{
-			materialPrims.push_back(prim);
-		}
-		else if (typeInfo.GetSchemaType().IsA<UsdPhysicsJoint>())
-		{
-			if (typeInfo.GetSchemaType().IsA<UsdPhysicsFixedJoint>())
-			{
-				physicsFixedJointPrims.push_back(prim);
-			}
-			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsRevoluteJoint>())
-			{
-				physicsRevoluteJointPrims.push_back(prim);
-			}
-			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsPrismaticJoint>())
-			{
-				physicsPrismaticJointPrims.push_back(prim);
-			}
-			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsSphericalJoint>())
-			{
-				physicsSphericalJointPrims.push_back(prim);
-			}
-			else if (typeInfo.GetSchemaType().IsA<UsdPhysicsDistanceJoint>())
-			{
-				physicsDistanceJointPrims.push_back(prim);
-			}
-			else
-			{
-				bool customJoint = false;
-				if (customPhysicsTokens)
-				{
-					const TfToken& primType = typeInfo.GetTypeName();
-					for (size_t i = 0; i < customPhysicsTokens->jointTokens.size(); i++)
-					{
-						if (primType == customPhysicsTokens->jointTokens[i])
-						{
-							customJoint = true;
-							break;
-						}
-					}
-				}
-
-				if (customJoint)
-				{
-					physicsCustomJointPrims.push_back(prim);
-				}
-				else
-				{
-					physicsD6JointPrims.push_back(prim);
-				}
-			}
-
-
-			// can be articulation definition
-			if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
-			{
-				articulationPrims.push_back(prim);
-				articulationPathsSet.insert(prim.GetPrimPath());
-			}
-		}
-		else
-		{
-			if (apiFlags & SchemaAPIFlag::eCollisionAPI)
-			{
-				collisionPrims.push_back(prim);
-			}
-			if (apiFlags & SchemaAPIFlag::eRigidBodyAPI)
-			{
-				rigidBodyPrims.push_back(prim);
-			}
-			if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
-			{
-				articulationPrims.push_back(prim);
-				articulationPathsSet.insert(prim.GetPrimPath());
-			}
-		}
-
-		primIterator.next();
-	}
-
-	// process parsing
-	// 
-	// Scenes
-	std::vector<UsdPhysicsSceneDesc> sceneDescs;
-
-	// is simulation owners provided, restrict scenes to just the one specified
-	if (simulationOwners)
-	{
-		for (size_t i = scenePrims.size(); i--;)
-		{
-			const SdfPath& primPath = scenePrims[i].GetPrimPath();
-			std::unordered_set<SdfPath, SdfPath::Hash>::const_iterator fit =
-				simulationOwnersSet.find(primPath);
-			if (fit == simulationOwnersSet.end())
-			{
-				scenePrims[i] = scenePrims.back();
-				scenePrims.pop_back();
-			}
-		}
-	}
-	ProcessPhysicsPrims<UsdPhysicsSceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs,
-		ParseSceneDesc);
-
-	// Collision Groups
-	std::vector<UsdPhysicsCollisionGroupDesc> collisionGroupsDescs;
-	ProcessPhysicsPrims<UsdPhysicsCollisionGroupDesc, UsdPhysicsCollisionGroup>
-		(collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
-	// Run groups merging
-	std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets;
-	std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
-	for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
-	{
-		const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
-
-		collisionGroupSets[desc.primPath];
-
-		if (!desc.mergeGroupName.empty())
-		{
-			std::unordered_map<std::string, size_t>::const_iterator fit =
-				mergeGroupNameToIndex.find(desc.mergeGroupName);
-			if (fit != mergeGroupNameToIndex.end())
-			{
-				UsdPhysicsCollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
-				mergeDesc.mergedGroups.push_back(desc.primPath);
-				for (const SdfPath& sp : desc.filteredGroups)
-				{
-					mergeDesc.filteredGroups.push_back(sp);
-				}
-
-				collisionGroupsDescs[i] = collisionGroupsDescs.back();
-				collisionGroupPrims[i] = collisionGroupPrims.back();
-				collisionGroupsDescs.pop_back();
-				collisionGroupPrims.pop_back();
-				i--;
-			}
-			else
-			{
-				mergeGroupNameToIndex[desc.mergeGroupName] = i;
-				collisionGroupsDescs[i].mergedGroups.push_back(desc.primPath);
-			}
-		}
-	}
-
-	// Populate the sets to check collisions
-	{
-		const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
-		{
-			for (size_t i = beginIdx; i < endIdx; i++)
-			{
-				const UsdPrim groupPrim = collisionGroupPrims[i];
-				UsdStageWeakPtr stage = groupPrim.GetStage();
-				const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
-
-				std::unordered_set<SdfPath, SdfPath::Hash>& hashSet =
-					collisionGroupSets[desc.primPath];
-
-				if (desc.mergedGroups.empty())
-				{
-					const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
-					if (cg)
-					{
-						const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
-						UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
-						const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
-						for (const SdfPath& path : includedPaths)
-						{
-							hashSet.insert(path);
-						}
-					}
-				}
-				else
-				{
-					for (const SdfPath& groupPath : desc.mergedGroups)
-					{
-						const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
-						if (cg)
-						{
-							const UsdCollectionAPI collectionAPI =
-								cg.GetCollidersCollectionAPI();
-							UsdCollectionMembershipQuery query =
-								collectionAPI.ComputeMembershipQuery();
-							const SdfPathSet includedPaths =
-								UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
-							for (const SdfPath& path : includedPaths)
-							{
-								hashSet.insert(path);
-							}
-						}
-					}
-				}
-			}
-		};
-
-		const size_t numPrimPerBatch = 10;
-		WorkParallelForN(collisionGroupsDescs.size(), workLambda, numPrimPerBatch);
-	}
-
-	// Rigid body physics material
-	std::vector<UsdPhysicsRigidBodyMaterialDesc> materialDescs;
-	ProcessPhysicsPrims<UsdPhysicsRigidBodyMaterialDesc, UsdPhysicsMaterialAPI>
-		(materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
-
-	// Joints
-	std::vector<UsdPhysicsD6JointDesc> jointDescs;
-	ProcessPhysicsPrims<UsdPhysicsD6JointDesc, UsdPhysicsJoint>
-		(physicsD6JointPrims, jointDescs, ParseD6JointDesc);
-
-	std::vector<UsdPhysicsRevoluteJointDesc> revoluteJointDescs;
-	ProcessPhysicsPrims<UsdPhysicsRevoluteJointDesc, UsdPhysicsRevoluteJoint>
-		(physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
-
-	std::vector<UsdPhysicsPrismaticJointDesc> prismaticJointDescs;
-	ProcessPhysicsPrims<UsdPhysicsPrismaticJointDesc, UsdPhysicsPrismaticJoint>
-		(physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
-
-	std::vector<UsdPhysicsSphericalJointDesc> sphericalJointDescs;
-	ProcessPhysicsPrims<UsdPhysicsSphericalJointDesc, UsdPhysicsSphericalJoint>
-		(physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
-
-	std::vector<UsdPhysicsFixedJointDesc> fixedJointDescs;
-	ProcessPhysicsPrims<UsdPhysicsFixedJointDesc, UsdPhysicsFixedJoint>
-		(physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
-
-	std::vector<UsdPhysicsDistanceJointDesc> distanceJointDescs;
-	ProcessPhysicsPrims<UsdPhysicsDistanceJointDesc, UsdPhysicsDistanceJoint>
-		(physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
-
-	std::vector<UsdPhysicsCustomJointDesc> customJointDescs;
-	ProcessPhysicsPrims<UsdPhysicsCustomJointDesc, UsdPhysicsJoint>
-		(physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
-
-	// A.B. contruct joint map revisit    
-	JointMap jointMap;
-	for (UsdPhysicsD6JointDesc& desc : jointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-	for (UsdPhysicsRevoluteJointDesc& desc : revoluteJointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-	for (UsdPhysicsPrismaticJointDesc& desc : prismaticJointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-	for (UsdPhysicsSphericalJointDesc& desc : sphericalJointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-	for (UsdPhysicsFixedJointDesc& desc : fixedJointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-	for (UsdPhysicsDistanceJointDesc& desc : distanceJointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-	for (UsdPhysicsCustomJointDesc& desc : customJointDescs)
-	{
-		jointMap[desc.primPath] = &desc;
-	}
-
-
-	// collisions
-	// first get the type
-	std::vector<UsdPhysicsObjectType::Enum> collisionTypes;
-	collisionTypes.resize(collisionPrims.size());
-	std::vector<TfToken> customTokens;
-	{
-		const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
-		{
-			for (size_t i = beginIdx; i < endIdx; i++)
-			{
-				if (customPhysicsTokens)
-				{
-					TfToken shapeToken;
-					const UsdPhysicsObjectType::Enum shapeType =
-						GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
-					collisionTypes[i] = shapeType;
-					if (shapeType == UsdPhysicsObjectType::eCustomShape)
-					{
-						customTokens.push_back(shapeToken);
-					}
-				}
-				else
-				{
-					collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
-				}
-			}
-		};
-
-		const size_t numPrimPerBatch = 10;
-		WorkParallelForN(collisionPrims.size(), workLambda, numPrimPerBatch);
-	}
-
-	std::vector<UsdPrim> sphereShapePrims;
-	std::vector<UsdPrim> cubeShapePrims;
-	std::vector<UsdPrim> cylinderShapePrims;
-	std::vector<UsdPrim> capsuleShapePrims;
-	std::vector<UsdPrim> coneShapePrims;
-	std::vector<UsdPrim> planeShapePrims;
-	std::vector<UsdPrim> meshShapePrims;
-	std::vector<UsdPrim> spherePointsShapePrims;
-	std::vector<UsdPrim> customShapePrims;
-	for (size_t i = 0; i < collisionTypes.size(); i++)
-	{
-		UsdPhysicsObjectType::Enum type = collisionTypes[i];
-		switch (type)
-		{
-		case UsdPhysicsObjectType::eSphereShape:
-		{
-			sphereShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eCubeShape:
-		{
-			cubeShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eCapsuleShape:
-		{
-			capsuleShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eCylinderShape:
-		{
-			cylinderShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eConeShape:
-		{
-			coneShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eMeshShape:
-		{
-			meshShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::ePlaneShape:
-		{
-			planeShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eCustomShape:
-		{
-			customShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eSpherePointsShape:
-		{
-			spherePointsShapePrims.push_back(collisionPrims[i]);
-		}
-		break;
-		case UsdPhysicsObjectType::eUndefined:
-		default:
-		{
-			TF_DIAGNOSTIC_WARNING("CollisionAPI applied to an unknown UsdGeomGPrim type, prim %s.",
-				collisionPrims[i].GetPrimPath().GetString().c_str());
-		}
-		break;
-		}
-	}
-	std::vector<UsdPhysicsSphereShapeDesc> sphereShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsSphereShapeDesc, UsdPhysicsCollisionAPI>
-		(sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
-
-	std::vector<UsdPhysicsCubeShapeDesc> cubeShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsCubeShapeDesc, UsdPhysicsCollisionAPI>
-		(cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
-
-	std::vector<UsdPhysicsCylinderShapeDesc> cylinderShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsCylinderShapeDesc, UsdPhysicsCollisionAPI>
-		(cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
-
-	std::vector<UsdPhysicsCapsuleShapeDesc> capsuleShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsCapsuleShapeDesc, UsdPhysicsCollisionAPI>
-		(capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
-
-	std::vector<UsdPhysicsConeShapeDesc> coneShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsConeShapeDesc, UsdPhysicsCollisionAPI>
-		(coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
-
-	std::vector<UsdPhysicsPlaneShapeDesc> planeShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsPlaneShapeDesc, UsdPhysicsCollisionAPI>
-		(planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
-
-	std::vector<UsdPhysicsMeshShapeDesc> meshShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsMeshShapeDesc, UsdPhysicsCollisionAPI>
-		(meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
-
-	std::vector<UsdPhysicsSpherePointsShapeDesc> spherePointsShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsSpherePointsShapeDesc, UsdPhysicsCollisionAPI>
-		(spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
-
-	std::vector<UsdPhysicsCustomShapeDesc> customShapeDescs;
-	ProcessPhysicsPrims<UsdPhysicsCustomShapeDesc, UsdPhysicsCollisionAPI>
-		(customShapePrims, customShapeDescs, ParseCustomShapeDesc);
-	if (customShapeDescs.size() == customTokens.size())
-	{
-		for (size_t i = 0; i < customShapeDescs.size(); i++)
-		{
-			customShapeDescs[i].customGeometryToken = customTokens[i];
-		}
-	}
-
-	// rigid bodies
-	std::vector<UsdPhysicsRigidBodyDesc> rigidBodyDescs;
-	ProcessPhysicsPrims<UsdPhysicsRigidBodyDesc, UsdPhysicsRigidBodyAPI>
-		(rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
-	// Ensure if we have a hierarchical parent that has a dynamic parent,
-	// that we also have a reset xform stack, otherwise we should log an error.
-	// check for nested articulation roots, these are not supported
-	RigidBodyMap bodyMap;
-	for (size_t i = rigidBodyPrims.size(); i--;)
-	{
-		bodyMap[rigidBodyPrims[i].GetPrimPath()] = &rigidBodyDescs[i];
-	}
-
-	for (size_t i = rigidBodyPrims.size(); i--;)
-	{
-		const UsdPrim bodyPrim = rigidBodyPrims[i];
-		UsdPrim bodyParent = UsdPrim();
-		if (HasDynamicBodyParent(bodyPrim.GetParent(), bodyMap, bodyParent))
-		{
-			bool hasResetXformStack = false;
-			UsdPrim parent = bodyPrim;
-			while (parent != stage->GetPseudoRoot() && parent != bodyParent)
-			{
-				const UsdGeomXformable xform(parent);
-				if (xform && xform.GetResetXformStack())
-				{
-					hasResetXformStack = true;
-					break;
-				}
-				parent = parent.GetParent();
-			}
-			if (!hasResetXformStack)
-			{
-
-				TF_DIAGNOSTIC_WARNING("Rigid Body of (%s) missing xformstack reset when child of rigid body (%s) in hierarchy."
-					"Simulation of multiple RigidBodyAPI's in a hierarchy will cause unpredicted results."
-					"Please fix the hierarchy or use XformStack reset.",
-					bodyPrim.GetPrimPath().GetText(),
-					bodyParent.GetPrimPath().GetText());
-
-				rigidBodyPrims[i] = rigidBodyPrims.back();
-				rigidBodyPrims.pop_back();
-			}
-		}
-	}
-
-	// articulations
-	// check for nested articulation roots, these are not supported    
-	for (size_t i = articulationPrims.size(); i--;)
-	{
-		if (CheckNestedArticulationRoot(articulationPrims[i], articulationPathsSet))
-		{
-			TF_DIAGNOSTIC_WARNING("Nested ArticulationRootAPI not supported, API ignored, prim %s.",
-				articulationPrims[i].GetPrimPath().GetString().c_str());
-			articulationPrims[i] = articulationPrims.back();
-			articulationPrims.pop_back();
-		}
-	}
-	std::vector<UsdPhysicsArticulationDesc> articulationDescs;
-	ProcessPhysicsPrims<UsdPhysicsArticulationDesc, UsdPhysicsArticulationRootAPI>
-		(articulationPrims, articulationDescs, ParseArticulationDesc);
-
-	ArticulationMap articulationMap; // A.B. TODO probably not needed
-	for (size_t i = articulationPrims.size(); i--;)
-	{
-		articulationMap[articulationPrims[i].GetPrimPath()] = &articulationDescs[i];
-	}
-
-	// Finalize collisions
-	{
-		UsdGeomXformCache xfCache;
-
-		FinalizeCollisionDescs<UsdPhysicsSphereShapeDesc>
-			(xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsCubeShapeDesc>
-			(xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsCapsuleShapeDesc>
-			(xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsCylinderShapeDesc>
-			(xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsConeShapeDesc>
-			(xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsPlaneShapeDesc>
-			(xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsMeshShapeDesc>
-			(xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsSpherePointsShapeDesc>
-			(xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
-		FinalizeCollisionDescs<UsdPhysicsCustomShapeDesc>
-			(xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
-	}
-
-	// Finalize articulations
-	{
-		// A.B. walk through the finalize code refactor
-		FinalizeArticulations(stage, articulationMap, bodyMap, jointMap);
-	}
-
-	// if simulationOwners are in play lets shrink down the reported descriptors    
-	if (simulationOwners && !simulationOwners->empty())
-	{
-		std::unordered_set<SdfPath, SdfPath::Hash> reportedBodies;
-		// first check bodies
-		CheckRigidBodySimulationOwner(rigidBodyPrims, rigidBodyDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-
-		// check collisions
-		// if collision belongs to a body that we care about include it
-		// if collision does not belong to a body we care about its not included
-		// if collision does not have a body set, we check its own simulationOwners
-		CheckCollisionSimulationOwner(sphereShapePrims, sphereShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(cubeShapePrims, cubeShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(capsuleShapePrims, capsuleShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(cylinderShapePrims, cylinderShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(coneShapePrims, coneShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(planeShapePrims, planeShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(meshShapePrims, meshShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(spherePointsShapePrims, spherePointsShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckCollisionSimulationOwner(customShapePrims, customShapeDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-
-		// Both bodies need to have simulation owners valid
-		CheckJointSimulationOwner(physicsFixedJointPrims, fixedJointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckJointSimulationOwner(physicsRevoluteJointPrims, revoluteJointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckJointSimulationOwner(physicsPrismaticJointPrims, prismaticJointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckJointSimulationOwner(physicsSphericalJointPrims, sphericalJointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckJointSimulationOwner(physicsDistanceJointPrims, distanceJointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckJointSimulationOwner(physicsD6JointPrims, jointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-		CheckJointSimulationOwner(physicsCustomJointPrims, customJointDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-
-		// All bodies need to have simulation owners valid
-		CheckArticulationSimulationOwner(articulationPrims, articulationDescs,
-			defaultSimulationOwner, reportedBodies, simulationOwnersSet);
-	}
-
-	SdfPathVector primPathsVector;
-	// get the descriptors, finalize them and send them out in an order
-	// 1. send out the scenes
-	{
-		CallReportFn(UsdPhysicsObjectType::eScene, scenePrims, sceneDescs,
-			reportFn, primPathsVector, userData);
-	}
-
-	// 2. send out the CollisionGroups
-	{
-		CallReportFn(UsdPhysicsObjectType::eCollisionGroup, collisionGroupPrims,
-			collisionGroupsDescs, reportFn, primPathsVector, userData);
-	}
-
-	// 3. send out the materials
-	{
-		CallReportFn(UsdPhysicsObjectType::eRigidBodyMaterial, materialPrims,
-			materialDescs, reportFn, primPathsVector, userData);
-	}
-
-	// 4. finish out and send out shapes
-	{
-		CallReportFn(UsdPhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs,
-			reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs,
-			reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eCapsuleShape, capsuleShapePrims,
-			capsuleShapeDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eCylinderShape, cylinderShapePrims,
-			cylinderShapeDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs,
-			reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs,
-			reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs,
-			reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eSpherePointsShape, spherePointsShapePrims,
-			spherePointsShapeDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs,
-			reportFn, primPathsVector, userData);
-	}
-
-	// 5. send out articulations
-	{
-		CallReportFn(UsdPhysicsObjectType::eArticulation, articulationPrims,
-			articulationDescs, reportFn, primPathsVector, userData);
-	}
-
-	// 6. send out bodies
-	{
-		CallReportFn(UsdPhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs,
-			reportFn, primPathsVector, userData);
-	}
-
-	// 7. send out joints    
-	{
-		CallReportFn(UsdPhysicsObjectType::eFixedJoint, physicsFixedJointPrims,
-			fixedJointDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims,
-			revoluteJointDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims,
-			prismaticJointDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims,
-			sphericalJointDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims,
-			distanceJointDescs, reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs,
-			reportFn, primPathsVector, userData);
-		CallReportFn(UsdPhysicsObjectType::eCustomJoint, physicsCustomJointPrims,
-			customJointDescs, reportFn, primPathsVector, userData);
-	}
-
-	return retVal;
+    bool retVal = true;
+
+    if (!stage)
+    {
+        TF_RUNTIME_ERROR("Provided stage not valid.");
+        return false;
+    }
+
+    if (!reportFn)
+    {
+        TF_RUNTIME_ERROR("Provided report callback is not valid.");
+        return false;
+    }
+
+
+    std::vector<UsdPrim> scenePrims;
+    std::vector<UsdPrim> collisionGroupPrims;
+    std::vector<UsdPrim> materialPrims;
+    std::vector<UsdPrim> articulationPrims;
+    std::unordered_set<SdfPath, SdfPath::Hash> articulationPathsSet;
+    std::vector<UsdPrim> physicsD6JointPrims;
+    std::vector<UsdPrim> physicsRevoluteJointPrims;
+    std::vector<UsdPrim> physicsFixedJointPrims;
+    std::vector<UsdPrim> physicsPrismaticJointPrims;
+    std::vector<UsdPrim> physicsSphericalJointPrims;
+    std::vector<UsdPrim> physicsDistanceJointPrims;
+    std::vector<UsdPrim> physicsCustomJointPrims;
+    std::vector<UsdPrim> collisionPrims;
+    std::vector<UsdPrim> rigidBodyPrims;
+
+    // parse for scene first, get the descriptors, report all prims
+    // the descriptors are not complete yet
+    primIterator.reset();
+
+    static const TfToken gRigidBodyAPIToken("PhysicsRigidBodyAPI");
+    static const TfToken gCollisionAPIToken("PhysicsCollisionAPI");
+    static const TfToken gArticulationRootAPIToken("PhysicsArticulationRootAPI");
+    static const TfToken gMaterialAPIToken("PhysicsMaterialAPI");
+
+    bool defaultSimulationOwner = false;
+    std::unordered_set<SdfPath, SdfPath::Hash> simulationOwnersSet;
+    if (simulationOwners)
+    {
+        for (const SdfPath& p : *simulationOwners)
+        {
+            if (p == SdfPath())
+            {
+                defaultSimulationOwner = true;
+            }
+            else
+            {
+                simulationOwnersSet.insert(p);
+            }
+        }
+    }
+
+    while (!primIterator.atEnd())
+    {
+        const UsdPrim& prim = *primIterator.getCurrent();
+        if (!prim)
+        {
+            primIterator.pruneChildren();
+            primIterator.next();
+            continue;
+        }
+
+        const SdfPath primPath = prim.GetPrimPath();
+        const UsdPrimTypeInfo& typeInfo = prim.GetPrimTypeInfo();
+
+        uint64_t apiFlags = 0;
+        const TfTokenVector& apis = prim.GetPrimTypeInfo().GetAppliedAPISchemas();
+        for (const TfToken& token : apis)
+        {
+            if (token == gArticulationRootAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eArticulationRootAPI;
+            }
+            if (token == gCollisionAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eCollisionAPI;
+            }
+            if (token == gRigidBodyAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eRigidBodyAPI;
+            }
+            if (!apiFlags && token == gMaterialAPIToken)
+            {
+                apiFlags |= SchemaAPIFlag::eMaterialAPI;
+            }
+        }
+
+        if (typeInfo.GetSchemaType().IsA<UsdGeomPointInstancer>())
+        {
+            primIterator.pruneChildren(); // Skip the subtree for point instancers, 
+            //those have to be traversed per prototype
+        }
+        else if (customPhysicsTokens && !customPhysicsTokens->instancerTokens.empty())
+        {
+            for (const TfToken& instToken : customPhysicsTokens->instancerTokens)
+            {
+                if (instToken == typeInfo.GetTypeName())
+                {
+                    primIterator.pruneChildren(); // Skip the subtree for custom 
+                    // instancers, those have to be traversed per prototype
+                    break;
+                }
+            }
+        }
+
+        if (typeInfo.GetSchemaType().IsA<UsdPhysicsScene>())
+        {
+            scenePrims.push_back(prim);
+        }
+        else if (typeInfo.GetSchemaType().IsA<UsdPhysicsCollisionGroup>())
+        {
+            collisionGroupPrims.push_back(prim);
+        }
+        else if (apiFlags & SchemaAPIFlag::eMaterialAPI)
+        {
+            materialPrims.push_back(prim);
+        }
+        else if (typeInfo.GetSchemaType().IsA<UsdPhysicsJoint>())
+        {
+            if (typeInfo.GetSchemaType().IsA<UsdPhysicsFixedJoint>())
+            {
+                physicsFixedJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsRevoluteJoint>())
+            {
+                physicsRevoluteJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsPrismaticJoint>())
+            {
+                physicsPrismaticJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsSphericalJoint>())
+            {
+                physicsSphericalJointPrims.push_back(prim);
+            }
+            else if (typeInfo.GetSchemaType().IsA<UsdPhysicsDistanceJoint>())
+            {
+                physicsDistanceJointPrims.push_back(prim);
+            }
+            else
+            {
+                bool customJoint = false;
+                if (customPhysicsTokens)
+                {
+                    const TfToken& primType = typeInfo.GetTypeName();
+                    for (size_t i = 0; i < customPhysicsTokens->jointTokens.size(); i++)
+                    {
+                        if (primType == customPhysicsTokens->jointTokens[i])
+                        {
+                            customJoint = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (customJoint)
+                {
+                    physicsCustomJointPrims.push_back(prim);
+                }
+                else
+                {
+                    physicsD6JointPrims.push_back(prim);
+                }
+            }
+
+
+            // can be articulation definition
+            if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
+            {
+                articulationPrims.push_back(prim);
+                articulationPathsSet.insert(prim.GetPrimPath());
+            }
+        }
+        else
+        {
+            if (apiFlags & SchemaAPIFlag::eCollisionAPI)
+            {
+                collisionPrims.push_back(prim);
+            }
+            if (apiFlags & SchemaAPIFlag::eRigidBodyAPI)
+            {
+                rigidBodyPrims.push_back(prim);
+            }
+            if (apiFlags & SchemaAPIFlag::eArticulationRootAPI)
+            {
+                articulationPrims.push_back(prim);
+                articulationPathsSet.insert(prim.GetPrimPath());
+            }
+        }
+
+        primIterator.next();
+    }
+
+    // process parsing
+    // 
+    // Scenes
+    std::vector<UsdPhysicsSceneDesc> sceneDescs;
+
+    // is simulation owners provided, restrict scenes to just the one specified
+    if (simulationOwners)
+    {
+        for (size_t i = scenePrims.size(); i--;)
+        {
+            const SdfPath& primPath = scenePrims[i].GetPrimPath();
+            std::unordered_set<SdfPath, SdfPath::Hash>::const_iterator fit =
+                simulationOwnersSet.find(primPath);
+            if (fit == simulationOwnersSet.end())
+            {
+                scenePrims[i] = scenePrims.back();
+                scenePrims.pop_back();
+            }
+        }
+    }
+    ProcessPhysicsPrims<UsdPhysicsSceneDesc, UsdPhysicsScene>(scenePrims, sceneDescs,
+        ParseSceneDesc);
+
+    // Collision Groups
+    std::vector<UsdPhysicsCollisionGroupDesc> collisionGroupsDescs;
+    ProcessPhysicsPrims<UsdPhysicsCollisionGroupDesc, UsdPhysicsCollisionGroup>
+        (collisionGroupPrims, collisionGroupsDescs, ParseCollisionGroupDesc);
+    // Run groups merging
+    std::map<SdfPath, std::unordered_set<SdfPath, SdfPath::Hash>> collisionGroupSets;
+    std::unordered_map<std::string, size_t> mergeGroupNameToIndex;
+    for (size_t i = 0; i < collisionGroupsDescs.size(); i++)
+    {
+        const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
+
+        collisionGroupSets[desc.primPath];
+
+        if (!desc.mergeGroupName.empty())
+        {
+            std::unordered_map<std::string, size_t>::const_iterator fit =
+                mergeGroupNameToIndex.find(desc.mergeGroupName);
+            if (fit != mergeGroupNameToIndex.end())
+            {
+                UsdPhysicsCollisionGroupDesc& mergeDesc = collisionGroupsDescs[fit->second];
+                mergeDesc.mergedGroups.push_back(desc.primPath);
+                for (const SdfPath& sp : desc.filteredGroups)
+                {
+                    mergeDesc.filteredGroups.push_back(sp);
+                }
+
+                collisionGroupsDescs[i] = collisionGroupsDescs.back();
+                collisionGroupPrims[i] = collisionGroupPrims.back();
+                collisionGroupsDescs.pop_back();
+                collisionGroupPrims.pop_back();
+                i--;
+            }
+            else
+            {
+                mergeGroupNameToIndex[desc.mergeGroupName] = i;
+                collisionGroupsDescs[i].mergedGroups.push_back(desc.primPath);
+            }
+        }
+    }
+
+    // Populate the sets to check collisions
+    {
+        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
+        {
+            for (size_t i = beginIdx; i < endIdx; i++)
+            {
+                const UsdPrim groupPrim = collisionGroupPrims[i];
+                UsdStageWeakPtr stage = groupPrim.GetStage();
+                const UsdPhysicsCollisionGroupDesc& desc = collisionGroupsDescs[i];
+
+                std::unordered_set<SdfPath, SdfPath::Hash>& hashSet =
+                    collisionGroupSets[desc.primPath];
+
+                if (desc.mergedGroups.empty())
+                {
+                    const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(desc.primPath));
+                    if (cg)
+                    {
+                        const UsdCollectionAPI collectionAPI = cg.GetCollidersCollectionAPI();
+                        UsdCollectionMembershipQuery query = collectionAPI.ComputeMembershipQuery();
+                        const SdfPathSet includedPaths = UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+                        for (const SdfPath& path : includedPaths)
+                        {
+                            hashSet.insert(path);
+                        }
+                    }
+                }
+                else
+                {
+                    for (const SdfPath& groupPath : desc.mergedGroups)
+                    {
+                        const UsdPhysicsCollisionGroup cg(stage->GetPrimAtPath(groupPath));
+                        if (cg)
+                        {
+                            const UsdCollectionAPI collectionAPI =
+                                cg.GetCollidersCollectionAPI();
+                            UsdCollectionMembershipQuery query =
+                                collectionAPI.ComputeMembershipQuery();
+                            const SdfPathSet includedPaths =
+                                UsdCollectionAPI::ComputeIncludedPaths(query, stage, UsdTraverseInstanceProxies());
+                            for (const SdfPath& path : includedPaths)
+                            {
+                                hashSet.insert(path);
+                            }
+                        }
+                    }
+                }
+            }
+        };
+
+        const size_t numPrimPerBatch = 10;
+        WorkParallelForN(collisionGroupsDescs.size(), workLambda, numPrimPerBatch);
+    }
+
+    // Rigid body physics material
+    std::vector<UsdPhysicsRigidBodyMaterialDesc> materialDescs;
+    ProcessPhysicsPrims<UsdPhysicsRigidBodyMaterialDesc, UsdPhysicsMaterialAPI>
+        (materialPrims, materialDescs, ParseRigidBodyMaterialDesc);
+
+    // Joints
+    std::vector<UsdPhysicsD6JointDesc> jointDescs;
+    ProcessPhysicsPrims<UsdPhysicsD6JointDesc, UsdPhysicsJoint>
+        (physicsD6JointPrims, jointDescs, ParseD6JointDesc);
+
+    std::vector<UsdPhysicsRevoluteJointDesc> revoluteJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsRevoluteJointDesc, UsdPhysicsRevoluteJoint>
+        (physicsRevoluteJointPrims, revoluteJointDescs, ParseRevoluteJointDesc);
+
+    std::vector<UsdPhysicsPrismaticJointDesc> prismaticJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsPrismaticJointDesc, UsdPhysicsPrismaticJoint>
+        (physicsPrismaticJointPrims, prismaticJointDescs, ParsePrismaticJointDesc);
+
+    std::vector<UsdPhysicsSphericalJointDesc> sphericalJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsSphericalJointDesc, UsdPhysicsSphericalJoint>
+        (physicsSphericalJointPrims, sphericalJointDescs, ParseSphericalJointDesc);
+
+    std::vector<UsdPhysicsFixedJointDesc> fixedJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsFixedJointDesc, UsdPhysicsFixedJoint>
+        (physicsFixedJointPrims, fixedJointDescs, ParseFixedJointDesc);
+
+    std::vector<UsdPhysicsDistanceJointDesc> distanceJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsDistanceJointDesc, UsdPhysicsDistanceJoint>
+        (physicsDistanceJointPrims, distanceJointDescs, ParseDistanceJointDesc);
+
+    std::vector<UsdPhysicsCustomJointDesc> customJointDescs;
+    ProcessPhysicsPrims<UsdPhysicsCustomJointDesc, UsdPhysicsJoint>
+        (physicsCustomJointPrims, customJointDescs, ParseCustomJointDesc);
+
+    // A.B. contruct joint map revisit    
+    JointMap jointMap;
+    for (UsdPhysicsD6JointDesc& desc : jointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (UsdPhysicsRevoluteJointDesc& desc : revoluteJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (UsdPhysicsPrismaticJointDesc& desc : prismaticJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (UsdPhysicsSphericalJointDesc& desc : sphericalJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (UsdPhysicsFixedJointDesc& desc : fixedJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (UsdPhysicsDistanceJointDesc& desc : distanceJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+    for (UsdPhysicsCustomJointDesc& desc : customJointDescs)
+    {
+        jointMap[desc.primPath] = &desc;
+    }
+
+
+    // collisions
+    // first get the type
+    std::vector<UsdPhysicsObjectType::Enum> collisionTypes;
+    collisionTypes.resize(collisionPrims.size());
+    std::vector<TfToken> customTokens;
+    {
+        const auto workLambda = [&](const size_t beginIdx, const size_t endIdx)
+        {
+            for (size_t i = beginIdx; i < endIdx; i++)
+            {
+                if (customPhysicsTokens)
+                {
+                    TfToken shapeToken;
+                    const UsdPhysicsObjectType::Enum shapeType =
+                        GetCollisionType(collisionPrims[i], &customPhysicsTokens->shapeTokens, &shapeToken);
+                    collisionTypes[i] = shapeType;
+                    if (shapeType == UsdPhysicsObjectType::eCustomShape)
+                    {
+                        customTokens.push_back(shapeToken);
+                    }
+                }
+                else
+                {
+                    collisionTypes[i] = GetCollisionType(collisionPrims[i], nullptr, nullptr);
+                }
+            }
+        };
+
+        const size_t numPrimPerBatch = 10;
+        WorkParallelForN(collisionPrims.size(), workLambda, numPrimPerBatch);
+    }
+
+    std::vector<UsdPrim> sphereShapePrims;
+    std::vector<UsdPrim> cubeShapePrims;
+    std::vector<UsdPrim> cylinderShapePrims;
+    std::vector<UsdPrim> capsuleShapePrims;
+    std::vector<UsdPrim> coneShapePrims;
+    std::vector<UsdPrim> planeShapePrims;
+    std::vector<UsdPrim> meshShapePrims;
+    std::vector<UsdPrim> spherePointsShapePrims;
+    std::vector<UsdPrim> customShapePrims;
+    for (size_t i = 0; i < collisionTypes.size(); i++)
+    {
+        UsdPhysicsObjectType::Enum type = collisionTypes[i];
+        switch (type)
+        {
+        case UsdPhysicsObjectType::eSphereShape:
+        {
+            sphereShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eCubeShape:
+        {
+            cubeShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eCapsuleShape:
+        {
+            capsuleShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eCylinderShape:
+        {
+            cylinderShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eConeShape:
+        {
+            coneShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eMeshShape:
+        {
+            meshShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::ePlaneShape:
+        {
+            planeShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eCustomShape:
+        {
+            customShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eSpherePointsShape:
+        {
+            spherePointsShapePrims.push_back(collisionPrims[i]);
+        }
+        break;
+        case UsdPhysicsObjectType::eUndefined:
+        default:
+        {
+            TF_DIAGNOSTIC_WARNING("CollisionAPI applied to an unknown UsdGeomGPrim type, prim %s.",
+                collisionPrims[i].GetPrimPath().GetString().c_str());
+        }
+        break;
+        }
+    }
+    std::vector<UsdPhysicsSphereShapeDesc> sphereShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsSphereShapeDesc, UsdPhysicsCollisionAPI>
+        (sphereShapePrims, sphereShapeDescs, ParseSphereShapeDesc);
+
+    std::vector<UsdPhysicsCubeShapeDesc> cubeShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCubeShapeDesc, UsdPhysicsCollisionAPI>
+        (cubeShapePrims, cubeShapeDescs, ParseCubeShapeDesc);
+
+    std::vector<UsdPhysicsCylinderShapeDesc> cylinderShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCylinderShapeDesc, UsdPhysicsCollisionAPI>
+        (cylinderShapePrims, cylinderShapeDescs, ParseCylinderShapeDesc);
+
+    std::vector<UsdPhysicsCapsuleShapeDesc> capsuleShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCapsuleShapeDesc, UsdPhysicsCollisionAPI>
+        (capsuleShapePrims, capsuleShapeDescs, ParseCapsuleShapeDesc);
+
+    std::vector<UsdPhysicsConeShapeDesc> coneShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsConeShapeDesc, UsdPhysicsCollisionAPI>
+        (coneShapePrims, coneShapeDescs, ParseConeShapeDesc);
+
+    std::vector<UsdPhysicsPlaneShapeDesc> planeShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsPlaneShapeDesc, UsdPhysicsCollisionAPI>
+        (planeShapePrims, planeShapeDescs, ParsePlaneShapeDesc);
+
+    std::vector<UsdPhysicsMeshShapeDesc> meshShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsMeshShapeDesc, UsdPhysicsCollisionAPI>
+        (meshShapePrims, meshShapeDescs, ParseMeshShapeDesc);
+
+    std::vector<UsdPhysicsSpherePointsShapeDesc> spherePointsShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsSpherePointsShapeDesc, UsdPhysicsCollisionAPI>
+        (spherePointsShapePrims, spherePointsShapeDescs, ParseSpherePointsShapeDesc);
+
+    std::vector<UsdPhysicsCustomShapeDesc> customShapeDescs;
+    ProcessPhysicsPrims<UsdPhysicsCustomShapeDesc, UsdPhysicsCollisionAPI>
+        (customShapePrims, customShapeDescs, ParseCustomShapeDesc);
+    if (customShapeDescs.size() == customTokens.size())
+    {
+        for (size_t i = 0; i < customShapeDescs.size(); i++)
+        {
+            customShapeDescs[i].customGeometryToken = customTokens[i];
+        }
+    }
+
+    // rigid bodies
+    std::vector<UsdPhysicsRigidBodyDesc> rigidBodyDescs;
+    ProcessPhysicsPrims<UsdPhysicsRigidBodyDesc, UsdPhysicsRigidBodyAPI>
+        (rigidBodyPrims, rigidBodyDescs, ParseRigidBodyDesc);
+    // Ensure if we have a hierarchical parent that has a dynamic parent,
+    // that we also have a reset xform stack, otherwise we should log an error.
+    // check for nested articulation roots, these are not supported
+    RigidBodyMap bodyMap;
+    for (size_t i = rigidBodyPrims.size(); i--;)
+    {
+        bodyMap[rigidBodyPrims[i].GetPrimPath()] = &rigidBodyDescs[i];
+    }
+
+    for (size_t i = rigidBodyPrims.size(); i--;)
+    {
+        const UsdPrim bodyPrim = rigidBodyPrims[i];
+        UsdPrim bodyParent = UsdPrim();
+        if (HasDynamicBodyParent(bodyPrim.GetParent(), bodyMap, bodyParent))
+        {
+            bool hasResetXformStack = false;
+            UsdPrim parent = bodyPrim;
+            while (parent != stage->GetPseudoRoot() && parent != bodyParent)
+            {
+                const UsdGeomXformable xform(parent);
+                if (xform && xform.GetResetXformStack())
+                {
+                    hasResetXformStack = true;
+                    break;
+                }
+                parent = parent.GetParent();
+            }
+            if (!hasResetXformStack)
+            {
+
+                TF_DIAGNOSTIC_WARNING("Rigid Body of (%s) missing xformstack reset when child of rigid body (%s) in hierarchy."
+                    "Simulation of multiple RigidBodyAPI's in a hierarchy will cause unpredicted results."
+                    "Please fix the hierarchy or use XformStack reset.",
+                    bodyPrim.GetPrimPath().GetText(),
+                    bodyParent.GetPrimPath().GetText());
+
+                rigidBodyPrims[i] = rigidBodyPrims.back();
+                rigidBodyPrims.pop_back();
+            }
+        }
+    }
+
+    // articulations
+    // check for nested articulation roots, these are not supported    
+    for (size_t i = articulationPrims.size(); i--;)
+    {
+        if (CheckNestedArticulationRoot(articulationPrims[i], articulationPathsSet))
+        {
+            TF_DIAGNOSTIC_WARNING("Nested ArticulationRootAPI not supported, API ignored, prim %s.",
+                articulationPrims[i].GetPrimPath().GetString().c_str());
+            articulationPrims[i] = articulationPrims.back();
+            articulationPrims.pop_back();
+        }
+    }
+    std::vector<UsdPhysicsArticulationDesc> articulationDescs;
+    ProcessPhysicsPrims<UsdPhysicsArticulationDesc, UsdPhysicsArticulationRootAPI>
+        (articulationPrims, articulationDescs, ParseArticulationDesc);
+
+    ArticulationMap articulationMap; // A.B. TODO probably not needed
+    for (size_t i = articulationPrims.size(); i--;)
+    {
+        articulationMap[articulationPrims[i].GetPrimPath()] = &articulationDescs[i];
+    }
+
+    // Finalize collisions
+    {
+        UsdGeomXformCache xfCache;
+
+        FinalizeCollisionDescs<UsdPhysicsSphereShapeDesc>
+            (xfCache, sphereShapePrims, sphereShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCubeShapeDesc>
+            (xfCache, cubeShapePrims, cubeShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCapsuleShapeDesc>
+            (xfCache, capsuleShapePrims, capsuleShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCylinderShapeDesc>
+            (xfCache, cylinderShapePrims, cylinderShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsConeShapeDesc>
+            (xfCache, coneShapePrims, coneShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsPlaneShapeDesc>
+            (xfCache, planeShapePrims, planeShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsMeshShapeDesc>
+            (xfCache, meshShapePrims, meshShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsSpherePointsShapeDesc>
+            (xfCache, spherePointsShapePrims, spherePointsShapeDescs, bodyMap, collisionGroupSets);
+        FinalizeCollisionDescs<UsdPhysicsCustomShapeDesc>
+            (xfCache, customShapePrims, customShapeDescs, bodyMap, collisionGroupSets);
+    }
+
+    // Finalize articulations
+    {
+        // A.B. walk through the finalize code refactor
+        FinalizeArticulations(stage, articulationMap, bodyMap, jointMap);
+    }
+
+    // if simulationOwners are in play lets shrink down the reported descriptors    
+    if (simulationOwners && !simulationOwners->empty())
+    {
+        std::unordered_set<SdfPath, SdfPath::Hash> reportedBodies;
+        // first check bodies
+        CheckRigidBodySimulationOwner(rigidBodyPrims, rigidBodyDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+        // check collisions
+        // if collision belongs to a body that we care about include it
+        // if collision does not belong to a body we care about its not included
+        // if collision does not have a body set, we check its own simulationOwners
+        CheckCollisionSimulationOwner(sphereShapePrims, sphereShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(cubeShapePrims, cubeShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(capsuleShapePrims, capsuleShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(cylinderShapePrims, cylinderShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(coneShapePrims, coneShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(planeShapePrims, planeShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(meshShapePrims, meshShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(spherePointsShapePrims, spherePointsShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckCollisionSimulationOwner(customShapePrims, customShapeDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+        // Both bodies need to have simulation owners valid
+        CheckJointSimulationOwner(physicsFixedJointPrims, fixedJointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsRevoluteJointPrims, revoluteJointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsPrismaticJointPrims, prismaticJointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsSphericalJointPrims, sphericalJointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsDistanceJointPrims, distanceJointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsD6JointPrims, jointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+        CheckJointSimulationOwner(physicsCustomJointPrims, customJointDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+
+        // All bodies need to have simulation owners valid
+        CheckArticulationSimulationOwner(articulationPrims, articulationDescs,
+            defaultSimulationOwner, reportedBodies, simulationOwnersSet);
+    }
+
+    SdfPathVector primPathsVector;
+    // get the descriptors, finalize them and send them out in an order
+    // 1. send out the scenes
+    {
+        CallReportFn(UsdPhysicsObjectType::eScene, scenePrims, sceneDescs,
+            reportFn, primPathsVector, userData);
+    }
+
+    // 2. send out the CollisionGroups
+    {
+        CallReportFn(UsdPhysicsObjectType::eCollisionGroup, collisionGroupPrims,
+            collisionGroupsDescs, reportFn, primPathsVector, userData);
+    }
+
+    // 3. send out the materials
+    {
+        CallReportFn(UsdPhysicsObjectType::eRigidBodyMaterial, materialPrims,
+            materialDescs, reportFn, primPathsVector, userData);
+    }
+
+    // 4. finish out and send out shapes
+    {
+        CallReportFn(UsdPhysicsObjectType::eSphereShape, sphereShapePrims, sphereShapeDescs,
+            reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eCubeShape, cubeShapePrims, cubeShapeDescs,
+            reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eCapsuleShape, capsuleShapePrims,
+            capsuleShapeDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eCylinderShape, cylinderShapePrims,
+            cylinderShapeDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eConeShape, coneShapePrims, coneShapeDescs,
+            reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::ePlaneShape, planeShapePrims, planeShapeDescs,
+            reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eMeshShape, meshShapePrims, meshShapeDescs,
+            reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eSpherePointsShape, spherePointsShapePrims,
+            spherePointsShapeDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eCustomShape, customShapePrims, customShapeDescs,
+            reportFn, primPathsVector, userData);
+    }
+
+    // 5. send out articulations
+    {
+        CallReportFn(UsdPhysicsObjectType::eArticulation, articulationPrims,
+            articulationDescs, reportFn, primPathsVector, userData);
+    }
+
+    // 6. send out bodies
+    {
+        CallReportFn(UsdPhysicsObjectType::eRigidBody, rigidBodyPrims, rigidBodyDescs,
+            reportFn, primPathsVector, userData);
+    }
+
+    // 7. send out joints    
+    {
+        CallReportFn(UsdPhysicsObjectType::eFixedJoint, physicsFixedJointPrims,
+            fixedJointDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eRevoluteJoint, physicsRevoluteJointPrims,
+            revoluteJointDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::ePrismaticJoint, physicsPrismaticJointPrims,
+            prismaticJointDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eSphericalJoint, physicsSphericalJointPrims,
+            sphericalJointDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eDistanceJoint, physicsDistanceJointPrims,
+            distanceJointDescs, reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eD6Joint, physicsD6JointPrims, jointDescs,
+            reportFn, primPathsVector, userData);
+        CallReportFn(UsdPhysicsObjectType::eCustomJoint, physicsCustomJointPrims,
+            customJointDescs, reportFn, primPathsVector, userData);
+    }
+
+    return retVal;
 }
 
 
diff --git a/pxr/usd/usdPhysics/parseUtils.h b/pxr/usd/usdPhysics/parseUtils.h
index cd28362098..9e32d6eedd 100644
--- a/pxr/usd/usdPhysics/parseUtils.h
+++ b/pxr/usd/usdPhysics/parseUtils.h
@@ -35,8 +35,8 @@ PXR_NAMESPACE_OPEN_SCOPE
 /// \param[in] userData User data provided to the parsing function
 using UsdPhysicsReportFn =
 std::function<void(UsdPhysicsObjectType::Enum type, size_t numDesc,
-	const SdfPath* primPaths, const UsdPhysicsObjectDesc* objectDescs,
-	void* userData)>;
+    const SdfPath* primPaths, const UsdPhysicsObjectDesc* objectDescs,
+    void* userData)>;
 
 /// \struct CustomUsdPhysicsTokens
 ///
@@ -44,10 +44,10 @@ std::function<void(UsdPhysicsObjectType::Enum type, size_t numDesc,
 ///
 struct CustomUsdPhysicsTokens
 {
-	std::vector<TfToken> jointTokens;       ///< Custom joints to be reported by parsing
-	std::vector<TfToken> shapeTokens;       ///< Custom shapes to be reported by parsing
-	std::vector<TfToken> instancerTokens;   ///< Custom physics instancers to be 
-	///< skipped by parsing
+    std::vector<TfToken> jointTokens;       ///< Custom joints to be reported by parsing
+    std::vector<TfToken> shapeTokens;       ///< Custom shapes to be reported by parsing
+    std::vector<TfToken> instancerTokens;   ///< Custom physics instancers to be 
+    ///< skipped by parsing
 };
 
 /// Load USD physics from a given range
@@ -62,11 +62,11 @@ struct CustomUsdPhysicsTokens
 ///                       simulation owner should be parsed too.
 /// \return True if load was successful
 USDPHYSICS_API bool LoadUsdPhysicsFromRange(const UsdStageWeakPtr stage,
-	ParsePrimIteratorBase& range,
-	UsdPhysicsReportFn reportFn,
-	void* userData,
-	const CustomUsdPhysicsTokens* customPhysicsTokens = nullptr,
-	const std::vector<SdfPath>* simulationOwners = nullptr);
+    ParsePrimIteratorBase& range,
+    UsdPhysicsReportFn reportFn,
+    void* userData,
+    const CustomUsdPhysicsTokens* customPhysicsTokens = nullptr,
+    const std::vector<SdfPath>* simulationOwners = nullptr);
 
 
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/usd/usdPhysics/wrapParseUtils.cpp b/pxr/usd/usdPhysics/wrapParseUtils.cpp
index 33f90c0a0f..6c6801dc35 100644
--- a/pxr/usd/usdPhysics/wrapParseUtils.cpp
+++ b/pxr/usd/usdPhysics/wrapParseUtils.cpp
@@ -35,8 +35,8 @@ PXR_NAMESPACE_USING_DIRECTIVE
 template <typename T>
 void registerVectorConverter(const char* name)
 {
-	pxr_boost::python::class_<std::vector<T>>(name).def(
-		pxr_boost::python::vector_indexing_suite<std::vector<T>>());
+    pxr_boost::python::class_<std::vector<T>>(name).def(
+        pxr_boost::python::vector_indexing_suite<std::vector<T>>());
 }
 
 using namespace pxr_boost::python;
@@ -44,1227 +44,1227 @@ using namespace pxr_boost::python;
 
 // Wrapper class
 class ParsePrimIteratorBaseWrap : public ParsePrimIteratorBase,
-	public pxr_boost::python::wrapper<ParsePrimIteratorBase>
+    public pxr_boost::python::wrapper<ParsePrimIteratorBase>
 {
 public:
-	void reset() {
-		this->get_override("reset")();
-	}
+    void reset() {
+        this->get_override("reset")();
+    }
 
-	bool atEnd() const {
-		return this->get_override("atEnd")();
-	}
+    bool atEnd() const {
+        return this->get_override("atEnd")();
+    }
 
-	UsdPrimRange::const_iterator getCurrent() {
-		return this->get_override("getCurrent")();
-	}
+    UsdPrimRange::const_iterator getCurrent() {
+        return this->get_override("getCurrent")();
+    }
 
-	void next() {
-		this->get_override("next")();
-	}
+    void next() {
+        this->get_override("next")();
+    }
 
-	void pruneChildren() {
-		this->get_override("pruneChildren")();
-	}
+    void pruneChildren() {
+        this->get_override("pruneChildren")();
+    }
 };
 
 class MarshalCallback
 {
 public:
 
-	SdfPathVector                   scenePrimPaths;
-	std::vector<UsdPhysicsSceneDesc>          sceneDescs;
+    SdfPathVector                   scenePrimPaths;
+    std::vector<UsdPhysicsSceneDesc>          sceneDescs;
 
-	SdfPathVector                   rigidBodyPrimPaths;
-	std::vector<UsdPhysicsRigidBodyDesc>      rigidBodyDescs;
+    SdfPathVector                   rigidBodyPrimPaths;
+    std::vector<UsdPhysicsRigidBodyDesc>      rigidBodyDescs;
 
-	SdfPathVector                   sphereShapePrimPaths;
-	std::vector<UsdPhysicsSphereShapeDesc>    sphereShapeDescs;
+    SdfPathVector                   sphereShapePrimPaths;
+    std::vector<UsdPhysicsSphereShapeDesc>    sphereShapeDescs;
 
-	SdfPathVector                   cubeShapePrimPaths;
-	std::vector<UsdPhysicsCubeShapeDesc>    cubeShapeDescs;
+    SdfPathVector                   cubeShapePrimPaths;
+    std::vector<UsdPhysicsCubeShapeDesc>    cubeShapeDescs;
 
-	SdfPathVector                   capsuleShapePrimPaths;
-	std::vector<UsdPhysicsCapsuleShapeDesc>    capsuleShapeDescs;
+    SdfPathVector                   capsuleShapePrimPaths;
+    std::vector<UsdPhysicsCapsuleShapeDesc>    capsuleShapeDescs;
 
-	SdfPathVector                   cylinderShapePrimPaths;
-	std::vector<UsdPhysicsCylinderShapeDesc>    cylinderShapeDescs;
+    SdfPathVector                   cylinderShapePrimPaths;
+    std::vector<UsdPhysicsCylinderShapeDesc>    cylinderShapeDescs;
 
-	SdfPathVector            coneShapePrimPaths;
-	std::vector<UsdPhysicsConeShapeDesc>    coneShapeDescs;
+    SdfPathVector            coneShapePrimPaths;
+    std::vector<UsdPhysicsConeShapeDesc>    coneShapeDescs;
 
-	SdfPathVector            meshShapePrimPaths;
-	std::vector<UsdPhysicsMeshShapeDesc>    meshShapeDescs;
+    SdfPathVector            meshShapePrimPaths;
+    std::vector<UsdPhysicsMeshShapeDesc>    meshShapeDescs;
 
-	SdfPathVector            planeShapePrimPaths;
-	std::vector<UsdPhysicsPlaneShapeDesc>    planeShapeDescs;
+    SdfPathVector            planeShapePrimPaths;
+    std::vector<UsdPhysicsPlaneShapeDesc>    planeShapeDescs;
 
-	SdfPathVector            customShapePrimPaths;
-	std::vector<UsdPhysicsCustomShapeDesc>    customShapeDescs;
+    SdfPathVector            customShapePrimPaths;
+    std::vector<UsdPhysicsCustomShapeDesc>    customShapeDescs;
 
-	SdfPathVector            spherePointShapePrimPaths;
-	std::vector<UsdPhysicsSpherePointsShapeDesc>    spherePointsShapeDescs;
+    SdfPathVector            spherePointShapePrimPaths;
+    std::vector<UsdPhysicsSpherePointsShapeDesc>    spherePointsShapeDescs;
 
-	SdfPathVector            fixedJointPrimPaths;
-	std::vector<UsdPhysicsFixedJointDesc>    fixedJointDescs;
+    SdfPathVector            fixedJointPrimPaths;
+    std::vector<UsdPhysicsFixedJointDesc>    fixedJointDescs;
 
-	SdfPathVector            revoluteJointPrimPaths;
-	std::vector<UsdPhysicsRevoluteJointDesc>    revoluteJointDescs;
+    SdfPathVector            revoluteJointPrimPaths;
+    std::vector<UsdPhysicsRevoluteJointDesc>    revoluteJointDescs;
 
-	SdfPathVector            prismaticJointPrimPaths;
-	std::vector<UsdPhysicsPrismaticJointDesc>    prismaticJointDescs;
+    SdfPathVector            prismaticJointPrimPaths;
+    std::vector<UsdPhysicsPrismaticJointDesc>    prismaticJointDescs;
 
-	SdfPathVector            sphericalJointPrimPaths;
-	std::vector<UsdPhysicsSphericalJointDesc>    sphericalJointDescs;
+    SdfPathVector            sphericalJointPrimPaths;
+    std::vector<UsdPhysicsSphericalJointDesc>    sphericalJointDescs;
 
-	SdfPathVector            distanceJointPrimPaths;
-	std::vector<UsdPhysicsDistanceJointDesc>    distanceJointDescs;
+    SdfPathVector            distanceJointPrimPaths;
+    std::vector<UsdPhysicsDistanceJointDesc>    distanceJointDescs;
 
-	SdfPathVector            d6JointPrimPaths;
-	std::vector<UsdPhysicsD6JointDesc>    d6JointDescs;
+    SdfPathVector            d6JointPrimPaths;
+    std::vector<UsdPhysicsD6JointDesc>    d6JointDescs;
 
-	SdfPathVector            customJointPrimPaths;
-	std::vector<UsdPhysicsCustomJointDesc>    customJointDescs;
+    SdfPathVector            customJointPrimPaths;
+    std::vector<UsdPhysicsCustomJointDesc>    customJointDescs;
 
-	SdfPathVector            rigidBodyMaterialPrimPaths;
-	std::vector<UsdPhysicsRigidBodyMaterialDesc>    rigidBodyMaterialDescs;
+    SdfPathVector            rigidBodyMaterialPrimPaths;
+    std::vector<UsdPhysicsRigidBodyMaterialDesc>    rigidBodyMaterialDescs;
 
-	SdfPathVector            articulationPrimPaths;
-	std::vector<UsdPhysicsArticulationDesc>    articulationDescs;
+    SdfPathVector            articulationPrimPaths;
+    std::vector<UsdPhysicsArticulationDesc>    articulationDescs;
 
-	SdfPathVector            collisionGroupPrimPaths;
-	std::vector<UsdPhysicsCollisionGroupDesc>    collisionGroupDescs;
+    SdfPathVector            collisionGroupPrimPaths;
+    std::vector<UsdPhysicsCollisionGroupDesc>    collisionGroupDescs;
 
-	void clear()
-	{
-		scenePrimPaths.clear();
-		sceneDescs.clear();
+    void clear()
+    {
+        scenePrimPaths.clear();
+        sceneDescs.clear();
 
-		rigidBodyPrimPaths.clear();
-		rigidBodyDescs.clear();
+        rigidBodyPrimPaths.clear();
+        rigidBodyDescs.clear();
 
-		sphereShapePrimPaths.clear();
-		sphereShapeDescs.clear();
+        sphereShapePrimPaths.clear();
+        sphereShapeDescs.clear();
 
-		cubeShapePrimPaths.clear();
-		cubeShapeDescs.clear();
+        cubeShapePrimPaths.clear();
+        cubeShapeDescs.clear();
 
-		capsuleShapePrimPaths.clear();
-		capsuleShapeDescs.clear();
+        capsuleShapePrimPaths.clear();
+        capsuleShapeDescs.clear();
 
-		cylinderShapePrimPaths.clear();
-		cylinderShapeDescs.clear();
+        cylinderShapePrimPaths.clear();
+        cylinderShapeDescs.clear();
 
-		coneShapePrimPaths.clear();
-		coneShapeDescs.clear();
+        coneShapePrimPaths.clear();
+        coneShapeDescs.clear();
 
-		meshShapePrimPaths.clear();
-		meshShapeDescs.clear();
+        meshShapePrimPaths.clear();
+        meshShapeDescs.clear();
 
-		planeShapePrimPaths.clear();
-		planeShapeDescs.clear();
+        planeShapePrimPaths.clear();
+        planeShapeDescs.clear();
 
-		customShapePrimPaths.clear();
-		customShapeDescs.clear();
+        customShapePrimPaths.clear();
+        customShapeDescs.clear();
 
-		spherePointShapePrimPaths.clear();
-		spherePointsShapeDescs.clear();
+        spherePointShapePrimPaths.clear();
+        spherePointsShapeDescs.clear();
 
-		fixedJointPrimPaths.clear();
-		fixedJointDescs.clear();
+        fixedJointPrimPaths.clear();
+        fixedJointDescs.clear();
 
-		revoluteJointPrimPaths.clear();
-		revoluteJointDescs.clear();
+        revoluteJointPrimPaths.clear();
+        revoluteJointDescs.clear();
 
-		prismaticJointPrimPaths.clear();
-		prismaticJointDescs.clear();
+        prismaticJointPrimPaths.clear();
+        prismaticJointDescs.clear();
 
-		sphericalJointPrimPaths.clear();
-		sphericalJointDescs.clear();
+        sphericalJointPrimPaths.clear();
+        sphericalJointDescs.clear();
 
-		distanceJointPrimPaths.clear();
-		distanceJointDescs.clear();
+        distanceJointPrimPaths.clear();
+        distanceJointDescs.clear();
 
-		d6JointPrimPaths.clear();
-		d6JointDescs.clear();
+        d6JointPrimPaths.clear();
+        d6JointDescs.clear();
 
-		customJointPrimPaths.clear();
-		customJointDescs.clear();
+        customJointPrimPaths.clear();
+        customJointDescs.clear();
 
-		rigidBodyMaterialPrimPaths.clear();
-		rigidBodyMaterialDescs.clear();
+        rigidBodyMaterialPrimPaths.clear();
+        rigidBodyMaterialDescs.clear();
 
-		articulationPrimPaths.clear();
-		articulationDescs.clear();
+        articulationPrimPaths.clear();
+        articulationDescs.clear();
 
-		collisionGroupPrimPaths.clear();
-		collisionGroupDescs.clear();
-	}
+        collisionGroupPrimPaths.clear();
+        collisionGroupDescs.clear();
+    }
 
 } gMarshalCallback;
 
 template <typename DescType>
 void copyDescs(size_t numDesc, const SdfPath* primsSource, SdfPathVector& primsDest,
-	const UsdPhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
+    const UsdPhysicsObjectDesc* objectDescsSource, std::vector<DescType>& objectDescsDest)
 {
-	primsDest.resize(numDesc);
-	objectDescsDest.resize(numDesc);
-
-	if (numDesc)
-	{
-		const DescType* sourceDesc = reinterpret_cast<const DescType*>(objectDescsSource);
-
-		for (size_t i = 0; i < numDesc; i++)
-		{
-			primsDest[i] = primsSource[i];
-			objectDescsDest[i] = sourceDesc[i];
-		}
-	}
+    primsDest.resize(numDesc);
+    objectDescsDest.resize(numDesc);
+
+    if (numDesc)
+    {
+        const DescType* sourceDesc = reinterpret_cast<const DescType*>(objectDescsSource);
+
+        for (size_t i = 0; i < numDesc; i++)
+        {
+            primsDest[i] = primsSource[i];
+            objectDescsDest[i] = sourceDesc[i];
+        }
+    }
 }
 
 void ReportPhysicsObjectsFn(UsdPhysicsObjectType::Enum type, size_t numDesc,
-	const SdfPath* primPaths,
-	const UsdPhysicsObjectDesc* objectDescs, void* userData)
+    const SdfPath* primPaths,
+    const UsdPhysicsObjectDesc* objectDescs, void* userData)
 {
-	MarshalCallback* cb = (MarshalCallback*)userData;
-
-	switch (type)
-	{
-	case UsdPhysicsObjectType::eScene:
-	{
-		copyDescs(numDesc, primPaths, cb->scenePrimPaths, objectDescs, cb->sceneDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eRigidBody:
-	{
-		copyDescs(numDesc, primPaths, cb->rigidBodyPrimPaths, objectDescs, cb->rigidBodyDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eSphereShape:
-	{
-		copyDescs(numDesc, primPaths, cb->sphereShapePrimPaths, objectDescs, cb->sphereShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eCubeShape:
-	{
-		copyDescs(numDesc, primPaths, cb->cubeShapePrimPaths, objectDescs, cb->cubeShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eCapsuleShape:
-	{
-		copyDescs(numDesc, primPaths, cb->capsuleShapePrimPaths, objectDescs, cb->capsuleShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eCylinderShape:
-	{
-		copyDescs(numDesc, primPaths, cb->cylinderShapePrimPaths, objectDescs, cb->cylinderShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eConeShape:
-	{
-		copyDescs(numDesc, primPaths, cb->coneShapePrimPaths, objectDescs, cb->coneShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eMeshShape:
-	{
-		copyDescs(numDesc, primPaths, cb->meshShapePrimPaths, objectDescs, cb->meshShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::ePlaneShape:
-	{
-		copyDescs(numDesc, primPaths, cb->planeShapePrimPaths, objectDescs, cb->planeShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eCustomShape:
-	{
-		copyDescs(numDesc, primPaths, cb->customShapePrimPaths, objectDescs,
-			cb->customShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eSpherePointsShape:
-	{
-		copyDescs(numDesc, primPaths, cb->spherePointShapePrimPaths, objectDescs,
-			cb->spherePointsShapeDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eFixedJoint:
-	{
-		copyDescs(numDesc, primPaths, cb->fixedJointPrimPaths, objectDescs, cb->fixedJointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eRevoluteJoint:
-	{
-		copyDescs(numDesc, primPaths, cb->revoluteJointPrimPaths, objectDescs,
-			cb->revoluteJointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::ePrismaticJoint:
-	{
-		copyDescs(numDesc, primPaths, cb->prismaticJointPrimPaths, objectDescs,
-			cb->prismaticJointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eSphericalJoint:
-	{
-		copyDescs(numDesc, primPaths, cb->sphericalJointPrimPaths, objectDescs,
-			cb->sphericalJointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eDistanceJoint:
-	{
-		copyDescs(numDesc, primPaths, cb->distanceJointPrimPaths, objectDescs,
-			cb->distanceJointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eD6Joint:
-	{
-		copyDescs(numDesc, primPaths, cb->d6JointPrimPaths, objectDescs, cb->d6JointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eCustomJoint:
-	{
-		copyDescs(numDesc, primPaths, cb->customJointPrimPaths, objectDescs,
-			cb->customJointDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eRigidBodyMaterial:
-	{
-		copyDescs(numDesc, primPaths, cb->rigidBodyMaterialPrimPaths, objectDescs,
-			cb->rigidBodyMaterialDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eArticulation:
-	{
-		copyDescs(numDesc, primPaths, cb->articulationPrimPaths, objectDescs,
-			cb->articulationDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eCollisionGroup:
-	{
-		copyDescs(numDesc, primPaths, cb->collisionGroupPrimPaths, objectDescs,
-			cb->collisionGroupDescs);
-	}
-	break;
-	case UsdPhysicsObjectType::eUndefined:
-	default:
-	{
-		TF_DIAGNOSTIC_WARNING("UsdPhysicsObject type unknown for python wrapping.");
-	}
-	break;
-	}
+    MarshalCallback* cb = (MarshalCallback*)userData;
+
+    switch (type)
+    {
+    case UsdPhysicsObjectType::eScene:
+    {
+        copyDescs(numDesc, primPaths, cb->scenePrimPaths, objectDescs, cb->sceneDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eRigidBody:
+    {
+        copyDescs(numDesc, primPaths, cb->rigidBodyPrimPaths, objectDescs, cb->rigidBodyDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eSphereShape:
+    {
+        copyDescs(numDesc, primPaths, cb->sphereShapePrimPaths, objectDescs, cb->sphereShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eCubeShape:
+    {
+        copyDescs(numDesc, primPaths, cb->cubeShapePrimPaths, objectDescs, cb->cubeShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eCapsuleShape:
+    {
+        copyDescs(numDesc, primPaths, cb->capsuleShapePrimPaths, objectDescs, cb->capsuleShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eCylinderShape:
+    {
+        copyDescs(numDesc, primPaths, cb->cylinderShapePrimPaths, objectDescs, cb->cylinderShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eConeShape:
+    {
+        copyDescs(numDesc, primPaths, cb->coneShapePrimPaths, objectDescs, cb->coneShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eMeshShape:
+    {
+        copyDescs(numDesc, primPaths, cb->meshShapePrimPaths, objectDescs, cb->meshShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::ePlaneShape:
+    {
+        copyDescs(numDesc, primPaths, cb->planeShapePrimPaths, objectDescs, cb->planeShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eCustomShape:
+    {
+        copyDescs(numDesc, primPaths, cb->customShapePrimPaths, objectDescs,
+            cb->customShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eSpherePointsShape:
+    {
+        copyDescs(numDesc, primPaths, cb->spherePointShapePrimPaths, objectDescs,
+            cb->spherePointsShapeDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eFixedJoint:
+    {
+        copyDescs(numDesc, primPaths, cb->fixedJointPrimPaths, objectDescs, cb->fixedJointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eRevoluteJoint:
+    {
+        copyDescs(numDesc, primPaths, cb->revoluteJointPrimPaths, objectDescs,
+            cb->revoluteJointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::ePrismaticJoint:
+    {
+        copyDescs(numDesc, primPaths, cb->prismaticJointPrimPaths, objectDescs,
+            cb->prismaticJointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eSphericalJoint:
+    {
+        copyDescs(numDesc, primPaths, cb->sphericalJointPrimPaths, objectDescs,
+            cb->sphericalJointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eDistanceJoint:
+    {
+        copyDescs(numDesc, primPaths, cb->distanceJointPrimPaths, objectDescs,
+            cb->distanceJointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eD6Joint:
+    {
+        copyDescs(numDesc, primPaths, cb->d6JointPrimPaths, objectDescs, cb->d6JointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eCustomJoint:
+    {
+        copyDescs(numDesc, primPaths, cb->customJointPrimPaths, objectDescs,
+            cb->customJointDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eRigidBodyMaterial:
+    {
+        copyDescs(numDesc, primPaths, cb->rigidBodyMaterialPrimPaths, objectDescs,
+            cb->rigidBodyMaterialDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eArticulation:
+    {
+        copyDescs(numDesc, primPaths, cb->articulationPrimPaths, objectDescs,
+            cb->articulationDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eCollisionGroup:
+    {
+        copyDescs(numDesc, primPaths, cb->collisionGroupPrimPaths, objectDescs,
+            cb->collisionGroupDescs);
+    }
+    break;
+    case UsdPhysicsObjectType::eUndefined:
+    default:
+    {
+        TF_DIAGNOSTIC_WARNING("UsdPhysicsObject type unknown for python wrapping.");
+    }
+    break;
+    }
 }
 
 struct _CustomUsdPhysicsTokens
 {
-	_CustomUsdPhysicsTokens()
-	{
+    _CustomUsdPhysicsTokens()
+    {
 
-	}
+    }
 
-	pxr_boost::python::list jointTokens;  ///< Custom joints to be reported by parsing
-	pxr_boost::python::list shapeTokens;  ///< Custom shapes to be reported by parsing
-	pxr_boost::python::list instancerTokens;  ///< Custom physics instancers to 
-	///<be skipped by parsing
+    pxr_boost::python::list jointTokens;  ///< Custom joints to be reported by parsing
+    pxr_boost::python::list shapeTokens;  ///< Custom shapes to be reported by parsing
+    pxr_boost::python::list instancerTokens;  ///< Custom physics instancers to 
+    ///<be skipped by parsing
 };
 
 std::string getString(const pxr_boost::python::object& po)
 {
-	if (pxr_boost::python::extract<std::string>(po).check()) {
-		std::string str = pxr_boost::python::extract<std::string>(po);
-		return str;
-	}
-	else
-	{
-		// Handle non-string items, e.g. convert to string
-		std::string str = pxr_boost::python::extract<std::string>(pxr_boost::python::str(po));
-		return str;
-	}
+    if (pxr_boost::python::extract<std::string>(po).check()) {
+        std::string str = pxr_boost::python::extract<std::string>(po);
+        return str;
+    }
+    else
+    {
+        // Handle non-string items, e.g. convert to string
+        std::string str = pxr_boost::python::extract<std::string>(pxr_boost::python::str(po));
+        return str;
+    }
 }
 
 pxr_boost::python::dict _LoadUsdPhysicsFromRange(UsdStageWeakPtr stage,
-	ParsePrimIteratorBase& range, const _CustomUsdPhysicsTokens& customTokens,
-	const std::vector<SdfPath>& simulationOwners)
+    ParsePrimIteratorBase& range, const _CustomUsdPhysicsTokens& customTokens,
+    const std::vector<SdfPath>& simulationOwners)
 {
-	CustomUsdPhysicsTokens parsingCustomTokens;
-	bool customTokensValid = false;
-	const size_t jointTokesSize = len(customTokens.jointTokens);
-	const size_t shapeTokesSize = len(customTokens.shapeTokens);
-	const size_t instancerTokesSize = len(customTokens.instancerTokens);
-	if (jointTokesSize || shapeTokesSize || instancerTokesSize)
-	{
-		for (size_t i = 0; i < jointTokesSize; i++)
-		{
-			parsingCustomTokens.jointTokens.push_back(
-				TfToken(getString(customTokens.jointTokens[i])));
-		}
-		for (size_t i = 0; i < shapeTokesSize; i++)
-		{
-			parsingCustomTokens.shapeTokens.push_back(
-				TfToken(getString(customTokens.shapeTokens[i])));
-		}
-		for (size_t i = 0; i < instancerTokesSize; i++)
-		{
-			parsingCustomTokens.instancerTokens.push_back(
-				TfToken(getString(customTokens.instancerTokens[i])));
-		}
-		customTokensValid = true;
-	}
-
-	gMarshalCallback.clear();
-	const bool ret_val = LoadUsdPhysicsFromRange(stage, range,
-		ReportPhysicsObjectsFn, &gMarshalCallback,
-		customTokensValid ? &parsingCustomTokens : nullptr,
-		!simulationOwners.empty() ? &simulationOwners : nullptr);
-	pxr_boost::python::dict retDict;
-	if (ret_val)
-	{
-		if (!gMarshalCallback.sceneDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eScene] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
-		}
-		if (!gMarshalCallback.rigidBodyDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eRigidBody] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
-		}
-		if (!gMarshalCallback.sphereShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eSphereShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
-		}
-		if (!gMarshalCallback.cubeShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eCubeShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
-		}
-		if (!gMarshalCallback.capsuleShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eCapsuleShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
-		}
-		if (!gMarshalCallback.cylinderShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eCylinderShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
-		}
-		if (!gMarshalCallback.coneShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eConeShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
-		}
-		if (!gMarshalCallback.meshShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eMeshShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
-		}
-		if (!gMarshalCallback.planeShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::ePlaneShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
-		}
-		if (!gMarshalCallback.customShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eCustomShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
-		}
-		if (!gMarshalCallback.spherePointsShapeDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eSpherePointsShape] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
-		}
-		if (!gMarshalCallback.fixedJointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eFixedJoint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
-		}
-		if (!gMarshalCallback.revoluteJointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eRevoluteJoint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
-		}
-		if (!gMarshalCallback.prismaticJointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::ePrismaticJoint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
-		}
-		if (!gMarshalCallback.sphericalJointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eSphericalJoint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
-		}
-		if (!gMarshalCallback.distanceJointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eDistanceJoint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
-		}
-		if (!gMarshalCallback.d6JointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eD6Joint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
-		}
-		if (!gMarshalCallback.customJointDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eCustomJoint] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
-		}
-		if (!gMarshalCallback.rigidBodyMaterialDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eRigidBodyMaterial] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
-		}
-		if (!gMarshalCallback.articulationDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eArticulation] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
-		}
-		if (!gMarshalCallback.collisionGroupDescs.empty())
-		{
-			retDict[UsdPhysicsObjectType::eCollisionGroup] =
-				pxr_boost::python::make_tuple(
-					gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
-		}
-	}
-	return retDict;
+    CustomUsdPhysicsTokens parsingCustomTokens;
+    bool customTokensValid = false;
+    const size_t jointTokesSize = len(customTokens.jointTokens);
+    const size_t shapeTokesSize = len(customTokens.shapeTokens);
+    const size_t instancerTokesSize = len(customTokens.instancerTokens);
+    if (jointTokesSize || shapeTokesSize || instancerTokesSize)
+    {
+        for (size_t i = 0; i < jointTokesSize; i++)
+        {
+            parsingCustomTokens.jointTokens.push_back(
+                TfToken(getString(customTokens.jointTokens[i])));
+        }
+        for (size_t i = 0; i < shapeTokesSize; i++)
+        {
+            parsingCustomTokens.shapeTokens.push_back(
+                TfToken(getString(customTokens.shapeTokens[i])));
+        }
+        for (size_t i = 0; i < instancerTokesSize; i++)
+        {
+            parsingCustomTokens.instancerTokens.push_back(
+                TfToken(getString(customTokens.instancerTokens[i])));
+        }
+        customTokensValid = true;
+    }
+
+    gMarshalCallback.clear();
+    const bool ret_val = LoadUsdPhysicsFromRange(stage, range,
+        ReportPhysicsObjectsFn, &gMarshalCallback,
+        customTokensValid ? &parsingCustomTokens : nullptr,
+        !simulationOwners.empty() ? &simulationOwners : nullptr);
+    pxr_boost::python::dict retDict;
+    if (ret_val)
+    {
+        if (!gMarshalCallback.sceneDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eScene] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.scenePrimPaths, gMarshalCallback.sceneDescs);
+        }
+        if (!gMarshalCallback.rigidBodyDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eRigidBody] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.rigidBodyPrimPaths, gMarshalCallback.rigidBodyDescs);
+        }
+        if (!gMarshalCallback.sphereShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eSphereShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.sphereShapePrimPaths, gMarshalCallback.sphereShapeDescs);
+        }
+        if (!gMarshalCallback.cubeShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eCubeShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.cubeShapePrimPaths, gMarshalCallback.cubeShapeDescs);
+        }
+        if (!gMarshalCallback.capsuleShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eCapsuleShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.capsuleShapePrimPaths, gMarshalCallback.capsuleShapeDescs);
+        }
+        if (!gMarshalCallback.cylinderShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eCylinderShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.cylinderShapePrimPaths, gMarshalCallback.cylinderShapeDescs);
+        }
+        if (!gMarshalCallback.coneShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eConeShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.coneShapePrimPaths, gMarshalCallback.coneShapeDescs);
+        }
+        if (!gMarshalCallback.meshShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eMeshShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.meshShapePrimPaths, gMarshalCallback.meshShapeDescs);
+        }
+        if (!gMarshalCallback.planeShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::ePlaneShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.planeShapePrimPaths, gMarshalCallback.planeShapeDescs);
+        }
+        if (!gMarshalCallback.customShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eCustomShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.customShapePrimPaths, gMarshalCallback.customShapeDescs);
+        }
+        if (!gMarshalCallback.spherePointsShapeDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eSpherePointsShape] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.spherePointShapePrimPaths, gMarshalCallback.spherePointsShapeDescs);
+        }
+        if (!gMarshalCallback.fixedJointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eFixedJoint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.fixedJointPrimPaths, gMarshalCallback.fixedJointDescs);
+        }
+        if (!gMarshalCallback.revoluteJointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eRevoluteJoint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.revoluteJointPrimPaths, gMarshalCallback.revoluteJointDescs);
+        }
+        if (!gMarshalCallback.prismaticJointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::ePrismaticJoint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.prismaticJointPrimPaths, gMarshalCallback.prismaticJointDescs);
+        }
+        if (!gMarshalCallback.sphericalJointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eSphericalJoint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.sphericalJointPrimPaths, gMarshalCallback.sphericalJointDescs);
+        }
+        if (!gMarshalCallback.distanceJointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eDistanceJoint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.distanceJointPrimPaths, gMarshalCallback.distanceJointDescs);
+        }
+        if (!gMarshalCallback.d6JointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eD6Joint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.d6JointPrimPaths, gMarshalCallback.d6JointDescs);
+        }
+        if (!gMarshalCallback.customJointDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eCustomJoint] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.customJointPrimPaths, gMarshalCallback.customJointDescs);
+        }
+        if (!gMarshalCallback.rigidBodyMaterialDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eRigidBodyMaterial] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.rigidBodyMaterialPrimPaths, gMarshalCallback.rigidBodyMaterialDescs);
+        }
+        if (!gMarshalCallback.articulationDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eArticulation] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.articulationPrimPaths, gMarshalCallback.articulationDescs);
+        }
+        if (!gMarshalCallback.collisionGroupDescs.empty())
+        {
+            retDict[UsdPhysicsObjectType::eCollisionGroup] =
+                pxr_boost::python::make_tuple(
+                    gMarshalCallback.collisionGroupPrimPaths, gMarshalCallback.collisionGroupDescs);
+        }
+    }
+    return retDict;
 }
 
 static std::string
 _CustomUsdPhysicsTokens_Repr(const CustomUsdPhysicsTokens& self)
 {
-	return TfStringPrintf(
-		"%sCustomUsdPhysicsTokens(jointTokens=%s, shapeTokens=%s, instancerTokens=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.jointTokens).c_str(),
-		TfPyRepr(self.shapeTokens).c_str(),
-		TfPyRepr(self.instancerTokens).c_str());
+    return TfStringPrintf(
+        "%sCustomUsdPhysicsTokens(jointTokens=%s, shapeTokens=%s, instancerTokens=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.jointTokens).c_str(),
+        TfPyRepr(self.shapeTokens).c_str(),
+        TfPyRepr(self.instancerTokens).c_str());
 }
 
 static std::string
 _PhysicsObjectDesc_Repr(const UsdPhysicsObjectDesc& self)
 {
-	return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.type).c_str(),
-		TfPyRepr(self.primPath).c_str(),
-		TfPyRepr(self.isValid).c_str());
+    return TfStringPrintf("%sPhysicsObjectDesc(type=%s, primPath=%s, isValid=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.type).c_str(),
+        TfPyRepr(self.primPath).c_str(),
+        TfPyRepr(self.isValid).c_str());
 }
 
 static std::string
 _SceneDesc_Repr(const UsdPhysicsSceneDesc& self)
 {
-	return TfStringPrintf(
-		"%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.gravityDirection).c_str(),
-		TfPyRepr(self.gravityMagnitude).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sSceneDesc(gravityDirection=%s, gravityMagnitude=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.gravityDirection).c_str(),
+        TfPyRepr(self.gravityMagnitude).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _CollisionGroupDesc_Repr(const UsdPhysicsCollisionGroupDesc& self)
 {
-	return TfStringPrintf(
-		"%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.invertFilteredGroups).c_str(),
-		TfPyRepr(self.mergeGroupName).c_str(),
-		TfPyRepr(self.mergedGroups).c_str(),
-		TfPyRepr(self.filteredGroups).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sCollisionGroupDesc(invertFilteredGroups=%s, mergeGroupName=%s, mergedGroups=%s, filteredGroups=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.invertFilteredGroups).c_str(),
+        TfPyRepr(self.mergeGroupName).c_str(),
+        TfPyRepr(self.mergedGroups).c_str(),
+        TfPyRepr(self.filteredGroups).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _RigidBodyMaterialDesc_Repr(const UsdPhysicsRigidBodyMaterialDesc& self)
 {
-	return TfStringPrintf(
-		"%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.staticFriction).c_str(),
-		TfPyRepr(self.dynamicFriction).c_str(),
-		TfPyRepr(self.restitution).c_str(),
-		TfPyRepr(self.density).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sRigidBodyMaterialDesc(staticFriction=%s, dynamicFriction=%s, restitution=%s, density=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.staticFriction).c_str(),
+        TfPyRepr(self.dynamicFriction).c_str(),
+        TfPyRepr(self.restitution).c_str(),
+        TfPyRepr(self.density).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _ShapeDesc_Repr(const UsdPhysicsShapeDesc& self)
 {
-	return TfStringPrintf(
-		"%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.rigidBody).c_str(),
-		TfPyRepr(self.localPos).c_str(),
-		TfPyRepr(self.localRot).c_str(),
-		TfPyRepr(self.localScale).c_str(),
-		TfPyRepr(self.materials).c_str(),
-		TfPyRepr(self.simulationOwners).c_str(),
-		TfPyRepr(self.filteredCollisions).c_str(),
-		TfPyRepr(self.collisionGroups).c_str(),
-		TfPyRepr(self.collisionEnabled).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sShapeDesc(rigidBody=%s, localPos=%s, localRot=%s, localScale=%s, materials=%s, simulationOwners=%s, filteredCollisions=%s, collisionGroups=%s, collisionEnabled=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.rigidBody).c_str(),
+        TfPyRepr(self.localPos).c_str(),
+        TfPyRepr(self.localRot).c_str(),
+        TfPyRepr(self.localScale).c_str(),
+        TfPyRepr(self.materials).c_str(),
+        TfPyRepr(self.simulationOwners).c_str(),
+        TfPyRepr(self.filteredCollisions).c_str(),
+        TfPyRepr(self.collisionGroups).c_str(),
+        TfPyRepr(self.collisionEnabled).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _SphereShapeDesc_Repr(const UsdPhysicsSphereShapeDesc& self)
 {
-	return TfStringPrintf(
-		"%sSphereShapeDesc(radius=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.radius).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sSphereShapeDesc(radius=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.radius).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CapsuleShapeDesc_Repr(const UsdPhysicsCapsuleShapeDesc& self)
 {
-	return TfStringPrintf(
-		"%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.radius).c_str(),
-		TfPyRepr(self.halfHeight).c_str(),
-		TfPyRepr(self.axis).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sCapsuleShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.radius).c_str(),
+        TfPyRepr(self.halfHeight).c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CylinderShapeDesc_Repr(const UsdPhysicsCylinderShapeDesc& self)
 {
-	return TfStringPrintf(
-		"%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.radius).c_str(),
-		TfPyRepr(self.halfHeight).c_str(),
-		TfPyRepr(self.axis).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sCylinderShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.radius).c_str(),
+        TfPyRepr(self.halfHeight).c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _ConeShapeDesc_Repr(const UsdPhysicsConeShapeDesc& self)
 {
-	return TfStringPrintf(
-		"%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.radius).c_str(),
-		TfPyRepr(self.halfHeight).c_str(),
-		TfPyRepr(self.axis).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sConeShapeDesc(radius=%s, halfHeight=%s, axis=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.radius).c_str(),
+        TfPyRepr(self.halfHeight).c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _PlaneShapeDesc_Repr(const UsdPhysicsPlaneShapeDesc& self)
 {
-	return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.axis).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf("%sPlaneShapeDesc(axis=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.axis).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CustomShapeDesc_Repr(const UsdPhysicsCustomShapeDesc& self)
 {
-	return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.customGeometryToken).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf("%sCustomShapeDesc(customGeometryToken=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.customGeometryToken).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _CubeShapeDesc_Repr(const UsdPhysicsCubeShapeDesc& self)
 {
-	return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.halfExtents).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf("%sCubeShapeDesc(halfExtents=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.halfExtents).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _MeshShapeDesc_Repr(const UsdPhysicsMeshShapeDesc& self)
 {
-	return TfStringPrintf(
-		"%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.approximation).c_str(),
-		TfPyRepr(self.meshScale).c_str(),
-		TfPyRepr(self.doubleSided).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sMeshShapeDesc(approximation=%s, meshScale=%s, doubleSided=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.approximation).c_str(),
+        TfPyRepr(self.meshScale).c_str(),
+        TfPyRepr(self.doubleSided).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _SpherePoint_Repr(const UsdPhysicsSpherePoint& self)
 {
-	return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.center).c_str(),
-		TfPyRepr(self.radius).c_str());
+    return TfStringPrintf("%sSpherePoint(center=%s, radius=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.center).c_str(),
+        TfPyRepr(self.radius).c_str());
 }
 
 static std::string
 _SpherePointsShapeDesc_Repr(const UsdPhysicsSpherePointsShapeDesc& self)
 {
-	return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.spherePoints).c_str(),
-		_ShapeDesc_Repr(self).c_str());
+    return TfStringPrintf("%sSpherePointsShapeDesc(spherePoints=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.spherePoints).c_str(),
+        _ShapeDesc_Repr(self).c_str());
 }
 
 static std::string
 _RigidBodyDesc_Repr(const UsdPhysicsRigidBodyDesc& self)
 {
-	return TfStringPrintf(
-		"%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, "
-		"simulationOwners=%s, position=%s, rotation=%s, scale=%s, "
-		"rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, "
-		"linearVelocity=%s, angularVelocity=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.collisions).c_str(),
-		TfPyRepr(self.filteredCollisions).c_str(),
-		TfPyRepr(self.simulationOwners).c_str(),
-		TfPyRepr(self.position).c_str(),
-		TfPyRepr(self.rotation).c_str(),
-		TfPyRepr(self.scale).c_str(),
-		TfPyRepr(self.rigidBodyEnabled).c_str(),
-		TfPyRepr(self.kinematicBody).c_str(),
-		TfPyRepr(self.startsAsleep).c_str(),
-		TfPyRepr(self.linearVelocity).c_str(),
-		TfPyRepr(self.angularVelocity).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sRigidBodyDesc(collisions=%s, filteredCollisions=%s, "
+        "simulationOwners=%s, position=%s, rotation=%s, scale=%s, "
+        "rigidBodyEnabled=%s, kinematicBody=%s, startsAsleep=%s, "
+        "linearVelocity=%s, angularVelocity=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.collisions).c_str(),
+        TfPyRepr(self.filteredCollisions).c_str(),
+        TfPyRepr(self.simulationOwners).c_str(),
+        TfPyRepr(self.position).c_str(),
+        TfPyRepr(self.rotation).c_str(),
+        TfPyRepr(self.scale).c_str(),
+        TfPyRepr(self.rigidBodyEnabled).c_str(),
+        TfPyRepr(self.kinematicBody).c_str(),
+        TfPyRepr(self.startsAsleep).c_str(),
+        TfPyRepr(self.linearVelocity).c_str(),
+        TfPyRepr(self.angularVelocity).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _JointLimit_Repr(const UsdPhysicsJointLimit& self)
 {
-	return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.enabled).c_str(),
-		TfPyRepr(self.lower).c_str(),
-		TfPyRepr(self.upper).c_str());
+    return TfStringPrintf("%sJointLimit(enabled=%s, lower=%s, upper=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.enabled).c_str(),
+        TfPyRepr(self.lower).c_str(),
+        TfPyRepr(self.upper).c_str());
 }
 
 static std::string
 _JointDrive_Repr(const UsdPhysicsJointDrive& self)
 {
-	return TfStringPrintf(
-		"%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, "
-		"forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.enabled).c_str(),
-		TfPyRepr(self.targetPosition).c_str(),
-		TfPyRepr(self.targetVelocity).c_str(),
-		TfPyRepr(self.forceLimit).c_str(),
-		TfPyRepr(self.stiffness).c_str(),
-		TfPyRepr(self.damping).c_str(),
-		TfPyRepr(self.acceleration).c_str());
+    return TfStringPrintf(
+        "%sJointDrive(enabled=%s, targetPosition=%s, targetVelocity=%s, "
+        "forceLimit=%s, stiffness=%s, damping=%s, acceleration=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.enabled).c_str(),
+        TfPyRepr(self.targetPosition).c_str(),
+        TfPyRepr(self.targetVelocity).c_str(),
+        TfPyRepr(self.forceLimit).c_str(),
+        TfPyRepr(self.stiffness).c_str(),
+        TfPyRepr(self.damping).c_str(),
+        TfPyRepr(self.acceleration).c_str());
 }
 
 static std::string
 _ArticulationDesc_Repr(const UsdPhysicsArticulationDesc& self)
 {
-	return TfStringPrintf(
-		"%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, "
-		"articulatedJoints=%s, articulatedBodies=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.rootPrims).c_str(),
-		TfPyRepr(self.filteredCollisions).c_str(),
-		TfPyRepr(self.articulatedJoints).c_str(),
-		TfPyRepr(self.articulatedBodies).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sArticulationDesc(rootPrims=%s, filteredCollisions=%s, "
+        "articulatedJoints=%s, articulatedBodies=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.rootPrims).c_str(),
+        TfPyRepr(self.filteredCollisions).c_str(),
+        TfPyRepr(self.articulatedJoints).c_str(),
+        TfPyRepr(self.articulatedBodies).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _JointDesc_Repr(const UsdPhysicsJointDesc& self)
 {
-	return TfStringPrintf(
-		"%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, "
-		"localPose0Position=%s, localPose0Orientation=%s, "
-		"localPose1Position=%s, localPose1Orientation=%s, "
-		"jointEnabled=%s, breakForce=%s, breakTorque=%s, "
-		"excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.rel0).c_str(),
-		TfPyRepr(self.rel1).c_str(),
-		TfPyRepr(self.body0).c_str(),
-		TfPyRepr(self.body1).c_str(),
-		TfPyRepr(self.localPose0Position).c_str(),
-		TfPyRepr(self.localPose0Orientation).c_str(),
-		TfPyRepr(self.localPose1Position).c_str(),
-		TfPyRepr(self.localPose1Orientation).c_str(),
-		TfPyRepr(self.jointEnabled).c_str(),
-		TfPyRepr(self.breakForce).c_str(),
-		TfPyRepr(self.breakTorque).c_str(),
-		TfPyRepr(self.excludeFromArticulation).c_str(),
-		TfPyRepr(self.collisionEnabled).c_str(),
-		_PhysicsObjectDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sJointDesc(rel0=%s, rel1=%s, body0=%s, body1=%s, "
+        "localPose0Position=%s, localPose0Orientation=%s, "
+        "localPose1Position=%s, localPose1Orientation=%s, "
+        "jointEnabled=%s, breakForce=%s, breakTorque=%s, "
+        "excludeFromArticulation=%s, collisionEnabled=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.rel0).c_str(),
+        TfPyRepr(self.rel1).c_str(),
+        TfPyRepr(self.body0).c_str(),
+        TfPyRepr(self.body1).c_str(),
+        TfPyRepr(self.localPose0Position).c_str(),
+        TfPyRepr(self.localPose0Orientation).c_str(),
+        TfPyRepr(self.localPose1Position).c_str(),
+        TfPyRepr(self.localPose1Orientation).c_str(),
+        TfPyRepr(self.jointEnabled).c_str(),
+        TfPyRepr(self.breakForce).c_str(),
+        TfPyRepr(self.breakTorque).c_str(),
+        TfPyRepr(self.excludeFromArticulation).c_str(),
+        TfPyRepr(self.collisionEnabled).c_str(),
+        _PhysicsObjectDesc_Repr(self).c_str());
 }
 
 static std::string
 _JointLimitDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>& self)
 {
-	return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.first).c_str(),
-		TfPyRepr(self.second).c_str());
+    return TfStringPrintf("%sJointLimitDOFPair(first=%s, second=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.first).c_str(),
+        TfPyRepr(self.second).c_str());
 }
 
 static std::string
 _JointDriveDOFPair_Repr(const std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>& self)
 {
-	return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.first).c_str(),
-		TfPyRepr(self.second).c_str());
+    return TfStringPrintf("%sJointDriveDOFPair(first=%s, second=%s)",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.first).c_str(),
+        TfPyRepr(self.second).c_str());
 }
 
 static std::string
 _D6JointDesc_Repr(const UsdPhysicsD6JointDesc& self)
 {
-	return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.jointLimits).c_str(),
-		TfPyRepr(self.jointDrives).c_str(),
-		_JointDesc_Repr(self).c_str());
+    return TfStringPrintf("%sD6JointDesc(jointLimits=%s, jointDrives=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.jointLimits).c_str(),
+        TfPyRepr(self.jointDrives).c_str(),
+        _JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _PrismaticJointDesc_Repr(const UsdPhysicsPrismaticJointDesc& self)
 {
-	return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.axis).c_str(),
-		TfPyRepr(self.limit).c_str(),
-		TfPyRepr(self.drive).c_str(),
-		_JointDesc_Repr(self).c_str());
+    return TfStringPrintf("%sPrismaticJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.axis).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        TfPyRepr(self.drive).c_str(),
+        _JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _SphericalJointDesc_Repr(const UsdPhysicsSphericalJointDesc& self)
 {
-	return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.axis).c_str(),
-		TfPyRepr(self.limit).c_str(),
-		_JointDesc_Repr(self).c_str());
+    return TfStringPrintf("%sSphericalJointDesc(axis=%s, limit=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.axis).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        _JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _RevoluteJointDesc_Repr(const UsdPhysicsRevoluteJointDesc& self)
 {
-	return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.axis).c_str(),
-		TfPyRepr(self.limit).c_str(),
-		TfPyRepr(self.drive).c_str(),
-		_JointDesc_Repr(self).c_str());
+    return TfStringPrintf("%sRevoluteJointDesc(axis=%s, limit=%s, drive=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.axis).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        TfPyRepr(self.drive).c_str(),
+        _JointDesc_Repr(self).c_str());
 }
 
 static std::string
 _DistanceJointDesc_Repr(const UsdPhysicsDistanceJointDesc& self)
 {
-	return TfStringPrintf(
-		"%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
-		TF_PY_REPR_PREFIX.c_str(),
-		TfPyRepr(self.minEnabled).c_str(),
-		TfPyRepr(self.limit).c_str(),
-		TfPyRepr(self.maxEnabled).c_str(),
-		_JointDesc_Repr(self).c_str());
+    return TfStringPrintf(
+        "%sDistanceJointDesc(minEnabled=%s, limit=%s, maxEnabled=%s), parent %s",
+        TF_PY_REPR_PREFIX.c_str(),
+        TfPyRepr(self.minEnabled).c_str(),
+        TfPyRepr(self.limit).c_str(),
+        TfPyRepr(self.maxEnabled).c_str(),
+        _JointDesc_Repr(self).c_str());
 }
 
 void wrapParseUtils()
 {
-	pxr_boost::python::enum_<UsdPhysicsObjectType::Enum>("ObjectType")
-		.value("Undefined", UsdPhysicsObjectType::eUndefined)
-		.value("Scene", UsdPhysicsObjectType::eScene)
-		.value("RigidBody", UsdPhysicsObjectType::eRigidBody)
-		.value("SphereShape", UsdPhysicsObjectType::eSphereShape)
-		.value("CubeShape", UsdPhysicsObjectType::eCubeShape)
-		.value("CapsuleShape", UsdPhysicsObjectType::eCapsuleShape)
-		.value("CylinderShape", UsdPhysicsObjectType::eCylinderShape)
-		.value("ConeShape", UsdPhysicsObjectType::eConeShape)
-		.value("MeshShape", UsdPhysicsObjectType::eMeshShape)
-		.value("PlaneShape", UsdPhysicsObjectType::ePlaneShape)
-		.value("CustomShape", UsdPhysicsObjectType::eCustomShape)
-		.value("SpherePointsShape", UsdPhysicsObjectType::eSpherePointsShape)
-		.value("FixedJoint", UsdPhysicsObjectType::eFixedJoint)
-		.value("RevoluteJoint", UsdPhysicsObjectType::eRevoluteJoint)
-		.value("PrismaticJoint", UsdPhysicsObjectType::ePrismaticJoint)
-		.value("SphericalJoint", UsdPhysicsObjectType::eSphericalJoint)
-		.value("DistanceJoint", UsdPhysicsObjectType::eDistanceJoint)
-		.value("D6Joint", UsdPhysicsObjectType::eD6Joint)
-		.value("CustomJoint", UsdPhysicsObjectType::eCustomJoint)
-		.value("RigidBodyMaterial", UsdPhysicsObjectType::eRigidBodyMaterial)
-		.value("Articulation", UsdPhysicsObjectType::eArticulation)
-		.value("CollisionGroup", UsdPhysicsObjectType::eCollisionGroup)
-		;
-
-	pxr_boost::python::enum_<UsdPhysicsAxis::Enum>("Axis")
-		.value("X", UsdPhysicsAxis::eX)
-		.value("Y", UsdPhysicsAxis::eY)
-		.value("Z", UsdPhysicsAxis::eZ)
-		;
-
-	pxr_boost::python::enum_<UsdPhysicsJointDOF::Enum>("JointDOF")
-		.value("Distance", UsdPhysicsJointDOF::eDistance)
-		.value("TransX", UsdPhysicsJointDOF::eTransX)
-		.value("TransY", UsdPhysicsJointDOF::eTransY)
-		.value("TransZ", UsdPhysicsJointDOF::eTransZ)
-		.value("RotX", UsdPhysicsJointDOF::eRotX)
-		.value("RotY", UsdPhysicsJointDOF::eRotY)
-		.value("RotZ", UsdPhysicsJointDOF::eRotZ)
-		;
-
-	pxr_boost::python::class_<_CustomUsdPhysicsTokens>
-		cupt("CustomUsdPhysicsTokens");
-	cupt
-		.def_readwrite("jointTokens", &_CustomUsdPhysicsTokens::jointTokens)
-		.def_readwrite("shapeTokens", &_CustomUsdPhysicsTokens::shapeTokens)
-		.def_readwrite("instancerTokens", &_CustomUsdPhysicsTokens::instancerTokens)
-		.def("__repr__", _CustomUsdPhysicsTokens_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsObjectDesc>
-		podcls("ObjectDesc", pxr_boost::python::no_init);
-	podcls
-		.def_readonly("type", &UsdPhysicsObjectDesc::type)
-		.def_readonly("primPath", &UsdPhysicsObjectDesc::primPath)
-		.def_readonly("isValid", &UsdPhysicsObjectDesc::isValid)
-		.def("__repr__", _PhysicsObjectDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsSceneDesc, bases<UsdPhysicsObjectDesc>>
-		sdcls("SceneDesc", pxr_boost::python::no_init);
-	sdcls
-		.def_readonly("gravityDirection", &UsdPhysicsSceneDesc::gravityDirection)
-		.def_readonly("gravityMagnitude", &UsdPhysicsSceneDesc::gravityMagnitude)
-		.def("__repr__", _SceneDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsCollisionGroupDesc, bases<UsdPhysicsObjectDesc>>
-		cgcls("CollisionGroupDesc", pxr_boost::python::no_init);
-	cgcls
-		.def_readonly("invertFilteredGroups", &UsdPhysicsCollisionGroupDesc::invertFilteredGroups)
-		.add_property("mergedGroups",
-			make_function(&UsdPhysicsCollisionGroupDesc::getMergedGroups,
-				return_value_policy<TfPySequenceToList>()))
-		.add_property("filteredGroups",
-			make_function(&UsdPhysicsCollisionGroupDesc::getFilteredGroups,
-				return_value_policy<TfPySequenceToList>()))
-		.def_readonly("mergeGroupName", &UsdPhysicsCollisionGroupDesc::mergeGroupName)
-		.def("__repr__", _CollisionGroupDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsRigidBodyMaterialDesc, bases<UsdPhysicsObjectDesc>>
-		rbmcls("RigidBodyMaterialDesc", pxr_boost::python::no_init);
-	rbmcls
-		.def_readonly("staticFriction", &UsdPhysicsRigidBodyMaterialDesc::staticFriction)
-		.def_readonly("dynamicFriction", &UsdPhysicsRigidBodyMaterialDesc::dynamicFriction)
-		.def_readonly("restitution", &UsdPhysicsRigidBodyMaterialDesc::restitution)
-		.def_readonly("density", &UsdPhysicsRigidBodyMaterialDesc::density)
-		.def("__repr__", _RigidBodyMaterialDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsShapeDesc, bases<UsdPhysicsObjectDesc>>
-		shdcls("ShapeDesc", pxr_boost::python::no_init);
-	shdcls
-		.def_readonly("rigidBody", &UsdPhysicsShapeDesc::rigidBody)
-		.def_readonly("localPos", &UsdPhysicsShapeDesc::localPos)
-		.def_readonly("localRot", &UsdPhysicsShapeDesc::localRot)
-		.def_readonly("localScale", &UsdPhysicsShapeDesc::localScale)
-		.add_property("materials", make_function(&UsdPhysicsShapeDesc::getMaterials,
-			return_value_policy<TfPySequenceToList>()))
-		.add_property("simulationOwners",
-			make_function(&UsdPhysicsShapeDesc::getSimulationOwners,
-				return_value_policy<TfPySequenceToList>()))
-		.add_property("filteredCollisions",
-			make_function(&UsdPhysicsShapeDesc::getFilteredCollisions,
-				return_value_policy<TfPySequenceToList>()))
-		.add_property("collisionGroups",
-			make_function(&UsdPhysicsShapeDesc::getCollisionGroups,
-				return_value_policy<TfPySequenceToList>()))
-		.def_readonly("collisionEnabled", &UsdPhysicsShapeDesc::collisionEnabled)
-		.def("__repr__", _ShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsSphereShapeDesc, bases<UsdPhysicsShapeDesc>>
-		ssdcls("SphereShapeDesc", pxr_boost::python::no_init);
-	ssdcls
-		.def_readonly("radius", &UsdPhysicsSphereShapeDesc::radius)
-		.def("__repr__", _SphereShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsCapsuleShapeDesc, bases<UsdPhysicsShapeDesc>>
-		csdcls("CapsuleShapeDesc", pxr_boost::python::no_init);
-	csdcls
-		.def_readonly("radius", &UsdPhysicsCapsuleShapeDesc::radius)
-		.def_readonly("halfHeight", &UsdPhysicsCapsuleShapeDesc::halfHeight)
-		.def_readonly("axis", &UsdPhysicsCapsuleShapeDesc::axis)
-		.def("__repr__", _CapsuleShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsCylinderShapeDesc, bases<UsdPhysicsShapeDesc>>
-		cysdcls("CylinderShapeDesc", pxr_boost::python::no_init);
-	cysdcls
-		.def_readonly("radius", &UsdPhysicsCylinderShapeDesc::radius)
-		.def_readonly("halfHeight", &UsdPhysicsCylinderShapeDesc::halfHeight)
-		.def_readonly("axis", &UsdPhysicsCylinderShapeDesc::axis)
-		.def("__repr__", _CylinderShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsConeShapeDesc, bases<UsdPhysicsShapeDesc>>
-		cosdcls("ConeShapeDesc", pxr_boost::python::no_init);
-	cosdcls
-		.def_readonly("radius", &UsdPhysicsConeShapeDesc::radius)
-		.def_readonly("halfHeight", &UsdPhysicsConeShapeDesc::halfHeight)
-		.def_readonly("axis", &UsdPhysicsConeShapeDesc::axis)
-		.def("__repr__", _ConeShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsPlaneShapeDesc, bases<UsdPhysicsShapeDesc>>
-		pscls("PlaneShapeDesc", pxr_boost::python::no_init);
-	pscls
-		.def_readonly("axis", &UsdPhysicsPlaneShapeDesc::axis)
-		.def("__repr__", _PlaneShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsCustomShapeDesc, bases<UsdPhysicsShapeDesc>>
-		cuscls("CustomShapeDesc", pxr_boost::python::no_init);
-	cuscls
-		.def_readonly("customGeometryToken", &UsdPhysicsCustomShapeDesc::customGeometryToken)
-		.def("__repr__", _CustomShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsCubeShapeDesc, bases<UsdPhysicsShapeDesc>>
-		cubescls("CubeShapeDesc", pxr_boost::python::no_init);
-	cubescls
-		.def_readonly("halfExtents", &UsdPhysicsCubeShapeDesc::halfExtents)
-		.def("__repr__", _CubeShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsMeshShapeDesc, bases<UsdPhysicsShapeDesc>>
-		mscls("MeshShapeDesc", pxr_boost::python::no_init);
-	mscls
-		.add_property("approximation", &UsdPhysicsMeshShapeDesc::GetApproximation)
-		.def_readonly("meshScale", &UsdPhysicsMeshShapeDesc::meshScale)
-		.def_readonly("doubleSided", &UsdPhysicsMeshShapeDesc::doubleSided)
-		.def("__repr__", _MeshShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsSpherePoint>
-		sppb("SpherePoint", pxr_boost::python::no_init);
-	sppb
-		.def_readonly("center", &UsdPhysicsSpherePoint::center)
-		.def_readonly("radius", &UsdPhysicsSpherePoint::radius)
-		.def("__repr__", _SpherePoint_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsSpherePointsShapeDesc, bases<UsdPhysicsShapeDesc>>
-		spmscls("SpherePointsShapeDesc", pxr_boost::python::no_init);
-	spmscls
-		.add_property("spherePoints", &UsdPhysicsSpherePointsShapeDesc::spherePoints)
-		.def("__repr__", _SpherePointsShapeDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsRigidBodyDesc, bases<UsdPhysicsObjectDesc>>
-		rbcls("RigidBodyDesc", pxr_boost::python::no_init);
-	rbcls
-		.add_property("collisions", make_function(&UsdPhysicsRigidBodyDesc::getCollisions,
-			return_value_policy<TfPySequenceToList>()))
-		.add_property("filteredCollisions",
-			make_function(&UsdPhysicsRigidBodyDesc::getFilteredCollisions,
-				return_value_policy<TfPySequenceToList>()))
-		.add_property("simulationOwners",
-			make_function(&UsdPhysicsRigidBodyDesc::getSimulationOwners,
-				return_value_policy<TfPySequenceToList>()))
-		.def_readonly("position", &UsdPhysicsRigidBodyDesc::position)
-		.def_readonly("rotation", &UsdPhysicsRigidBodyDesc::rotation)
-		.def_readonly("scale", &UsdPhysicsRigidBodyDesc::scale)
-		.def_readonly("rigidBodyEnabled", &UsdPhysicsRigidBodyDesc::rigidBodyEnabled)
-		.def_readonly("kinematicBody", &UsdPhysicsRigidBodyDesc::kinematicBody)
-		.def_readonly("startsAsleep", &UsdPhysicsRigidBodyDesc::startsAsleep)
-		.def_readonly("linearVelocity", &UsdPhysicsRigidBodyDesc::linearVelocity)
-		.def_readonly("angularVelocity", &UsdPhysicsRigidBodyDesc::angularVelocity)
-		.def("__repr__", _RigidBodyDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsJointLimit>
-		jlcls("JointLimit", pxr_boost::python::no_init);
-	jlcls
-		.def_readonly("enabled", &UsdPhysicsJointLimit::enabled)
-		.def_readonly("lower", &UsdPhysicsJointLimit::lower)
-		.def_readonly("upper", &UsdPhysicsJointLimit::upper)
-		.def("__repr__", _JointLimit_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsJointDrive>
-		jdcls("JointDrive", pxr_boost::python::no_init);
-	jdcls
-		.def_readonly("enabled", &UsdPhysicsJointDrive::enabled)
-		.def_readonly("targetPosition", &UsdPhysicsJointDrive::targetPosition)
-		.def_readonly("targetVelocity", &UsdPhysicsJointDrive::targetVelocity)
-		.def_readonly("forceLimit", &UsdPhysicsJointDrive::forceLimit)
-		.def_readonly("stiffness", &UsdPhysicsJointDrive::stiffness)
-		.def_readonly("damping", &UsdPhysicsJointDrive::damping)
-		.def_readonly("acceleration", &UsdPhysicsJointDrive::acceleration)
-		.def("__repr__", _JointDrive_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsArticulationDesc, bases<UsdPhysicsObjectDesc>>
-		adcls("ArticulationDesc", pxr_boost::python::no_init);
-	adcls
-		.add_property("rootPrims", make_function(&UsdPhysicsArticulationDesc::GetRootPrims,
-			return_value_policy<TfPySequenceToList>()))
-		.add_property("filteredCollisions",
-			make_function(&UsdPhysicsArticulationDesc::GetFilteredCollisions,
-				return_value_policy<TfPySequenceToList>()))
-		.add_property("articulatedJoints",
-			make_function(&UsdPhysicsArticulationDesc::GetArticulatedJoints,
-				return_value_policy<TfPySequenceToList>()))
-		.add_property("articulatedBodies",
-			make_function(&UsdPhysicsArticulationDesc::GetArticulatedBodies,
-				return_value_policy<TfPySequenceToList>()))
-		.def("__repr__", _ArticulationDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsJointDesc, bases<UsdPhysicsObjectDesc>>
-		jdscls("JointDesc", pxr_boost::python::no_init);
-	jdscls
-		.def_readonly("rel0", &UsdPhysicsJointDesc::rel0)
-		.def_readonly("rel1", &UsdPhysicsJointDesc::rel1)
-		.def_readonly("body0", &UsdPhysicsJointDesc::body0)
-		.def_readonly("body1", &UsdPhysicsJointDesc::body1)
-		.def_readonly("localPose0Position", &UsdPhysicsJointDesc::localPose0Position)
-		.def_readonly("localPose0Orientation", &UsdPhysicsJointDesc::localPose0Orientation)
-		.def_readonly("localPose1Position", &UsdPhysicsJointDesc::localPose1Position)
-		.def_readonly("localPose1Orientation", &UsdPhysicsJointDesc::localPose1Orientation)
-		.def_readonly("jointEnabled", &UsdPhysicsJointDesc::jointEnabled)
-		.def_readonly("breakForce", &UsdPhysicsJointDesc::breakForce)
-		.def_readonly("breakTorque", &UsdPhysicsJointDesc::breakTorque)
-		.def_readonly("excludeFromArticulation", &UsdPhysicsJointDesc::excludeFromArticulation)
-		.def_readonly("collisionEnabled", &UsdPhysicsJointDesc::collisionEnabled)
-		.def("__repr__", _JointDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsCustomJointDesc, bases<UsdPhysicsJointDesc>>
-		cjdscls("CustomJointDesc", pxr_boost::python::no_init);
-
-	pxr_boost::python::class_<UsdPhysicsFixedJointDesc, bases<UsdPhysicsJointDesc>>
-		fjdscls("FixedJointDesc", pxr_boost::python::no_init);
-
-	class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit> >("JointLimitDOFPair")
-		.def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::first)
-		.def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::second)
-		.def("__repr__", _JointLimitDOFPair_Repr);
-
-	class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive> >("JointDriveDOFPair")
-		.def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::first)
-		.def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::second)
-		.def("__repr__", _JointDriveDOFPair_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsD6JointDesc, bases<UsdPhysicsJointDesc>>
-		d6jdscls("D6JointDesc", pxr_boost::python::no_init);
-	d6jdscls
-		.def_readonly("jointLimits", &UsdPhysicsD6JointDesc::jointLimits)
-		.def_readonly("jointDrives", &UsdPhysicsD6JointDesc::jointDrives)
-		.def("__repr__", _D6JointDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsPrismaticJointDesc, bases<UsdPhysicsJointDesc>>
-		pjdscls("PrismaticJointDesc", pxr_boost::python::no_init);
-	pjdscls
-		.def_readonly("axis", &UsdPhysicsPrismaticJointDesc::axis)
-		.def_readonly("limit", &UsdPhysicsPrismaticJointDesc::limit)
-		.def_readonly("drive", &UsdPhysicsPrismaticJointDesc::drive)
-		.def("__repr__", _PrismaticJointDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsSphericalJointDesc, bases<UsdPhysicsJointDesc>>
-		sjdscls("SphericalJointDesc", pxr_boost::python::no_init);
-	sjdscls
-		.def_readonly("axis", &UsdPhysicsSphericalJointDesc::axis)
-		.def_readonly("limit", &UsdPhysicsSphericalJointDesc::limit)
-		.def("__repr__", _SphericalJointDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsRevoluteJointDesc, bases<UsdPhysicsJointDesc>>
-		rjdscls("RevoluteJointDesc", pxr_boost::python::no_init);
-	rjdscls
-		.def_readonly("axis", &UsdPhysicsRevoluteJointDesc::axis)
-		.def_readonly("limit", &UsdPhysicsRevoluteJointDesc::limit)
-		.def_readonly("drive", &UsdPhysicsRevoluteJointDesc::drive)
-		.def("__repr__", _RevoluteJointDesc_Repr);
-
-	pxr_boost::python::class_<UsdPhysicsDistanceJointDesc, bases<UsdPhysicsJointDesc>>
-		djdscls("DistanceJointDesc", pxr_boost::python::no_init);
-	djdscls
-		.def_readonly("minEnabled", &UsdPhysicsDistanceJointDesc::minEnabled)
-		.def_readonly("limit", &UsdPhysicsDistanceJointDesc::limit)
-		.def_readonly("maxEnabled", &UsdPhysicsDistanceJointDesc::maxEnabled)
-		.def("__repr__", _DistanceJointDesc_Repr);
-
-	registerVectorConverter<UsdCollectionMembershipQuery>
-		("PhysicsCollectionMembershipQueryVector");
-
-	registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>
-		("PhysicsJointLimitDOFVector");
+    pxr_boost::python::enum_<UsdPhysicsObjectType::Enum>("ObjectType")
+        .value("Undefined", UsdPhysicsObjectType::eUndefined)
+        .value("Scene", UsdPhysicsObjectType::eScene)
+        .value("RigidBody", UsdPhysicsObjectType::eRigidBody)
+        .value("SphereShape", UsdPhysicsObjectType::eSphereShape)
+        .value("CubeShape", UsdPhysicsObjectType::eCubeShape)
+        .value("CapsuleShape", UsdPhysicsObjectType::eCapsuleShape)
+        .value("CylinderShape", UsdPhysicsObjectType::eCylinderShape)
+        .value("ConeShape", UsdPhysicsObjectType::eConeShape)
+        .value("MeshShape", UsdPhysicsObjectType::eMeshShape)
+        .value("PlaneShape", UsdPhysicsObjectType::ePlaneShape)
+        .value("CustomShape", UsdPhysicsObjectType::eCustomShape)
+        .value("SpherePointsShape", UsdPhysicsObjectType::eSpherePointsShape)
+        .value("FixedJoint", UsdPhysicsObjectType::eFixedJoint)
+        .value("RevoluteJoint", UsdPhysicsObjectType::eRevoluteJoint)
+        .value("PrismaticJoint", UsdPhysicsObjectType::ePrismaticJoint)
+        .value("SphericalJoint", UsdPhysicsObjectType::eSphericalJoint)
+        .value("DistanceJoint", UsdPhysicsObjectType::eDistanceJoint)
+        .value("D6Joint", UsdPhysicsObjectType::eD6Joint)
+        .value("CustomJoint", UsdPhysicsObjectType::eCustomJoint)
+        .value("RigidBodyMaterial", UsdPhysicsObjectType::eRigidBodyMaterial)
+        .value("Articulation", UsdPhysicsObjectType::eArticulation)
+        .value("CollisionGroup", UsdPhysicsObjectType::eCollisionGroup)
+        ;
+
+    pxr_boost::python::enum_<UsdPhysicsAxis::Enum>("Axis")
+        .value("X", UsdPhysicsAxis::eX)
+        .value("Y", UsdPhysicsAxis::eY)
+        .value("Z", UsdPhysicsAxis::eZ)
+        ;
+
+    pxr_boost::python::enum_<UsdPhysicsJointDOF::Enum>("JointDOF")
+        .value("Distance", UsdPhysicsJointDOF::eDistance)
+        .value("TransX", UsdPhysicsJointDOF::eTransX)
+        .value("TransY", UsdPhysicsJointDOF::eTransY)
+        .value("TransZ", UsdPhysicsJointDOF::eTransZ)
+        .value("RotX", UsdPhysicsJointDOF::eRotX)
+        .value("RotY", UsdPhysicsJointDOF::eRotY)
+        .value("RotZ", UsdPhysicsJointDOF::eRotZ)
+        ;
+
+    pxr_boost::python::class_<_CustomUsdPhysicsTokens>
+        cupt("CustomUsdPhysicsTokens");
+    cupt
+        .def_readwrite("jointTokens", &_CustomUsdPhysicsTokens::jointTokens)
+        .def_readwrite("shapeTokens", &_CustomUsdPhysicsTokens::shapeTokens)
+        .def_readwrite("instancerTokens", &_CustomUsdPhysicsTokens::instancerTokens)
+        .def("__repr__", _CustomUsdPhysicsTokens_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsObjectDesc>
+        podcls("ObjectDesc", pxr_boost::python::no_init);
+    podcls
+        .def_readonly("type", &UsdPhysicsObjectDesc::type)
+        .def_readonly("primPath", &UsdPhysicsObjectDesc::primPath)
+        .def_readonly("isValid", &UsdPhysicsObjectDesc::isValid)
+        .def("__repr__", _PhysicsObjectDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsSceneDesc, bases<UsdPhysicsObjectDesc>>
+        sdcls("SceneDesc", pxr_boost::python::no_init);
+    sdcls
+        .def_readonly("gravityDirection", &UsdPhysicsSceneDesc::gravityDirection)
+        .def_readonly("gravityMagnitude", &UsdPhysicsSceneDesc::gravityMagnitude)
+        .def("__repr__", _SceneDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsCollisionGroupDesc, bases<UsdPhysicsObjectDesc>>
+        cgcls("CollisionGroupDesc", pxr_boost::python::no_init);
+    cgcls
+        .def_readonly("invertFilteredGroups", &UsdPhysicsCollisionGroupDesc::invertFilteredGroups)
+        .add_property("mergedGroups",
+            make_function(&UsdPhysicsCollisionGroupDesc::getMergedGroups,
+                return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredGroups",
+            make_function(&UsdPhysicsCollisionGroupDesc::getFilteredGroups,
+                return_value_policy<TfPySequenceToList>()))
+        .def_readonly("mergeGroupName", &UsdPhysicsCollisionGroupDesc::mergeGroupName)
+        .def("__repr__", _CollisionGroupDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsRigidBodyMaterialDesc, bases<UsdPhysicsObjectDesc>>
+        rbmcls("RigidBodyMaterialDesc", pxr_boost::python::no_init);
+    rbmcls
+        .def_readonly("staticFriction", &UsdPhysicsRigidBodyMaterialDesc::staticFriction)
+        .def_readonly("dynamicFriction", &UsdPhysicsRigidBodyMaterialDesc::dynamicFriction)
+        .def_readonly("restitution", &UsdPhysicsRigidBodyMaterialDesc::restitution)
+        .def_readonly("density", &UsdPhysicsRigidBodyMaterialDesc::density)
+        .def("__repr__", _RigidBodyMaterialDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsShapeDesc, bases<UsdPhysicsObjectDesc>>
+        shdcls("ShapeDesc", pxr_boost::python::no_init);
+    shdcls
+        .def_readonly("rigidBody", &UsdPhysicsShapeDesc::rigidBody)
+        .def_readonly("localPos", &UsdPhysicsShapeDesc::localPos)
+        .def_readonly("localRot", &UsdPhysicsShapeDesc::localRot)
+        .def_readonly("localScale", &UsdPhysicsShapeDesc::localScale)
+        .add_property("materials", make_function(&UsdPhysicsShapeDesc::getMaterials,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("simulationOwners",
+            make_function(&UsdPhysicsShapeDesc::getSimulationOwners,
+                return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredCollisions",
+            make_function(&UsdPhysicsShapeDesc::getFilteredCollisions,
+                return_value_policy<TfPySequenceToList>()))
+        .add_property("collisionGroups",
+            make_function(&UsdPhysicsShapeDesc::getCollisionGroups,
+                return_value_policy<TfPySequenceToList>()))
+        .def_readonly("collisionEnabled", &UsdPhysicsShapeDesc::collisionEnabled)
+        .def("__repr__", _ShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsSphereShapeDesc, bases<UsdPhysicsShapeDesc>>
+        ssdcls("SphereShapeDesc", pxr_boost::python::no_init);
+    ssdcls
+        .def_readonly("radius", &UsdPhysicsSphereShapeDesc::radius)
+        .def("__repr__", _SphereShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsCapsuleShapeDesc, bases<UsdPhysicsShapeDesc>>
+        csdcls("CapsuleShapeDesc", pxr_boost::python::no_init);
+    csdcls
+        .def_readonly("radius", &UsdPhysicsCapsuleShapeDesc::radius)
+        .def_readonly("halfHeight", &UsdPhysicsCapsuleShapeDesc::halfHeight)
+        .def_readonly("axis", &UsdPhysicsCapsuleShapeDesc::axis)
+        .def("__repr__", _CapsuleShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsCylinderShapeDesc, bases<UsdPhysicsShapeDesc>>
+        cysdcls("CylinderShapeDesc", pxr_boost::python::no_init);
+    cysdcls
+        .def_readonly("radius", &UsdPhysicsCylinderShapeDesc::radius)
+        .def_readonly("halfHeight", &UsdPhysicsCylinderShapeDesc::halfHeight)
+        .def_readonly("axis", &UsdPhysicsCylinderShapeDesc::axis)
+        .def("__repr__", _CylinderShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsConeShapeDesc, bases<UsdPhysicsShapeDesc>>
+        cosdcls("ConeShapeDesc", pxr_boost::python::no_init);
+    cosdcls
+        .def_readonly("radius", &UsdPhysicsConeShapeDesc::radius)
+        .def_readonly("halfHeight", &UsdPhysicsConeShapeDesc::halfHeight)
+        .def_readonly("axis", &UsdPhysicsConeShapeDesc::axis)
+        .def("__repr__", _ConeShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsPlaneShapeDesc, bases<UsdPhysicsShapeDesc>>
+        pscls("PlaneShapeDesc", pxr_boost::python::no_init);
+    pscls
+        .def_readonly("axis", &UsdPhysicsPlaneShapeDesc::axis)
+        .def("__repr__", _PlaneShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsCustomShapeDesc, bases<UsdPhysicsShapeDesc>>
+        cuscls("CustomShapeDesc", pxr_boost::python::no_init);
+    cuscls
+        .def_readonly("customGeometryToken", &UsdPhysicsCustomShapeDesc::customGeometryToken)
+        .def("__repr__", _CustomShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsCubeShapeDesc, bases<UsdPhysicsShapeDesc>>
+        cubescls("CubeShapeDesc", pxr_boost::python::no_init);
+    cubescls
+        .def_readonly("halfExtents", &UsdPhysicsCubeShapeDesc::halfExtents)
+        .def("__repr__", _CubeShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsMeshShapeDesc, bases<UsdPhysicsShapeDesc>>
+        mscls("MeshShapeDesc", pxr_boost::python::no_init);
+    mscls
+        .add_property("approximation", &UsdPhysicsMeshShapeDesc::GetApproximation)
+        .def_readonly("meshScale", &UsdPhysicsMeshShapeDesc::meshScale)
+        .def_readonly("doubleSided", &UsdPhysicsMeshShapeDesc::doubleSided)
+        .def("__repr__", _MeshShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsSpherePoint>
+        sppb("SpherePoint", pxr_boost::python::no_init);
+    sppb
+        .def_readonly("center", &UsdPhysicsSpherePoint::center)
+        .def_readonly("radius", &UsdPhysicsSpherePoint::radius)
+        .def("__repr__", _SpherePoint_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsSpherePointsShapeDesc, bases<UsdPhysicsShapeDesc>>
+        spmscls("SpherePointsShapeDesc", pxr_boost::python::no_init);
+    spmscls
+        .add_property("spherePoints", &UsdPhysicsSpherePointsShapeDesc::spherePoints)
+        .def("__repr__", _SpherePointsShapeDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsRigidBodyDesc, bases<UsdPhysicsObjectDesc>>
+        rbcls("RigidBodyDesc", pxr_boost::python::no_init);
+    rbcls
+        .add_property("collisions", make_function(&UsdPhysicsRigidBodyDesc::getCollisions,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredCollisions",
+            make_function(&UsdPhysicsRigidBodyDesc::getFilteredCollisions,
+                return_value_policy<TfPySequenceToList>()))
+        .add_property("simulationOwners",
+            make_function(&UsdPhysicsRigidBodyDesc::getSimulationOwners,
+                return_value_policy<TfPySequenceToList>()))
+        .def_readonly("position", &UsdPhysicsRigidBodyDesc::position)
+        .def_readonly("rotation", &UsdPhysicsRigidBodyDesc::rotation)
+        .def_readonly("scale", &UsdPhysicsRigidBodyDesc::scale)
+        .def_readonly("rigidBodyEnabled", &UsdPhysicsRigidBodyDesc::rigidBodyEnabled)
+        .def_readonly("kinematicBody", &UsdPhysicsRigidBodyDesc::kinematicBody)
+        .def_readonly("startsAsleep", &UsdPhysicsRigidBodyDesc::startsAsleep)
+        .def_readonly("linearVelocity", &UsdPhysicsRigidBodyDesc::linearVelocity)
+        .def_readonly("angularVelocity", &UsdPhysicsRigidBodyDesc::angularVelocity)
+        .def("__repr__", _RigidBodyDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsJointLimit>
+        jlcls("JointLimit", pxr_boost::python::no_init);
+    jlcls
+        .def_readonly("enabled", &UsdPhysicsJointLimit::enabled)
+        .def_readonly("lower", &UsdPhysicsJointLimit::lower)
+        .def_readonly("upper", &UsdPhysicsJointLimit::upper)
+        .def("__repr__", _JointLimit_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsJointDrive>
+        jdcls("JointDrive", pxr_boost::python::no_init);
+    jdcls
+        .def_readonly("enabled", &UsdPhysicsJointDrive::enabled)
+        .def_readonly("targetPosition", &UsdPhysicsJointDrive::targetPosition)
+        .def_readonly("targetVelocity", &UsdPhysicsJointDrive::targetVelocity)
+        .def_readonly("forceLimit", &UsdPhysicsJointDrive::forceLimit)
+        .def_readonly("stiffness", &UsdPhysicsJointDrive::stiffness)
+        .def_readonly("damping", &UsdPhysicsJointDrive::damping)
+        .def_readonly("acceleration", &UsdPhysicsJointDrive::acceleration)
+        .def("__repr__", _JointDrive_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsArticulationDesc, bases<UsdPhysicsObjectDesc>>
+        adcls("ArticulationDesc", pxr_boost::python::no_init);
+    adcls
+        .add_property("rootPrims", make_function(&UsdPhysicsArticulationDesc::GetRootPrims,
+            return_value_policy<TfPySequenceToList>()))
+        .add_property("filteredCollisions",
+            make_function(&UsdPhysicsArticulationDesc::GetFilteredCollisions,
+                return_value_policy<TfPySequenceToList>()))
+        .add_property("articulatedJoints",
+            make_function(&UsdPhysicsArticulationDesc::GetArticulatedJoints,
+                return_value_policy<TfPySequenceToList>()))
+        .add_property("articulatedBodies",
+            make_function(&UsdPhysicsArticulationDesc::GetArticulatedBodies,
+                return_value_policy<TfPySequenceToList>()))
+        .def("__repr__", _ArticulationDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsJointDesc, bases<UsdPhysicsObjectDesc>>
+        jdscls("JointDesc", pxr_boost::python::no_init);
+    jdscls
+        .def_readonly("rel0", &UsdPhysicsJointDesc::rel0)
+        .def_readonly("rel1", &UsdPhysicsJointDesc::rel1)
+        .def_readonly("body0", &UsdPhysicsJointDesc::body0)
+        .def_readonly("body1", &UsdPhysicsJointDesc::body1)
+        .def_readonly("localPose0Position", &UsdPhysicsJointDesc::localPose0Position)
+        .def_readonly("localPose0Orientation", &UsdPhysicsJointDesc::localPose0Orientation)
+        .def_readonly("localPose1Position", &UsdPhysicsJointDesc::localPose1Position)
+        .def_readonly("localPose1Orientation", &UsdPhysicsJointDesc::localPose1Orientation)
+        .def_readonly("jointEnabled", &UsdPhysicsJointDesc::jointEnabled)
+        .def_readonly("breakForce", &UsdPhysicsJointDesc::breakForce)
+        .def_readonly("breakTorque", &UsdPhysicsJointDesc::breakTorque)
+        .def_readonly("excludeFromArticulation", &UsdPhysicsJointDesc::excludeFromArticulation)
+        .def_readonly("collisionEnabled", &UsdPhysicsJointDesc::collisionEnabled)
+        .def("__repr__", _JointDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsCustomJointDesc, bases<UsdPhysicsJointDesc>>
+        cjdscls("CustomJointDesc", pxr_boost::python::no_init);
+
+    pxr_boost::python::class_<UsdPhysicsFixedJointDesc, bases<UsdPhysicsJointDesc>>
+        fjdscls("FixedJointDesc", pxr_boost::python::no_init);
+
+    class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit> >("JointLimitDOFPair")
+        .def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::first)
+        .def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>::second)
+        .def("__repr__", _JointLimitDOFPair_Repr);
+
+    class_<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive> >("JointDriveDOFPair")
+        .def_readwrite("first", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::first)
+        .def_readwrite("second", &std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>::second)
+        .def("__repr__", _JointDriveDOFPair_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsD6JointDesc, bases<UsdPhysicsJointDesc>>
+        d6jdscls("D6JointDesc", pxr_boost::python::no_init);
+    d6jdscls
+        .def_readonly("jointLimits", &UsdPhysicsD6JointDesc::jointLimits)
+        .def_readonly("jointDrives", &UsdPhysicsD6JointDesc::jointDrives)
+        .def("__repr__", _D6JointDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsPrismaticJointDesc, bases<UsdPhysicsJointDesc>>
+        pjdscls("PrismaticJointDesc", pxr_boost::python::no_init);
+    pjdscls
+        .def_readonly("axis", &UsdPhysicsPrismaticJointDesc::axis)
+        .def_readonly("limit", &UsdPhysicsPrismaticJointDesc::limit)
+        .def_readonly("drive", &UsdPhysicsPrismaticJointDesc::drive)
+        .def("__repr__", _PrismaticJointDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsSphericalJointDesc, bases<UsdPhysicsJointDesc>>
+        sjdscls("SphericalJointDesc", pxr_boost::python::no_init);
+    sjdscls
+        .def_readonly("axis", &UsdPhysicsSphericalJointDesc::axis)
+        .def_readonly("limit", &UsdPhysicsSphericalJointDesc::limit)
+        .def("__repr__", _SphericalJointDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsRevoluteJointDesc, bases<UsdPhysicsJointDesc>>
+        rjdscls("RevoluteJointDesc", pxr_boost::python::no_init);
+    rjdscls
+        .def_readonly("axis", &UsdPhysicsRevoluteJointDesc::axis)
+        .def_readonly("limit", &UsdPhysicsRevoluteJointDesc::limit)
+        .def_readonly("drive", &UsdPhysicsRevoluteJointDesc::drive)
+        .def("__repr__", _RevoluteJointDesc_Repr);
+
+    pxr_boost::python::class_<UsdPhysicsDistanceJointDesc, bases<UsdPhysicsJointDesc>>
+        djdscls("DistanceJointDesc", pxr_boost::python::no_init);
+    djdscls
+        .def_readonly("minEnabled", &UsdPhysicsDistanceJointDesc::minEnabled)
+        .def_readonly("limit", &UsdPhysicsDistanceJointDesc::limit)
+        .def_readonly("maxEnabled", &UsdPhysicsDistanceJointDesc::maxEnabled)
+        .def("__repr__", _DistanceJointDesc_Repr);
+
+    registerVectorConverter<UsdCollectionMembershipQuery>
+        ("PhysicsCollectionMembershipQueryVector");
+
+    registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointLimit>>
+        ("PhysicsJointLimitDOFVector");
 
-	registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>>
-		("PhysicsJointDriveDOFVector");
+    registerVectorConverter<std::pair<UsdPhysicsJointDOF::Enum, UsdPhysicsJointDrive>>
+        ("PhysicsJointDriveDOFVector");
 
-	registerVectorConverter<UsdPhysicsSpherePoint>("PhysicsSpherePointVector");
+    registerVectorConverter<UsdPhysicsSpherePoint>("PhysicsSpherePointVector");
 
-	registerVectorConverter<UsdPhysicsSceneDesc>("SceneDescVector");
+    registerVectorConverter<UsdPhysicsSceneDesc>("SceneDescVector");
 
-	registerVectorConverter<UsdPhysicsRigidBodyDesc>("RigidBodyDescVector");
+    registerVectorConverter<UsdPhysicsRigidBodyDesc>("RigidBodyDescVector");
 
-	registerVectorConverter<UsdPhysicsSphereShapeDesc>("SphereShapeDescVector");
+    registerVectorConverter<UsdPhysicsSphereShapeDesc>("SphereShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsCapsuleShapeDesc>("CapsuleShapeDescVector");
+    registerVectorConverter<UsdPhysicsCapsuleShapeDesc>("CapsuleShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsCylinderShapeDesc>("CylinderShapeDescVector");
+    registerVectorConverter<UsdPhysicsCylinderShapeDesc>("CylinderShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsConeShapeDesc>("ConeShapeDescVector");
+    registerVectorConverter<UsdPhysicsConeShapeDesc>("ConeShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsCubeShapeDesc>("CubeShapeDescVector");
+    registerVectorConverter<UsdPhysicsCubeShapeDesc>("CubeShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsMeshShapeDesc>("MeshShapeDescVector");
+    registerVectorConverter<UsdPhysicsMeshShapeDesc>("MeshShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsPlaneShapeDesc>("PlaneShapeDescVector");
+    registerVectorConverter<UsdPhysicsPlaneShapeDesc>("PlaneShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsCustomShapeDesc>("CustomShapeDescVector");
+    registerVectorConverter<UsdPhysicsCustomShapeDesc>("CustomShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsSpherePointsShapeDesc>("SpherePointsShapeDescVector");
+    registerVectorConverter<UsdPhysicsSpherePointsShapeDesc>("SpherePointsShapeDescVector");
 
-	registerVectorConverter<UsdPhysicsJointDesc>("JointDescVector");
+    registerVectorConverter<UsdPhysicsJointDesc>("JointDescVector");
 
-	registerVectorConverter<UsdPhysicsFixedJointDesc>("FixedJointDescVector");
+    registerVectorConverter<UsdPhysicsFixedJointDesc>("FixedJointDescVector");
 
-	registerVectorConverter<UsdPhysicsDistanceJointDesc>("DistanceJointDescVector");
+    registerVectorConverter<UsdPhysicsDistanceJointDesc>("DistanceJointDescVector");
 
-	registerVectorConverter<UsdPhysicsRevoluteJointDesc>("RevoluteJointDescVector");
+    registerVectorConverter<UsdPhysicsRevoluteJointDesc>("RevoluteJointDescVector");
 
-	registerVectorConverter<UsdPhysicsPrismaticJointDesc>("PrismaticJointDescVector");
+    registerVectorConverter<UsdPhysicsPrismaticJointDesc>("PrismaticJointDescVector");
 
-	registerVectorConverter<UsdPhysicsSphericalJointDesc>("SphericalJointDescVector");
+    registerVectorConverter<UsdPhysicsSphericalJointDesc>("SphericalJointDescVector");
 
-	registerVectorConverter<UsdPhysicsD6JointDesc>("D6JointDescVector");
+    registerVectorConverter<UsdPhysicsD6JointDesc>("D6JointDescVector");
 
-	registerVectorConverter<UsdPhysicsCustomJointDesc>("CustomJointDescVector");
+    registerVectorConverter<UsdPhysicsCustomJointDesc>("CustomJointDescVector");
 
-	registerVectorConverter<UsdPhysicsRigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
+    registerVectorConverter<UsdPhysicsRigidBodyMaterialDesc>("RigidBodyMaterialDescVector");
 
-	registerVectorConverter<UsdPhysicsArticulationDesc>("ArticulationDescVector");
+    registerVectorConverter<UsdPhysicsArticulationDesc>("ArticulationDescVector");
 
-	registerVectorConverter<UsdPhysicsCollisionGroupDesc>("CollisionGroupDescVector");
+    registerVectorConverter<UsdPhysicsCollisionGroupDesc>("CollisionGroupDescVector");
 
-	pxr_boost::python::class_<ParsePrimIteratorBaseWrap, noncopyable>
-		vparseitclsvv("ParsePrimIteratorBaseWrap", no_init);
-	vparseitclsvv.def(init<>());
+    pxr_boost::python::class_<ParsePrimIteratorBaseWrap, noncopyable>
+        vparseitclsvv("ParsePrimIteratorBaseWrap", no_init);
+    vparseitclsvv.def(init<>());
 
-	pxr_boost::python::class_<ParsePrimIteratorRange, bases<ParsePrimIteratorBase>>
-		parseitcls("ParsePrimIteratorRange", no_init);
-	parseitcls
-		.def(init<UsdPrimRange>(arg("primRange")));
+    pxr_boost::python::class_<ParsePrimIteratorRange, bases<ParsePrimIteratorBase>>
+        parseitcls("ParsePrimIteratorRange", no_init);
+    parseitcls
+        .def(init<UsdPrimRange>(arg("primRange")));
 
-	pxr_boost::python::class_<ExcludeListPrimIteratorRange, bases<ParsePrimIteratorBase>>
-		parseitExccls("ExcludeListPrimIteratorRange", no_init);
-	parseitExccls
-		.def(init<UsdPrimRange, SdfPathVector>());
+    pxr_boost::python::class_<ExcludeListPrimIteratorRange, bases<ParsePrimIteratorBase>>
+        parseitExccls("ExcludeListPrimIteratorRange", no_init);
+    parseitExccls
+        .def(init<UsdPrimRange, SdfPathVector>());
 
-	def("LoadUsdPhysicsFromRange", _LoadUsdPhysicsFromRange,
-		(args("stage"), args("range"), args("customTokens") = _CustomUsdPhysicsTokens(),
-			args("simulationOwners") = std::vector<SdfPath>()));
+    def("LoadUsdPhysicsFromRange", _LoadUsdPhysicsFromRange,
+        (args("stage"), args("range"), args("customTokens") = _CustomUsdPhysicsTokens(),
+            args("simulationOwners") = std::vector<SdfPath>()));
 }
